Vue-Router原理：
实例化VueRouter对象时，以构造函数的方式传入mode参数决定Router模式。
默认为hash模式，通过supportPushState判断是否支持history模式。
不支持则回滚为hash模式，如果不在浏览器下运行强制为abstract模式。
根据mode确定并类型实例化路由。通过类型初始化操作和监听。
其中暴露了两个方法push(),replace()。

Hash模式：
路径上的#用于指示网页中的位置，#符号以及后面的字符称为hash。
可通过window.location.hash属性读取。有以下特点：
1.不包括在HTTP请求中，用来指导浏览器动作，对服务器无用。改Hash不会重新加载页面。
2.可以为Hash的改变添加监听事件// window.addEventListener("hashchange",funcRef,false)
3.每次改变Hash，都会在浏览器访问历史增加一个记录。

Hash.push()//函数原理
push (location: RawLocation, onComplete?: Function, onAbort?: Function) { 
  this.transitionTo(location, route => { //该方法用于处理路由变化，父类定义。
    pushHash(route.fullPath)
    onComplete && onComplete(route)
  }, onAbort)
}
function pushHash (path) { //push函数直接对Hash进行赋值
  window.location.hash = path
}

transitionTo()//函数原理
transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
  const route = this.router.match(location, this.current)
  this.confirmTransition(route, () => {
    this.updateRoute(route)
    ...
  })
}

updateRoute (route: Route) {
  this.cb && this.cb(route)
}

listen (cb: Function) { //路由变化调用this.cd方法，通过History.listen(cb)设置
  this.cb = cb //this == history（路由对象） 初始化时有调用
}

初始化时，在插件加载的时候，VueRouter的install()方法中混入Vue对象，通过调用Vue.minxin()方法，全局注册一个mixin对象，影响每个Vue实例，混合在beforeCreated钩子中，通过Vue.util.defineReactive()定义_route属性。当_route值改变时，会自动调用Vue实例的render()方法，更新视图。//即为响应行为

$router.push() --> HashHistory.push() --> History.transitionTo() --> History.updateRoute() --> {app._route = route} --> vm.render() //路由改变到更新的流程

Hash.replace()//函数原理
调用replaceHash()//window.location.replace方法进行替换

监听地址栏
setupListeners () { //通过添加监听事件，监听地址栏中路由的变化，其余响应与Hash相同。
  window.addEventListener('hashchange', () => {
    if (!ensureSlash()) {
      return
    }
    this.transitionTo(getHash(), route => {
      replaceHash(route.fullPath)
    })
  })
}

History模式：
History interface是浏览器历史记录栈提供的接口，通过back(),forward(),go()等方法进行各种跳转。并且可以读取浏览器历史记录栈的信息。
History提供了两个方法：
window.history.pushState(stateObject, title, URL) //pushState()
window.history.replaceState(stateObject, title, URL)//replaceState()
stateObject:当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个StateObject参数的副本
title:所添加记录的标题
URL:所添加记录的URL

两个方法虽然改变了URL，但不会立即发送请求该URL。
两个方法的逻辑与Hash相似，不过将hash赋值改为history.pushState()和replaceState()
History模式中添加浏览器地址栏的监听是直接在构造函数中执行的：
constructor (router: Router, base: ?string) {
  window.addEventListener('popstate', e => {
    const current = this.current
    this.transitionTo(getLocation(this.base), route => {
      if (expectScroll) {
        handleScroll(router, route, current, true)
      }
    })
  })
}
History模式需要浏览器版本的支持。

Vue-router两种模式总结：
都是通过浏览器接口实现的，除此之外还有一个abstract模式，原理是使用数组stack模拟出浏览器历史记录栈的功能。
hash模式与history模式差距不大，就差一个#导航。
pushState()方法有以下优势：
1.pushState设置的新URL可以是与当前URL同源的任意URL，Hash只能修改#后面的部分，故只可设置与当前同文档的URL
2.pushState设置的新URL可以与当前URL一模一样，也会添加记录到栈中，而Hash必须不同才会触发添加记录
3.pushState通过StateObject可以添加任意类型的数据到记录中，Hash只可添加短字符串
4.pushState可额外设置title属性供后续使用
History模式的一个问题：
用户直接输入地址并回车，history模式会将URL修改，如正常请求后端，并无经过index.html页面，而打包后请求的文件通常需要经过index.html页面去访问。如未配置对应处理会返回404错误。
如果使用Hash模式并注意打包后配置路径，可以直接从文件系统直接加载Vue单页应用。

Vuex：
1.State:包含了store中存储的各个状态。
2.getter：类似于Vue中的计算属性，根据其他getter或state计算返回值。
3.mutation：一组方法，是改变store中状态的执行者，只能是同步操作。
4.action：一组方法，其中可以包含异步操作。
action类似于mutation，提交mutation（调用mutation），而不是直接变更状态。
1.mapState 2.mapGetters 3.mapMutations 4.mapActions//辅助函数方法
响应式的原因是因为将state存入Vue实例组件中的data，Vuex的getters借助vue的计算属性computed实现数据实时监听。Vuex通过全局注入store对象，实现组件间的状态共享。
多个组件自动获取更改后的数据进行业务逻辑处理，这时候使用vuex比较合适。


Vue生命周期
钩子函数的this指向Vue实例
除beforeUpdate/updated钩子函数外，其余钩子在初始化和销毁时只会执行一次。
beforeCreate():实例初始化之后调用，不能访问到data，computed，watch，methods上的方法和数据。//常用于初始化非响应式变量
created():实例创建完成，可访问data，computed，watch，methods上的方法和数据，未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组。//常用与简单的Ajax请求，页面的初始化。
beforeMount():在挂载开始之前被调用，beforeMounted之前，会找到对应的template，并编译成render函数。
mounted():实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问。//常用于获取VNode（类，用于创建DOM，不同实例代表不同类型的真实DOM）信息和操作，Ajax请求。
beforeupdate():响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM。//比如手动移除已添加的事件监听器
updated():虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新。//可执行依赖于DOM的操作，避免在这个钩子函数中操作数据，可能陷入死循环。
beforeDestroy():实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例。//常用与销毁定时器，解绑全局事件，销毁插件对象等操作。
destoryed():实例销毁后调用，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
注意：
1.created阶段的Ajax与mounted请求的区别：created页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。
2.mounted不会承诺所有的子组件也都一起被挂载。此时调用子组件refs可能会报错，可以通过调用this.$nextTick()函数等到视图渲染完毕。
父子组件的生命周期：
1.仅当子组件完成挂载后，父组件才会挂载
2.当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（一次）
3.父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践）
4.会先销毁子组件再销毁父组件
-----
将Vue组件实例挂载在DOM上，由Vue去操作DOM，我们更改Vue实例里的数据，Vue会更新视图。
使用Object.freeze()可以使响应式失效：data:obj，Object.freeze(obj);
initEvents(vm);//事件
initLifecycle(vm);//生命周期
initRender(vm);//渲染
callHook(vm,'beforeCreate');//通过callHook调用beforeCreate钩子函数
initInjections(vm);
initState(vm);//props、data、methods、watch、computed
initProvide(vm);
callHook(vm,'created');//调用created钩子函数
vm.$mount(vm.$options.el)//挂载
查看el和template确定最后的字符串，转为render方法。
callHook(vm,'beforeMount')//调用beforeMount钩子函数
vm._render()=>vm.update()=>vm._patch()//调用render方法，使用createElement生成虚拟DOM(VNode)，形成VNode Tree，调用vm.update()进行首次渲染，update()调用patch()方法，根据VNodeTree递归创建DOM Tree挂载到DOM上。
callHook(vm,'mount')//调用mount钩子函数。先子后父的执行顺序，生成与销毁都是这个顺序。
data changes//数据更新后
callHook(vm,'beforeUpdate')//执行watcher时会执行watcher的before方法，调用beforeUpdate声明周期钩子函数。
Virtual DOM re-render//重新生成VirtualDOMpatch到DOM上。
callHook(vm,'updated')//调用update钩子函数
vm.$destroy()//启动销毁过程
callHook(vm,'beforeDestroy');//调用beforeDestory钩子函数
执行销毁过程
callHook(vm,'destroyed')//调用destroyed钩子函数
----
keep-alive：内置抽象组件
在created钩子中定义了this.cache和this.keys，缓存已创建的VNode。
有三个props:include,exclude,max
渲染机制：
1.首次渲染：执行普通生命周期，将生产的VNode缓存到内存中。
2.组件切换：保留旧组件为未激活状态,执行deactivated钩子函数，如果不在缓存数组中就进行首次渲染，否则执行缓存渲染。
3.缓存渲染：组件激活，执行activated。
---

Vue引入了Flow做静态类型检查，由于Babel和ESLint都有对应的Flow插件以支持语法。
Flow的工作方式：
1.类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。
2.类型注释：事先注释好我们期待的类型，Flow会基于这些注释来判断。
Vue.js源码目录：
src：
1.compiler  #编译相关
包含编译相关代码。包括把模板解析成ast语法树，ast语法树优化，代码生成等功能。
借助webpack，vue-loader等插件构建时编译，编译耗费性能，更推荐离线编译。
2.core  #核心代码
包含内置组件、全局API封装、Vue实例化、观察者、虚拟DOM、工具函数等等。
3.platforms  #不同平台的支持
跨平台MVVM框架，可以在web运行，也可以配合weex在native客户端运行。
platform为Vue.js的入口。
4.server  #服务端渲染
这部分代码在服务端的Node.js运行。
主要工作是把组件渲染为服务端的HTML字符串，直接发送到浏览器，最后将静态标记“混合”为客户端上完全交互的应用程序。
5.sfc  #.vue文件解析
把.vue文件内容解析成一个JavaScript的对象。
6.shared  #共享代码
工具方法所在，被浏览器和服务端的Vue.js共享。
优点：目录设计详细，功能模块划分，不同逻辑不同目录，复用代码独立出来。
提高代码阅读性和可维护性。
Vue.js源码构建：
基于Rollup构建，构建相关配置在scripts目录下。
构建脚本：
package.json文件下，对项目描述文件，script字段作为NPM的执行脚本。
{
  "script": {
    "build":"node scripts/build.js",
    "build:ssr":"npm run build --web"
    "build:weex":"npm run build --weex"
  }
}
构建过程：
遵循CommonJS规范，es表示构建出来的文件遵循ES Module规范，umd表示构建出来的文件遵循UMD规范。
经过Rollup构建打包后，最终会在dist目录下生成vue.runtime.common.js。
从入口开始：
entry-runtime-with-compiler.js-->runtime\index.js-->core\index.js-->instance\index.js
有在文件中引入Vue，并且对Vue做一些拓展。
Vue实例其实就是function(),通过prototype原型扩展方法，还给Vue对象本身扩展全局的静态方法，在src/core/global-api/index.js中：
发现Object.defineProperty()!!
总结：
Vue本质上是一个用Function实现的Class，原型prototype以及它本身都扩展了一系列方法和属性。
---
Vue.js的核心思想是数据驱动。通过模板语法来声明式的将数据渲染为DOM。
不直接操作DOM，通过修改数据。
new Vue()=>调用_init()方法，在src/core/instance/init.js
该方法执行：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化data,props,computed,watcher等等。
初始化完后需要将模板渲染成DOM，需要挂载VM。通过$mount实例方法去挂载。
src/platform/web/entry-runtime-with-compiler.js
对el做限制，Vue不能挂载在body，html（根节点）上。将el和template字符串转换成render方法。Vue组件的渲染最终都需要render方法，调用compileToFunctions实现，
最后调用原型上的$mount挂载。
$mount方法的定义是为了复用。$mount方法会调用mountComponent方法，定义在src/core/instance/lifecycle.js中
先实例一个watcher,里面会调用updateComponent方法，在此方法中生成虚拟Node，调用update更新DOM。
watcher在初始化和监测数据发生变化时都会执行回调函数。
总结：mountComponent方法的逻辑。
---
Vue的_render方法是实例的一个私有方法。用来把实例渲染成一个虚拟Node。定义在src/core/instance/render.js
_render中调用render方法。render方法执行createElement方法返回vnode。
---
真实DOM元素非常庞大，使用virtual DOM代价小。
virtual DOM用VNode类（class）去描述，定义在src/core/vdom/vnode.js
总结：VNode是对真实DOM的一种抽象描述，核心定义包括标签名、数据、子节点、键值等。VNode用于映射到真实DOM，不需要操作DOM。映射需要经历VNode的create,diff,patch等过程。
---
createElement方法创建VNode，定义于src/core/vdom/create-element.js
createElement封装了_createElement方法，添加更多参数。处理完后创建真正的VNode。
创建VNode有五个参数，context（上下文）：Component，tag（标签）：四种类型，data（数据），children（子节点），normalizationType（子节点规范类型）
子节点通过规范类型调用不同规范方法:normalizeChildren(children),simpleNormalizeChildren(children),定义于src/core/vdom/helpers/normalize-children.js
simpleNormalizeChildren方法用于函数式组件，返回一个数组，用concat将数组铺平。
用户手写render函数时，children只有一个节点，允许写成基础类型创建文本节点。
这是会调用createTextVNode创建一个文本节点的VNode。（调用normalizeChidren）
编译slot，v-for时产生嵌套数组，会调用normalizeArrayChildren方法（调用normalizeChildren）
normalizeArrayChildren接收两个参数:children(子节点)，nestedIndex(嵌套索引)。
函数主要逻辑是遍历children，获得单个节点c，然后判断C的类型，数组则递归调用normalizeArrayChildren,基础类型则创建VNode类型。如果children是一个列表且有嵌套，则根据nestedIndex去更新它的key。遍历过程中对3种情况都做了如下处理，如果存在两个连续的text节点，会把它们合并成一个text节点。对children规范化后，变成一个VNode Array。
通过VNode Array创建VNode实例：new VNode
总结：
VNode都有children，形成VNode Tree，描述了DOM Tree。
创建完VNode后下一步渲染成真实DOM。
---
Vue通过调用_update把VNode渲染成真实DOM。
调用的情况有两个：首次渲染，数据更新后。该方法定义于src/core/instance/lifecycle.js
该方法核心为调用patch，_patch_方法定义于src/paltforms/web(weex)/runtime/index.js
如果在浏览器环境，指向patch方法，定义于src/platforms/web/runtiome/patch.js
patch方法为调用createPatchFunction的返回值，createPatchFunction定义于src/core/vdom/patch.js
createPatchFunction定义了patch方法返回赋值给vm._update函数里的vm._patch_
该函数有4个参数:oldVnode(旧节点),vnode(VNode节点),hydrating(是否服务端渲染),removeOnly后续使用。
通过emptyNodeAt方法把oldVnode转换成VNode对象然后调用createElm方法通过VNode创建真实DOM插入到父节点中。并且有createComponent创建子组件。


