---
title: 前端进阶之道
date: 2020-12-04 15:21:26
tags:
 - 前端学习
categories: Web前端
---
# JS内置类型
null,undefined,boolean,number,string,symbol
数字类型属于浮点类型，没有整型。NaN属于number类型，NaN不等于自身。
let a = 111 //这只是字面量，不是number类型
a.toString()//使用时候才会转换为对象类型
JS对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。
let a = {name:'FE'}    let b = a
b.name='EF'  console.log(a.name) //EF
# Typeof
typeof对于基本类型，除了null都可以显示正确的类型。
typeof对于对象，除了函数都会显示object
typeof null //  'object'
变量的正确类型获取：Object.prototype.toString.call(xx)//获取[object Type]
# 类型转换
转Boolean:在条件判断时，除了undefined，null，false，NaN，'',0,-0,其他所有值都转为true，包括所有对象。
# 对象转基本类型
首先调用valueOf,调用toString,方法可以重写
重写Symbol.toPrimitive,该方法在转基本类型时调用优先级最高
let a = {
valueOf(){return 0;},
toString(){return '1';},
[Symbol.toPrimitive](){return 2;}
}
# 四则运算符
+（加法）：其中一方是字符串类型，就会转另一个为字符串。
其他运算，只要一方是数字，另一方就转为数字。
加法运算会触发三只类型转换，将值转换为原始值，转换为数字，转换为字符串。
== 操作符：
undefined == undefined //true
Null == Null //true
NaN == Nan //false
+0 == -0 //true
a == b //引用同一对象时相等
null == undefined //true
comparison x(Number) == ToNumber y(String)//对比类型返回此结果
ToNumber x(String) == y(Number)
ToNumber x(Boolean) == y
x == ToNumber y(Boolean)
x(String/Number) == ToPrimitive y(Object)
ToPrimitive x(Object) == y(String/Number)
---
[ ] == ! [ ] // ->true
// [ ]转成true，取反为false
[ ] == false
// 根据 x == ToNumber y(Boolean)
[ ] == 0
//根据ToPrimitive x(Object) == y(Number)
ToPrimitive([ ]) == 0
// [ ].toString() -> ' '
' ' == 0
//根据ToNumber x(String) == y
0 == 0 // -> true
# 比较运算符
1.如果是对象，通过toPrimitive转换对象来比较
2.如果是字符串，通过Unicode字符索引来比较
# 原型
每个函数都有prototype属性，除了Function.prototype.bind(),该属性指向原型。
每个对象都有_proto_属性，指向创建该对象的构造函数的原型。其实这个指向了[[prototype]],但是[[prototype]]是内部属性，我们并不能访问到，所以用_proto_来访问。
# new
1.新生成一个对象
2.链接到原型
3.绑定this
4.返回新对象
function create() {
    let obj = new Object() //创建一个空的对象
    let Con = [].shift.call(arguments) //获得构造函数
    obj.__proto__ = Con.prototype //链接到原型
    let result = Con.apply(obj,arguments)//绑定this，执行构造函数
    return typeof result === 'object' ? result :obj//确保new出来的是个对象
}
创建对象，更推荐使用字面量的方式创建对象。使用new Object()需通过作用域链找Object
function Foo() {} // function就是个语法糖，内部等同于 new Function
let a = {b:1} //这个字面量内部也是使用了 new Object()
new 需要注意下运算符优先级
function Foo(){return this;}
Foo.getName = function (){console.log('1');};
Foo.prototype.getName = function () {console.log('2');};
new Foo.getName(); // ->1
new Foo().getName(); // -> 2
Foo()的优先级更大
# instanceof
instanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype。
手动实现instanceof:
function instanceof(left,right){
    //获得类型的原型
    let prototype = right.prototype
    //获得对象的原型
    left = left.__proto__
    //判断对象的类型是否等于类型的原型
    while(true) {
       if(left === null)
          return false
       if(prototype === left)
          return true
       left = left.__proto__
    }
}
# this
function foo(){console.log(this.a)}
var a = 1
foo()

var obj = {a: 2,foo: foo}
obj.foo()
//以上两者情况'this'只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

//以下情况是优先级最高的，'this'只会绑定在'c'上，不会被任何方式修改'this'指向
var c = new foo()
c.a = 3


console.log(c.a)
// 还有种就是利用call，apply，bind改变this，最高优先级仅次于new
针对箭头函数
function a(){
 return ()=>{
    return ()=>{
      console.log(this)
    }
 }
}
console.log(a()()())
箭头函数没有this,这个函数只取决于他外面的第一个不是箭头函数的this，在这个例子中，因为调用a符合前面代码中的第一个情况，所以this是Window，并且this一旦绑定的上下文，就不会被任何代码改变。
# 执行上下文
执行JS代码由三种上下文
1.全局执行上下文
2.函数执行上下文
3.eval执行上下文
每个执行上下文中都有三个重要的属性
.变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问
.作用域链（JS采用词法作用域，也就是说变量的作用域是在定义时就决定了）
.this
var a = 10
function foo(i){var b = 20}
foo()
上诉代码，执行栈中有两个上下文：全局上下文和函数foo上下文
stack=[globalContext,fooContext]
对于全局上下文来说，VO是这样的
globalContext.VO === globe
globalContext.VO = {
   a: undefined,
   foo:<Function>,
}
对于函数foo来说，VO不能访问，只能访问到活动对象（AO）
fooContext.VO === foo.AO
fooContext.AO {
   i: undefined
   b: undefined
   arguments:<>
}
//arguments是函数独有的对象(箭头函数没有)
//该对象是一个伪数组，有length属性且可以通过下标访问元素
//该对象中的callee属性代表函数本身
//caller属性代表函数的调用者
对于作用域链，可以把它理解成自身变量对象和上级变量对象的列表，通过[[Scope]]属性查找上级变量
fooContext.[[Scope]] = [globalContext.VO]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
    fooContext.VO,
    globalContext.VO
]
函数和变量提升：
生成执行上下文有两个阶段，第一个阶段是创建的阶段（创建VO），JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只需要声明并且赋值为undefined，第二个阶段为代码执行阶段，可以提前使用。
在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升。
b() // b2
function b(){
   console.log('b1')
}
function b(){
   console.log('b2')
}
var会产生很多错误，所以ES6引入了let，let不能在声明前使用，let有提升，但未赋值，所以不能提前使用。
var foo = 1
(function foo(){
   foo = 10
   console.log(foo)
}()) // ->f foo(){foo=10;console.log(foo)}
JS解释器遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到foo。但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生改变。
# 闭包
闭包定义：函数A返回一个函数B，函数B使用A的变量，B成为闭包。
function A(){
   let a = 1
   function B(){
       console.log(a)
   }
   return B
}
# 深浅拷贝
let a = {
   age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2 因为是引用，浅拷贝
浅拷贝：
1.通过Object.assign解决
let a = {age:1}
let b = Object.assign({},a)
a.age = 2
console.log(b.age) // 1
2.运算符(...)解决
let a = {age:1}
let b = {...a}
a.age = 2
console.log(b.age) // 1
浅拷贝对于二层对象引用无效
let a = {jobs:{first:'FE'}}
let b = {...a}
a.jobs.first = 'native'
console.log(b.jobs.first) // native
# 深拷贝
1.通过JSON.parse(JSON.stringify(object))解决
let a = {jobs:{first:'FE'}}
let b = JSON.parse(JSON.stringfy(a))
a.jobs.first = 'native'
console.log(b.jobs.first)
该方法有局限性:
会忽略undefined
会忽略symbol
不能序列化函数
不能解决循环引用的对象
# 模块化
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import {a,b} from './a.js'
import XXX from './b.js'

# CommonJS
// a.js
module.exports = {
   a:1
}
// or
exports.a = 1

//b.js
var module = require('./a.js')
module.a // ->log 1

var module = require('./a.js')
module.a
// 这里其实包装了一层立即执行函数，这样就不会污染全局变量了
// 重要的是module这里，module是Node独有的一个变量
module.exports = {a:1}
//基本实现
var module = {exports:{} //exports是个空对象}
// 这个是为什么exports和module.exports用法相似的原因
var exports = module.exports
var load = function (module) {
   //导出的东西
  var a = 1
  module.exports = a
  return module.exports
};
module.exports和exports用法相似,但是无法直接赋值，无效果。
CommonJS和ES6中的模块化的两者区别是：
1.前者支持动态导入，也就是require(${path}/xx.js),后者目前不支持
2.前者是同步导入，因为用于服务端，文件在本地，同步导入即使卡住主线程影响也不大。后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
3.前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
后者会编译成require/exports来执行的
# AMD
# 防抖
防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用函数。
防抖实现：
const debounce = (func,wait=50) =>{
    // 缓存一个定时器id
    let timer = 0
    // 这里返回的函数是每次用户实际调用的防抖函数
    // 如果已经设定过定时器了就清空上一次的定时器
    // 开始一个新的定时器，延迟执行用户传入的方法
    return function(...args) {
        if(timer) clearTimeout(timer)
        timer = setTimeout(() =>{
           func.apply(this,args)
        },wait)
    }
}
// 这是一个简单版的防抖，只能在最后调用，一般防抖有immediate选项，表示是否立即调用。
```bash
// 这个是用来获取当前时间戳的
function now() {
  return +new Date()
}
/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
function debounce (func, wait = 50, immediate = true) {
  let timer, context, args

  // 延迟执行函数
  const later = () => setTimeout(() => {
    // 延迟函数执行完毕，清空缓存的定时器序号
    timer = null
    // 延迟执行的情况下，函数会在延迟函数中执行
    // 使用到之前缓存的参数和上下文
    if (!immediate) {
      func.apply(context, args)
      context = args = null
    }
  }, wait)

  // 这里返回的函数是每次实际调用的函数
  return function(...params) {
    // 如果没有创建延迟执行函数（later），就创建一个
    if (!timer) {
      timer = later()
      // 如果是立即执行，调用函数
      // 否则缓存参数和调用上下文
      if (immediate) {
        func.apply(this, params)
      } else {
        context = this
        args = params
      }
    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个
    // 这样做延迟函数会重新计时
    } else {
      clearTimeout(timer)
      timer = later()
    }
  }
}
```

# 节流
防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。
```bash
/**
 * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 *
 * @param  {function}   func      回调函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。
 *                                如果想忽略结尾函数的调用，传入{trailing: false}
 *                                两者不能共存，否则函数不能执行
 * @return {function}             返回客户调用函数
 */
_.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    // 之前的时间戳
    var previous = 0;
    // 如果 options 没传则设为空对象
    if (!options) options = {};
    // 定时器回调函数
    var later = function() {
      // 如果设置了 leading，就将 previous 设为 0
      // 用于下面函数的第一个 if 判断
      previous = options.leading === false ? 0 : _.now();
      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      // 获得当前时间戳
      var now = _.now();
      // 首次进入前者肯定为 true
	  // 如果需要第一次不执行函数
	  // 就将上次时间戳设为当前的
      // 这样在接下来计算 remaining 的值时会大于0
      if (!previous && options.leading === false) previous = now;
      // 计算剩余时间
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      // 如果当前调用已经大于上次调用时间 + wait
      // 或者用户手动调了时间
 	  // 如果设置了 trailing，只会进入这个条件
	  // 如果没有设置 leading，那么第一次会进入这个条件
	  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了
	  // 其实还是会进入的，因为定时器的延时
	  // 并不是准确的时间，很可能你设置了2秒
	  // 但是他需要2.2秒才触发，这时候就会进入这个条件
      if (remaining <= 0 || remaining > wait) {
        // 如果存在定时器就清理掉否则会调用二次回调
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        // 判断是否设置了定时器和 trailing
	    // 没有的话就开启一个定时器
        // 并且不能不能同时设置 leading 和 trailing
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
```
# 继承
function MyData(){}
MyData.prototype.test = function (){
    return this.getTime()
}
let d = new Date()
Object.setPrototypeOf(d,MyData,prototype)
Object.setPrototypeOf(MyData.prototype,Date.prototype)
先创建父类实例=>改变实例原先的__proto__转而连接到子类的prototype =>子类的prototype的__proto__改为父类的prototype
# apply,call,bind区别
call和apply都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同。
除了第一个参数外，call可以接受一个参数列表，apply只接受一个参数数组。
let a = {value:1}
function getValue(name,age){
    console.log(name)
    console.log(age)
    console.log(this.value)
}
getValue.call(a,'yck','24')
getValue.apply(a,['yck','24'])
模拟实现call和apply
不传入第一个参数，默认为window
改变了this指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？
Call：
Function.prototype.myCall = function (context) {
  var context = context || window
  // 给 context 添加一个属性
  // getValue.call(a, 'yck', '24') => a.fn = getValue
  context.fn = this
  // 将 context 后面的参数取出来
  var args = [...arguments].slice(1)
  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
  var result = context.fn(...args)
  // 删除 fn
  delete context.fn
  return result
}
Apply：
Function.prototype.myApply = function (context) {
  var context = context || window
  context.fn = this

  var result
  // 需要判断是否存储第二个参数
  // 如果存在，就将第二个参数展开
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }

  delete context.fn
  return result
}
bind：
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  var _this = this
  var args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
# Promise实现
```bash
// 三种状态
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";
// promise 接收一个函数参数，该函数会立即执行
function MyPromise(fn) {
  let _this = this;
  _this.currentState = PENDING;
  _this.value = undefined;
  // 用于保存 then 中的回调，只有当 promise
  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个
  _this.resolvedCallbacks = [];
  _this.rejectedCallbacks = [];

  _this.resolve = function (value) {
    if (value instanceof MyPromise) {
      // 如果 value 是个 Promise，递归执行
      return value.then(_this.resolve, _this.reject)
    }
    setTimeout(() => { // 异步执行，保证执行顺序
      if (_this.currentState === PENDING) {
        _this.currentState = RESOLVED;
        _this.value = value;
        _this.resolvedCallbacks.forEach(cb => cb());
      }
    })
  };

  _this.reject = function (reason) {
    setTimeout(() => { // 异步执行，保证执行顺序
      if (_this.currentState === PENDING) {
        _this.currentState = REJECTED;
        _this.value = reason;
        _this.rejectedCallbacks.forEach(cb => cb());
      }
    })
  }
  // 用于解决以下问题
  // new Promise(() => throw Error('error))
  try {
    fn(_this.resolve, _this.reject);
  } catch (e) {
    _this.reject(e);
  }
}

MyPromise.prototype.then = function (onResolved, onRejected) {
  var self = this;
  // 规范 2.2.7，then 必须返回一个新的 promise
  var promise2;
  // 规范 2.2.onResolved 和 onRejected 都为可选参数
  // 如果类型不是函数需要忽略，同时也实现了透传
  // Promise.resolve(4).then().then((value) => console.log(value))
  onResolved = typeof onResolved === 'function' ? onResolved : v => v;
  onRejected = typeof onRejected === 'function' ? onRejected : r => throw r;

  if (self.currentState === RESOLVED) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行
      // 所以用了 setTimeout 包裹下
      setTimeout(function () {
        try {
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (reason) {
          reject(reason);
        }
      });
    }));
  }

  if (self.currentState === REJECTED) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      setTimeout(function () {
        // 异步执行onRejected
        try {
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (reason) {
          reject(reason);
        }
      });
    }));
  }

  if (self.currentState === PENDING) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      self.resolvedCallbacks.push(function () {
        // 考虑到可能会有报错，所以使用 try/catch 包裹
        try {
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (r) {
          reject(r);
        }
      });

      self.rejectedCallbacks.push(function () {
        try {
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (r) {
          reject(r);
        }
      });
    }));
  }
};
// 规范 2.3
function resolutionProcedure(promise2, x, resolve, reject) {
  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用
  if (promise2 === x) {
    return reject(new TypeError("Error"));
  }
  // 规范 2.3.2
  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行
  if (x instanceof MyPromise) {
    if (x.currentState === PENDING) {
      x.then(function (value) {
        // 再次调用该函数是为了确认 x resolve 的
        // 参数是什么类型，如果是基本类型就再次 resolve
        // 把值传给下个 then
        resolutionProcedure(promise2, value, resolve, reject);
      }, reject);
    } else {
      x.then(resolve, reject);
    }
    return;
  }
  // 规范 2.3.3.3.3
  // reject 或者 resolve 其中一个执行过得话，忽略其他的
  let called = false;
  // 规范 2.3.3，判断 x 是否为对象或者函数
  if (x !== null && (typeof x === "object" || typeof x === "function")) {
    // 规范 2.3.3.2，如果不能取出 then，就 reject
    try {
      // 规范 2.3.3.1
      let then = x.then;
      // 如果 then 是函数，调用 x.then
      if (typeof then === "function") {
        // 规范 2.3.3.3
        then.call(
          x,
          y => {
            if (called) return;
            called = true;
            // 规范 2.3.3.3.1
            resolutionProcedure(promise2, y, resolve, reject);
          },
          e => {
            if (called) return;
            called = true;
            reject(e);
          }
        );
      } else {
        // 规范 2.3.3.4
        resolve(x);
      }
    } catch (e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // 规范 2.3.4，x 为基本类型
    resolve(x);
  }
}
```