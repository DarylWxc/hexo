<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-16x16-Aren.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-16x16-Aren.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/Aren.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="每日提升一点点">
<meta property="og:type" content="website">
<meta property="og:title" content="DarylWXC的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="DarylWXC的博客">
<meta property="og:description" content="每日提升一点点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DarylWxc">
<meta property="article:tag" content="小逗比">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>DarylWXC的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DarylWXC的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/vue%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/26/vue%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" itemprop="url">vue权限管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-26T10:30:39+08:00">
                2021-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.2k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-权限是啥？"><a href="#1-权限是啥？" class="headerlink" title="1. 权限是啥？"></a>1. 权限是啥？</h2><p>权限是对特定资源的访问许可，确保用户只能访问到被分配的资源。其原理是请求发起权，请求发起有两种形式：</p>
<ul>
<li>页面加载触发</li>
<li>页面上的按钮点击触发<br>实现目标：</li>
<li>路由方面，只能看到有权访问的菜单</li>
<li>视图方面，只能看到自己有权浏览的内容和有权操作的控件</li>
<li>请求控制，越权请求在前端进行拦截<h2 id="2-如何实现？"><a href="#2-如何实现？" class="headerlink" title="2. 如何实现？"></a>2. 如何实现？</h2>权限控制可以分四个方面：</li>
<li>接口权限</li>
<li>按钮权限</li>
<li>菜单权限</li>
<li>路由权限<h1 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h1>接口权限一般采用jwt的形式来严重，登录完拿到token将token保存，每次请求拦截器进行拦截，请求头部带token<h1 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a>路由权限控制</h1>方案一：在路由标记相应的权限信息，路由跳转前做校验<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const routerMap &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;permission&#39;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: &#39;&#x2F;permission&#x2F;index&#39;,</span><br><span class="line">    alwaysShow: true, &#x2F;&#x2F; will always show the root menu</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#39;permission&#39;,</span><br><span class="line">      icon: &#39;lock&#39;,</span><br><span class="line">      roles: [&#39;admin&#39;, &#39;editor&#39;] &#x2F;&#x2F; you can set roles in root nav</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &#39;page&#39;,</span><br><span class="line">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;page&#39;),</span><br><span class="line">      name: &#39;pagePermission&#39;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: &#39;pagePermission&#39;,</span><br><span class="line">        roles: [&#39;admin&#39;] &#x2F;&#x2F; or you can only set roles in sub nav</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: &#39;directive&#39;,</span><br><span class="line">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;directive&#39;),</span><br><span class="line">      name: &#39;directivePermission&#39;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: &#39;directivePermission&#39;</span><br><span class="line">        &#x2F;&#x2F; if do not set roles, means: this page does not require permission</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br></pre></td></tr></table></figure>
缺点：</li>
<li>加载所有的路由，如果路由很多，而用户并不是所有路由都有权限访问，会性能会有影响</li>
<li>全局路由守卫里，每次路由跳转都要做权限判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<br>方案二：<br>初始化的时候挂载公共路由，比如404，登录页。登录后获取用户的权限信息筛选有权限访问的路由在全局路由守卫调用addRoutes添加路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; permission judge function</span><br><span class="line">function hasPermission(roles, permissionRoles) &#123;</span><br><span class="line">  if (roles.indexOf(&#39;admin&#39;) &gt;&#x3D; 0) return true &#x2F;&#x2F; admin permission passed directly</span><br><span class="line">  if (!permissionRoles) return true</span><br><span class="line">  return roles.some(role &#x3D;&gt; permissionRoles.indexOf(role) &gt;&#x3D; 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const whiteList &#x3D; [&#39;&#x2F;login&#39;, &#39;&#x2F;authredirect&#39;]&#x2F;&#x2F; no redirect whitelist</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  NProgress.start() &#x2F;&#x2F; start progress bar</span><br><span class="line">  if (getToken()) &#123; &#x2F;&#x2F; determine if there has token</span><br><span class="line">    &#x2F;* has token*&#x2F;</span><br><span class="line">    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class="line">      next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class="line">      NProgress.done() &#x2F;&#x2F; if current page is dashboard will not trigger afterEach hook, so manually handle it</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (store.getters.roles.length &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断当前用户是否已拉取完user_info信息</span><br><span class="line">        store.dispatch(&#39;GetUserInfo&#39;).then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 拉取user_info</span><br><span class="line">          const roles &#x3D; res.data.roles &#x2F;&#x2F; note: roles must be a array! such as: [&#39;editor&#39;,&#39;develop&#39;]</span><br><span class="line">          store.dispatch(&#39;GenerateRoutes&#39;, &#123; roles &#125;).then(() &#x3D;&gt; &#123; &#x2F;&#x2F; 根据roles权限生成可访问的路由表</span><br><span class="line">            router.addRoutes(store.getters.addRouters) &#x2F;&#x2F; 动态添加可访问路由表</span><br><span class="line">            next(&#123; ...to, replace: true &#125;) &#x2F;&#x2F; hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class="line">          store.dispatch(&#39;FedLogOut&#39;).then(() &#x3D;&gt; &#123;</span><br><span class="line">            Message.error(err || &#39;Verification failed, please login again&#39;)</span><br><span class="line">            next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓</span><br><span class="line">        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;</span><br><span class="line">          next()&#x2F;&#x2F;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          next(&#123; path: &#39;&#x2F;401&#39;, replace: true, query: &#123; noGoBack: true &#125;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 可删 ↑</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;* has no token*&#x2F;</span><br><span class="line">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(&#39;&#x2F;login&#39;) &#x2F;&#x2F; 否则全部重定向到登录页</span><br><span class="line">      NProgress.done() &#x2F;&#x2F; if current page is login will not trigger afterEach hook, so manually handle it</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(() &#x3D;&gt; &#123;</span><br><span class="line">  NProgress.done() &#x2F;&#x2F; finish progress bar</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
缺点：</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<h1 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h1>菜单权限可以理解成将页面与路由进行解耦<br>方案一<br>菜单与路由分离，菜单由后端返回<br>前端定义路由信息，name属性不得为空，需要此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function hasPermission(router, accessMenu) &#123;</span><br><span class="line">  if (whiteList.indexOf(router.path) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  let menu &#x3D; Util.getMenuByName(router.name, accessMenu);</span><br><span class="line">  if (menu.name) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Router.beforeEach(async (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    let userInfo &#x3D; store.state.user.userInfo;</span><br><span class="line">    if (!userInfo.name) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        await store.dispatch(&quot;GetUserInfo&quot;)</span><br><span class="line">        await store.dispatch(&#39;updateAccessMenu&#39;)</span><br><span class="line">        if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class="line">          next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F;Util.toDefaultPage([...routers], to.name, router, next);</span><br><span class="line">          next(&#123; ...to, replace: true &#125;)&#x2F;&#x2F;菜单权限更新完成,重新进一次当前路由</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">      catch (e) &#123;</span><br><span class="line">        if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class="line">          next()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          next(&#39;&#x2F;login&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class="line">        next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (hasPermission(to, store.getters.accessMenu)) &#123;</span><br><span class="line">          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          next(&#123; path: &#39;&#x2F;403&#39;,replace:true &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(&#39;&#x2F;login&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let menu &#x3D; Util.getMenuByName(to.name, store.getters.accessMenu);</span><br><span class="line">  Util.title(menu.title);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.afterEach((to) &#x3D;&gt; &#123;</span><br><span class="line">  window.scrollTo(0, 0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
缺点：</li>
<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，菜单配置不对会导致应用不能正常使用</li>
<li>全局路由守卫里，每次路由跳转都要做判断<br>方案二<br>菜单和路由都由后端返回，前端统一定义路由组件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Home &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;Home.vue&quot;);</span><br><span class="line">const UserInfo &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;UserInfo.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">    home: Home,</span><br><span class="line">    userInfo: UserInfo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
后端路由组件返回以下格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;home&quot;,</span><br><span class="line">        path: &quot;&#x2F;&quot;,</span><br><span class="line">        component: &quot;home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;home&quot;,</span><br><span class="line">        path: &quot;&#x2F;userinfo&quot;,</span><br><span class="line">        component: &quot;userInfo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
前后端都需要做相应的路由处理<br>缺点：</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>前后端的配合要求更高<h1 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h1>方案一<br>按钮权限用v-if判断，但是页面过多情况下，每个页面都要获取用户权限role和路由表里的meta.Permission，再做判断<br>方案二<br>通过自定义指令进行权限判断<br>配置路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#39;&#x2F;permission&#39;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    name: &#39;权限测试&#39;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        btnPermissions: [&#39;admin&#39;, &#39;supper&#39;, &#39;normal&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;页面需要的权限</span><br><span class="line">    children: [&#123;</span><br><span class="line">        path: &#39;supper&#39;,</span><br><span class="line">        component: _import(&#39;system&#x2F;supper&#39;),</span><br><span class="line">        name: &#39;权限测试页&#39;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            btnPermissions: [&#39;admin&#39;, &#39;supper&#39;]</span><br><span class="line">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#39;normal&#39;,</span><br><span class="line">        component: _import(&#39;system&#x2F;normal&#39;),</span><br><span class="line">        name: &#39;权限测试页&#39;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            btnPermissions: [&#39;admin&#39;]</span><br><span class="line">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
自定义权限鉴定指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**权限指令**&#x2F;</span><br><span class="line">const has &#x3D; Vue.directive(&#39;has&#39;, &#123;</span><br><span class="line">    bind: function (el, binding, vnode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取页面按钮权限</span><br><span class="line">        let btnPermissionsArr &#x3D; [];</span><br><span class="line">        if(binding.value)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。</span><br><span class="line">            btnPermissionsArr &#x3D; Array.of(binding.value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F; 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。</span><br><span class="line">            btnPermissionsArr &#x3D; vnode.context.$route.meta.btnPermissions;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;</span><br><span class="line">            el.parentNode.removeChild(el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 权限检查方法</span><br><span class="line">Vue.prototype.$_has &#x3D; function (value) &#123;</span><br><span class="line">    let isExist &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 获取用户按钮权限</span><br><span class="line">    let btnPermissionsStr &#x3D; sessionStorage.getItem(&quot;btnPermissions&quot;);</span><br><span class="line">    if (btnPermissionsStr &#x3D;&#x3D; undefined || btnPermissionsStr &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;</span><br><span class="line">        isExist &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isExist;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;has&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>根据项目进行方案考虑，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/25/Vue-mixin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/25/Vue-mixin/" itemprop="url">Vue-mixin</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-25T15:05:59+08:00">
                2021-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  412 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mixin是什么？"><a href="#1-mixin是什么？" class="headerlink" title="1. mixin是什么？"></a>1. mixin是什么？</h2><p>Mixin是一种类，提供方法实现。通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用，避免多继承的复杂。本质是一个JS对象，包含组件的任意功能，将功能传入mixins中就可以使用，可以局部混入，可以全局混入（不推荐！）。</p>
<h2 id="2-如何使用？"><a href="#2-如何使用？" class="headerlink" title="2. 如何使用？"></a>2. 如何使用？</h2><p>局部混入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 组件通过mixins属性调用mixin对象</span><br><span class="line">Vue.component(<span class="string">'componentA'</span>,&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line">// 使用该组件时，会混合mixin里的方法，自动执行钩子函数。也可以调用mixin里的data值</span><br></pre></td></tr></table></figure>
<p>全局混入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(<span class="string">"全局混入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 全局混入需要特别注意，会影响到每个组件。</span><br></pre></td></tr></table></figure>
<p>当组件存在于mixin对象相同的选项时，合并时会覆盖mixin的选项。<br>生命周期钩子相同时，会合并成一个数组，先执行mixin的钩子。</p>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><p>相似或相同的代码，功能相对独立。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const toggle = &#123; // 编写mixin</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      isShowing: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">toggleShow</span></span>() &#123;</span><br><span class="line">      this.isShowing = !this.isShowing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Modal = &#123;  // 使用时引入</span><br><span class="line">  template: <span class="string">'#modal'</span>,</span><br><span class="line">  mixins: [toggle]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>·替换型策略有props、methods、inject、computed，新参数替换旧<br>·合并型策略是data，通过set方法进行合并和重新赋值<br>·队列型策略有生命周期和watch，原理是将函数存入一个数组，然后正序遍历依次执行<br>·叠加型有component、directives、filters，通过原型链进行层层叠加</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/25/Vue%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/25/Vue%E6%8C%87%E4%BB%A4/" itemprop="url">Vue指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-25T14:05:04+08:00">
                2021-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.1k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-指令是啥？"><a href="#1-指令是啥？" class="headerlink" title="1.指令是啥？"></a>1.指令是啥？</h2><p>Vue有一套为数据驱动视图更方便的指令系统。v-开头的行内属性都是指令，不同指令可以实现不同的功能。</p>
<h2 id="2-如何实现？"><a href="#2-如何实现？" class="headerlink" title="2.如何实现？"></a>2.如何实现？</h2><p>局部注册，全局注册。通过Vue.directive注册。<br>全局注册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123; // 注册v-focus指令</span><br><span class="line">   inserted: <span class="keyword">function</span> (el) &#123;</span><br><span class="line">      el.focus() // 让元素自动聚焦</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>局部注册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">   focus: &#123;</span><br><span class="line">      inserted: <span class="keyword">function</span> (el) &#123;</span><br><span class="line">         el.focus() //功能同上</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板中的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure>

<p>自定义指令也存在钩子函数：<br>·bind：只调用一次，指令第一次绑定到元素时使用。初始化设置。<br>·inserted：被绑定元素插入父节点时调用<br>·update：所在组件VNode更新时调用<br>·componentUpdated：所在组件VNode和子VNode全部更新后调用<br>·unbind：只调用一次，指令与元素解绑时调用<br>钩子函数的参数有：<br>·el：指令绑定的元素，可操作DOM<br>·binding：一个对象，包含name,value,oldValue,expression,arg,modifiers<br>·vnode：虚拟节点<br>·oldVnode：上一个虚拟节点</p>
<h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><p>·防抖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1.设置v-throttle自定义指令</span><br><span class="line">Vue.directive(<span class="string">'throttle'</span>, &#123;</span><br><span class="line">  <span class="built_in">bind</span>: (el, binding) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class="line">      throttleTime = 2000;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> cbFun;</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class="line">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class="line">          cbFun = null;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">// 2.为button标签设置v-throttle自定义指令</span><br><span class="line">&lt;button @click=<span class="string">"sayHello"</span> v-throttle&gt;提交&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>·图片懒加载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">// 1.设置v-throttle自定义指令</span><br><span class="line">Vue.directive(<span class="string">'throttle'</span>, &#123;</span><br><span class="line">  <span class="built_in">bind</span>: (el, binding) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class="line">      throttleTime = 2000;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> cbFun;</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class="line">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class="line">          cbFun = null;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">// 2.为button标签设置v-throttle自定义指令</span><br><span class="line">&lt;button @click=<span class="string">"sayHello"</span> v-throttle&gt;提交&lt;/button&gt;</span><br><span class="line">图片懒加载</span><br><span class="line">设置一个v-lazy自定义组件完成图片懒加载</span><br><span class="line">const LazyLoad = &#123;</span><br><span class="line">    // install方法</span><br><span class="line">    install(Vue,options)&#123;</span><br><span class="line">       // 代替图片的loading图</span><br><span class="line">        <span class="built_in">let</span> defaultSrc = options.default;</span><br><span class="line">        Vue.directive(<span class="string">'lazy'</span>,&#123;</span><br><span class="line">            <span class="built_in">bind</span>(el,binding)&#123;</span><br><span class="line">                LazyLoad.init(el,binding.value,defaultSrc);</span><br><span class="line">            &#125;,</span><br><span class="line">            inserted(el)&#123;</span><br><span class="line">                // 兼容处理</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'IntersectionObserver'</span> <span class="keyword">in</span> window)&#123;</span><br><span class="line">                    LazyLoad.observe(el);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    LazyLoad.listenerScroll(el);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化</span><br><span class="line">    init(el,val,def)&#123;</span><br><span class="line">        // data-src 储存真实src</span><br><span class="line">        el.setAttribute(<span class="string">'data-src'</span>,val);</span><br><span class="line">        // 设置src为loading图</span><br><span class="line">        el.setAttribute(<span class="string">'src'</span>,def);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 利用IntersectionObserver监听el</span><br><span class="line">    observe(el)&#123;</span><br><span class="line">        <span class="built_in">let</span> io = new IntersectionObserver(entries =&gt; &#123;</span><br><span class="line">            <span class="built_in">let</span> realSrc = el.dataset.src;</span><br><span class="line">            <span class="keyword">if</span>(entries[0].isIntersecting)&#123;</span><br><span class="line">                <span class="keyword">if</span>(realSrc)&#123;</span><br><span class="line">                    el.src = realSrc;</span><br><span class="line">                    el.removeAttribute(<span class="string">'data-src'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        io.observe(el);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 监听scroll事件</span><br><span class="line">    listenerScroll(el)&#123;</span><br><span class="line">        <span class="built_in">let</span> handler = LazyLoad.throttle(LazyLoad.load,300);</span><br><span class="line">        LazyLoad.load(el);</span><br><span class="line">        window.addEventListener(<span class="string">'scroll'</span>,() =&gt; &#123;</span><br><span class="line">            handler(el);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 加载真实图片</span><br><span class="line">    load(el)&#123;</span><br><span class="line">        <span class="built_in">let</span> windowHeight = document.documentElement.clientHeight</span><br><span class="line">        <span class="built_in">let</span> elTop = el.getBoundingClientRect().top;</span><br><span class="line">        <span class="built_in">let</span> elBtm = el.getBoundingClientRect().bottom;</span><br><span class="line">        <span class="built_in">let</span> realSrc = el.dataset.src;</span><br><span class="line">        <span class="keyword">if</span>(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123;</span><br><span class="line">            <span class="keyword">if</span>(realSrc)&#123;</span><br><span class="line">                el.src = realSrc;</span><br><span class="line">                el.removeAttribute(<span class="string">'data-src'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 节流</span><br><span class="line">    throttle(fn,delay)&#123;</span><br><span class="line">        <span class="built_in">let</span> timer; </span><br><span class="line">        <span class="built_in">let</span> prevTime;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">function</span>(...args)&#123;</span><br><span class="line">            <span class="built_in">let</span> currTime = Date.now();</span><br><span class="line">            <span class="built_in">let</span> context = this;</span><br><span class="line">            <span class="keyword">if</span>(!prevTime) prevTime = currTime;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(currTime - prevTime &gt; delay)&#123;</span><br><span class="line">                prevTime = currTime;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timer = setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                prevTime = Date.now();</span><br><span class="line">                timer = null;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> default LazyLoad;</span><br></pre></td></tr></table></figure>
<p>·一键copy的功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Message &#125; from <span class="string">'ant-design-vue'</span>;</span><br><span class="line"></span><br><span class="line">const vCopy = &#123; //</span><br><span class="line">  /*</span><br><span class="line">    <span class="built_in">bind</span> 钩子函数，第一次绑定时调用，可以在这里做初始化设置</span><br><span class="line">    el: 作用的 dom 对象</span><br><span class="line">    value: 传给指令的值，也就是我们要 copy 的值</span><br><span class="line">  */</span><br><span class="line">  <span class="built_in">bind</span>(el, &#123; value &#125;) &#123;</span><br><span class="line">    el.<span class="variable">$value</span> = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到</span><br><span class="line">    el.handler = () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!el.<span class="variable">$value</span>) &#123;</span><br><span class="line">      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意</span><br><span class="line">        Message.warning(<span class="string">'无复制内容'</span>);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      // 动态创建 textarea 标签</span><br><span class="line">      const textarea = document.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">      // 将该 textarea 设为 <span class="built_in">readonly</span> 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span><br><span class="line">      textarea.readOnly = <span class="string">'readonly'</span>;</span><br><span class="line">      textarea.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">      textarea.style.left = <span class="string">'-9999px'</span>;</span><br><span class="line">      // 将要 copy 的值赋给 textarea 标签的 value 属性</span><br><span class="line">      textarea.value = el.<span class="variable">$value</span>;</span><br><span class="line">      // 将 textarea 插入到 body 中</span><br><span class="line">      document.body.appendChild(textarea);</span><br><span class="line">      // 选中值并复制</span><br><span class="line">      textarea.select();</span><br><span class="line">      // textarea.setSelectionRange(0, textarea.value.length);</span><br><span class="line">      const result = document.execCommand(<span class="string">'Copy'</span>);</span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        Message.success(<span class="string">'复制成功'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      document.body.removeChild(textarea);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 绑定点击事件，就是所谓的一键 copy 啦</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, el.handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当传进来的值更新的时候触发</span><br><span class="line">  componentUpdated(el, &#123; value &#125;) &#123;</span><br><span class="line">    el.<span class="variable">$value</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 指令与元素解绑的时候，移除事件绑定</span><br><span class="line">  unbind(el) &#123;</span><br><span class="line">    el.removeEventListener(<span class="string">'click'</span>, el.handler);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default vCopy;</span><br></pre></td></tr></table></figure>
<p>还有拖拽指令、页面水印、权限校验等等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/21/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/21/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2/" itemprop="url">单页面和多页面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-21T09:38:11+08:00">
                2021-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%9A%E5%8A%A1/" itemprop="url" rel="index">
                    <span itemprop="name">业务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  254 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单页面应用(SPA):只有一个主页面的应用，单页面跳转，仅刷新局部资源。多应用于PC端。<br>多页面应用(MPA):就是指一个应用中有多个页面，页面跳转时是整页刷新，公共资源等选择性重新加载。<br>单页面的优点：<br>资源共用，页面局部刷新，切换速度快，用户体验良好。<br>数据传递容易，维护成本较低。开发成本较高，需要借助框架。<br>缺点：不利于SEO优化，可利用SSR优化。</p>
<p>多页面优点：搜索引擎优化简易，开发成本较低，但重复代码多。<br>缺点：公共资源不共用，页面切换加载慢，流畅度不够。无法实现跳转动画，<br>依赖url，cookie，localstorage传参。维护成本较高。</p>
<p>单页面适用场景：高要求的体验度、追求界面流畅的应用。<br>多页面的适用场景：适用于追求高度支持搜索引擎的应用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/04/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/04/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%81%93/" itemprop="url">前端进阶之道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-04T15:21:26+08:00">
                2020-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.7k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  20 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JS内置类型"><a href="#JS内置类型" class="headerlink" title="JS内置类型"></a>JS内置类型</h1><p>null,undefined,boolean,number,string,symbol<br>数字类型属于浮点类型，没有整型。NaN属于number类型，NaN不等于自身。<br>let a = 111 //这只是字面量，不是number类型<br>a.toString()//使用时候才会转换为对象类型<br>JS对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。<br>let a = {name:’FE’}    let b = a<br>b.name=’EF’  console.log(a.name) //EF</p>
<h1 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h1><p>typeof对于基本类型，除了null都可以显示正确的类型。<br>typeof对于对象，除了函数都会显示object<br>typeof null //  ‘object’<br>变量的正确类型获取：Object.prototype.toString.call(xx)//获取[object Type]</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>转Boolean:在条件判断时，除了undefined，null，false，NaN，’’,0,-0,其他所有值都转为true，包括所有对象。</p>
<h1 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h1><p>首先调用valueOf,调用toString,方法可以重写<br>重写Symbol.toPrimitive,该方法在转基本类型时调用优先级最高<br>let a = {<br>valueOf(){return 0;},<br>toString(){return ‘1’;},<br><a href>Symbol.toPrimitive</a>{return 2;}<br>}</p>
<h1 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h1><p>+（加法）：其中一方是字符串类型，就会转另一个为字符串。<br>其他运算，只要一方是数字，另一方就转为数字。<br>加法运算会触发三只类型转换，将值转换为原始值，转换为数字，转换为字符串。<br>== 操作符：<br>undefined == undefined //true<br>Null == Null //true<br>NaN == Nan //false<br>+0 == -0 //true<br>a == b //引用同一对象时相等<br>null == undefined //true<br>comparison x(Number) == ToNumber y(String)//对比类型返回此结果<br>ToNumber x(String) == y(Number)<br>ToNumber x(Boolean) == y<br>x == ToNumber y(Boolean)<br>x(String/Number) == ToPrimitive y(Object)<br>ToPrimitive x(Object) == y(String/Number)</p>
<hr>
<p>[ ] == ! [ ] // -&gt;true<br>// [ ]转成true，取反为false<br>[ ] == false<br>// 根据 x == ToNumber y(Boolean)<br>[ ] == 0<br>//根据ToPrimitive x(Object) == y(Number)<br>ToPrimitive([ ]) == 0<br>// [ ].toString() -&gt; ‘ ‘<br>‘ ‘ == 0<br>//根据ToNumber x(String) == y<br>0 == 0 // -&gt; true</p>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>1.如果是对象，通过toPrimitive转换对象来比较<br>2.如果是字符串，通过Unicode字符索引来比较</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>每个函数都有prototype属性，除了Function.prototype.bind(),该属性指向原型。<br>每个对象都有_proto_属性，指向创建该对象的构造函数的原型。其实这个指向了[[prototype]],但是[[prototype]]是内部属性，我们并不能访问到，所以用_proto_来访问。</p>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>1.新生成一个对象<br>2.链接到原型<br>3.绑定this<br>4.返回新对象<br>function create() {<br>    let obj = new Object() //创建一个空的对象<br>    let Con = [].shift.call(arguments) //获得构造函数<br>    obj.<strong>proto</strong> = Con.prototype //链接到原型<br>    let result = Con.apply(obj,arguments)//绑定this，执行构造函数<br>    return typeof result === ‘object’ ? result :obj//确保new出来的是个对象<br>}<br>创建对象，更推荐使用字面量的方式创建对象。使用new Object()需通过作用域链找Object<br>function Foo() {} // function就是个语法糖，内部等同于 new Function<br>let a = {b:1} //这个字面量内部也是使用了 new Object()<br>new 需要注意下运算符优先级<br>function Foo(){return this;}<br>Foo.getName = function (){console.log(‘1’);};<br>Foo.prototype.getName = function () {console.log(‘2’);};<br>new Foo.getName(); // -&gt;1<br>new Foo().getName(); // -&gt; 2<br>Foo()的优先级更大</p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>instanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype。<br>手动实现instanceof:<br>function instanceof(left,right){<br>    //获得类型的原型<br>    let prototype = right.prototype<br>    //获得对象的原型<br>    left = left.<strong>proto</strong><br>    //判断对象的类型是否等于类型的原型<br>    while(true) {<br>       if(left === null)<br>          return false<br>       if(prototype === left)<br>          return true<br>       left = left.<strong>proto</strong><br>    }<br>}</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>function foo(){console.log(this.a)}<br>var a = 1<br>foo()</p>
<p>var obj = {a: 2,foo: foo}<br>obj.foo()<br>//以上两者情况’this’只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</p>
<p>//以下情况是优先级最高的，’this’只会绑定在’c’上，不会被任何方式修改’this’指向<br>var c = new foo()<br>c.a = 3</p>
<p>console.log(c.a)<br>// 还有种就是利用call，apply，bind改变this，最高优先级仅次于new<br>针对箭头函数<br>function a(){<br> return ()=&gt;{<br>    return ()=&gt;{<br>      console.log(this)<br>    }<br> }<br>}<br>console.log(a()()())<br>箭头函数没有this,这个函数只取决于他外面的第一个不是箭头函数的this，在这个例子中，因为调用a符合前面代码中的第一个情况，所以this是Window，并且this一旦绑定的上下文，就不会被任何代码改变。</p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行JS代码由三种上下文<br>1.全局执行上下文<br>2.函数执行上下文<br>3.eval执行上下文<br>每个执行上下文中都有三个重要的属性<br>.变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问<br>.作用域链（JS采用词法作用域，也就是说变量的作用域是在定义时就决定了）<br>.this<br>var a = 10<br>function foo(i){var b = 20}<br>foo()<br>上诉代码，执行栈中有两个上下文：全局上下文和函数foo上下文<br>stack=[globalContext,fooContext]<br>对于全局上下文来说，VO是这样的<br>globalContext.VO === globe<br>globalContext.VO = {<br>   a: undefined,<br>   foo:<Function>,<br>}<br>对于函数foo来说，VO不能访问，只能访问到活动对象（AO）<br>fooContext.VO === foo.AO<br>fooContext.AO {<br>   i: undefined<br>   b: undefined<br>   arguments:&lt;&gt;<br>}<br>//arguments是函数独有的对象(箭头函数没有)<br>//该对象是一个伪数组，有length属性且可以通过下标访问元素<br>//该对象中的callee属性代表函数本身<br>//caller属性代表函数的调用者<br>对于作用域链，可以把它理解成自身变量对象和上级变量对象的列表，通过[[Scope]]属性查找上级变量<br>fooContext.[[Scope]] = [globalContext.VO]<br>fooContext.Scope = fooContext.[[Scope]] + fooContext.VO<br>fooContext.Scope = [<br>    fooContext.VO,<br>    globalContext.VO<br>]<br>函数和变量提升：<br>生成执行上下文有两个阶段，第一个阶段是创建的阶段（创建VO），JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只需要声明并且赋值为undefined，第二个阶段为代码执行阶段，可以提前使用。<br>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升。<br>b() // b2<br>function b(){<br>   console.log(‘b1’)<br>}<br>function b(){<br>   console.log(‘b2’)<br>}<br>var会产生很多错误，所以ES6引入了let，let不能在声明前使用，let有提升，但未赋值，所以不能提前使用。<br>var foo = 1<br>(function foo(){<br>   foo = 10<br>   console.log(foo)<br>}()) // -&gt;f foo(){foo=10;console.log(foo)}<br>JS解释器遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到foo。但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生改变。</Function></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包定义：函数A返回一个函数B，函数B使用A的变量，B成为闭包。<br>function A(){<br>   let a = 1<br>   function B(){<br>       console.log(a)<br>   }<br>   return B<br>}</p>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>let a = {<br>   age: 1<br>}<br>let b = a<br>a.age = 2<br>console.log(b.age) // 2 因为是引用，浅拷贝<br>浅拷贝：<br>1.通过Object.assign解决<br>let a = {age:1}<br>let b = Object.assign({},a)<br>a.age = 2<br>console.log(b.age) // 1<br>2.运算符(…)解决<br>let a = {age:1}<br>let b = {…a}<br>a.age = 2<br>console.log(b.age) // 1<br>浅拷贝对于二层对象引用无效<br>let a = {jobs:{first:’FE’}}<br>let b = {…a}<br>a.jobs.first = ‘native’<br>console.log(b.jobs.first) // native</p>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>1.通过JSON.parse(JSON.stringify(object))解决<br>let a = {jobs:{first:’FE’}}<br>let b = JSON.parse(JSON.stringfy(a))<br>a.jobs.first = ‘native’<br>console.log(b.jobs.first)<br>该方法有局限性:<br>会忽略undefined<br>会忽略symbol<br>不能序列化函数<br>不能解决循环引用的对象</p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>// file a.js<br>export function a() {}<br>export function b() {}<br>// file b.js<br>export default function() {}</p>
<p>import {a,b} from ‘./a.js’<br>import XXX from ‘./b.js’</p>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>// a.js<br>module.exports = {<br>   a:1<br>}<br>// or<br>exports.a = 1</p>
<p>//b.js<br>var module = require(‘./a.js’)<br>module.a // -&gt;log 1</p>
<p>var module = require(‘./a.js’)<br>module.a<br>// 这里其实包装了一层立即执行函数，这样就不会污染全局变量了<br>// 重要的是module这里，module是Node独有的一个变量<br>module.exports = {a:1}<br>//基本实现<br>var module = {exports:{} //exports是个空对象}<br>// 这个是为什么exports和module.exports用法相似的原因<br>var exports = module.exports<br>var load = function (module) {<br>   //导出的东西<br>  var a = 1<br>  module.exports = a<br>  return module.exports<br>};<br>module.exports和exports用法相似,但是无法直接赋值，无效果。<br>CommonJS和ES6中的模块化的两者区别是：<br>1.前者支持动态导入，也就是require(${path}/xx.js),后者目前不支持<br>2.前者是同步导入，因为用于服务端，文件在本地，同步导入即使卡住主线程影响也不大。后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响<br>3.前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化<br>后者会编译成require/exports来执行的</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用函数。<br>防抖实现：<br>const debounce = (func,wait=50) =&gt;{<br>    // 缓存一个定时器id<br>    let timer = 0<br>    // 这里返回的函数是每次用户实际调用的防抖函数<br>    // 如果已经设定过定时器了就清空上一次的定时器<br>    // 开始一个新的定时器，延迟执行用户传入的方法<br>    return function(…args) {<br>        if(timer) clearTimeout(timer)<br>        timer = setTimeout(() =&gt;{<br>           func.apply(this,args)<br>        },wait)<br>    }<br>}<br>// 这是一个简单版的防抖，只能在最后调用，一般防抖有immediate选项，表示是否立即调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 这个是用来获取当前时间戳的</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">now</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> +new Date()</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 <span class="built_in">wait</span>，func 才会执行</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;<span class="keyword">function</span>&#125; func        回调函数</span><br><span class="line"> * @param  &#123;number&#125;   <span class="built_in">wait</span>        表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span><br><span class="line"> * @<span class="built_in">return</span> &#123;<span class="keyword">function</span>&#125;             返回客户调用函数</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> debounce (func, <span class="built_in">wait</span> = 50, immediate = <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">let</span> timer, context, args</span><br><span class="line"></span><br><span class="line">  // 延迟执行函数</span><br><span class="line">  const later = () =&gt; setTimeout(() =&gt; &#123;</span><br><span class="line">    // 延迟函数执行完毕，清空缓存的定时器序号</span><br><span class="line">    timer = null</span><br><span class="line">    // 延迟执行的情况下，函数会在延迟函数中执行</span><br><span class="line">    // 使用到之前缓存的参数和上下文</span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="built_in">wait</span>)</span><br><span class="line"></span><br><span class="line">  // 这里返回的函数是每次实际调用的函数</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(...params) &#123;</span><br><span class="line">    // 如果没有创建延迟执行函数（later），就创建一个</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      // 如果是立即执行，调用函数</span><br><span class="line">      // 否则缓存参数和调用上下文</span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(this, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = this</span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span><br><span class="line">    // 这样做延迟函数会重新计时</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / <span class="built_in">wait</span></span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;<span class="keyword">function</span>&#125;   func      回调函数</span><br><span class="line"> * @param  &#123;number&#125;     <span class="built_in">wait</span>      表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: <span class="literal">false</span>&#125;。</span><br><span class="line"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: <span class="literal">false</span>&#125;</span><br><span class="line"> *                                两者不能共存，否则函数不能执行</span><br><span class="line"> * @<span class="built_in">return</span> &#123;<span class="keyword">function</span>&#125;             返回客户调用函数</span><br><span class="line"> */</span><br><span class="line">_.throttle = <span class="keyword">function</span>(func, <span class="built_in">wait</span>, options) &#123;</span><br><span class="line">    var context, args, result;</span><br><span class="line">    var timeout = null;</span><br><span class="line">    // 之前的时间戳</span><br><span class="line">    var previous = 0;</span><br><span class="line">    // 如果 options 没传则设为空对象</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    // 定时器回调函数</span><br><span class="line">    var later = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      // 如果设置了 leading，就将 previous 设为 0</span><br><span class="line">      // 用于下面函数的第一个 <span class="keyword">if</span> 判断</span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? 0 : _.now();</span><br><span class="line">      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span><br><span class="line">      timeout = null;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      // 获得当前时间戳</span><br><span class="line">      var now = _.now();</span><br><span class="line">      // 首次进入前者肯定为 <span class="literal">true</span></span><br><span class="line">	  // 如果需要第一次不执行函数</span><br><span class="line">	  // 就将上次时间戳设为当前的</span><br><span class="line">      // 这样在接下来计算 remaining 的值时会大于0</span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      // 计算剩余时间</span><br><span class="line">      var remaining = <span class="built_in">wait</span> - (now - previous);</span><br><span class="line">      context = this;</span><br><span class="line">      args = arguments;</span><br><span class="line">      // 如果当前调用已经大于上次调用时间 + <span class="built_in">wait</span></span><br><span class="line">      // 或者用户手动调了时间</span><br><span class="line"> 	  // 如果设置了 trailing，只会进入这个条件</span><br><span class="line">	  // 如果没有设置 leading，那么第一次会进入这个条件</span><br><span class="line">	  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 <span class="keyword">if</span> 条件了</span><br><span class="line">	  // 其实还是会进入的，因为定时器的延时</span><br><span class="line">	  // 并不是准确的时间，很可能你设置了2秒</span><br><span class="line">	  // 但是他需要2.2秒才触发，这时候就会进入这个条件</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= 0 || remaining &gt; <span class="built_in">wait</span>) &#123;</span><br><span class="line">        // 如果存在定时器就清理掉否则会调用二次回调</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = null;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = null;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        // 判断是否设置了定时器和 trailing</span><br><span class="line">	    // 没有的话就开启一个定时器</span><br><span class="line">        // 并且不能不能同时设置 leading 和 trailing</span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>function MyData(){}<br>MyData.prototype.test = function (){<br>    return this.getTime()<br>}<br>let d = new Date()<br>Object.setPrototypeOf(d,MyData,prototype)<br>Object.setPrototypeOf(MyData.prototype,Date.prototype)<br>先创建父类实例=&gt;改变实例原先的<strong>proto</strong>转而连接到子类的prototype =&gt;子类的prototype的<strong>proto</strong>改为父类的prototype</p>
<h1 id="apply-call-bind区别"><a href="#apply-call-bind区别" class="headerlink" title="apply,call,bind区别"></a>apply,call,bind区别</h1><p>call和apply都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同。<br>除了第一个参数外，call可以接受一个参数列表，apply只接受一个参数数组。<br>let a = {value:1}<br>function getValue(name,age){<br>    console.log(name)<br>    console.log(age)<br>    console.log(this.value)<br>}<br>getValue.call(a,’yck’,’24’)<br>getValue.apply(a,[‘yck’,’24’])<br>模拟实现call和apply<br>不传入第一个参数，默认为window<br>改变了this指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？<br>Call：<br>Function.prototype.myCall = function (context) {<br>  var context = context || window<br>  // 给 context 添加一个属性<br>  // getValue.call(a, ‘yck’, ‘24’) =&gt; a.fn = getValue<br>  context.fn = this<br>  // 将 context 后面的参数取出来<br>  var args = […arguments].slice(1)<br>  // getValue.call(a, ‘yck’, ‘24’) =&gt; a.fn(‘yck’, ‘24’)<br>  var result = context.fn(…args)<br>  // 删除 fn<br>  delete context.fn<br>  return result<br>}<br>Apply：<br>Function.prototype.myApply = function (context) {<br>  var context = context || window<br>  context.fn = this</p>
<p>  var result<br>  // 需要判断是否存储第二个参数<br>  // 如果存在，就将第二个参数展开<br>  if (arguments[1]) {<br>    result = context.fn(…arguments[1])<br>  } else {<br>    result = context.fn()<br>  }</p>
<p>  delete context.fn<br>  return result<br>}<br>bind：<br>Function.prototype.myBind = function (context) {<br>  if (typeof this !== ‘function’) {<br>    throw new TypeError(‘Error’)<br>  }<br>  var _this = this<br>  var args = […arguments].slice(1)<br>  // 返回一个函数<br>  return function F() {<br>    // 因为返回了一个函数，我们可以 new F()，所以需要判断<br>    if (this instanceof F) {<br>      return new _this(…args, …arguments)<br>    }<br>    return _this.apply(context, args.concat(…arguments))<br>  }<br>}</p>
<h1 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">// 三种状态</span><br><span class="line">const PENDING = <span class="string">"pending"</span>;</span><br><span class="line">const RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line">const REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line">// promise 接收一个函数参数，该函数会立即执行</span><br><span class="line"><span class="keyword">function</span> MyPromise(fn) &#123;</span><br><span class="line">  <span class="built_in">let</span> _this = this;</span><br><span class="line">  _this.currentState = PENDING;</span><br><span class="line">  _this.value = undefined;</span><br><span class="line">  // 用于保存 <span class="keyword">then</span> 中的回调，只有当 promise</span><br><span class="line">  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span><br><span class="line">  _this.resolvedCallbacks = [];</span><br><span class="line">  _this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  _this.resolve = <span class="keyword">function</span> (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value instanceof MyPromise) &#123;</span><br><span class="line">      // 如果 value 是个 Promise，递归执行</span><br><span class="line">      <span class="built_in">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序</span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = RESOLVED;</span><br><span class="line">        _this.value = value;</span><br><span class="line">        _this.resolvedCallbacks.forEach(cb =&gt; cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  _this.reject = <span class="keyword">function</span> (reason) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序</span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = REJECTED;</span><br><span class="line">        _this.value = reason;</span><br><span class="line">        _this.rejectedCallbacks.forEach(cb =&gt; cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 用于解决以下问题</span><br><span class="line">  // new Promise(() =&gt; throw Error(<span class="string">'error))</span></span><br><span class="line"><span class="string">  try &#123;</span></span><br><span class="line"><span class="string">    fn(_this.resolve, _this.reject);</span></span><br><span class="line"><span class="string">  &#125; catch (e) &#123;</span></span><br><span class="line"><span class="string">    _this.reject(e);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MyPromise.prototype.then = function (onResolved, onRejected) &#123;</span></span><br><span class="line"><span class="string">  var self = this;</span></span><br><span class="line"><span class="string">  // 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line"><span class="string">  var promise2;</span></span><br><span class="line"><span class="string">  // 规范 2.2.onResolved 和 onRejected 都为可选参数</span></span><br><span class="line"><span class="string">  // 如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line"><span class="string">  // Promise.resolve(4).then().then((value) =&gt; console.log(value))</span></span><br><span class="line"><span class="string">  onResolved = typeof onResolved === '</span><span class="keyword">function</span><span class="string">' ? onResolved : v =&gt; v;</span></span><br><span class="line"><span class="string">  onRejected = typeof onRejected === '</span><span class="keyword">function</span><span class="string">' ? onRejected : r =&gt; throw r;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (self.currentState === RESOLVED) &#123;</span></span><br><span class="line"><span class="string">    return (promise2 = new MyPromise(function (resolve, reject) &#123;</span></span><br><span class="line"><span class="string">      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line"><span class="string">      // 所以用了 setTimeout 包裹下</span></span><br><span class="line"><span class="string">      setTimeout(function () &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          var x = onResolved(self.value);</span></span><br><span class="line"><span class="string">          resolutionProcedure(promise2, x, resolve, reject);</span></span><br><span class="line"><span class="string">        &#125; catch (reason) &#123;</span></span><br><span class="line"><span class="string">          reject(reason);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (self.currentState === REJECTED) &#123;</span></span><br><span class="line"><span class="string">    return (promise2 = new MyPromise(function (resolve, reject) &#123;</span></span><br><span class="line"><span class="string">      setTimeout(function () &#123;</span></span><br><span class="line"><span class="string">        // 异步执行onRejected</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          var x = onRejected(self.value);</span></span><br><span class="line"><span class="string">          resolutionProcedure(promise2, x, resolve, reject);</span></span><br><span class="line"><span class="string">        &#125; catch (reason) &#123;</span></span><br><span class="line"><span class="string">          reject(reason);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (self.currentState === PENDING) &#123;</span></span><br><span class="line"><span class="string">    return (promise2 = new MyPromise(function (resolve, reject) &#123;</span></span><br><span class="line"><span class="string">      self.resolvedCallbacks.push(function () &#123;</span></span><br><span class="line"><span class="string">        // 考虑到可能会有报错，所以使用 try/catch 包裹</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          var x = onResolved(self.value);</span></span><br><span class="line"><span class="string">          resolutionProcedure(promise2, x, resolve, reject);</span></span><br><span class="line"><span class="string">        &#125; catch (r) &#123;</span></span><br><span class="line"><span class="string">          reject(r);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      self.rejectedCallbacks.push(function () &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">          var x = onRejected(self.value);</span></span><br><span class="line"><span class="string">          resolutionProcedure(promise2, x, resolve, reject);</span></span><br><span class="line"><span class="string">        &#125; catch (r) &#123;</span></span><br><span class="line"><span class="string">          reject(r);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">// 规范 2.3</span></span><br><span class="line"><span class="string">function resolutionProcedure(promise2, x, resolve, reject) &#123;</span></span><br><span class="line"><span class="string">  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line"><span class="string">  if (promise2 === x) &#123;</span></span><br><span class="line"><span class="string">    return reject(new TypeError("Error"));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  // 规范 2.3.2</span></span><br><span class="line"><span class="string">  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line"><span class="string">  if (x instanceof MyPromise) &#123;</span></span><br><span class="line"><span class="string">    if (x.currentState === PENDING) &#123;</span></span><br><span class="line"><span class="string">      x.then(function (value) &#123;</span></span><br><span class="line"><span class="string">        // 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line"><span class="string">        // 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line"><span class="string">        // 把值传给下个 then</span></span><br><span class="line"><span class="string">        resolutionProcedure(promise2, value, resolve, reject);</span></span><br><span class="line"><span class="string">      &#125;, reject);</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">      x.then(resolve, reject);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  // 规范 2.3.3.3.3</span></span><br><span class="line"><span class="string">  // reject 或者 resolve 其中一个执行过得话，忽略其他的</span></span><br><span class="line"><span class="string">  let called = false;</span></span><br><span class="line"><span class="string">  // 规范 2.3.3，判断 x 是否为对象或者函数</span></span><br><span class="line"><span class="string">  if (x !== null &amp;&amp; (typeof x === "object" || typeof x === "function")) &#123;</span></span><br><span class="line"><span class="string">    // 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">      // 规范 2.3.3.1</span></span><br><span class="line"><span class="string">      let then = x.then;</span></span><br><span class="line"><span class="string">      // 如果 then 是函数，调用 x.then</span></span><br><span class="line"><span class="string">      if (typeof then === "function") &#123;</span></span><br><span class="line"><span class="string">        // 规范 2.3.3.3</span></span><br><span class="line"><span class="string">        then.call(</span></span><br><span class="line"><span class="string">          x,</span></span><br><span class="line"><span class="string">          y =&gt; &#123;</span></span><br><span class="line"><span class="string">            if (called) return;</span></span><br><span class="line"><span class="string">            called = true;</span></span><br><span class="line"><span class="string">            // 规范 2.3.3.3.1</span></span><br><span class="line"><span class="string">            resolutionProcedure(promise2, y, resolve, reject);</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          e =&gt; &#123;</span></span><br><span class="line"><span class="string">            if (called) return;</span></span><br><span class="line"><span class="string">            called = true;</span></span><br><span class="line"><span class="string">            reject(e);</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        // 规范 2.3.3.4</span></span><br><span class="line"><span class="string">        resolve(x);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125; catch (e) &#123;</span></span><br><span class="line"><span class="string">      if (called) return;</span></span><br><span class="line"><span class="string">      called = true;</span></span><br><span class="line"><span class="string">      reject(e);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125; else &#123;</span></span><br><span class="line"><span class="string">    // 规范 2.3.4，x 为基本类型</span></span><br><span class="line"><span class="string">    resolve(x);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url">JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-23T09:43:04+08:00">
                2020-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript高级程序设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  12.9k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  51 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-1-历史回顾"><a href="#1-1-历史回顾" class="headerlink" title="1.1 历史回顾"></a>1.1 历史回顾</h1><p>网站数据量大，复杂。需要JS来解决，优化。</p>
<h1 id="1-2-JS实现"><a href="#1-2-JS实现" class="headerlink" title="1.2 JS实现"></a>1.2 JS实现</h1><p>JS = ECMAScript（核心） + DOM（文档对象模型） + BOM（浏览器对象模型）</p>
<h2 id="1-2-1（ECMAScript）"><a href="#1-2-1（ECMAScript）" class="headerlink" title="1.2.1（ECMAScript）"></a>1.2.1（ECMAScript）</h2><p>ES：网页提供ES的基准实现和与环境自身交互必须的扩展。<br>ES包括：语法、类型、语句、关键字、保留字、操作符、全局对象。<br>大部分浏览器兼容ES6。</p>
<h2 id="1-2-2-DOM"><a href="#1-2-2-DOM" class="headerlink" title="1.2.2 DOM"></a>1.2.2 DOM</h2><p>文档对象模型：是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。F12中常见的文档树。<br><img src="/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%96%87%E6%A1%A3%E6%A0%91.png" alt="文档树"><br>DOM通过创建表示文档的树，让开发者可以更好地控制网页的内容和结构。使用DOM的API，可以轻松删除，添加，替换，修改节点。<br>DOM视图：描述追踪文档不同视图的接口。<br>DOM事件：描述事件及事件处理的接口。<br>DOM样式：描述处理元素CSS样式的接口。<br>DOM遍历的范围：描述遍历和操作DOM数的接口。<br>其他DOM：可伸缩矢量图（SVG），数学标记语言（MathML），同步多媒体集成语言（SMIL）<br>DOM有不同level（版本）:目前到了level3</p>
<h2 id="1-2-3-BOM"><a href="#1-2-3-BOM" class="headerlink" title="1.2.3 BOM"></a>1.2.3 BOM</h2><p>浏览器对象模型：用于支持访问和操作浏览器的窗口。使用BOM，可以操控浏览器显示页面之外的部分，BOM针对浏览器窗口和子窗口。拓展：<br>弹出新浏览器窗口的能力；<br>移动、缩放和关闭浏览器窗口的能力；<br>navigator对象，提供关于浏览器的详尽信息；<br>location对象，提供浏览器加载页面的详尽信息；<br>screen对象，提供关于用户屏幕分辨率的详尽信息；<br>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；<br>对cookie的支持；<br>其他自定义对象，XMLHttp，ActiveXObject；</p>
<h1 id="1-3-JavaScript版本"><a href="#1-3-JavaScript版本" class="headerlink" title="1.3 JavaScript版本"></a>1.3 JavaScript版本</h1><h1 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h1><p>JS是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br>ES：有ECMA-262定义并提供核心功能。<br>文档对象模型（DOM）:提供与网页内容交互的方法和接口。<br>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。<br>JS这三个部门得到了五大Web浏览器不同程度的支持。所有浏览器基本上对ES5提供了完善的支持，ES6最佳。</p>
<hr>
<h1 id="2-1-script元素"><a href="#2-1-script元素" class="headerlink" title="2.1 script元素"></a>2.1 script元素</h1><p>将Js插入HTML的主要方法是使用script元素。有下列8个属性：<br>1.async：可选，表示立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。<br>2.charset：可选，使用src属性指定的代码字符集。很少用。<br>3.crossorigin：可选，配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。<br>defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。<br>integrity：可选，允许比对接收到的资源和指定的加密签名以验证子资源完整性。<br>language：废弃。<br>src：可选，表示包含要执行的代码的外部文件。（引入外部JS文件）<br>type：可选，代替language，表示代码块中脚本语言的内容类型（MIME类型）。按照惯例这个值始终都是“text/JavaScript”，MIME类型通常都是“application/x-javascript”，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。</p>
<h2 id="2-1-1-标签位置"><a href="#2-1-1-标签位置" class="headerlink" title="2.1.1 标签位置"></a>2.1.1 标签位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>
<p>上述是把文件放在head里，不过这种写法以为着必须把所有JS代码都下载、解析和解释完成后，才能开始渲染页面，可能会导致页面渲染的明显延迟，所以通常把文件引用放在body元素中的页面内容后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src&#x3D;&#39;example2.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-2-推迟执行脚本"><a href="#2-1-2-推迟执行脚本" class="headerlink" title="2.1.2 推迟执行脚本"></a>2.1.2 推迟执行脚本</h2><p>可用defer属性，可用推迟脚本执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-3-异步执行脚本"><a href="#2-1-3-异步执行脚本" class="headerlink" title="2.1.3 异步执行脚本"></a>2.1.3 异步执行脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-4-动态加载脚本"><a href="#2-1-4-动态加载脚本" class="headerlink" title="2.1.4 动态加载脚本"></a>2.1.4 动态加载脚本</h2><p>JS可用使用DOM API ，通过向DOM中动态添加Script元素同样可用加载指定的脚本，只要创建一个Script元素并将其添加到DOM即可。如下：<br>let script = document.createElement(‘script’);<br>script.src = ‘gibbersh.js’<br>document.head.appendChild(script);<br>这个请求是异步的，不是所有浏览器都支持async属性，因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。<br>添加：script.async = false;<br>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。这种可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;gibberish.js&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-5-XMHTL中的变化"><a href="#2-1-5-XMHTL中的变化" class="headerlink" title="2.1.5 XMHTL中的变化"></a>2.1.5 XMHTL中的变化</h2><p>XHTML：可扩展超文本标记语言，是将HTML作为XML的应用重新包装的结果。在XHTML中使用JS必须制定type属性且值为text/javascript。<br>XHTML比较少见。</p>
<h2 id="2-1-6-废弃的语法"><a href="#2-1-6-废弃的语法" class="headerlink" title="2.1.6 废弃的语法"></a>2.1.6 废弃的语法</h2><p>个别废弃的语法，可不看。</p>
<h1 id="2-2-行内代码与外部文件"><a href="#2-2-行内代码与外部文件" class="headerlink" title="2.2 行内代码与外部文件"></a>2.2 行内代码与外部文件</h1><p>最佳实践是尽可能将JS代码放在外部文件中。推荐原因如下：<br>可维护性：JS代码分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。<br>缓存：浏览器会根据特定的设置缓存所有外部链接的JS文件，这意味着若干两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。<br>适应未来：通过把JS放到外部文件中，就不比考虑用XHTML的或注释黑科技。包含外部JS文件的语法在HTML和XHTML是一样的。<br>在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JS组件形式向客户端送达脚本更具优势。<br>在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从同一个地方取得一批文件，并将他们逐个放到浏览器缓存中。从浏览器角度看，通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JS文件的 延迟差不多。<br>在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。</p>
<h1 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3 文档模式"></a>2.3 文档模式</h1><p>最初有两种模式：混杂模式，标准模式。<br>第三种模式：准标准模式。</p>
<h1 id="2-4-noscript元素"><a href="#2-4-noscript元素" class="headerlink" title="2.4 noscript元素"></a>2.4 noscript元素</h1><p>针对不支持JS的浏览器而出的元素。以下两种情况，浏览器将显示包含在noscript中的内容：<br>浏览器不支持脚本；<br>浏览器对脚本的支持被关闭；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;noscript&gt; </span><br><span class="line">&lt;p&gt;This page requires a JavaScript-enabled browser.&lt;&#x2F;p&gt; </span><br><span class="line">&lt;&#x2F;noscript&gt;</span><br></pre></td></tr></table></figure>
<h1 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h1><p>JS通过script元素插入到HTML页面中。这个元素可以用于把JS代码嵌入到HTML页面汇总，跟其他标记混合在一起，也可以用与引入保存在外部文件中的JS。本章的重点如下：<br>1.要包含外部JS文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。<br>2.所有script元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在script元素中的代码必须严格按次序解释。<br>3.对不推迟执行的脚本，浏览器必须解释完位于script元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常把script元素放到页面末尾，介于主内容之后及body标签之前。<br>4.可以使用defer推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。<br>5.可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。<br>6.通过使用noscript元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则noscript元素中的任何内容都不会被渲染。</p>
<h1 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h1><h2 id="3-1-1-区别大小写"><a href="#3-1-1-区别大小写" class="headerlink" title="3.1.1 区别大小写"></a>3.1.1 区别大小写</h2><p>ECMA中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。<br>typeof不能作为函数名，因为它是一个关键字。但Typeof可以用。</p>
<h2 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a>3.1.2 标识符</h2><p>变量、函数、属性或函数参数的名称。可以由一个或多个下列字符组成：<br>第一个字符必须是一个字母、下划线（_）或美元符号（$）;<br>剩下的其他字符可以是字母、下划线、美元符号或数字。<br>一般使用驼峰大小写形式。</p>
<h2 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3 注释"></a>3.1.3 注释</h2><h2 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a>3.1.4 严格模式</h2><p>“use strict” //脚本开头加上这一行<br>也可以在指定函数内加上开头。所有现代浏览器都支持严格模式。</p>
<h2 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5 语句"></a>3.1.5 语句</h2><p>结尾建议加分号，建议语句块加{}</p>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2 关键字与保留字"></a>3.2 关键字与保留字</h2><p>ES6的关键字有：<br>break     do     in     typeof<br>case     else     instanceof     var<br>catch     export     new     void<br>class     extends     return     while<br>const     finally     super     with<br>continue   for     switch     yield<br>debugger function    this<br>default     if     throw<br>delete     import     try<br>ES6将来保留词汇：<br>始终保留：<br>enum<br>严格模式下保留：<br>implements     package     public<br>interface     protected     static<br>let     private<br>模块代码中保留：<br>await<br>这些词汇不能作标识符，但可以坐对象的属性名，推荐不用作属性名。</p>
<h1 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h1><p>ECMA变量是松散类型的，变量可以用于保存任何类型的数据。每个变量不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var,const,let<br>var:声明完后可以赋值，但未标识类型。//声明提升<br>//var message = “hi”;<br>//message = 100; // 合法，但不推荐。<br>//作用域在声明的环境下的函数作用域，例在函数内定义，调用完函数随即被销毁。<br>//在函数内定义时省略var操作符，可以创建一个全局变量。不推荐这么做。<br>let:块作用域，同一个块内不能重复声明。变量在作用域中无声明提升。<br>//有暂时性死区。<br>//无法全局声明，声明的变量不会成为window对象的属性。<br>//ES6不能依赖条件声明模式<br>const:与let基本相同，区别是声明变量时必须同时初始化变量，且无法修改const声明的变量。</p>
<h2 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4 声明风格及最佳实践"></a>3.3.4 声明风格及最佳实践</h2><p>1.不使用var<br>2.const优先，let次之</p>
<h1 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h1><p>ES6有6种简单的数据类型（原始类型）：undefined,null,boolean,number,String,Symbol。Symbol是ES6新增的。还有一种复杂的数据类型叫Object（对象）。Object是一种无序名值对的集合。</p>
<h2 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1 typeof操作符"></a>3.4.1 typeof操作符</h2><p>不需要参数（但可以使用参数），严格来说，函数也是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。可以用typeof区分。</p>
<h2 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2 Undefined类型"></a>3.4.2 Undefined类型</h2><p>变量未初始化即是Undefined，相当于给变量赋值了Undefined。<br>建议在声明时初始化，出现undefined可以更好辨别。</p>
<h2 id="3-4-4-Null类型"><a href="#3-4-4-Null类型" class="headerlink" title="3.4.4 Null类型"></a>3.4.4 Null类型</h2><p>Null类型同样只有一个值，即特殊值null。null值表示一个空对象指针，typeof null返回Object。<br>在定义将来要保存对象值的变量时，建议初始化为null。</p>
<h2 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4 Boolean类型"></a>3.4.4 Boolean类型</h2><p>有两个字面值：true，false。<br>True和False是有效的标识符，不是布尔值。//区分大小写<br>使用Boolean()来转换类型</p>
<h2 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a>3.4.5 Number类型</h2><p>1.浮点值<br>//小数点后面必须带数字，不然当整数处理。<br>2.值的范围<br>//Number.MIN_VALUE:5e-324<br>Number.MAX_VALUE:1.7976931348623157e+308<br>超出以上范围会表示为Infinity或-Infinity,该值无法用于计算。<br>可使用isFinite()函数进行判断<br>3.NaN<br>NaN表示”不是数值”,用于表示本来要返回数值的操作失败了（不是抛出错误）。<br>例：0除任意数值<br>console.log(0/0) // NaN<br>console.log(5/0) //Infinity<br>console.log(5/-0)//-Infinity<br>任何涉及NaN的操作始终返回NaN，NaN不等于任何值。//(NaN == NaN)–&gt;false<br>可用isNaN()函数判断是否不是数值<br>isNaN(NaN)//true<br>isNaN(10)//false<br>isNaN(“10”)//false,可转换为数值10<br>isNaN(“blue”)//true,无法转换为数值<br>isNaN(true)//false,可以转换为1<br>4.数值转换<br>有3个函数可以将非数值转换为数值：<br>Number(),parseInt(),parseFloat()<br>Number()是转型函数，可用于任何数据类型。后两个主要用于将字符串转为数值。<br>Number()有如下规则：<br>(true)-&gt;1,(false)-&gt;0,(null)-&gt;0,(undefined)-&gt;NaN,数值直接返回<br>如果字符串包含数值字符，包括数值字符前面带加号、减号的情况，则转换为一个十进制数值。<br>如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值（同样，忽略前面的0）。<br>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。<br>如果是空字符串（不包含字符），则返回0。<br>如果字符串包含上述情况之外的其他字符，则返回NaN。<br>通常使用parseInt（）</p>
<h2 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6 String类型"></a>3.4.6 String类型</h2><p>字符串使用：双引号，单引号，反引号都合法，引号类型前后必须一致。<br>1.字面量：<br>\n  换行<br>\t   制表<br>\b  退格<br>\r   回车<br>\f   换页等<br>2.特点<br>不可变，一旦创建，值不能变。要修改某个变量的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。<br>3.转换为字符串<br>toString()//函数<br>还可以传入参数输出不同进制<br>let num = 10;<br>num.toString() // “10”<br>num.toString(2) // “1010”<br>num.toString(8) // “12”<br>4.模板字面量<br>可以使用换行字符，可以跨行定义字符串。<br>使用反引号会保持引号内部的空格，字面量，length会增加。<br>5.字符串插值<br>可以在定义中插入一个或多个值。<br>通过反引号中使用 ${}插入，插入的值都会通过toString转换为字符串<br>插值表达式中可以调用函数和方法：<br>foo = {toString:() =&gt; ‘Wrold’};<code>hello,${foo}</code> // hello world<br>capitalize(word) =&gt;return <code>${word[0].toUpperCase()}</code>   // <code>${capitalize(&#39;hello&#39;)}</code>//-&gt;Hello<br>6.模板字面量标签函数<br>支持定义标签函数，通过标签函数可以自定义插值行为。<br>7.原始字符串<br>Unicode字符<br>使用String.raw获取原始字符串<br>‘\u00A9’ // 版权符号<br>String.raw<code>\u00A9</code>// \u00A9</p>
<h2 id="3-4-7-Symbol类型"><a href="#3-4-7-Symbol类型" class="headerlink" title="3.4.7 Symbol类型"></a>3.4.7 Symbol类型</h2><p>Symbol是ES6新增的，且实例是唯一，不可变的。用于创建唯一记号，进而用作非字符串形式的对象属性。<br>1.基本用法<br>let sym = Symbol(); type of sym//symbol<br>也可以传入字符串参数作为对symbol的描述，可通过这个字符串来调试代码。但这个字符串参数与符号定义或标识无关。<br>符号无法与new关键字一起作为构造函数使用。<br>可以使用符号包装对象，借用Object函数()函数：<br>let mySymbol = Symbol();<br>let myWrappedSymbol = Object (mySymbol);<br>console.log(typeof myWrappedSymbol); // “object”<br>2.使用全局符号注册表<br>如果运行时的不同部分需要共享和 重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br>需要使用Symbol.for()方法。</p>
<h2 id="3-4-8-Object类型"><a href="#3-4-8-Object类型" class="headerlink" title="3.4.8 Object类型"></a>3.4.8 Object类型</h2><p>对象其实就是一组数据和功能的集合。可以通过new来创建实例对象。<br>每个对象都有如下属性和方法：<br>constructor：用于创建当前对象的函数，构造函数。<br>hasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性。<br>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。<br>propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用。<br>toLacaleString():返回对象的字符串表示,反映对象所在本地化执行环境。<br>toString():返回对象的字符串表示。<br>valueOf():返回对象对应的字符串、数值或布尔值表示。</p>
<h1 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h1><h2 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h2><p>只操作一个值的操作符叫一元操作符。<br>++,–;  //操作中会自行转换类型,(递增和递减)<br>+,-//一元加减符，可以用于运算和转换</p>
<h2 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h2><p>…</p>
<h2 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h2><p>逻辑非，逻辑与逻辑或<br>1.逻辑非 ：！（感叹号）<br>!false // true<br>!”blue” //false<br>!0 //true<br>!NaN //true<br>!”” //true<br>!12345 //false<br>也可以用两个感叹号:!!,相当于调用了转型函数Boolean()。第一个返回布尔值，第二个对该布尔值取反。<br>相当于如上例子，布尔值取反。<br>2.逻辑与<br>由&amp;&amp;表示 // true &amp;&amp; true为true  其余都为false<br>3.逻辑或<br>由||表示 //有一个是true为true，false || false为false</p>
<h2 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4 乘性操作符"></a>3.5.4 乘性操作符</h2><p>乘法(<em>)，除法(/)，取模(%)。<br>乘法(</em>):都为数值则计算，有一项为NaN则返回NaN，如果是Infinity<em>0=NaN,Infinity</em>(-/+)num=(-)Infinity，Infinity*Infinity=Infinity,如果不是数值会转换后再近些操作。<br>除法(/):<br>0 / 0 = NaN,Infinity / Infinity = NaN,-(number)/0 = (-)Infinity,Infinity / (-)Number = (-)Infinity<br>取模(%):类似除</p>
<h2 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5 指数操作符"></a>3.5.5 指数操作符</h2><p>ES7新增的操作符 (*<em>)//Math.pow(3,2) == 3 *</em> 2 == 9<br>squared ** = 2 //9</p>
<h2 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6 加性操作符"></a>3.5.6 加性操作符</h2><p>（+），（-）</p>
<h2 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7 关系操作符"></a>3.5.7 关系操作符</h2><p>（&lt;）,（&gt;）,（&lt;=），（&gt;=）</p>
<h2 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8 相等操作符"></a>3.5.8 相等操作符</h2><p>（==），（!=），（===）,（!==）</p>
<h2 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9 条件操作符"></a>3.5.9 条件操作符</h2><p>（?）// let max = （num1 &gt; num2）? num1 : num2</p>
<h2 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10 赋值操作符"></a>3.5.10 赋值操作符</h2><p>（=），（*=），（/=），（%=），（+=）,（-=）,（&lt;&lt;=）,（&gt;&gt;=）,（&gt;&gt;&gt;=）</p>
<h1 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h1><h2 id="3-6-1-if语句"><a href="#3-6-1-if语句" class="headerlink" title="3.6.1 if语句"></a>3.6.1 if语句</h2><p>…</p>
<h2 id="3-6-2-do-while语句"><a href="#3-6-2-do-while语句" class="headerlink" title="3.6.2 do-while语句"></a>3.6.2 do-while语句</h2><p>do {***} while(expression);</p>
<h2 id="3-6-3-while语句"><a href="#3-6-3-while语句" class="headerlink" title="3.6.3 while语句"></a>3.6.3 while语句</h2><p>let i = 0;<br>while(i &lt; 10) { i += 2};</p>
<h2 id="3-6-4-for语句"><a href="#3-6-4-for语句" class="headerlink" title="3.6.4 for语句"></a>3.6.4 for语句</h2><p>for(initialization;expression;post-loop-expression) statement</p>
<h2 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5 for-in语句"></a>3.6.5 for-in语句</h2><p>for(property in expression) statement<br>for(const propName in window) {document.write(propName)}//例子</p>
<h2 id="3-6-6-for-of语句"><a href="#3-6-6-for-of语句" class="headerlink" title="3.6.6 for-of语句"></a>3.6.6 for-of语句</h2><p>for(property of expression) statement<br>for(const el of [2,4,6,8]){document.write(el)}//例子</p>
<h2 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7 标签语句"></a>3.6.7 标签语句</h2><p>label:statement<br>start: for(let i = 0;i &lt; count;i++){console.log(i)}//start是一个标签，可在后面通过break，continue语句引用。</p>
<h2 id="3-6-8-break和continue语句"><a href="#3-6-8-break和continue语句" class="headerlink" title="3.6.8 break和continue语句"></a>3.6.8 break和continue语句</h2><p>break用于立即退出循环,强行执行循环后的下一条语句。<br>continue语句用于立即退出循环，但会从循环顶部开始执行。</p>
<h2 id="3-6-9-with语句"><a href="#3-6-9-with语句" class="headerlink" title="3.6.9 with语句"></a>3.6.9 with语句</h2><p>with(expression) statement;<br>let qs = location.search.substring(1);<br>let hostName = location.hostname;<br>let url = location.href;<br>with(location){<br>let qs = search.substring(1);<br>let hostName = hostname;<br>let url = href;<br>}<br>严格模式不允许使用</p>
<h2 id="3-6-10-switch语句"><a href="#3-6-10-switch语句" class="headerlink" title="3.6.10 switch语句"></a>3.6.10 switch语句</h2><p>switch(expression){<br>  case value1:<br>    statament<br>    break;<br>  case value2:<br>    statement<br>    break;<br>  …<br>  default:<br>    statement<br>}<br>//switch不会强制转换数据类型</p>
<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h2><p>function Name(arg0,arg1){ statements}<br>遇到return语句函数就会立即停止执行并退出。<br>函数不能以eval，arguments作为名称；<br>函数的参数不能叫eval，arguments；<br>两个命名参数不能拥有同一个名称。</p>
<h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h2><p>ES中基本数据类型包括：undefined,Null,Boolean,Number,String,Symbol<br>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。//声明方式<br>不指定返回值的函数实际上会返回特殊值undefined。</p>
<h1 id="4-变量、作用域与内存"><a href="#4-变量、作用域与内存" class="headerlink" title="4 变量、作用域与内存"></a>4 变量、作用域与内存</h1><h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1 原始值与引用值"></a>4.1 原始值与引用值</h2><p>变量有两种不同的类型：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。<br>原始值的变量是按值访问的，引用值是保存在内存中的对象，操作对象时，操作的是对该对象的引用而非实际的对象本身。</p>
<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h3><p>引用值可以随时添加、修改和删除其属性和方法。<br>只有引用值可以动态添加后面可以使用的属性。<br>原始类型的初始化可以只使用原始字面量形式。如果使用new则创建Object类型的实例。<br>let name1 = “wxc”;//typeof name1 == string<br>let name2 = new String(“Matt”);//typeof name2 == object</p>
<h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2 复制值"></a>4.1.2 复制值</h3><p>原始值的变量复制会创建新变量。//let name1 = “wxc”;let name2 = name1;<br>引用值的变量复制的是一个指针，两个变量指向同一个对象，一改则都改。</p>
<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p>函数的参数都是按值传递的，传递时，值会被复制到一个局部变量。<br>按引用传递参数时，值在内存中的位置会被保存在一个局部变量，对本地变量的修改会反映到函数外部。ES中函数的参数就是局部变量。</p>
<h3 id="4-1-4确定类型"><a href="#4-1-4确定类型" class="headerlink" title="4.1.4确定类型"></a>4.1.4确定类型</h3><p>typeof对于原始值有用，但对引用值不大。<br>引用值判断可以用instanceof<br>person instanceof Object<br>colors instanceof Array<br>pattern instanceof RegExp<br>instanceof对于原始值始终返回false，原始值不是对象。</p>
<h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2 执行上下文与作用域"></a>4.2 执行上下文与作用域</h2><p>每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。<br>浏览器中，全局上下文为window对象。var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。<br>每个函数也有自己的上下文，执行函数时，函数上下文被推倒一个上下文栈上，执行完后弹出。ES的执行流通过该上下文栈进行控制。<br>上下文中的代码在执行时，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链的下一个变量对象来自上级包含上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。<br>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>
<h3 id="4-2-1-作用域链增强"><a href="#4-2-1-作用域链增强" class="headerlink" title="4.2.1 作用域链增强"></a>4.2.1 作用域链增强</h3><p>代码执行到try/catch语句的catch块与with语句时，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>
<h3 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2 变量声明"></a>4.2.2 变量声明</h3><p>1.使用var声明变量，变量会被自动添加到最接近的上下文，最接近的上下文大多是函数的局部上下文，如果未声明就被初始化了，就被添加到全局上下文。如果在函数内声明变量添加到全局上下文，函数退出后依然可以访问。<br>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。变量提升。<br>2.使用let声明的块级作用域声明<br>块级作用域由最近的{}界定。<br>3.使用const的常量声明<br>const声明的同时必须初始化为某个值。声明后不能重新赋新值。<br>作用域与let声明一样。<br>建议多使用const，除非需要一个会重新赋值的变量。可以防止重新赋值的BUG。<br>4.标识符查找<br>特定上下文读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。//其实就是调用变量</p>
<h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3 垃圾回收"></a>4.3 垃圾回收</h2><p>JS使用垃圾回收，程序每隔一段就会自动运行。确定不会再使用的变量，释放内存。</p>
<h3 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1 标记清理"></a>4.3.1 标记清理</h3><p>常用策略是标记清理。程序运行时，标记内存中存储的所有变量，将所有上下文中的变量，以及被在上下文中的变量引用的标记去掉。再加上标记代表待删除，随后做一次内存清理，销毁带标记的所有值并回收内存。<br>IE，Firefox，Opera，Chrome，Safari都在JS实习标记清理，频率有所差异。</p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h3><p>对每个值记录引用次数。声明变量并赋一个引用值时，这个值的引用数为1。 如果保存对该值引用的变量被其他值给覆盖了，引用数-1。引用数为0时回收内存。</p>
<h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3 性能"></a>4.3.3 性能</h3><p>垃圾回收的时间调度很重要，变量太多会造成性能损失。JS引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果回收的内存不到已分配的15%，这些阈值会翻倍。如果一次回收的内存达到已分配的85%，则阈值重置为默认值。</p>
<h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4 内存管理"></a>4.3.4 内存管理</h3><p>保证在执行代码时只保存必要的数据。不在必要则设置为null，从而释放其引用。这也可以叫作解除引用。局部变量在超出作用域会自动解除引用，所以该建议更适合全局变量和全局对象。<br>1.通过const和let声明提升性能<br>块作用域，能更早让垃圾回收程序介入。<br>2.隐藏类和删除操作<br>对象与隐藏类会被关联起来，用于跟踪他们的属性特征。共享相同隐藏类的对象性能会更好。<br>function Article(){this.title = ‘go go go’}<br>let a1 = new Article();//隐藏类title<br>let a2 = new Article();//隐藏类title<br>a1.author = ‘Jake’//对应多出author隐藏类，可能对性能产生明显影响。<br>function Article(author){this.title=’go’,this.author=author}<br>let a2 = new Article(‘wxc’)//a2与a1相同，共享一个隐藏类。<br>delete a1.author//使用delete关键字会导致生成同样的隐藏类片段<br>a1.author = null; //保持共享，并达到垃圾回收的效果<br>3.内存泄漏<br>JS的内存泄漏大部分是不合理的引用导致的。<br>function(){name = ‘Jake’}意外声明全局变量是最常见也最容易修复的内存泄漏问题。无关键字声明。<br>定时器也会导致内存泄漏，定时器的回调通过闭包引用了外部变量。<br>使用闭包容易造成内存泄漏，如下：<br>let outer = function() {let name = ‘Jake’;return function() {return name};};<br>调用outer()会导致内存泄漏。只要返回的函数存在就不能清理name，因为闭包一直在引用，加入name的内容很大，就是个大问题。<br>4.静态分配与对象池<br>不要动态创建矢量对象<br>在初始化的时候，创建一个对象池，管理一组可回收的对象。使用完后回归对象池。</p>
<h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><p>原始值大小固定，因此保存在栈内存上。<br>引用值是对象，存储在堆内存上。<br>任何变量都存在于某个作用域（上下文）中，这个作用域决定了变量的声明周期，以及它们可以访问代码的哪些部分。<br>全局上下文：window，浏览器。<br>函数上下文：声明函数的{}内<br>块级上下文：最近的{}内<br>JS有垃圾回收，垃圾回收的方法有：引用计数，标记清理。主流为标记清理。<br>接触变量引用一般直接给变量赋值为null。</p>
<h1 id="5-基本引用类型"><a href="#5-基本引用类型" class="headerlink" title="5.基本引用类型"></a>5.基本引用类型</h1><p>引用值是某个特定引用类型的实例。<br>对象被认为是某个特定引用类型的实例。新对象通过使用new操作符跟一个构造函数来创建。<br>函数也是一种引用类型。</p>
<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h2><p>日期对象//let now = new Date();<br>可用Date.parse()转换成日期对象//let someDate = new Date(Date.parse(“May 23,2019”));如果字符串不表示日期，会返回NaN。<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55));//GMT时间——Date.UTC方法<br>ES提供了Date.now()方法，返回表示方法执行时日期。<br>let start = Date.now();//当前时间</p>
<h3 id="5-1-1-继承的方法"><a href="#5-1-1-继承的方法" class="headerlink" title="5.1.1 继承的方法"></a>5.1.1 继承的方法</h3><p>let date = new Date(2021,1,20);<br>toLocaleString()//–&gt;2021/2/20 上午12:00:00<br>toString()//–&gt;Sat Feb 20 2021 00:00:00 GMT+0800<br>valueOf()//–&gt;1613750400000</p>
<h3 id="5-1-2-日期格式化方法"><a href="#5-1-2-日期格式化方法" class="headerlink" title="5.1.2 日期格式化方法"></a>5.1.2 日期格式化方法</h3><p>Date格式化日期的方法：<br>toDateString()//显示日期中的周几，月，日，年<br>toTimeString()//显示日期中的时分秒和时区<br>toLocaleDateString()//显示日期中的周几 月 日 年<br>toLocaleTimeString()//显示日期中的时 分 秒<br>toUTCString()//显示完整的UTC日期</p>
<h3 id="5-1-3-日期-时间组件方法"><a href="#5-1-3-日期-时间组件方法" class="headerlink" title="5.1.3 日期/时间组件方法"></a>5.1.3 日期/时间组件方法</h3><p>主要应用：<br>getTime()//返回日期的毫秒表示，与valueOf相同<br>setTime(milliseconds)//设置日期的毫秒表示，从而修改整个日期<br>getFullYear()//返回四位年数<br>getMonth()//返回日期的月<br>getDate()//返回日期的日<br>getDay()//返回日期中表示周几的数值<br>getHours()//返回日期中的时<br>getMinutes()//返回日期中的分<br>getSeconds()//返回日期中的秒</p>
<h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2 RegExp"></a>5.2 RegExp</h2><p>ES通过RegExp类型支持正则表达式。<br>let expression = /pattern/flags;<br>匹配模式的标记：<br>1.g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。<br>2.i:不区分大小写，表示查找匹配时忽略pattern和字符串的大小写。<br>3.m:多行模式，表示查找到一行文本末尾时会继续查找。<br>4.y:粘附模式，表示只查找从lastIndex开始及之后的字符串。<br>5.u:Unicode模式，启用Unicode匹配。<br>6.s：dotAll模式，表示元字符匹配任何字符。(包括\n或\r)。<br>使用不同模式和标记可以创建出各种正则表达式，比如：<br>//匹配字符串中的所有”at”<br>let pattern1 = /at/g;<br>//匹配第一个”bat”或”cat” 忽略大小写<br>let pattern2 = /[bc]at/i<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi<br>元字符在模式中必须转义：<br>( ，[， {，\，^，$，|，)，]，}，？，*，+，- //这些符号前面需要\来转义<br>//匹配第一个”bat”或”cat”，忽略大小写<br>let pattern1 = /[bc]at/i;<br>//匹配第一个”[bc]at”，忽略大小写<br>let pattern2 = /[bc]at/i;<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi;<br>//匹配所有”.at”，忽略大小写<br>let pattern4 = /.at/gi;<br>也可使用RegExp构造函数来创建：<br>let pattern1 = /[bc]at/i   ==   new RegExp(“[bc]at”,”i”);<br>也可以使用实例，选择性修改标记<br>const re1 = /cat/g;<br>const re2 = new RegExp(re1);<br>const re3 = new RegExp(re1,”i”);</p>
<h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1 RegExp实例属性"></a>5.2.1 RegExp实例属性</h3><p>global:布尔值，表示是否设置了g标记。<br>ignoreCase:布尔值，表示是否设置了i标记。<br>unicode:布尔值，表示是否设置了u标记。<br>sticky:布尔值，表示是否设置了y标记。<br>lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。<br>multiline:布尔值，表示是否设置了m标记。<br>dotAll:布尔值，表示是否设置了s标记。<br>source:正则表达式的字面量字符串，没有开头和结尾的斜杠。<br>flags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回。</p>
<h3 id="5-2-2-RegExp实例方法"><a href="#5-2-2-RegExp实例方法" class="headerlink" title="5.2.2 RegExp实例方法"></a>5.2.2 RegExp实例方法</h3><p>exec()函数：<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);<br>  console.log(matchs);//cat<br>//设置了全局标记(g)，每次调用返回一个匹配的信息，如果没有设置全局标记，只会返回第一个匹配的信息。<br>//设置了g标记，每次调用exec()都会在字符中向前搜索下一个匹配项<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);//cat<br>  let matchs = pattern.exec(text);//bat<br>  let matchs = pattern.exec(text);//sat<br>  console.log(matchs);<br>//设置了y标记，每次调用会在lastIndex的位置上寻找匹配项。y标记覆盖g标记。<br>test()函数：//用于判断是否存在实际内容中，常在if判断语句中<br>let text = “000-00-00 00”;<br>let pattern = /\d{3}-\d{2}-\d(4)/;<br>if(pattern.test(text)) {console.log(“The pattern was matched.”)};<br>继承的方法toLocaleString()和toString()都返回字面量表示。<br>let pattern = new RegExp(“\[bc\]at”,”gt”);<br>console.log(pattern.toString());//  /[bc]at/gi<br>console.log(pattern.toLocaleString());//  /[bc]at/gi</p>
<h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3 RegExp构造函数属性"></a>5.2.3 RegExp构造函数属性</h3><p>input：$_   //最后搜索的字符串<br>lastMatch：$&amp;   //最后匹配的文本<br>lastParen：$+   //最后匹配的捕获组<br>leftContext：$`   //input字符串中出现在lastMatch前面的文本<br>rightContext：$’   //input字符串中出现在lastMatch后面的文本<br>let text = “this has been a short summer”;<br>let pattern = /(.)hort/g; //()–&gt;捕获组<br>if(pattern.test(text)) {<br>   console.log(RegExp.input); //this has been a short summer<br>   console.log(RegExp.leftContext); //this has been a<br>   console.log(RegExp.rightContext); //summer<br>   console.log(RegExp.lastMatch); //short<br>   console.log(RegExp.input); //s<br>}</p>
<p>if(pattern.test(text)) {<br>   console.log(RegExp.$_); //this has been a short summer<br>   console.log(RegExp[“$`”]); //this has been a<br>   console.log(RegExp[“$’”]); //summer<br>   console.log(RegExp[“$&amp;”]); //short<br>   console.log(RegExp[“$+”]); //s<br>}<br>let pattern = /(..)or(.)/g;</p>
<p>if(pattern.test(text)) {<br>   console.log(RegExp.$1); // sh<br>   console.log(RegExp.$2);// t<br>}</p>
<h3 id="5-2-4-模式局限"><a href="#5-2-4-模式局限" class="headerlink" title="5.2.4 模式局限"></a>5.2.4 模式局限</h3><p>ES对正则表达式的支持还缺少一些高级特性。</p>
<h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3 原始值包装类型"></a>5.3 原始值包装类型</h2><p>ES提供了3种特殊类型的引用类型：Boolean,Number,String。<br>以读模式访问字符串时，后台执行：<br>（1）创建一个String类型的实例；// let s1 = “some text”<br>（2）调用实例上的特点方法；// let s2 = s1.substring(2);<br>（3）销毁实例；// s1 = null;<br>let value = “25”;<br>let number = Number(value);   //转型函数<br>console.log(typeof number);   //“number”<br>let obj = new Number(value); // 构造函数<br>console.log(typeof obj); //“object”<br>变量obj保存一个Number实例。</p>
<h3 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1 Boolean"></a>5.3.1 Boolean</h3><p>let falseObject = new Boolean(false);// typeof == object<br>let result = falseObject &amp;&amp; true;<br>console.log(result); //true<br>let falseValue = false;//typeof == boolean 强烈建议永远不要使用<br>result = falseValue &amp;&amp; true;<br>console.log(result); //false</p>
<h3 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2 Number"></a>5.3.2 Number</h3><p>方法：toFix()//let num = 10;num.toFixed(2);// “10.00”<br>方法：toExponential()//let num = 10;num.toExponential(1);//“1.0e+1”<br>方法：toPrecision()//let num = 99;<br>num.toPrecision(1)//“1e+2”<br>num.toPrecision(2)//“99”<br>num.toPrecision(3)//“99.0”<br>方法：isInterger()//辨别一个数值是否保存为整数。<br>Number.isInterger(1);// true<br>Number.isInterger(1.00)//true<br>Number.isInterger(1.01)//false<br>方法：isSafeInterger()判断数值范围</p>
<h3 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3 String"></a>5.3.3 String</h3><p>每个字符用16位表示，基于16位码元完成操作。//基本多语言平面。<br>normalize()方法：用于判断规范性。<br>concat()：拼接//用加法运算符也可<br>Value = “hello world”;<br>slice()：<br>Value.slice(3)//“lo world”;<br>Value.slice(3,7)//“lo w”;<br>Value.slice(-3)//“rld” 等同于slice(8);(11-3)<br>Value.slice(3,-4)//“lo w” 等同于slice(3,7);(3+4)<br>substr()：<br>Value.substr(3)//“lo world”;<br>Value.substr(3,7)//“lo worl”;<br>Value.substr(-3)//“rld” 等同于substr(8);<br>Value.substr(3,-4)//“”等同于substr(3,0);<br>substring()：<br>Value.substring(3)//“lo world”;<br>Value.substring(3,7)//“lo w”;<br>Value.substring(-3)//“hello world” 等同于substring(0)<br>Value.substring(3,-4)//“hel”等同于substring(0,3)<br>indexOf():<br>Value.indexOf(“o”);// 4<br>Value.indexOf(“t”)// -1<br>Value.indexOf(“o”,6)//7<br>lastIndexOf():<br>Value.lastIndexOf(“o”)//7<br>Value.lastIndexOf(“t”)//-1<br>Value.lastIndexOf(“o”,6)//4<br>message = “foobarbaz”;<br>startWith():<br>message.startWith(“foo”);//true<br>message.startWith(“bar”);//false<br>endWith():<br>message.endWith(“baz”);//true<br>message.endWith(“bar”);//false<br>includes():<br>message.includes(“bar”);//true<br>message.includes(“qux”);//false<br>trim()://不影响原字符串，trimLeft(),trimRight()<br>let string = “   hello  world   “;<br>string.trim()//“hello  world”<br>repeat():<br>string = “abc”;<br>string.repeat(2)//“abcabc”;<br>padStart(),padEnd():<br>string = “foo”<br>string.padStart(6)//“   foo”;len=6<br>string.padStart(9,”.”)//“……foo”;len=9<br>string.padStart(8,”bar”)//“barbafoo”len=8<br>string.padEnd(6)//“foo   “;<br>string.padEnd(9,”.”)//“foo……”;<br>string.padEnd(8,”bar”)//“foobarba”;<br>迭代与解构<br>let message = “abc”;<br>Iterator = message<a href>Symbol.iterator</a>;<br>Iterator.next()//{value:”a”,done:false}<br>Iterator.next()//{value:”b”,done:false}<br>Iterator.next()//{value:”c”,done:false}<br>Iterator.next()//{value:”undefined”,done:true}<br>大小写转换<br>toLowerCase()//小写<br>toLocalLowerCase()//特定地区方法使用<br>toUpperCase()//大写<br>toLocalUpperCase()//特定地区方法使用<br>字符串模式匹配方法<br>match():与exec()方法一致<br>search():<br>let text = “cat, bat, sat, fat”;<br>let pos = text.search(/at/);//1第一个位置为1<br>replace():<br>let res = text.replace(“at”,”ond”);//“cond, bat, sat, fat”<br>let res = text.replace(/at/g,”ond”)//“cond, bond, sond, fond”<br>localeCompare():按字母表顺序比较返回值</p>
<h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4 单例内置对象"></a>5.4 单例内置对象</h2><p>包括Global,Math</p>
<h3 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1 Global"></a>5.4.1 Global</h3><p>全局作用域中定义的变量和函数都会成为Global对象的属性。<br>encodeURI(),encodeURIComponent()//编码统一资源标识符。<br>eval():<br>eval(“console.log(‘hi’)”);///console.log(“hi”);<br>eval(“function sayHi(){console.log(‘hi’);}”);///sayHi();<br>容易被XSS攻击。<br>对象属性：<br>undefined//特殊值<br>NaN//特殊值<br>Infinity//特殊值<br>Object//构造函数<br>Array//构造函数<br>Function//构造函数<br>….<br>window对象<br>window为Global对象的代理,全局变量和函数即为window的属性。</p>
<h3 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2 Math"></a>5.4.2 Math</h3><p>Math对象属性：<br>E //自然对数的基数e的值<br>LN10 //10为底的自然对数<br>LN2 //2为底的自然对数<br>LOG2E //以2为底e的对数<br>LOG10E //以10为底e的对数<br>PI //π的值<br>SQRT1_2 //1/2的平方根<br>SQRT2 //2的平方根<br>Math方法：<br>min():取最小值//配合数组可以使用扩展操作符<br>max():取最大值//max = Math.max(…array);<br>ceil():向上取<br>Math.ceil(25.9);//26<br>Math.ceil(25.5);//26<br>Math.ceil(25.1);//26<br>round():四舍五入<br>console.log(Math.round(25.9)); // 26<br>console.log(Math.round(25.5)); // 26<br>console.log(Math.round(25.1)); // 25<br>fround():取单精度浮点值<br>console.log(Math.fround(0.4)); // 0.4000000059604645<br>console.log(Math.fround(0.5)); // 0.5<br>console.log(Math.fround(25.9)); // 25.899999618530273<br>floor():向下取<br>console.log(Math.floor(25.9)); // 25<br>console.log(Math.floor(25.5)); // 25<br>console.log(Math.floor(25.1)); // 25<br>random()://返回小数0~1内<br>加密提高不确定性：建议使用window.crypto.getRandomValues()。<br>abs()//绝对值<br>exp()//次幂<br>log()//自然对数<br>….</p>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><p>对象为引用值，内置的引用类型可用于创建特定类型的对象。<br>RegExp是ES支持正则表达式的接口。<br>函数实际上是Function类型的实例，是对象。</p>
<h1 id="6-集合引用类型"><a href="#6-集合引用类型" class="headerlink" title="6 集合引用类型"></a>6 集合引用类型</h1><h2 id="6-1-Object"><a href="#6-1-Object" class="headerlink" title="6.1 Object"></a>6.1 Object</h2><p>let person = new Object();//构造函数<br>person.name = ‘micheal’;<br>let person = {name:’micheal’};//{}字面量表达式<br>person[“name”]//micheal<br>person.name//micheal</p>
<h2 id="6-2-Array"><a href="#6-2-Array" class="headerlink" title="6.2 Array"></a>6.2 Array</h2><h3 id="6-2-1-创建数组"><a href="#6-2-1-创建数组" class="headerlink" title="6.2.1 创建数组"></a>6.2.1 创建数组</h3><p>let colors = new Array();//可以传值创建初始length的数组，也可以传数组值<br>let colors = [“red”,”blue”]//字面量表达式<br>from():<br>Array.from(“Matt”)//[“M”,”a”,”t”,”t”]<br>适用于Map,Set,Array,iterator,arguments<br>of()://使用Array.prototype.slice.call(arguments)<br>Array.of(1,2,3,4)//[1,2,3,4]<br>Array.of(undefined)//[undefined]</p>
<h3 id="6-2-2-数组空位"><a href="#6-2-2-数组空位" class="headerlink" title="6.2.2 数组空位"></a>6.2.2 数组空位</h3><p>使用(,)创建数组空位<br>const options = [,,,,,]<br>options.length = 5<br>options //[,,,,,]<br>空值为undefined<br>options = [1,,,5];<br>options.map(()=&gt;6)//[6,,,6]<br>options.join(‘-‘)//“1—–5”</p>
<h3 id="6-2-3-数组索引"><a href="#6-2-3-数组索引" class="headerlink" title="6.2.3 数组索引"></a>6.2.3 数组索引</h3><p>colors[0]–&gt;第一个元素<br>给数组设置length会改变数组大小</p>
<h3 id="6-2-4-检测数组"><a href="#6-2-4-检测数组" class="headerlink" title="6.2.4 检测数组"></a>6.2.4 检测数组</h3><p>判断是否数组，使用instanceof<br>也可使用isArray()方法</p>
<h3 id="6-2-5-迭代器方法"><a href="#6-2-5-迭代器方法" class="headerlink" title="6.2.5 迭代器方法"></a>6.2.5 迭代器方法</h3><p>const a = [“a”,”b”,”c”,”d”];<br>keys()://返回数组索引的迭代器<br>const akeys = Array.from(a.keys()); // [0,1,2,3]<br>values()://返回数组元素的迭代器<br>const aValues = Array.from(a.Values());//[“a”,”b”,”c”,”d”]<br>entries()://返回索引/值对的迭代器<br>const aEntries = Array.from(a.entries());//[[0,”a”],[1,”b”],[2,”c”],[3,”d”]]<br>for(const [idx,element] of a.entries()){<br>alert(idx);<br>alert(element);<br>}<br>//0<br>//a<br>//1<br>//b<br>//2<br>//c<br>//3<br>//d</p>
<h3 id="6-2-6-复制和填充方法"><a href="#6-2-6-复制和填充方法" class="headerlink" title="6.2.6 复制和填充方法"></a>6.2.6 复制和填充方法</h3><p>copyWithin()//批量复制<br>fill()://填充<br>const a = [0,0,0,0,0];<br>zeros.fill(5)//[5,5,5,5,5];<br>zeros.fill(6,3)//[0,0,0,6,6]<br>zeros.fill(7,1,3)//[0,7,7,0,0]<br>索引过低，过高，反向都会被忽略<br>部门可用的索引，填充可用部分。<br>ints = [0,1,2,3,4,5,6,7,8,9];<br>ints.copyWithin(5) // [0,1,2,3,4,0,1,2,3,4];<br>ints.copyWithin(0,5)//[5,6,7,8,9,5,6,7,8,9];<br>ints.copyWithin(4,0,3)//[0,1,2,3,0,1,2,7,8,9];<br>ints.copyWithin(2,0,6)//[0,1,0,1,2,3,4,5,8,9];</p>
<h3 id="6-2-7-转换方法"><a href="#6-2-7-转换方法" class="headerlink" title="6.2.7 转换方法"></a>6.2.7 转换方法</h3><p>数组调用toString(),valueOf()方法相当于每个元素调用一次这个方法。</p>
<h3 id="6-2-8-栈方法"><a href="#6-2-8-栈方法" class="headerlink" title="6.2.8 栈方法"></a>6.2.8 栈方法</h3><p>push()//从最后推入数据<br>pop()//弹出最后一项并返回</p>
<h3 id="6-2-9-队列方法"><a href="#6-2-9-队列方法" class="headerlink" title="6.2.9 队列方法"></a>6.2.9 队列方法</h3><p>shift()://删除数组第一项并返回<br>push()://从最后推入数据<br>unshift()://从开头推入</p>
<h3 id="6-2-10-排序方法"><a href="#6-2-10-排序方法" class="headerlink" title="6.2.10 排序方法"></a>6.2.10 排序方法</h3><p>reverse()://反向排序<br>sort()://将元素转换成字符串比较</p>
<h3 id="6-1-11-操作方法"><a href="#6-1-11-操作方法" class="headerlink" title="6.1.11 操作方法"></a>6.1.11 操作方法</h3><p>concat():添加//直接使用会打平数组<br>slice():取值<br>splice()://可实现删除(两个参数)，插入(三个参数)，替换(三个参数)</p>
<h3 id="6-2-12-搜索和位置方法"><a href="#6-2-12-搜索和位置方法" class="headerlink" title="6.2.12 搜索和位置方法"></a>6.2.12 搜索和位置方法</h3><p>indexOf()//查找元素位置，返回<br>lastIndexOf()//查找元素位置，返回<br>includes()//返回布尔值，是否包含元素<br>find()//返回第一个匹配的元素<br>findIndex()//返回索引</p>
<h3 id="6-2-13-迭代方法"><a href="#6-2-13-迭代方法" class="headerlink" title="6.2.13 迭代方法"></a>6.2.13 迭代方法</h3><p>every():元素都匹配才会返回true<br>filter():返回true的元素组成数组返回<br>forEach():运行函数，无返回值<br>map():调用结果构成数组返回<br>some():如果有一项返回true，则返回true</p>
<h3 id="6-2-14-归并方法"><a href="#6-2-14-归并方法" class="headerlink" title="6.2.14 归并方法"></a>6.2.14 归并方法</h3><p>reduce():从头遍历,构建一个返回值<br>reduceRight():从尾遍历,构建一个返回值</p>
<h2 id="6-3-定型数组"><a href="#6-3-定型数组" class="headerlink" title="6.3 定型数组"></a>6.3 定型数组</h2><h3 id="6-3-1-历史"><a href="#6-3-1-历史" class="headerlink" title="6.3.1 历史"></a>6.3.1 历史</h3><p>WebGL用到，3D技术。<br>定型数组</p>
<h3 id="6-3-2-ArrayBuffer"><a href="#6-3-2-ArrayBuffer" class="headerlink" title="6.3.2 ArrayBuffer"></a>6.3.2 ArrayBuffer</h3><p>构造函数，用于内存中分配特定数量的字节空间。</p>
<h3 id="6-3-3-DataView"><a href="#6-3-3-DataView" class="headerlink" title="6.3.3 DataView"></a>6.3.3 DataView</h3><h3 id="6-3-4-定型数组"><a href="#6-3-4-定型数组" class="headerlink" title="6.3.4 定型数组"></a>6.3.4 定型数组</h3><h2 id="6-4-Map"><a href="#6-4-Map" class="headerlink" title="6.4 Map"></a>6.4 Map</h2><p>一种实现键值存储机制的集合类型。</p>
<h3 id="6-4-1-基本API"><a href="#6-4-1-基本API" class="headerlink" title="6.4.1 基本API"></a>6.4.1 基本API</h3><p>const m2 = new Map([[“key1”,”val1”][“key2”,”val2”][“key3”,”val3”]])<br>m1.size = 3<br>可使用has(),get()进行查询，delete(),clear()删除值。</p>
<h3 id="6-4-2-顺序与迭代"><a href="#6-4-2-顺序与迭代" class="headerlink" title="6.4.2 顺序与迭代"></a>6.4.2 顺序与迭代</h3><p>提供迭代器(Iterator),通过entries()获取<br>可以通过遍历获取。</p>
<h3 id="6-4-3-选择Object还是Map"><a href="#6-4-3-选择Object还是Map" class="headerlink" title="6.4.3 选择Object还是Map"></a>6.4.3 选择Object还是Map</h3><p>1.内存占用<br>Map占用更小<br>2.插入性能<br>Map插入性能更好<br>3.查找速度<br>Object优于Map<br>4.删除性能<br>Map更快，涉及大量删除 Map最佳。</p>
<h2 id="6-5-WeakMap"><a href="#6-5-WeakMap" class="headerlink" title="6.5 WeakMap"></a>6.5 WeakMap</h2><p>类似于Map，只能用对象作为键。<br>API与Map相同。<br>键不存在时，值会被垃圾回收。<br>无法迭代。</p>
<h2 id="6-6-Set"><a href="#6-6-Set" class="headerlink" title="6.6 Set"></a>6.6 Set</h2><h3 id="6-6-1-基本API"><a href="#6-6-1-基本API" class="headerlink" title="6.6.1 基本API"></a>6.6.1 基本API</h3><p>与Map相似，size长度，has()查询，delete()和clear()删除元素。<br>add()添加元素。</p>
<h3 id="6-6-2-顺序与迭代"><a href="#6-6-2-顺序与迭代" class="headerlink" title="6.6.2 顺序与迭代"></a>6.6.2 顺序与迭代</h3><p>可通过values()与keys()获取迭代器<br>可以使用遍历方法迭代。</p>
<h2 id="6-7-WeakSet"><a href="#6-7-WeakSet" class="headerlink" title="6.7 WeakSet"></a>6.7 WeakSet</h2><p>与WeakMap类型</p>
<h2 id="6-8-迭代与扩展操作"><a href="#6-8-迭代与扩展操作" class="headerlink" title="6.8 迭代与扩展操作"></a>6.8 迭代与扩展操作</h2><p>支持for-of循环<br>支持浅拷贝<br>let arr1 = […arr2];</p>
<h2 id="6-9-小结"><a href="#6-9-小结" class="headerlink" title="6.9 小结"></a>6.9 小结</h2><p>JS的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。<br>Object类型是一个基础类型，所有引用类型都继承了它的基本行为。<br>Array是一组有序的值，并提供了操作和转换值的能力。<br>定型数组包含一套不同的引用类型。<br>Date，日期类型。RegExp，正则表达式的接口。<br>ES6新增Map，WeakMap,Set,WeakSet。</p>
<h1 id="7-迭代器与生成器"><a href="#7-迭代器与生成器" class="headerlink" title="7 迭代器与生成器"></a>7 迭代器与生成器</h1><p>迭代即“重复”，“再来”。</p>
<h2 id="7-1-理解迭代"><a href="#7-1-理解迭代" class="headerlink" title="7.1 理解迭代"></a>7.1 理解迭代</h2><p>JS中，计数循环就是一种最简单的迭代：for（）<br>可以指定顺序，次数，在一个有序集合上进行。<br>需知道如何使用数据结构，遍历顺序不是数据结构固有的。</p>
<h2 id="7-2-迭代器模式"><a href="#7-2-迭代器模式" class="headerlink" title="7.2 迭代器模式"></a>7.2 迭代器模式</h2><p>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。<br>迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。</p>
<h3 id="7-2-1-可迭代协议"><a href="#7-2-1-可迭代协议" class="headerlink" title="7.2.1 可迭代协议"></a>7.2.1 可迭代协议</h3><p>实现了Iterable接口的内置类型：<br>1.字符串<br>2.数组<br>3.映射<br>4.集合<br>5.arguments对象<br>6.NodeList等DOM集合类型<br>接受可迭代对象的语言特性包括：<br>let arr = [“foo”,”bar”,”baz”];<br>1.for-of //for(let el of arr){el};<br>2.数组解构 //let [a,b,c] = arr;<br>3.扩展操作符 // let arr2 = […arr];<br>4.Array.from() //let arr3 = Array.from(arr);<br>5.创建集合 //let set = new Set(arr);<br>6.创建映射 //let pairs = arr.map((x,i)=&gt;[x,i]);<br>7.promise.all()<br>8.promise.race()<br>9.yield*操作符</p>
<h3 id="7-2-2-迭代器协议"><a href="#7-2-2-迭代器协议" class="headerlink" title="7.2.2 迭代器协议"></a>7.2.2 迭代器协议</h3><p>let arr = [“a”,”b”];<br>console.log(arr[Symbol.iterator]); //f values(){[native code]};<br>let iter = arr<a href>Symbol.iterator</a>;<br>console.log(iter);// ArrayIterator()<br>iter.next();//{done:false,value:”a”};</p>
<h3 id="7-2-3-自定义迭代器"><a href="#7-2-3-自定义迭代器" class="headerlink" title="7.2.3 自定义迭代器"></a>7.2.3 自定义迭代器</h3><p>自定义迭代方法</p>
<h3 id="7-2-4-提前终止迭代器"><a href="#7-2-4-提前终止迭代器" class="headerlink" title="7.2.4 提前终止迭代器"></a>7.2.4 提前终止迭代器</h3><p>return {done:true};<br>或break</p>
<h2 id="7-3-生成器"><a href="#7-3-生成器" class="headerlink" title="7.3 生成器"></a>7.3 生成器</h2><h3 id="7-3-1-生成器基础"><a href="#7-3-1-生成器基础" class="headerlink" title="7.3.1 生成器基础"></a>7.3.1 生成器基础</h3><h3 id="7-3-2-通过yield中断执行"><a href="#7-3-2-通过yield中断执行" class="headerlink" title="7.3.2 通过yield中断执行"></a>7.3.2 通过yield中断执行</h3><h3 id="7-3-3-生成器作为默认迭代器"><a href="#7-3-3-生成器作为默认迭代器" class="headerlink" title="7.3.3 生成器作为默认迭代器"></a>7.3.3 生成器作为默认迭代器</h3><h3 id="7-3-4-提前终止生成器"><a href="#7-3-4-提前终止生成器" class="headerlink" title="7.3.4 提前终止生成器"></a>7.3.4 提前终止生成器</h3><h2 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h2><p>由任意对象实现的接口，支持连续获取对象产出的每一个值。使用symbol.iterator获取，并且通过一些方法调用，例next(),for-of。</p>
<h1 id="8-对象、类与面向对象编程"><a href="#8-对象、类与面向对象编程" class="headerlink" title="8 对象、类与面向对象编程"></a>8 对象、类与面向对象编程</h1><p>无特定顺序的值。每个属性或方法都用名称标识。</p>
<h2 id="8-1-理解对象"><a href="#8-1-理解对象" class="headerlink" title="8.1 理解对象"></a>8.1 理解对象</h2><h3 id="8-1-1-属性的类型"><a href="#8-1-1-属性的类型" class="headerlink" title="8.1.1 属性的类型"></a>8.1.1 属性的类型</h3><p>数据属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Writable]]:表示属性的值是否可以被修改。<br>[[Value]]:表示属性的值。<br>访问器属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Get]]:获取函数，读取属性调用。<br>[[Set]]:设置函数，写入属性时调用。</p>
<h3 id="8-1-2-定义多个属性"><a href="#8-1-2-定义多个属性" class="headerlink" title="8.1.2 定义多个属性"></a>8.1.2 定义多个属性</h3><p>let book = {};<br>Object.defineProperties(book,{year:{value:2017},edition:{value:1},year:{get(){return this.year;}}});</p>
<h3 id="8-1-3-读取属性的特性"><a href="#8-1-3-读取属性的特性" class="headerlink" title="8.1.3 读取属性的特性"></a>8.1.3 读取属性的特性</h3><p>Object.getOwnPropertyDescriptor(object,’name’);<br>descriptor = Object.getOwnPropertyDescriptor(book,”year”);<br>Object.getOwnPropertyDescriptors(object);//获取所有</p>
<h3 id="8-1-4-合并对象"><a href="#8-1-4-合并对象" class="headerlink" title="8.1.4 合并对象"></a>8.1.4 合并对象</h3><p>Object.assgin();//浅拷贝,会覆盖重复的属性<br>result = Object.assign(object1,object2);<br>object === result<br>result = Object.assign(object1,object2,object3);</p>
<h3 id="8-1-5-对象标识及相等判定"><a href="#8-1-5-对象标识及相等判定" class="headerlink" title="8.1.5 对象标识及相等判定"></a>8.1.5 对象标识及相等判定</h3><p>Object.is()//需要两个参数<br>Object.is(+0,-0)//false</p>
<h3 id="8-1-6-增强的对象语法"><a href="#8-1-6-增强的对象语法" class="headerlink" title="8.1.6 增强的对象语法"></a>8.1.6 增强的对象语法</h3><p>let person = {name:name};  === let person = {name};//不建议<br>namekey = “name”;let person = {[namekey]:’Matt’};//[]内可以使用表达式，属性可计算<br>let person = {<a href="name">nameKey</a>{console.log(‘name’)}};//方法名兼容计算属性</p>
<h3 id="8-1-7-对象解构"><a href="#8-1-7-对象解构" class="headerlink" title="8.1.7 对象解构"></a>8.1.7 对象解构</h3><p>let person = {name:’matt’,age:27}//不解构<br>let personName = person.name,personAge = person.age;//解构<br>let {name:personName,age:personAge} = person;<br>null和undefined不支持解构</p>
<p>let person = {job:{title:’Software engineer’}};//嵌套解构<br>let personCopy={};<br>let({job:personCopy.job}=person);</p>
<p>前面的解构出错，后面的解构会失败。</p>
<p>let person = {name:’matt’,age:27}; function printPerson(foo,{name,age},bar)//参数解构，调用时传入对象</p>
<h2 id="8-2-创建对象"><a href="#8-2-创建对象" class="headerlink" title="8.2 创建对象"></a>8.2 创建对象</h2><h3 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1 概述"></a>8.2.1 概述</h3><p>与类不同，对象的巧妙运行可以实现与类相同的行为。</p>
<h3 id="8-2-2-工厂模式"><a href="#8-2-2-工厂模式" class="headerlink" title="8.2.2 工厂模式"></a>8.2.2 工厂模式</h3><p>设计模式之一<br>function createPerson(name,age,job){<br>   let o = new Object();<br>   o.name = name;<br>   o.age = age;<br>   o.job = job;<br>   o.sayName = function(){<br>       console.log(this.name);<br>   };<br>   return o;<br>}<br>解决创建多个类似对象的问题，但无解决对象标识问题（对象类型）。</p>
<h3 id="8-2-3-构造函数模式"><a href="#8-2-3-构造函数模式" class="headerlink" title="8.2.3 构造函数模式"></a>8.2.3 构造函数模式</h3><p>function Person(name,age,job){<br>   this.name = name;<br>   this.age = age;<br>   this.job = job;<br>   this.sayName = function(){<br>      console.log(this.name);<br>   }<br>}<br>与工厂模式类似,无return，无显式创建对象。<br>构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可。<br>let person = function(){};<br>let person1 = new person(…);<br>let person2 = new person(…);<br>person1 instanceof Object//true<br>person1 instanceof person//true<br>person2一样<br>构造函数也可以直接调用<br>person(…);window.sayName();//添加到了window<br>let o = new Object();<br>Person.call(o,”wxc”,25);o.sayName()//wxc 在另一个对象的作用域中调用<br>在构造函数内定义的函数实例化后相同名称确不相等，是两个不同的函数。<br>可以在外部定义函数，在内部赋值解决这个问题。</p>
<h3 id="8-2-4-原型模式"><a href="#8-2-4-原型模式" class="headerlink" title="8.2.4 原型模式"></a>8.2.4 原型模式</h3><p>prototype,这个属性为一个对象。包含由特定引用类型的实例共享的属性和方法。实际上是构造函数创建的原型。<br>在原型上定义的值可以共享。<br>Chrome暴露了<em>proto_属性，可通过这个属性访问对象的原型。prototype属性为对象。<br>原型链会终止与Object的原型链。<br>person.prototype._proto</em>.<em>proto</em> === null//true<br>构造函数、原型对象和实例，三个完全不同的对象。<br>实例通过_proto_链接到原型对象，实际指向[[Prototype]]<br>构造函数通过prototype属性链接到原型对象。<br>同一个构造函数创建的两个实例，共享一个原型对象。<br>isPrototypeOf()//用于判断实例原型对象与构造函数的原型相同否<br>getPrototypeOf()//用于获取[[prototype]]原型对象<br>setPrototypeOf()//用于给[[prototype]]对象写入新值,该方法调用可能会严重导致性能下降。<br>create()//用于创建新对象指定原型<br>访问对象属性时，如果未在对象实例本身找到则会沿着指针进入原型对象，在原型对象上查找。无法通过实例重写这些值，如果创建于原型对象中同名的属性，会在实例上创建这个属性，遮蔽原型对象上的属性，只有delete后才能继续搜索原型对象的该属性。<br>hasOwnProperty()//用于判断属性在实例或原型上<br>可以通过for-in判断通过对象能否访问到一个属性//“name” in person(true)<br>getOwnPropertyNames()//…按顺序进行枚举</p>
<h3 id="8-2-5-对象迭代"><a href="#8-2-5-对象迭代" class="headerlink" title="8.2.5 对象迭代"></a>8.2.5 对象迭代</h3><p>Object.values()//以数组的形式输出值<br>Object.entries()//以数组的形式输出键值和值<br>非字符串的属性会被转换为字符串输出，符号属性会被忽略。<br>重写了prototype的函数原型不默认指向constructor<br>ES语法需要使用defineProperty()来恢复constructor属性。<br>实例只有指向原型的指针，没有指向构造函数的指针。</p>
<h2 id="8-3-继承"><a href="#8-3-继承" class="headerlink" title="8.3 继承"></a>8.3 继承</h2><p>ES中只支持实现继承。</p>
<h3 id="8-3-1-原型链"><a href="#8-3-1-原型链" class="headerlink" title="8.3.1 原型链"></a>8.3.1 原型链</h3><p>通过原型继承多个引用类型的属性和方法。原型链为ES主要继承方式。<br>将A函数原型赋值为B函数的实例，A函数的实例可以通过原型访问到B函数实例的属性和方法。实际A函数可以通过原型与B函数的原型挂钩。在搜索属性时，会通过原型链访问到原型的原型，直到末端。<br>所有引用类型都继承自Object，任何函数的默认原型都是一个Object的实例，也是为什么自定义类型能够继承toString(),valueOf()方法的原因。调用toString()时，实际在调用Object.prototype上的方法。<br>通过instanceof返回原型与构造函数的原型关系。<br>通过isPrototypeOf返回原型链中是否含有这个原型。<br>添加属性或覆盖属性时需要在原型赋值后添加到原型上。<br>通过prototype字面量直接修改原型，会破坏之前的原型链。<br>原型链的问题：<br>1.使用原型实现继承后，函数原型对象的所有属性都会被函数实例共享。<br>2.子类型在实例化时不能给父类型的构造函数传参。</p>
<h3 id="8-3-2-盗用构造函数"><a href="#8-3-2-盗用构造函数" class="headerlink" title="8.3.2 盗用构造函数"></a>8.3.2 盗用构造函数</h3><p>通过call，apply来调用执行函数的构造函数，从而得到构造函数的属性和方法。<br>可以通过apply,call来向父类构造函数传值。<br>缺点：必须在构造函数中定义方法，函数无法重用。且子类无法访问父类原型的方法。（原型不是父类的实例对象）</p>
<h3 id="8-3-3-组合继承"><a href="#8-3-3-组合继承" class="headerlink" title="8.3.3 组合继承"></a>8.3.3 组合继承</h3><p>P244</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/18/javaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/18/javaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">javaScript设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-18T17:40:57+08:00">
                2020-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  147 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开放封闭原则:<br>对稳定的东西进行封装，将可能会变动的东西分离出来，增加功能或者改动的时候增加代码即可，无需改动代码。<br>1.放置挂钩<br>hook（待研究）<br>2.使用回调函数<br>把回调函数当做参数传入一个稳定和封闭的函数中，当回调函数被执行的时候，程序会因为回调函数的内部逻辑不同，而产生不同的结果。<br>ajax异步请求是不变的，获取数据后的下一步可能变化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-11T15:44:22+08:00">
                2020-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  732 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  2 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><hr>
<p>1.适配器模式<br>特点：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。<br>后台返回的数据格式不同，可以通过适配器修改。例：<br>后台返回json格式的数据，通过方法检索出自己需要的数据进行显示，这个方法即为适配器。<br>通常用来避免项目迭代后数据格式或者方法名发生改变出现的错误。<br>最优解：项目开发过程中前后端协商讨论数据格式、文件名等代码规范。</p>
<hr>
<p>2.代理模式<br>为一个对象提供一个代用品或占位符，以便控制对他的访问。<br>在一个对象中调用其他对象的方法（函数可以实例化成对象）<br>保护代理：数据拦截（可以在函数中条件判断拦截数据从而执行不同下文）<br>虚拟代理：数据通过这些代理传递没有被拦截（可实现图片懒加载）</p>
<hr>
<p>3.桥接模式<br>把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。<br>需要一种方式让对象和行为分离，便于随意拼接。<br>优点：分离抽象接口及其实现部分，提高可拓展性。<br>缺点：增加系统的理解和设计难度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">boy,girl,piano,guitar</span><br><span class="line">boy-piano,boy-guitar,girl-piano,girl-guitar</span><br><span class="line"><span class="keyword">function</span> Boy(instrument) &#123;</span><br><span class="line">      this.sayHi = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'hi, 我是男生'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      this.playInstrument = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          instrument.play()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> Girl(instrument) &#123;</span><br><span class="line">      this.sayHi = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'hi, 我是女生'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      this.playInstrument = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          instrument.play()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">Piano</span></span>() &#123;</span><br><span class="line">      this.play = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'钢琴开始演奏'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">Guitar</span></span>() &#123;</span><br><span class="line">      this.play = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'吉他开始演奏'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> piano = new Piano()</span><br><span class="line">  <span class="built_in">let</span> guitar = new Guitar()</span><br><span class="line">  <span class="built_in">let</span> pianoBoy = new Boy(piano)</span><br><span class="line">  pianoBoy.playInstrument()</span><br><span class="line">  <span class="built_in">let</span> guitarGirl = new Girl(guitar)</span><br><span class="line">  guitarGirl.playInstrument()</span><br></pre></td></tr></table></figure>
<hr>
<p>4.装饰模式<br>动态地给一个对象添加一些额外的职责。（类似魂斗罗的子弹种类变化，原来子弹还在）<br>优点：装饰类和被装饰类可以独立发展，不会相互耦合，继承的一个替代模式。<br>缺点：多层装饰，比较复杂。<br>类似闭包，在函数对象中添加调用其他函数，给对象增加功能</p>
<hr>
<p>5.组合模式<br>由小对象构建大对象，常和装饰者模式一起使用<br>优点：通过对象的多态表现，使对单个对象和组合对象的使用具有一致性<br>缺点：系统负担，性能<br>小函数添加进一个对象（可以是实例化的函数），通过该函数去调用各种小函数，囊括这些功能。</p>
<hr>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><hr>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/11/%E5%B7%A5%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/11/%E5%B7%A5%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" itemprop="url">工作注意事项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-11T10:53:39+08:00">
                2020-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" itemprop="url" rel="index">
                    <span itemprop="name">工作注意事项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  279 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="项目流程："><a href="#项目流程：" class="headerlink" title="项目流程："></a>项目流程：</h2><p>项目路线图-&gt;<br>项目评估确认阶段<br>项目立项<br>需求开发<br>设计阶段<br>研发及生产<br>测试及缺陷修复<br>生产环境实施部署<br>系统验收<br>项目结项</p>
<pre><code class="以上为项目完整流程。">---
前端工作流程：
立项--项目研讨--需求确认--产品出原型--后台开发，UI设计--前端开发--测试提bug--改bug--重复N次--产品验收

注意工作内容，个人职责，只负责职责相关部分。
需要讨论好工作分配。在职责范围内，与UI（页面），产品（功能），项目（需求）进行沟通完成后进行开发。
需要注意以下几点：
1.深刻理解需求，清楚需求的动机和缘由。
2.换位思考
3.不放过细节
4.换一种方式说“不能实现”
5.当遇到不合理的需求时，寻找替换方案
6.必须遵循文档精神
7.对自己的程序有一颗艺术的心

归根结底：解决问题！！！！
责任划分要清晰：口头确认---发email到责任人确认---通知上级

</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/25/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/" itemprop="url">Nginx服务器的部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-25T16:05:41+08:00">
                2020-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index">
                    <span itemprop="name">经验</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  405 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Nginx服务器对Vue项目的部署"><a href="#Nginx服务器对Vue项目的部署" class="headerlink" title="Nginx服务器对Vue项目的部署"></a>Nginx服务器对Vue项目的部署</h3><h2 id="1-在本地下载Nginx"><a href="#1-在本地下载Nginx" class="headerlink" title="1.在本地下载Nginx"></a>1.在本地下载Nginx</h2><p>直接百度nginx，进入官网，选择Stable（稳定版），windows（版本）下载</p>
<h2 id="2-解压下载的压缩包"><a href="#2-解压下载的压缩包" class="headerlink" title="2.解压下载的压缩包"></a>2.解压下载的压缩包</h2><p>解压压缩包在磁盘（合理规划磁盘）</p>
<h2 id="3-配置nginx文件"><a href="#3-配置nginx文件" class="headerlink" title="3.配置nginx文件"></a>3.配置nginx文件</h2><p>在解压出的文件夹中有conf文件，进入，选择nginx.conf文件进行配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       8100; //此为端口,如果端口有被占用请更改</span><br><span class="line">       server_name  localhost;//服务器名</span><br><span class="line"></span><br><span class="line">       location ^~ /wms &#123; // 配置，用到正则表达式</span><br><span class="line">           <span class="built_in">alias</span>   E:/nginx-1.18.0/html/dist//如使用<span class="built_in">alias</span>，则不会进行路径拼接，会进行替换，直接在该绝对路径中寻找index下的文件</span><br><span class="line">           root   E:/nginx-1.18.0/html/dist;//根目录，root代表路径，会跟上面的/wms进行拼接，为绝对路径</span><br><span class="line">           index  index.html index.htm;//从上面得到的绝对路径中寻找index.html文件，如查找不到则报403 forbidden错误，即为文件不存在</span><br><span class="line">       &#125;</span><br><span class="line">       location /dev-api/&#123; //webpack不会打包代理请求路径，需自己配置</span><br><span class="line">           proxy_pass http://192.168.1.58:8888/; // 在nginx上部署的项目请求服务器地址代理</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="history模式下的问题"><a href="#history模式下的问题" class="headerlink" title="history模式下的问题"></a>history模式下的问题</h2><p>在router使用history模式下，部署nginx的项目刷新会出现404，找不到页面的情况<br>这时候需要进行重定位</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">　　root  /；</span><br><span class="line">　　index index.html;</span><br><span class="line">　　try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html //根目录的情况下</span><br><span class="line">&#125;</span><br><span class="line">location /xx/xx/ &#123;</span><br><span class="line">　　root  /；</span><br><span class="line">　　index index.html;</span><br><span class="line">　　try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /xx/xx/index.html //特定目录情况下</span><br><span class="line">&#125;</span><br><span class="line">location /payfor/ &#123;</span><br><span class="line">       root /home/web;</span><br><span class="line">       index index.html;</span><br><span class="line">       try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /payfor/index.html; //例子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接：匹配规则"><a href="#参考链接：匹配规则" class="headerlink" title="参考链接：匹配规则"></a><a href="https://www.cnblogs.com/jpfss/p/10418150.html" target="_blank" rel="noopener">参考链接：匹配规则</a></h2><p>重点：路径配置规则需了解</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Aren.jpg"
                alt="DarylWxc" />
            
              <p class="site-author-name" itemprop="name">DarylWxc</p>
              <p class="site-description motion-element" itemprop="description">每日提升一点点</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives/%7C%7Carchive">
                <a href="/archives">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=485347116&auto=1&height=66"></iframe>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wxc" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1498368314@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-qq"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                CSDN博客链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/weixin_43898759" title="CSDN主页" target="_blank">CSDN主页</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DarylWxc</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Wxc</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">L·O·V·E</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="true"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


<script type="text/javascript" 
color="0,0,0" opacity='1' zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
