<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-16x16-Aren.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-16x16-Aren.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/Aren.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="每日提升一点点">
<meta property="og:type" content="website">
<meta property="og:title" content="DarylWXC的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="DarylWXC的博客">
<meta property="og:description" content="每日提升一点点">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DarylWxc">
<meta property="article:tag" content="小逗比">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>DarylWXC的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DarylWXC的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/15/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/15/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" itemprop="url">Vue响应式原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-15T10:56:14+08:00">
                2021-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  434 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-数据初始化"><a href="#1-数据初始化" class="headerlink" title="1. 数据初始化"></a>1. 数据初始化</h2><p>Vue源码中在initState中进行了数据初始化，为数据添加响应式。针对props，methods，data，computed和watch，做数据的初始化处理，响应式转换。</p>
<h2 id="2-initProps"><a href="#2-initProps" class="headerlink" title="2. initProps"></a>2. initProps</h2><p>Props用于父子组件间传值(父传子)。<br>:test=test会被解析成{attrs: {test: test}}，并作为子组件的render函数。<br>创建VNode遇到child占位符时，根据attrs属性进行规范校验，最后以propsData形式传入Vnode构造器中。<br>通过proxy为props做了一层代理，可通过vue实例代理访问到props的值，本质上是利用Object.defineProperty对数据的getter和setter方法进行重写。<br>总结：props以propsData的形式在Vnode的属性存在，通过proxy进行代理，然后实例访问。</p>
<h2 id="3-initMethods"><a href="#3-initMethods" class="headerlink" title="3. initMethods"></a>3. initMethods</h2><p>methods方法定义必须是函数，命名不能与props重复。定义的方法都将挂载在根实例上。</p>
<h2 id="4-initData"><a href="#4-initData" class="headerlink" title="4. initData"></a>4. initData</h2><p>核心方法是observe，在observe方法中将数据对象标记为响应式对象，然后进行响应式处理。同props，通过proxy对data做一层处理，可通过实例访问对象属性。</p>
<h2 id="5-initComputed"><a href="#5-initComputed" class="headerlink" title="5. initComputed"></a>5. initComputed</h2><p>1.computed可以是对象，也可以是函数，函数必须有getter。<br>2.针对每个computed属性都需要创建一个监听的依赖(watcher)。<br>computed的命名防止与props，data冲突</p>
<h2 id="6-响应式系统"><a href="#6-响应式系统" class="headerlink" title="6. 响应式系统"></a>6. 响应式系统</h2><p>observe：挂载组件，引入observe类，通过Object.defineProperty，对数据的getter和setter进行改写，读取getter进行依赖手机，在setter时进行依赖更新。<br>watcher：一个watcher实例急速一个依赖，watcher记录这个依赖监听的状态以及如何更新操作的方法。渲染数据到真实DOM时会创建watcher。</p>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>最终都是调用Object.defineProperty进行数据拦截。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/15/CSS%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/15/CSS%E5%9F%BA%E7%A1%80/" itemprop="url">CSS基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-15T10:26:23+08:00">
                2021-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">页面样式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.7k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-盒模型？"><a href="#1-盒模型？" class="headerlink" title="1. 盒模型？"></a>1. 盒模型？</h3><p>盒模型：框模型，包含content(内容)、padding(内边距)、border(边框)、margin(外边距)。</p>
<h2 id="1-IE模型和标准模型的区别？"><a href="#1-IE模型和标准模型的区别？" class="headerlink" title="1. IE模型和标准模型的区别？"></a>1. IE模型和标准模型的区别？</h2><p>IE模型：width=content+padding，height=content+padding<br>标准模型：width=content，height=content</p>
<h2 id="2-CSS设置方式"><a href="#2-CSS设置方式" class="headerlink" title="2. CSS设置方式"></a>2. CSS设置方式</h2><p>可通过CSS3新增的属性box-sizing设置盒模型的模式，content-box(标准模型)，IE模型(border-box)。</p>
<h2 id="3-JavaScript设置盒模型的宽高"><a href="#3-JavaScript设置盒模型的宽高" class="headerlink" title="3. JavaScript设置盒模型的宽高"></a>3. JavaScript设置盒模型的宽高</h2><p>1.dom.style.width/height //只能取到行内样式的宽和高，style标签中的link外链取不到。<br>2.dom.currentStyle.width/height //取到的是最终渲染后的宽高，只IE支持<br>3.window.getComputedStyle(dom).width/height //同(2)，IE9以上支持，其他浏览器支持<br>4.dom.getBoundingClientRect().width/height //同(3)，还可取到对于视窗的上下左右的距离</p>
<h2 id="4-外边距重叠"><a href="#4-外边距重叠" class="headerlink" title="4. 外边距重叠"></a>4. 外边距重叠</h2><p>当两个垂直外边距相遇时，会形成外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。普通文档流才会发生，行内框，浮动框和绝对定位之间的外边距不会合并。</p>
<h2 id="5-BFC"><a href="#5-BFC" class="headerlink" title="5. BFC"></a>5. BFC</h2><p>BFC：块级格式化上下文</p>
<ul>
<li>BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠。</li>
<li>BFC的区域不会与浮动元素的布局重叠。</li>
<li>BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。</li>
<li>计算BFC高度的时候，浮动元素也会参与计算（清楚浮动）。<h2 id="6-触发条件"><a href="#6-触发条件" class="headerlink" title="6. 触发条件"></a>6. 触发条件</h2></li>
<li>overflow部位visible；</li>
<li>float的值不为none；</li>
<li>position的值不为static或relative；</li>
<li>display属性为inline-block，table，table-cell，table-caption，flex，inline-flex<br>当子元素浮动不会影响父元素时，可以给父元素触发BFC。</li>
</ul>
<hr>
<h3 id="2-CSS选择器"><a href="#2-CSS选择器" class="headerlink" title="2. CSS选择器"></a>2. CSS选择器</h3><p>选择器类型：</p>
<ul>
<li>简单选择器：通过元素类型(元素名)、class(.)或id(#)匹配一个或多个元素</li>
<li>属性选择器：通过属性/属性值匹配一个或多个元素</li>
<li>伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点(:)</li>
<li>伪元素：匹配处于相关的确定位置的一个或多个元素(::)</li>
<li>组合器：不仅是选择器本身，还以有效的方式组合老两个或更多的选择器用于非常特定的选择的方法。(嵌套)</li>
<li>多用选择器：以逗号分隔开的多个选择器放在一个CSS规则下面</li>
</ul>
<hr>
<h3 id="3-BFC"><a href="#3-BFC" class="headerlink" title="3. BFC"></a>3. BFC</h3><p>块级格式化上下文，独立的容器，不影响外面的布局。<br>触发条件：</p>
<ul>
<li>body根元素</li>
<li>浮动元素</li>
<li>绝对定位元素</li>
<li>display(inline-block、table-cells、flex)</li>
<li>overflow(hidden、auto、scroll)<br>特性：</li>
<li>在同一个BFC中，外边距会发生折叠</li>
<li>BFC可以包含浮动的元素(清除浮动)</li>
<li>可以阻止元素被浮动元素覆盖</li>
</ul>
<hr>
<h3 id="4-position"><a href="#4-position" class="headerlink" title="4. position"></a>4. position</h3><ul>
<li>默认是static(静态定位)</li>
<li>相对定位(relative)</li>
<li>绝对定位(absolute)</li>
<li>固定定位(fixed)</li>
<li>sticky(fixed和relative的混合)<br>元素根据z-index决定显示层级</li>
</ul>
<hr>
<h3 id="4-flex布局"><a href="#4-flex布局" class="headerlink" title="4. flex布局"></a>4. flex布局</h3><p>根据主轴和交叉轴进行排列<br>align-items(交叉轴方向)：对齐方式<br>justify-content(主轴方向)：对齐方式</p>
<hr>
<h3 id="5-CSS优先级"><a href="#5-CSS优先级" class="headerlink" title="5. CSS优先级"></a>5. CSS优先级</h3><p>根据权重决定</p>
<ul>
<li>行内样式+1000</li>
<li>id选择器+100</li>
<li>属性,class选择器,伪类+10</li>
<li>元素选择器,伪元素+1</li>
<li>通配符+0</li>
<li>!important提升样式优先级(最高)，最好不用<br>css样式单线程，依次从上向下加载，优先级和加载顺序有关<br>!important&gt;行内&gt;内联and外联<br>权重相等时，靠近目标的优先<br>总结：</li>
<li>!important &gt; id &gt; class &gt; tag</li>
<li>!important可以提升，不建议使用，会影响子属性</li>
<li>同样的!important，按权重决定</li>
<li>同一个CSS样式写两次，前面会被覆盖</li>
<li>样式指向同一元素，权重规则生效，权重大的被应用</li>
<li>样式指向同一元素，权重规则生效，权重相同，就近原则，后面的样式应用</li>
<li>样式不指向同一元素，权重失效，就近原则，离目标近的样式应用</li>
</ul>
<hr>
<h3 id="6-双飞翼-圣杯布局"><a href="#6-双飞翼-圣杯布局" class="headerlink" title="6. 双飞翼/圣杯布局"></a>6. 双飞翼/圣杯布局</h3><h2 id="6-1-圣杯"><a href="#6-1-圣杯" class="headerlink" title="6.1 圣杯"></a>6.1 圣杯</h2><p>1.给left、middle、right设置float:left，脱离文档流<br>2.给container设置overflow:hidden，形成BFC撑开文档<br>3.left，right设置上各自的宽度<br>4.middle设置width:100%<br>5.给left,middle,right设置positon:relative<br>6.left设置left:-leftWidth,right设置right:-rightWidth<br>7.container设置padding:0,rightWidth,0,leftWidth</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.left middle right &#123;position:relative;float:left;word-break:break-all&#125;</span><br><span class="line">.left&#123;margin-left:-100%;left:-200px;width:200px;&#125;</span><br><span class="line">.right&#123;margin-left:-220px;right:-220px;width:220px;&#125;</span><br><span class="line">.middle&#123;width:100%&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-双飞翼布局"><a href="#6-2-双飞翼布局" class="headerlink" title="6.2 双飞翼布局"></a>6.2 双飞翼布局</h2><p>1.middle增加inner<br>2.给left,middle,right设置float:left脱离文档流<br>3.container加上overflow:hidden,触发BFC<br>4.left,right设置宽度<br>5.middle设置width:100%<br>6.left设置margin-left:-100%,right设置right:-rightWidth;<br>7.container设置padding:0,rightWidth,0,leftWidth;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.left middle right &#123;float:left;word-break:break-all&#125;</span><br><span class="line">.left&#123;margin-left:-100%;width:200px&#125;</span><br><span class="line">.right&#123;margin-left:-220px;width:220px;&#125;</span><br><span class="line">.middle&#123;width:100%;height:100%&#125;</span><br></pre></td></tr></table></figure>
<h2 id="由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width-gt-LeftWidth-RightWidth"><a href="#由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width-gt-LeftWidth-RightWidth" class="headerlink" title="由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width&gt;LeftWidth+RightWidth"></a>由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width&gt;LeftWidth+RightWidth</h2><h3 id="7-CSS3新特性"><a href="#7-CSS3新特性" class="headerlink" title="7. CSS3新特性"></a>7. CSS3新特性</h3><h2 id="7-1-过渡"><a href="#7-1-过渡" class="headerlink" title="7.1 过渡"></a>7.1 过渡</h2><p>transition: CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)<br>transition:width,.5s,ease,.2s</p>
<h2 id="7-2-动画"><a href="#7-2-动画" class="headerlink" title="7.2 动画"></a>7.2 动画</h2><p>animation:动画名称，花费时间，运动曲线，动画延迟，播放次数，是否反向动画，是否暂停动画<br>animation:logo2-line 2s linear;</p>
<h2 id="7-3-形状转换"><a href="#7-3-形状转换" class="headerlink" title="7.3 形状转换"></a>7.3 形状转换</h2><p>tranform:适用于2D或3D转换的元素<br>transform:rotate(30deg);</p>
<h2 id="7-4-选择器"><a href="#7-4-选择器" class="headerlink" title="7.4 选择器"></a>7.4 选择器</h2><p><a href="https://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">CSS选择器参考手册</a></p>
<h2 id="7-5-阴影"><a href="#7-5-阴影" class="headerlink" title="7.5 阴影"></a>7.5 阴影</h2><p>box-shadow:水平阴影位置 垂直阴影位置 模糊距离 阴影大小 阴影颜色等<br>box-shadow:10px 10px 5px #888888</p>
<h2 id="7-6-边框"><a href="#7-6-边框" class="headerlink" title="7.6 边框"></a>7.6 边框</h2><p>border-image:..//边框图<br>border-radius:..//边框圆角</p>
<h2 id="7-7-背景"><a href="#7-7-背景" class="headerlink" title="7.7 背景"></a>7.7 背景</h2><p>background-clip:padding-box;//content-box</p>
<h2 id="7-8-反射"><a href="#7-8-反射" class="headerlink" title="7.8 反射"></a>7.8 反射</h2><p>-webkit-box-reflect:方向[above-上|below-下|right-右|left-左]</p>
<h2 id="7-9-文字"><a href="#7-9-文字" class="headerlink" title="7.9 文字"></a>7.9 文字</h2><p>单行文本溢出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text-overflow:显示省略号 clip(溢出裁剪) ellipsis(溢出显示省略)</span><br><span class="line">white-space:不能换行</span><br><span class="line">overflow:隐藏超出内容</span><br></pre></td></tr></table></figure>
<p>多行文本溢出：<br>伪元素+定位：基于高于截断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position:relative;</span><br><span class="line">overflow:hidden;</span><br><span class="line">position:absolute;省略号定位</span><br><span class="line">line-height:20px&#x2F;&#x2F;结合元素高度</span><br><span class="line">height:40px&#x2F;&#x2F;元素高度</span><br><span class="line">::after&#123;&#125; &#x2F;&#x2F;设置省略号样式</span><br></pre></td></tr></table></figure>
<p>兼容性较好<br>纯CSS实现：基于行数截断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-webkit-line-clamp:2&#x2F;&#x2F;限制行数</span><br><span class="line">display:-webkit-box&#x2F;&#x2F;作为弹性盒子模型显示</span><br><span class="line">-webkit-box-orient:vertical&#x2F;&#x2F;排列方式</span><br><span class="line">overflow:hidden&#x2F;&#x2F;溢出隐藏</span><br><span class="line">text-overflow:ellipsis&#x2F;&#x2F;省略号</span><br></pre></td></tr></table></figure>
<h2 id="如果为英文或数字，需添加word-wrap-break-word"><a href="#如果为英文或数字，需添加word-wrap-break-word" class="headerlink" title="如果为英文或数字，需添加word-wrap:break-word"></a>如果为英文或数字，需添加word-wrap:break-word</h2><h3 id="8-CSS画三角"><a href="#8-CSS画三角" class="headerlink" title="8. CSS画三角"></a>8. CSS画三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.border &#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-style:solid;</span><br><span class="line">    border-width: 0 50px 50px;</span><br><span class="line">    border-color: transparent transparent #d9534f;</span><br><span class="line">&#125; &#x2F;&#x2F;利用边框</span><br><span class="line"></span><br><span class="line">.box &#123;   &#x2F;&#x2F;直角三角形</span><br><span class="line">    &#x2F;* 内部大小 *&#x2F;</span><br><span class="line">    width: 0px;</span><br><span class="line">    height: 0px;</span><br><span class="line">    &#x2F;* 边框大小 只设置两条边*&#x2F;</span><br><span class="line">    border-top: #4285f4 solid;</span><br><span class="line">    border-right: transparent solid;</span><br><span class="line">    border-width: 85px; </span><br><span class="line">    &#x2F;* 其他设置 *&#x2F;</span><br><span class="line">    margin: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/JavaScript%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/26/JavaScript%E5%9F%BA%E7%A1%80/" itemprop="url">JavaScript基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-26T15:17:21+08:00">
                2021-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.5k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h2><p>每个函数都有prototype，指向了一个对象，该对象为实例的原型。<br>每个JS对象（除了null）都具有_proto_属性，指向该对象的原型。<br>每个原型都具有constructor属性，指向关联的构造函数。<br>Object.prototype._proto_为null代表该对象没有原型。</p>
<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><ul>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(); &#x2F;&#x2F; 引用类型的属性被所有实例共享</span><br><span class="line"></span><br><span class="line">child1.names.push(&#39;yayu&#39;); </span><br><span class="line"></span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(); &#x2F;&#x2F; 创建child实例时无法向Parent传参</span><br><span class="line"></span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure></li>
<li>借用构造函数（经典继承）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br><span class="line"></span><br><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure>
优点：<br>1.避免了引用类型的属性被所有实例共享<br>2.可以在Child中向Parent传参<br>缺点：<br>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li>
<li>组合继承<br>原型链继承和经典继承合并。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    </span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">Child.prototype.constructor &#x3D; Child;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#39;black&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class="line">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class="line">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class="line">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>
融合原型链和构造函数的优点，最常用的继承模式。</li>
<li>原型式继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
ES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：<br>包含引用类型的属性值始终会共享相应的值，与原型链继承一样。</li>
<li>寄生式继承<br>创建一个仅用与封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone &#x3D; Object.create(o);</span><br><span class="line">    clone.sayName &#x3D; function () &#123;</span><br><span class="line">        console.log(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</li>
<li>寄生组合式继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键的三步</span><br><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype &#x3D; Parent.prototype;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1);</span><br><span class="line">&#x2F;&#x2F;封装</span><br><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype(child, parent) &#123;</span><br><span class="line">    var prototype &#x3D; object(parent.prototype);</span><br><span class="line">    prototype.constructor &#x3D; child;</span><br><span class="line">    child.prototype &#x3D; prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>
普遍认为是最理想的继承范式。<h2 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h2>对于每个执行上下文，都有三个重要属性：</li>
<li>变量对象（Variable）</li>
<li>作用域链（Scope）</li>
<li>this<br>全局作用域：<br>window对象的上下文<br>块级作用域：<br>用let声明的代码块{}内<br>函数作用域：<br>函数上下文的作用域{}内<br>作用域链：<br>不断向上访问，直到全局作用域<h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h2>理解：引用另一个函数作用域中变量的函数。<br>闭包可以传入this对象作为参数，通过该对象访问this上下文的值。<br>由于闭包会保留他们包含函数的作用域，所以使用闭包要注意，内存的回收。<h2 id="5-变量提升"><a href="#5-变量提升" class="headerlink" title="5. 变量提升"></a>5. 变量提升</h2>var声明的变量和方法，都会提升到全局对象上。<br>全局对象就是由Object构造函数实例化的一个对象。<br>函数上下文的变量对象初始化只包括Arguments对象<br>在进入执行上下文时会给变量对象添加形参(arguments)、函数声明(func)、变量声明(var)等初始化的属性值<br>在代码执行阶段，会再次修改变量对象的属性值<br>进入执行上下文中，首先会处理函数声明，其次处理变量声明，如果变量名称跟已声明的元素相同，则声明不会干扰已经存在的这类属性。<h2 id="6-this的指向"><a href="#6-this的指向" class="headerlink" title="6. this的指向"></a>6. this的指向</h2>执行上下文都有this属性<br>标准函数中，this引用的是把函数当成方法调用的上下值。<br>箭头函数会保留定义它时的上下文<h2 id="7-立即执行函数"><a href="#7-立即执行函数" class="headerlink" title="7. 立即执行函数"></a>7. 立即执行函数</h2>调用需要在后面添加()，也需要在前面将函数用()包裹。<br>后面的()可以用来传值，立即执行会保存闭包的状态。<br>前面的()包裹函数则被解析成表达式，匿名函数后面的()被用于调用，将前面的函数当成声明。<br>IIFE（立即自执行）<br>模块模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; (function()&#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            i &#x3D; val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: function()&#123;</span><br><span class="line">            return ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;());</span><br><span class="line">    counter.get();&#x2F;&#x2F;0</span><br><span class="line">    counter.set(3);</span><br><span class="line">    counter.increment();&#x2F;&#x2F;4</span><br><span class="line">    counter.increment();&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    conuter.i;&#x2F;&#x2F;undefined (&#96;i&#96; is not a property of the returned object)</span><br><span class="line">    i;&#x2F;&#x2F;ReferenceError: i is not defined (it only exists inside the closure)</span><br></pre></td></tr></table></figure>
最小化了全局变量的污染，创造了使用变量。<h2 id="8-instanceof原理"><a href="#8-instanceof原理" class="headerlink" title="8. instanceof原理"></a>8. instanceof原理</h2>typeof也可用于判断object类型，但判断null会显示object。(typeof用于判断基本数据类型，包括symbol都是没问题的，避免null)<br>instanceof用于判断object类型，判断null时会报错，显示null不是object。<br>也可使用Object.prototype.toString来判断一个变量的类型（比较准确）。<br>原理：<br>根据原型链判断，遍历原型链查找相同的类型。<br>一边查找函数的原型，一边查找实例的原型。<br>总结：准确判断对象实例类型，可以使用Object.prototype.toString.call，<br>typeof只适合判断基本数据类型，instanceof判断null为Object。<h2 id="9-bind的实现"><a href="#9-bind的实现" class="headerlink" title="9. bind的实现"></a>9. bind的实现</h2>bind()方法会创建一个新的函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。<br>bind特点：</li>
<li>返回一个函数</li>
<li>可以传入参数<br>当bind返回的函数作为构造函数时，bind指定的this会失效，但参数生效。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-apply和call"><a href="#10-apply和call" class="headerlink" title="10. apply和call"></a>10. apply和call</h2>共同点：</li>
<li>改变上下文tihs</li>
<li>必须是函数调用<br>区别：</li>
<li>call传入多个参数</li>
<li>apply传入参数数组或类数组(具有length和for遍历)<br>call使用场景：<br>1.继承对象<br>2.借用方法<br>apply使用场景：<br>1.Math.max<br>2.两个数组合并<br>3.实现bind<h2 id="11-柯里化"><a href="#11-柯里化" class="headerlink" title="11. 柯里化"></a>11. 柯里化</h2>定义：将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>用途：参数复用，降低通用性，提高适用性。<br>实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        return fn.apply(this, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
本质上是用函数包裹原函数，给原函数传入之前的参数，当执行func()()时，执行包裹函数，返回原函数，调用sub_curry再包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的书目达到要求为止。<h2 id="12-v8垃圾回收机制"><a href="#12-v8垃圾回收机制" class="headerlink" title="12. v8垃圾回收机制"></a>12. v8垃圾回收机制</h2>1.为什么要垃圾回收？<br>避免内存泄漏，性能下降<br>2.V8引擎内存限制<br>64位系统，1.4G<br>32位系统，0.7G<br>由于JS单线程机制，垃圾回收会影响程序执行。为了减少对应用的性能影响，V8直接限制内存大小。<br>3.V8的垃圾回收策略<br>分代式垃圾回收机制，根据存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。<br>V8有如下内存结构：</li>
<li>新生代：一般分配内存，一般用于垃圾回收时保存保留对象</li>
<li>老生代：新生代对象一段时候后转移的地方</li>
<li>大对象区：存放体积较大的对象，垃圾回收不会移动该区</li>
<li>代码区：代码对象，会被分配在这里，唯一拥有执行权限的内存区域</li>
<li>map区：存放cell和map，区域存放相同大小<br>新生代回收算法：<br>Scavenge算法：Cheney算法，二分空间From和To，先From，回收时复制到To，然后将To变成From，From清空变为To。<br>对象晋升：<br>多次存活后转到老生代的对象，过程称为对象晋升。<br>条件：</li>
<li>经过过一次Scavenge算法</li>
<li>To空间的内存占比超过25%<br>老生代回收算法：<br>采用Mark-Sweep标记清除和Mark-Compact标记清理算法<br>引用计数，如果对象没有被指针引用，则被视为垃圾回收。<ol start="4">
<li>避免内存泄漏</li>
</ol>
</li>
<li>尽可能减少全局变量</li>
<li>手动清除计时器</li>
<li>少用闭包</li>
<li>清除DOM引用</li>
<li>弱引用<ol start="5">
<li>总结<br>新生代，老生代，算法，垃圾回收机制，避免内存泄漏。<h2 id="13-浮点数精度"><a href="#13-浮点数精度" class="headerlink" title="13. 浮点数精度"></a>13. 浮点数精度</h2><h2 id="14-new操作符"><a href="#14-new操作符" class="headerlink" title="14. new操作符"></a>14. new操作符</h2><h2 id="15-事件循环机制"><a href="#15-事件循环机制" class="headerlink" title="15. 事件循环机制"></a>15. 事件循环机制</h2><h2 id="16-promise原理"><a href="#16-promise原理" class="headerlink" title="16. promise原理"></a>16. promise原理</h2><h2 id="17-generator原理"><a href="#17-generator原理" class="headerlink" title="17. generator原理"></a>17. generator原理</h2></li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/vue%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/26/vue%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" itemprop="url">vue权限管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-26T10:30:39+08:00">
                2021-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.2k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-权限是啥？"><a href="#1-权限是啥？" class="headerlink" title="1. 权限是啥？"></a>1. 权限是啥？</h2><p>权限是对特定资源的访问许可，确保用户只能访问到被分配的资源。其原理是请求发起权，请求发起有两种形式：</p>
<ul>
<li>页面加载触发</li>
<li>页面上的按钮点击触发<br>实现目标：</li>
<li>路由方面，只能看到有权访问的菜单</li>
<li>视图方面，只能看到自己有权浏览的内容和有权操作的控件</li>
<li>请求控制，越权请求在前端进行拦截<h2 id="2-如何实现？"><a href="#2-如何实现？" class="headerlink" title="2. 如何实现？"></a>2. 如何实现？</h2>权限控制可以分四个方面：</li>
<li>接口权限</li>
<li>按钮权限</li>
<li>菜单权限</li>
<li>路由权限<h1 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h1>接口权限一般采用jwt的形式来严重，登录完拿到token将token保存，每次请求拦截器进行拦截，请求头部带token<h1 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a>路由权限控制</h1>方案一：在路由标记相应的权限信息，路由跳转前做校验<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const routerMap &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;permission&#39;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: &#39;&#x2F;permission&#x2F;index&#39;,</span><br><span class="line">    alwaysShow: true, &#x2F;&#x2F; will always show the root menu</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#39;permission&#39;,</span><br><span class="line">      icon: &#39;lock&#39;,</span><br><span class="line">      roles: [&#39;admin&#39;, &#39;editor&#39;] &#x2F;&#x2F; you can set roles in root nav</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &#39;page&#39;,</span><br><span class="line">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;page&#39;),</span><br><span class="line">      name: &#39;pagePermission&#39;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: &#39;pagePermission&#39;,</span><br><span class="line">        roles: [&#39;admin&#39;] &#x2F;&#x2F; or you can only set roles in sub nav</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: &#39;directive&#39;,</span><br><span class="line">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;directive&#39;),</span><br><span class="line">      name: &#39;directivePermission&#39;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        title: &#39;directivePermission&#39;</span><br><span class="line">        &#x2F;&#x2F; if do not set roles, means: this page does not require permission</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br></pre></td></tr></table></figure>
缺点：</li>
<li>加载所有的路由，如果路由很多，而用户并不是所有路由都有权限访问，会性能会有影响</li>
<li>全局路由守卫里，每次路由跳转都要做权限判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<br>方案二：<br>初始化的时候挂载公共路由，比如404，登录页。登录后获取用户的权限信息筛选有权限访问的路由在全局路由守卫调用addRoutes添加路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; permission judge function</span><br><span class="line">function hasPermission(roles, permissionRoles) &#123;</span><br><span class="line">  if (roles.indexOf(&#39;admin&#39;) &gt;&#x3D; 0) return true &#x2F;&#x2F; admin permission passed directly</span><br><span class="line">  if (!permissionRoles) return true</span><br><span class="line">  return roles.some(role &#x3D;&gt; permissionRoles.indexOf(role) &gt;&#x3D; 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const whiteList &#x3D; [&#39;&#x2F;login&#39;, &#39;&#x2F;authredirect&#39;]&#x2F;&#x2F; no redirect whitelist</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  NProgress.start() &#x2F;&#x2F; start progress bar</span><br><span class="line">  if (getToken()) &#123; &#x2F;&#x2F; determine if there has token</span><br><span class="line">    &#x2F;* has token*&#x2F;</span><br><span class="line">    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class="line">      next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class="line">      NProgress.done() &#x2F;&#x2F; if current page is dashboard will not trigger afterEach hook, so manually handle it</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (store.getters.roles.length &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断当前用户是否已拉取完user_info信息</span><br><span class="line">        store.dispatch(&#39;GetUserInfo&#39;).then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 拉取user_info</span><br><span class="line">          const roles &#x3D; res.data.roles &#x2F;&#x2F; note: roles must be a array! such as: [&#39;editor&#39;,&#39;develop&#39;]</span><br><span class="line">          store.dispatch(&#39;GenerateRoutes&#39;, &#123; roles &#125;).then(() &#x3D;&gt; &#123; &#x2F;&#x2F; 根据roles权限生成可访问的路由表</span><br><span class="line">            router.addRoutes(store.getters.addRouters) &#x2F;&#x2F; 动态添加可访问路由表</span><br><span class="line">            next(&#123; ...to, replace: true &#125;) &#x2F;&#x2F; hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class="line">          store.dispatch(&#39;FedLogOut&#39;).then(() &#x3D;&gt; &#123;</span><br><span class="line">            Message.error(err || &#39;Verification failed, please login again&#39;)</span><br><span class="line">            next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓</span><br><span class="line">        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;</span><br><span class="line">          next()&#x2F;&#x2F;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          next(&#123; path: &#39;&#x2F;401&#39;, replace: true, query: &#123; noGoBack: true &#125;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 可删 ↑</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;* has no token*&#x2F;</span><br><span class="line">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(&#39;&#x2F;login&#39;) &#x2F;&#x2F; 否则全部重定向到登录页</span><br><span class="line">      NProgress.done() &#x2F;&#x2F; if current page is login will not trigger afterEach hook, so manually handle it</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(() &#x3D;&gt; &#123;</span><br><span class="line">  NProgress.done() &#x2F;&#x2F; finish progress bar</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
缺点：</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<h1 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h1>菜单权限可以理解成将页面与路由进行解耦<br>方案一<br>菜单与路由分离，菜单由后端返回<br>前端定义路由信息，name属性不得为空，需要此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function hasPermission(router, accessMenu) &#123;</span><br><span class="line">  if (whiteList.indexOf(router.path) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  let menu &#x3D; Util.getMenuByName(router.name, accessMenu);</span><br><span class="line">  if (menu.name) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Router.beforeEach(async (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    let userInfo &#x3D; store.state.user.userInfo;</span><br><span class="line">    if (!userInfo.name) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        await store.dispatch(&quot;GetUserInfo&quot;)</span><br><span class="line">        await store.dispatch(&#39;updateAccessMenu&#39;)</span><br><span class="line">        if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class="line">          next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F;Util.toDefaultPage([...routers], to.name, router, next);</span><br><span class="line">          next(&#123; ...to, replace: true &#125;)&#x2F;&#x2F;菜单权限更新完成,重新进一次当前路由</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">      catch (e) &#123;</span><br><span class="line">        if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class="line">          next()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          next(&#39;&#x2F;login&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class="line">        next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (hasPermission(to, store.getters.accessMenu)) &#123;</span><br><span class="line">          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          next(&#123; path: &#39;&#x2F;403&#39;,replace:true &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(&#39;&#x2F;login&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let menu &#x3D; Util.getMenuByName(to.name, store.getters.accessMenu);</span><br><span class="line">  Util.title(menu.title);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.afterEach((to) &#x3D;&gt; &#123;</span><br><span class="line">  window.scrollTo(0, 0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
缺点：</li>
<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，菜单配置不对会导致应用不能正常使用</li>
<li>全局路由守卫里，每次路由跳转都要做判断<br>方案二<br>菜单和路由都由后端返回，前端统一定义路由组件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Home &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;Home.vue&quot;);</span><br><span class="line">const UserInfo &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;UserInfo.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">    home: Home,</span><br><span class="line">    userInfo: UserInfo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
后端路由组件返回以下格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;home&quot;,</span><br><span class="line">        path: &quot;&#x2F;&quot;,</span><br><span class="line">        component: &quot;home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;home&quot;,</span><br><span class="line">        path: &quot;&#x2F;userinfo&quot;,</span><br><span class="line">        component: &quot;userInfo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
前后端都需要做相应的路由处理<br>缺点：</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>前后端的配合要求更高<h1 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h1>方案一<br>按钮权限用v-if判断，但是页面过多情况下，每个页面都要获取用户权限role和路由表里的meta.Permission，再做判断<br>方案二<br>通过自定义指令进行权限判断<br>配置路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#39;&#x2F;permission&#39;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    name: &#39;权限测试&#39;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        btnPermissions: [&#39;admin&#39;, &#39;supper&#39;, &#39;normal&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;页面需要的权限</span><br><span class="line">    children: [&#123;</span><br><span class="line">        path: &#39;supper&#39;,</span><br><span class="line">        component: _import(&#39;system&#x2F;supper&#39;),</span><br><span class="line">        name: &#39;权限测试页&#39;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            btnPermissions: [&#39;admin&#39;, &#39;supper&#39;]</span><br><span class="line">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#39;normal&#39;,</span><br><span class="line">        component: _import(&#39;system&#x2F;normal&#39;),</span><br><span class="line">        name: &#39;权限测试页&#39;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            btnPermissions: [&#39;admin&#39;]</span><br><span class="line">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
自定义权限鉴定指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**权限指令**&#x2F;</span><br><span class="line">const has &#x3D; Vue.directive(&#39;has&#39;, &#123;</span><br><span class="line">    bind: function (el, binding, vnode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取页面按钮权限</span><br><span class="line">        let btnPermissionsArr &#x3D; [];</span><br><span class="line">        if(binding.value)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。</span><br><span class="line">            btnPermissionsArr &#x3D; Array.of(binding.value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F; 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。</span><br><span class="line">            btnPermissionsArr &#x3D; vnode.context.$route.meta.btnPermissions;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;</span><br><span class="line">            el.parentNode.removeChild(el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 权限检查方法</span><br><span class="line">Vue.prototype.$_has &#x3D; function (value) &#123;</span><br><span class="line">    let isExist &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 获取用户按钮权限</span><br><span class="line">    let btnPermissionsStr &#x3D; sessionStorage.getItem(&quot;btnPermissions&quot;);</span><br><span class="line">    if (btnPermissionsStr &#x3D;&#x3D; undefined || btnPermissionsStr &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;</span><br><span class="line">        isExist &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isExist;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;has&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>根据项目进行方案考虑，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/25/Vue-mixin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/25/Vue-mixin/" itemprop="url">Vue-mixin</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-25T15:05:59+08:00">
                2021-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  412 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mixin是什么？"><a href="#1-mixin是什么？" class="headerlink" title="1. mixin是什么？"></a>1. mixin是什么？</h2><p>Mixin是一种类，提供方法实现。通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用，避免多继承的复杂。本质是一个JS对象，包含组件的任意功能，将功能传入mixins中就可以使用，可以局部混入，可以全局混入（不推荐！）。</p>
<h2 id="2-如何使用？"><a href="#2-如何使用？" class="headerlink" title="2. 如何使用？"></a>2. 如何使用？</h2><p>局部混入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 组件通过mixins属性调用mixin对象</span><br><span class="line">Vue.component(<span class="string">'componentA'</span>,&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line">// 使用该组件时，会混合mixin里的方法，自动执行钩子函数。也可以调用mixin里的data值</span><br></pre></td></tr></table></figure>
<p>全局混入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(<span class="string">"全局混入"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 全局混入需要特别注意，会影响到每个组件。</span><br></pre></td></tr></table></figure>
<p>当组件存在于mixin对象相同的选项时，合并时会覆盖mixin的选项。<br>生命周期钩子相同时，会合并成一个数组，先执行mixin的钩子。</p>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><p>相似或相同的代码，功能相对独立。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const toggle = &#123; // 编写mixin</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      isShowing: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">toggleShow</span></span>() &#123;</span><br><span class="line">      this.isShowing = !this.isShowing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Modal = &#123;  // 使用时引入</span><br><span class="line">  template: <span class="string">'#modal'</span>,</span><br><span class="line">  mixins: [toggle]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>·替换型策略有props、methods、inject、computed，新参数替换旧<br>·合并型策略是data，通过set方法进行合并和重新赋值<br>·队列型策略有生命周期和watch，原理是将函数存入一个数组，然后正序遍历依次执行<br>·叠加型有component、directives、filters，通过原型链进行层层叠加</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/25/Vue%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/25/Vue%E6%8C%87%E4%BB%A4/" itemprop="url">Vue指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-25T14:05:04+08:00">
                2021-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.1k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-指令是啥？"><a href="#1-指令是啥？" class="headerlink" title="1.指令是啥？"></a>1.指令是啥？</h2><p>Vue有一套为数据驱动视图更方便的指令系统。v-开头的行内属性都是指令，不同指令可以实现不同的功能。</p>
<h2 id="2-如何实现？"><a href="#2-如何实现？" class="headerlink" title="2.如何实现？"></a>2.如何实现？</h2><p>局部注册，全局注册。通过Vue.directive注册。<br>全局注册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123; // 注册v-focus指令</span><br><span class="line">   inserted: <span class="keyword">function</span> (el) &#123;</span><br><span class="line">      el.focus() // 让元素自动聚焦</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>局部注册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">   focus: &#123;</span><br><span class="line">      inserted: <span class="keyword">function</span> (el) &#123;</span><br><span class="line">         el.focus() //功能同上</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板中的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure>

<p>自定义指令也存在钩子函数：<br>·bind：只调用一次，指令第一次绑定到元素时使用。初始化设置。<br>·inserted：被绑定元素插入父节点时调用<br>·update：所在组件VNode更新时调用<br>·componentUpdated：所在组件VNode和子VNode全部更新后调用<br>·unbind：只调用一次，指令与元素解绑时调用<br>钩子函数的参数有：<br>·el：指令绑定的元素，可操作DOM<br>·binding：一个对象，包含name,value,oldValue,expression,arg,modifiers<br>·vnode：虚拟节点<br>·oldVnode：上一个虚拟节点</p>
<h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><p>·防抖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1.设置v-throttle自定义指令</span><br><span class="line">Vue.directive(<span class="string">'throttle'</span>, &#123;</span><br><span class="line">  <span class="built_in">bind</span>: (el, binding) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class="line">      throttleTime = 2000;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> cbFun;</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class="line">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class="line">          cbFun = null;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">// 2.为button标签设置v-throttle自定义指令</span><br><span class="line">&lt;button @click=<span class="string">"sayHello"</span> v-throttle&gt;提交&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>·图片懒加载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">// 1.设置v-throttle自定义指令</span><br><span class="line">Vue.directive(<span class="string">'throttle'</span>, &#123;</span><br><span class="line">  <span class="built_in">bind</span>: (el, binding) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class="line">      throttleTime = 2000;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> cbFun;</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class="line">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class="line">          cbFun = null;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">// 2.为button标签设置v-throttle自定义指令</span><br><span class="line">&lt;button @click=<span class="string">"sayHello"</span> v-throttle&gt;提交&lt;/button&gt;</span><br><span class="line">图片懒加载</span><br><span class="line">设置一个v-lazy自定义组件完成图片懒加载</span><br><span class="line">const LazyLoad = &#123;</span><br><span class="line">    // install方法</span><br><span class="line">    install(Vue,options)&#123;</span><br><span class="line">       // 代替图片的loading图</span><br><span class="line">        <span class="built_in">let</span> defaultSrc = options.default;</span><br><span class="line">        Vue.directive(<span class="string">'lazy'</span>,&#123;</span><br><span class="line">            <span class="built_in">bind</span>(el,binding)&#123;</span><br><span class="line">                LazyLoad.init(el,binding.value,defaultSrc);</span><br><span class="line">            &#125;,</span><br><span class="line">            inserted(el)&#123;</span><br><span class="line">                // 兼容处理</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">'IntersectionObserver'</span> <span class="keyword">in</span> window)&#123;</span><br><span class="line">                    LazyLoad.observe(el);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    LazyLoad.listenerScroll(el);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化</span><br><span class="line">    init(el,val,def)&#123;</span><br><span class="line">        // data-src 储存真实src</span><br><span class="line">        el.setAttribute(<span class="string">'data-src'</span>,val);</span><br><span class="line">        // 设置src为loading图</span><br><span class="line">        el.setAttribute(<span class="string">'src'</span>,def);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 利用IntersectionObserver监听el</span><br><span class="line">    observe(el)&#123;</span><br><span class="line">        <span class="built_in">let</span> io = new IntersectionObserver(entries =&gt; &#123;</span><br><span class="line">            <span class="built_in">let</span> realSrc = el.dataset.src;</span><br><span class="line">            <span class="keyword">if</span>(entries[0].isIntersecting)&#123;</span><br><span class="line">                <span class="keyword">if</span>(realSrc)&#123;</span><br><span class="line">                    el.src = realSrc;</span><br><span class="line">                    el.removeAttribute(<span class="string">'data-src'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        io.observe(el);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 监听scroll事件</span><br><span class="line">    listenerScroll(el)&#123;</span><br><span class="line">        <span class="built_in">let</span> handler = LazyLoad.throttle(LazyLoad.load,300);</span><br><span class="line">        LazyLoad.load(el);</span><br><span class="line">        window.addEventListener(<span class="string">'scroll'</span>,() =&gt; &#123;</span><br><span class="line">            handler(el);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 加载真实图片</span><br><span class="line">    load(el)&#123;</span><br><span class="line">        <span class="built_in">let</span> windowHeight = document.documentElement.clientHeight</span><br><span class="line">        <span class="built_in">let</span> elTop = el.getBoundingClientRect().top;</span><br><span class="line">        <span class="built_in">let</span> elBtm = el.getBoundingClientRect().bottom;</span><br><span class="line">        <span class="built_in">let</span> realSrc = el.dataset.src;</span><br><span class="line">        <span class="keyword">if</span>(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123;</span><br><span class="line">            <span class="keyword">if</span>(realSrc)&#123;</span><br><span class="line">                el.src = realSrc;</span><br><span class="line">                el.removeAttribute(<span class="string">'data-src'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 节流</span><br><span class="line">    throttle(fn,delay)&#123;</span><br><span class="line">        <span class="built_in">let</span> timer; </span><br><span class="line">        <span class="built_in">let</span> prevTime;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">function</span>(...args)&#123;</span><br><span class="line">            <span class="built_in">let</span> currTime = Date.now();</span><br><span class="line">            <span class="built_in">let</span> context = this;</span><br><span class="line">            <span class="keyword">if</span>(!prevTime) prevTime = currTime;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(currTime - prevTime &gt; delay)&#123;</span><br><span class="line">                prevTime = currTime;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timer = setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                prevTime = Date.now();</span><br><span class="line">                timer = null;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> default LazyLoad;</span><br></pre></td></tr></table></figure>
<p>·一键copy的功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Message &#125; from <span class="string">'ant-design-vue'</span>;</span><br><span class="line"></span><br><span class="line">const vCopy = &#123; //</span><br><span class="line">  /*</span><br><span class="line">    <span class="built_in">bind</span> 钩子函数，第一次绑定时调用，可以在这里做初始化设置</span><br><span class="line">    el: 作用的 dom 对象</span><br><span class="line">    value: 传给指令的值，也就是我们要 copy 的值</span><br><span class="line">  */</span><br><span class="line">  <span class="built_in">bind</span>(el, &#123; value &#125;) &#123;</span><br><span class="line">    el.<span class="variable">$value</span> = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到</span><br><span class="line">    el.handler = () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!el.<span class="variable">$value</span>) &#123;</span><br><span class="line">      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意</span><br><span class="line">        Message.warning(<span class="string">'无复制内容'</span>);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      // 动态创建 textarea 标签</span><br><span class="line">      const textarea = document.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">      // 将该 textarea 设为 <span class="built_in">readonly</span> 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span><br><span class="line">      textarea.readOnly = <span class="string">'readonly'</span>;</span><br><span class="line">      textarea.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">      textarea.style.left = <span class="string">'-9999px'</span>;</span><br><span class="line">      // 将要 copy 的值赋给 textarea 标签的 value 属性</span><br><span class="line">      textarea.value = el.<span class="variable">$value</span>;</span><br><span class="line">      // 将 textarea 插入到 body 中</span><br><span class="line">      document.body.appendChild(textarea);</span><br><span class="line">      // 选中值并复制</span><br><span class="line">      textarea.select();</span><br><span class="line">      // textarea.setSelectionRange(0, textarea.value.length);</span><br><span class="line">      const result = document.execCommand(<span class="string">'Copy'</span>);</span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        Message.success(<span class="string">'复制成功'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      document.body.removeChild(textarea);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 绑定点击事件，就是所谓的一键 copy 啦</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, el.handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当传进来的值更新的时候触发</span><br><span class="line">  componentUpdated(el, &#123; value &#125;) &#123;</span><br><span class="line">    el.<span class="variable">$value</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 指令与元素解绑的时候，移除事件绑定</span><br><span class="line">  unbind(el) &#123;</span><br><span class="line">    el.removeEventListener(<span class="string">'click'</span>, el.handler);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default vCopy;</span><br></pre></td></tr></table></figure>
<p>还有拖拽指令、页面水印、权限校验等等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/21/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/21/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2/" itemprop="url">单页面和多页面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-21T09:38:11+08:00">
                2021-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%9A%E5%8A%A1/" itemprop="url" rel="index">
                    <span itemprop="name">业务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  254 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单页面应用(SPA):只有一个主页面的应用，单页面跳转，仅刷新局部资源。多应用于PC端。<br>多页面应用(MPA):就是指一个应用中有多个页面，页面跳转时是整页刷新，公共资源等选择性重新加载。<br>单页面的优点：<br>资源共用，页面局部刷新，切换速度快，用户体验良好。<br>数据传递容易，维护成本较低。开发成本较高，需要借助框架。<br>缺点：不利于SEO优化，可利用SSR优化。</p>
<p>多页面优点：搜索引擎优化简易，开发成本较低，但重复代码多。<br>缺点：公共资源不共用，页面切换加载慢，流畅度不够。无法实现跳转动画，<br>依赖url，cookie，localstorage传参。维护成本较高。</p>
<p>单页面适用场景：高要求的体验度、追求界面流畅的应用。<br>多页面的适用场景：适用于追求高度支持搜索引擎的应用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/04/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/04/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%81%93/" itemprop="url">前端进阶之道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-04T15:21:26+08:00">
                2020-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">Web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.6k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  6 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><p>JS分两种类型，原始类型和对象类型。<br>原始类型：<br>1.boolean<br>2.number<br>3.string<br>4.undefined<br>5.null<br>6.symbol<br>7.bigint<br>对象类型：<br>1.Object(Array,RegExp,Math,Map,Set)<br>2.Function</p>
<hr>
<h3 id="2-类型判断"><a href="#2-类型判断" class="headerlink" title="2. 类型判断"></a>2. 类型判断</h3><h2 id="2-1-typeof"><a href="#2-1-typeof" class="headerlink" title="2.1 typeof"></a>2.1 typeof</h2><p>原始类型中除了null，都可以用typeof判断。<br>typeof判断函数为function，其他均为object。</p>
<h2 id="2-2-instanceof"><a href="#2-2-instanceof" class="headerlink" title="2.2 instanceof"></a>2.2 instanceof</h2><p>常用于判断对象类型</p>
<h2 id="2-3-Object-prototype-toString"><a href="#2-3-Object-prototype-toString" class="headerlink" title="2.3 Object.prototype.toString"></a>2.3 Object.prototype.toString</h2><p>最佳选择，能判断的类型最完整</p>
<h2 id="2-4-isXXX-API"><a href="#2-4-isXXX-API" class="headerlink" title="2.4 isXXX API"></a>2.4 isXXX API</h2><p>isArray()，isNaN()</p>
<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3. 类型转换"></a>3. 类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(false) &#x2F;&#x2F; -&gt; 0</span><br><span class="line">Number(&#39;1&#39;)&#x2F;&#x2F; -&gt; 1</span><br><span class="line">Number(&#39;zb&#39;)&#x2F;&#x2F; -&gt; NaN</span><br><span class="line">(1).toString()&#x2F;&#x2F; &#39;1&#39;</span><br></pre></td></tr></table></figure>
<p>转布尔值规则：<br>1.undefined、null、false、NaN、’’、0、-0都转为false<br>2.其他所有值都转为true，包括所有对象<br>转数字规则：<br>1.true为1，false为0<br>2.null为0，undefined为NaN，symbol报错<br>3.字符串看内容，如果是数字或者进制值就正常转，否则就NaN<br>4.对象的规则隐式转换再讲</p>
<h3 id="4-this"><a href="#4-this" class="headerlink" title="4. this"></a>4. this</h3><h2 id="4-1-普通函数"><a href="#4-1-普通函数" class="headerlink" title="4.1 普通函数"></a>4.1 普通函数</h2><p>谁调用this指向谁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; new foo()</span><br><span class="line">c.a &#x3D; 3</span><br><span class="line">console.log(c.a) &#x2F;&#x2F; this绑定到c上，不会被任何方式修改</span><br></pre></td></tr></table></figure>
<p>使用apply，call，bind改变this，优先级仅次于new</p>
<h2 id="4-2-箭头函数"><a href="#4-2-箭头函数" class="headerlink" title="4.2 箭头函数"></a>4.2 箭头函数</h2><p>箭头函数的this取决于定义时的环境</p>
<h3 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h3><p>定义：加入一个函数能访问外部的变量，那么这个函数它就是一个闭包。<br>闭包会将访问的变量存放在内部对象[[Scopes]]上，因此可以访问到本该销毁的变量<br>局部变量才是被存储在栈上，全局变量存在静态区域上，其他都存在堆上。(只针对Chrome)</p>
<h3 id="6-new"><a href="#6-new" class="headerlink" title="6. new"></a>6. new</h3><p>new可以构建出一个实例，并绑定上this，执行步骤如下：<br>1.新生成一个对象<br>2.对象连接到构造函数原型上，并绑定this<br>3.执行构造函数代码<br>4.返回新对象<br>当构造函数中返回一个对象时，内部创建的新对象会被我们返回的对象所覆盖，所以构造函数一般来说不返回对象。</p>
<h3 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7. 作用域"></a>7. 作用域</h3><p>作用域有三类：<br>1.全局作用域<br>2.函数作用域<br>3.块级作用域<br>[[Scopes]],定义时就被确定下来，后续不会改变</p>
<h3 id="8-原型"><a href="#8-原型" class="headerlink" title="8. 原型"></a>8. 原型</h3><p>原型更重要引出继承，概念：<br>1.每个对象都有一个_proto_指向一个对象，就是原型<br>2.每个对象的原型都可以通过constructor访问构造函数，构造函数通过prototype访问原型<br>3.所有函数都可以通过_proto_找到Function对象<br>4.所有对象都可以通过_proto_找到Object对象<br>5.对象直接通过_proto_连接起来为原型链，顶层Object对象的原型为null</p>
<h3 id="9-继承"><a href="#9-继承" class="headerlink" title="9. 继承"></a>9. 继承</h3><p>继承中的class，本质上还是一个函数。<br>ES5与6继承的区别：<br>1.ES6继承的子类需要调用super()才能拿到子类，ES5的话是通过apply这种绑定的方式<br>2.类声明不会提升，和let这些一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;&#125;</span><br><span class="line">Super.prototype.getNumber &#x3D; function() &#123;</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub() &#123;&#125;</span><br><span class="line">Sub.prototype &#x3D; Object.create(Super.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Sub,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">let s &#x3D; new Sub()</span><br><span class="line">s.getNumber()</span><br></pre></td></tr></table></figure>
<h3 id="10-深浅拷贝"><a href="#10-深浅拷贝" class="headerlink" title="10. 深浅拷贝"></a>10. 深浅拷贝</h3><h2 id="10-1-浅拷贝"><a href="#10-1-浅拷贝" class="headerlink" title="10.1 浅拷贝"></a>10.1 浅拷贝</h2><p>浅拷贝：第一层引用不同<br>通过assign和扩展运算符实现浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#123;age:1&#125;</span><br><span class="line">let b &#x3D; Object.assign(&#123;&#125;,a)</span><br><span class="line">b &#x3D; &#123;...a&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-2-深拷贝"><a href="#10-2-深拷贝" class="headerlink" title="10.2 深拷贝"></a>10.2 深拷贝</h2><p>深拷贝：所有引用不同<br>使用JSON.parse(JSON.stringify(object))可以实现，不过存在不少缺陷。<br>也可以通过递归实现深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用 WeakMap 解决循环引用</span><br><span class="line">let map &#x3D; new WeakMap()</span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  if (obj instanceof Object) &#123;</span><br><span class="line">    if (map.has(obj)) &#123;</span><br><span class="line">      return map.get(obj)</span><br><span class="line">    &#125;</span><br><span class="line">    let newObj</span><br><span class="line">    if (obj instanceof Array) &#123;</span><br><span class="line">      newObj &#x3D; []</span><br><span class="line">    &#125; else if (obj instanceof Function) &#123;</span><br><span class="line">      newObj &#x3D; function() &#123;</span><br><span class="line">        return obj.apply(this, arguments)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (obj instanceof RegExp) &#123;</span><br><span class="line">      &#x2F;&#x2F; 拼接正则</span><br><span class="line">      newobj &#x3D; new RegExp(obj.source, obj.flags)</span><br><span class="line">    &#125; else if (obj instanceof Date) &#123;</span><br><span class="line">      newobj &#x3D; new Date(obj)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      newObj &#x3D; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 克隆一份对象出来</span><br><span class="line">    let desc &#x3D; Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">    let clone &#x3D; Object.create(Object.getPrototypeOf(obj), desc)</span><br><span class="line">    map.set(obj, clone)</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        newObj[key] &#x3D; deepClone(obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11. Promise"></a>11. Promise</h3><p>高频考点，涉及API，问到all，race。<br>then，catch，finally都为微任务。其他代码都是宏任务(同步执行)<br>这些微任务在Promise状态为非pending时加入队列。<br>同级then下，前一个then执行完后，后面的才会加入任务队列。<br>最开始调用的then会首先依次加入任务队列。<br>同一个promise的每个链式调用的开端会首先依次进入队列。</p>
<h2 id="11-1-async-await"><a href="#11-1-async-await" class="headerlink" title="11.1 async/await"></a>11.1 async/await</h2><p>async/await(ES8)<br>阻塞await后面的内容。</p>
<h3 id="12-事件循环"><a href="#12-事件循环" class="headerlink" title="12. 事件循环"></a>12. 事件循环</h3><p>异步只是延迟执行同步代码。其他线程不影响(Web worker)。<br>Task(宏任务)：同步代码、setTimeout回调、setInterval回调、IO、UI交互事件、postMessage、MessageChannel。<br>MicroTask(微任务)：Promise的回调，Mutation observer回调，queueMicrotask回调。<br>执行顺序如下：<br>1.执行同步代码<br>2.执行完所有同步代码后且执行栈为空，判断是否有微任务需要执行<br>3.执行所有微任务且微任务队列为空<br>4.是否有必要渲染页面<br>5.执行一个宏任务</p>
<h3 id="13-模块化"><a href="#13-模块化" class="headerlink" title="13. 模块化"></a>13. 模块化</h3><p>CommonJS，ES6的ESM</p>
<h3 id="14-垃圾回收"><a href="#14-垃圾回收" class="headerlink" title="14. 垃圾回收"></a>14. 垃圾回收</h3><p>分两个空间，新生代和老生代。</p>
<h2 id="14-1-新生代"><a href="#14-1-新生代" class="headerlink" title="14.1 新生代"></a>14.1 新生代</h2><p>使用Scavenge GC算法<br>也分两个部分，From空间，To空间。<br>From占满时，启动算法检查存活的对象复制到To空间中，会和To空间互换。</p>
<h2 id="14-2-老生代"><a href="#14-2-老生代" class="headerlink" title="14.2 老生代"></a>14.2 老生代</h2><p>使用标记清除和标记压缩算法<br>经历过Scavenge算法后还存活，To空间对象占比大小超过25%，会将新生代移到老生代。<br>启动标记清除算法条件：<br>1.某一个空间没有分块<br>2.空间中被对象超过一定限制<br>3.空间不能保证新生代中的对象移动到老生代中<br>标记活对象，销毁没被标记的对象</p>
<h3 id="15-其他"><a href="#15-其他" class="headerlink" title="15. 其他"></a>15. 其他</h3><p>0.1+0.2 !== 0.3<br>浮点数用二进制表示的时候是无穷的，因为精度的问题，两个浮点数相加会造成截断丢失精度，因此再转换为十进制就出了问题。</p>
<h3 id="16-手写题"><a href="#16-手写题" class="headerlink" title="16. 手写题"></a>16. 手写题</h3><h2 id="16-1-防抖"><a href="#16-1-防抖" class="headerlink" title="16.1 防抖"></a>16.1 防抖</h2><h2 id="16-2-节流"><a href="#16-2-节流" class="headerlink" title="16.2 节流"></a>16.2 节流</h2><h2 id="16-3-Event-Bus"><a href="#16-3-Event-Bus" class="headerlink" title="16.3 Event Bus"></a>16.3 Event Bus</h2><h2 id="16-4-instanceof"><a href="#16-4-instanceof" class="headerlink" title="16.4 instanceof"></a>16.4 instanceof</h2><h2 id="16-5-call，bind，apply"><a href="#16-5-call，bind，apply" class="headerlink" title="16.5 call，bind，apply"></a>16.5 call，bind，apply</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url">JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-23T09:43:04+08:00">
                2020-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript高级程序设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  17.7k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  68 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-1-历史回顾"><a href="#1-1-历史回顾" class="headerlink" title="1.1 历史回顾"></a>1.1 历史回顾</h1><p>网站数据量大，复杂。需要JS来解决，优化。</p>
<h1 id="1-2-JS实现"><a href="#1-2-JS实现" class="headerlink" title="1.2 JS实现"></a>1.2 JS实现</h1><p>JS = ECMAScript（核心） + DOM（文档对象模型） + BOM（浏览器对象模型）</p>
<h2 id="1-2-1（ECMAScript）"><a href="#1-2-1（ECMAScript）" class="headerlink" title="1.2.1（ECMAScript）"></a>1.2.1（ECMAScript）</h2><p>ES：网页提供ES的基准实现和与环境自身交互必须的扩展。<br>ES包括：语法、类型、语句、关键字、保留字、操作符、全局对象。<br>大部分浏览器兼容ES6。</p>
<h2 id="1-2-2-DOM"><a href="#1-2-2-DOM" class="headerlink" title="1.2.2 DOM"></a>1.2.2 DOM</h2><p>文档对象模型：是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。F12中常见的文档树。<br><img src="/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%96%87%E6%A1%A3%E6%A0%91.png" alt="文档树"><br>DOM通过创建表示文档的树，让开发者可以更好地控制网页的内容和结构。使用DOM的API，可以轻松删除，添加，替换，修改节点。<br>DOM视图：描述追踪文档不同视图的接口。<br>DOM事件：描述事件及事件处理的接口。<br>DOM样式：描述处理元素CSS样式的接口。<br>DOM遍历的范围：描述遍历和操作DOM数的接口。<br>其他DOM：可伸缩矢量图（SVG），数学标记语言（MathML），同步多媒体集成语言（SMIL）<br>DOM有不同level（版本）:目前到了level3</p>
<h2 id="1-2-3-BOM"><a href="#1-2-3-BOM" class="headerlink" title="1.2.3 BOM"></a>1.2.3 BOM</h2><p>浏览器对象模型：用于支持访问和操作浏览器的窗口。使用BOM，可以操控浏览器显示页面之外的部分，BOM针对浏览器窗口和子窗口。拓展：<br>弹出新浏览器窗口的能力；<br>移动、缩放和关闭浏览器窗口的能力；<br>navigator对象，提供关于浏览器的详尽信息；<br>location对象，提供浏览器加载页面的详尽信息；<br>screen对象，提供关于用户屏幕分辨率的详尽信息；<br>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；<br>对cookie的支持；<br>其他自定义对象，XMLHttp，ActiveXObject；</p>
<h1 id="1-3-JavaScript版本"><a href="#1-3-JavaScript版本" class="headerlink" title="1.3 JavaScript版本"></a>1.3 JavaScript版本</h1><h1 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h1><p>JS是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br>ES：有ECMA-262定义并提供核心功能。<br>文档对象模型（DOM）:提供与网页内容交互的方法和接口。<br>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。<br>JS这三个部门得到了五大Web浏览器不同程度的支持。所有浏览器基本上对ES5提供了完善的支持，ES6最佳。</p>
<hr>
<h1 id="2-1-script元素"><a href="#2-1-script元素" class="headerlink" title="2.1 script元素"></a>2.1 script元素</h1><p>将Js插入HTML的主要方法是使用script元素。有下列8个属性：<br>1.async：可选，表示立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。<br>2.charset：可选，使用src属性指定的代码字符集。很少用。<br>3.crossorigin：可选，配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。<br>defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。<br>integrity：可选，允许比对接收到的资源和指定的加密签名以验证子资源完整性。<br>language：废弃。<br>src：可选，表示包含要执行的代码的外部文件。（引入外部JS文件）<br>type：可选，代替language，表示代码块中脚本语言的内容类型（MIME类型）。按照惯例这个值始终都是“text/JavaScript”，MIME类型通常都是“application/x-javascript”，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。</p>
<h2 id="2-1-1-标签位置"><a href="#2-1-1-标签位置" class="headerlink" title="2.1.1 标签位置"></a>2.1.1 标签位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>
<p>上述是把文件放在head里，不过这种写法以为着必须把所有JS代码都下载、解析和解释完成后，才能开始渲染页面，可能会导致页面渲染的明显延迟，所以通常把文件引用放在body元素中的页面内容后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src&#x3D;&#39;example2.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-2-推迟执行脚本"><a href="#2-1-2-推迟执行脚本" class="headerlink" title="2.1.2 推迟执行脚本"></a>2.1.2 推迟执行脚本</h2><p>可用defer属性，可用推迟脚本执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-3-异步执行脚本"><a href="#2-1-3-异步执行脚本" class="headerlink" title="2.1.3 异步执行脚本"></a>2.1.3 异步执行脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-4-动态加载脚本"><a href="#2-1-4-动态加载脚本" class="headerlink" title="2.1.4 动态加载脚本"></a>2.1.4 动态加载脚本</h2><p>JS可用使用DOM API ，通过向DOM中动态添加Script元素同样可用加载指定的脚本，只要创建一个Script元素并将其添加到DOM即可。如下：<br>let script = document.createElement(‘script’);<br>script.src = ‘gibbersh.js’<br>document.head.appendChild(script);<br>这个请求是异步的，不是所有浏览器都支持async属性，因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。<br>添加：script.async = false;<br>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。这种可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;gibberish.js&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-5-XMHTL中的变化"><a href="#2-1-5-XMHTL中的变化" class="headerlink" title="2.1.5 XMHTL中的变化"></a>2.1.5 XMHTL中的变化</h2><p>XHTML：可扩展超文本标记语言，是将HTML作为XML的应用重新包装的结果。在XHTML中使用JS必须制定type属性且值为text/javascript。<br>XHTML比较少见。</p>
<h2 id="2-1-6-废弃的语法"><a href="#2-1-6-废弃的语法" class="headerlink" title="2.1.6 废弃的语法"></a>2.1.6 废弃的语法</h2><p>个别废弃的语法，可不看。</p>
<h1 id="2-2-行内代码与外部文件"><a href="#2-2-行内代码与外部文件" class="headerlink" title="2.2 行内代码与外部文件"></a>2.2 行内代码与外部文件</h1><p>最佳实践是尽可能将JS代码放在外部文件中。推荐原因如下：<br>可维护性：JS代码分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。<br>缓存：浏览器会根据特定的设置缓存所有外部链接的JS文件，这意味着若干两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。<br>适应未来：通过把JS放到外部文件中，就不比考虑用XHTML的或注释黑科技。包含外部JS文件的语法在HTML和XHTML是一样的。<br>在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JS组件形式向客户端送达脚本更具优势。<br>在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从同一个地方取得一批文件，并将他们逐个放到浏览器缓存中。从浏览器角度看，通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JS文件的 延迟差不多。<br>在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。</p>
<h1 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3 文档模式"></a>2.3 文档模式</h1><p>最初有两种模式：混杂模式，标准模式。<br>第三种模式：准标准模式。</p>
<h1 id="2-4-noscript元素"><a href="#2-4-noscript元素" class="headerlink" title="2.4 noscript元素"></a>2.4 noscript元素</h1><p>针对不支持JS的浏览器而出的元素。以下两种情况，浏览器将显示包含在noscript中的内容：<br>浏览器不支持脚本；<br>浏览器对脚本的支持被关闭；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;noscript&gt; </span><br><span class="line">&lt;p&gt;This page requires a JavaScript-enabled browser.&lt;&#x2F;p&gt; </span><br><span class="line">&lt;&#x2F;noscript&gt;</span><br></pre></td></tr></table></figure>
<h1 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h1><p>JS通过script元素插入到HTML页面中。这个元素可以用于把JS代码嵌入到HTML页面汇总，跟其他标记混合在一起，也可以用与引入保存在外部文件中的JS。本章的重点如下：<br>1.要包含外部JS文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。<br>2.所有script元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在script元素中的代码必须严格按次序解释。<br>3.对不推迟执行的脚本，浏览器必须解释完位于script元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常把script元素放到页面末尾，介于主内容之后及body标签之前。<br>4.可以使用defer推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。<br>5.可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。<br>6.通过使用noscript元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则noscript元素中的任何内容都不会被渲染。</p>
<h1 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h1><h2 id="3-1-1-区别大小写"><a href="#3-1-1-区别大小写" class="headerlink" title="3.1.1 区别大小写"></a>3.1.1 区别大小写</h2><p>ECMA中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。<br>typeof不能作为函数名，因为它是一个关键字。但Typeof可以用。</p>
<h2 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a>3.1.2 标识符</h2><p>变量、函数、属性或函数参数的名称。可以由一个或多个下列字符组成：<br>第一个字符必须是一个字母、下划线（_）或美元符号（$）;<br>剩下的其他字符可以是字母、下划线、美元符号或数字。<br>一般使用驼峰大小写形式。</p>
<h2 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3 注释"></a>3.1.3 注释</h2><h2 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a>3.1.4 严格模式</h2><p>“use strict” //脚本开头加上这一行<br>也可以在指定函数内加上开头。所有现代浏览器都支持严格模式。</p>
<h2 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5 语句"></a>3.1.5 语句</h2><p>结尾建议加分号，建议语句块加{}</p>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2 关键字与保留字"></a>3.2 关键字与保留字</h2><p>ES6的关键字有：<br>break     do     in     typeof<br>case     else     instanceof     var<br>catch     export     new     void<br>class     extends     return     while<br>const     finally     super     with<br>continue   for     switch     yield<br>debugger function    this<br>default     if     throw<br>delete     import     try<br>ES6将来保留词汇：<br>始终保留：<br>enum<br>严格模式下保留：<br>implements     package     public<br>interface     protected     static<br>let     private<br>模块代码中保留：<br>await<br>这些词汇不能作标识符，但可以坐对象的属性名，推荐不用作属性名。</p>
<h1 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h1><p>ECMA变量是松散类型的，变量可以用于保存任何类型的数据。每个变量不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var,const,let<br>var:声明完后可以赋值，但未标识类型。//声明提升<br>//var message = “hi”;<br>//message = 100; // 合法，但不推荐。<br>//作用域在声明的环境下的函数作用域，例在函数内定义，调用完函数随即被销毁。<br>//在函数内定义时省略var操作符，可以创建一个全局变量。不推荐这么做。<br>let:块作用域，同一个块内不能重复声明。变量在作用域中无声明提升。<br>//有暂时性死区。<br>//无法全局声明，声明的变量不会成为window对象的属性。<br>//ES6不能依赖条件声明模式<br>const:与let基本相同，区别是声明变量时必须同时初始化变量，且无法修改const声明的变量。</p>
<h2 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4 声明风格及最佳实践"></a>3.3.4 声明风格及最佳实践</h2><p>1.不使用var<br>2.const优先，let次之</p>
<h1 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h1><p>ES6有6种简单的数据类型（原始类型）：undefined,null,boolean,number,String,Symbol。Symbol是ES6新增的。还有一种复杂的数据类型叫Object（对象）。Object是一种无序名值对的集合。</p>
<h2 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1 typeof操作符"></a>3.4.1 typeof操作符</h2><p>不需要参数（但可以使用参数），严格来说，函数也是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。可以用typeof区分。</p>
<h2 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2 Undefined类型"></a>3.4.2 Undefined类型</h2><p>变量未初始化即是Undefined，相当于给变量赋值了Undefined。<br>建议在声明时初始化，出现undefined可以更好辨别。</p>
<h2 id="3-4-4-Null类型"><a href="#3-4-4-Null类型" class="headerlink" title="3.4.4 Null类型"></a>3.4.4 Null类型</h2><p>Null类型同样只有一个值，即特殊值null。null值表示一个空对象指针，typeof null返回Object。<br>在定义将来要保存对象值的变量时，建议初始化为null。</p>
<h2 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4 Boolean类型"></a>3.4.4 Boolean类型</h2><p>有两个字面值：true，false。<br>True和False是有效的标识符，不是布尔值。//区分大小写<br>使用Boolean()来转换类型</p>
<h2 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a>3.4.5 Number类型</h2><p>1.浮点值<br>//小数点后面必须带数字，不然当整数处理。<br>2.值的范围<br>//Number.MIN_VALUE:5e-324<br>Number.MAX_VALUE:1.7976931348623157e+308<br>超出以上范围会表示为Infinity或-Infinity,该值无法用于计算。<br>可使用isFinite()函数进行判断<br>3.NaN<br>NaN表示”不是数值”,用于表示本来要返回数值的操作失败了（不是抛出错误）。<br>例：0除任意数值<br>console.log(0/0) // NaN<br>console.log(5/0) //Infinity<br>console.log(5/-0)//-Infinity<br>任何涉及NaN的操作始终返回NaN，NaN不等于任何值。//(NaN == NaN)–&gt;false<br>可用isNaN()函数判断是否不是数值<br>isNaN(NaN)//true<br>isNaN(10)//false<br>isNaN(“10”)//false,可转换为数值10<br>isNaN(“blue”)//true,无法转换为数值<br>isNaN(true)//false,可以转换为1<br>4.数值转换<br>有3个函数可以将非数值转换为数值：<br>Number(),parseInt(),parseFloat()<br>Number()是转型函数，可用于任何数据类型。后两个主要用于将字符串转为数值。<br>Number()有如下规则：<br>(true)-&gt;1,(false)-&gt;0,(null)-&gt;0,(undefined)-&gt;NaN,数值直接返回<br>如果字符串包含数值字符，包括数值字符前面带加号、减号的情况，则转换为一个十进制数值。<br>如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值（同样，忽略前面的0）。<br>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。<br>如果是空字符串（不包含字符），则返回0。<br>如果字符串包含上述情况之外的其他字符，则返回NaN。<br>通常使用parseInt（）</p>
<h2 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6 String类型"></a>3.4.6 String类型</h2><p>字符串使用：双引号，单引号，反引号都合法，引号类型前后必须一致。<br>1.字面量：<br>\n  换行<br>\t   制表<br>\b  退格<br>\r   回车<br>\f   换页等<br>2.特点<br>不可变，一旦创建，值不能变。要修改某个变量的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。<br>3.转换为字符串<br>toString()//函数<br>还可以传入参数输出不同进制<br>let num = 10;<br>num.toString() // “10”<br>num.toString(2) // “1010”<br>num.toString(8) // “12”<br>4.模板字面量<br>可以使用换行字符，可以跨行定义字符串。<br>使用反引号会保持引号内部的空格，字面量，length会增加。<br>5.字符串插值<br>可以在定义中插入一个或多个值。<br>通过反引号中使用 ${}插入，插入的值都会通过toString转换为字符串<br>插值表达式中可以调用函数和方法：<br>foo = {toString:() =&gt; ‘Wrold’};<code>hello,${foo}</code> // hello world<br>capitalize(word) =&gt;return <code>${word[0].toUpperCase()}</code>   // <code>${capitalize(&#39;hello&#39;)}</code>//-&gt;Hello<br>6.模板字面量标签函数<br>支持定义标签函数，通过标签函数可以自定义插值行为。<br>7.原始字符串<br>Unicode字符<br>使用String.raw获取原始字符串<br>‘\u00A9’ // 版权符号<br>String.raw<code>\u00A9</code>// \u00A9</p>
<h2 id="3-4-7-Symbol类型"><a href="#3-4-7-Symbol类型" class="headerlink" title="3.4.7 Symbol类型"></a>3.4.7 Symbol类型</h2><p>Symbol是ES6新增的，且实例是唯一，不可变的。用于创建唯一记号，进而用作非字符串形式的对象属性。<br>1.基本用法<br>let sym = Symbol(); type of sym//symbol<br>也可以传入字符串参数作为对symbol的描述，可通过这个字符串来调试代码。但这个字符串参数与符号定义或标识无关。<br>符号无法与new关键字一起作为构造函数使用。<br>可以使用符号包装对象，借用Object函数()函数：<br>let mySymbol = Symbol();<br>let myWrappedSymbol = Object (mySymbol);<br>console.log(typeof myWrappedSymbol); // “object”<br>2.使用全局符号注册表<br>如果运行时的不同部分需要共享和 重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br>需要使用Symbol.for()方法。</p>
<h2 id="3-4-8-Object类型"><a href="#3-4-8-Object类型" class="headerlink" title="3.4.8 Object类型"></a>3.4.8 Object类型</h2><p>对象其实就是一组数据和功能的集合。可以通过new来创建实例对象。<br>每个对象都有如下属性和方法：<br>constructor：用于创建当前对象的函数，构造函数。<br>hasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性。<br>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。<br>propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用。<br>toLacaleString():返回对象的字符串表示,反映对象所在本地化执行环境。<br>toString():返回对象的字符串表示。<br>valueOf():返回对象对应的字符串、数值或布尔值表示。</p>
<h1 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h1><h2 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h2><p>只操作一个值的操作符叫一元操作符。<br>++,–;  //操作中会自行转换类型,(递增和递减)<br>+,-//一元加减符，可以用于运算和转换</p>
<h2 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h2><p>…</p>
<h2 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h2><p>逻辑非，逻辑与逻辑或<br>1.逻辑非 ：！（感叹号）<br>!false // true<br>!”blue” //false<br>!0 //true<br>!NaN //true<br>!”” //true<br>!12345 //false<br>也可以用两个感叹号:!!,相当于调用了转型函数Boolean()。第一个返回布尔值，第二个对该布尔值取反。<br>相当于如上例子，布尔值取反。<br>2.逻辑与<br>由&amp;&amp;表示 // true &amp;&amp; true为true  其余都为false<br>3.逻辑或<br>由||表示 //有一个是true为true，false || false为false</p>
<h2 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4 乘性操作符"></a>3.5.4 乘性操作符</h2><p>乘法(<em>)，除法(/)，取模(%)。<br>乘法(</em>):都为数值则计算，有一项为NaN则返回NaN，如果是Infinity<em>0=NaN,Infinity</em>(-/+)num=(-)Infinity，Infinity*Infinity=Infinity,如果不是数值会转换后再近些操作。<br>除法(/):<br>0 / 0 = NaN,Infinity / Infinity = NaN,-(number)/0 = (-)Infinity,Infinity / (-)Number = (-)Infinity<br>取模(%):类似除</p>
<h2 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5 指数操作符"></a>3.5.5 指数操作符</h2><p>ES7新增的操作符 (*<em>)//Math.pow(3,2) == 3 *</em> 2 == 9<br>squared ** = 2 //9</p>
<h2 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6 加性操作符"></a>3.5.6 加性操作符</h2><p>（+），（-）</p>
<h2 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7 关系操作符"></a>3.5.7 关系操作符</h2><p>（&lt;）,（&gt;）,（&lt;=），（&gt;=）</p>
<h2 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8 相等操作符"></a>3.5.8 相等操作符</h2><p>（==），（!=），（===）,（!==）</p>
<h2 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9 条件操作符"></a>3.5.9 条件操作符</h2><p>（?）// let max = （num1 &gt; num2）? num1 : num2</p>
<h2 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10 赋值操作符"></a>3.5.10 赋值操作符</h2><p>（=），（*=），（/=），（%=），（+=）,（-=）,（&lt;&lt;=）,（&gt;&gt;=）,（&gt;&gt;&gt;=）</p>
<h1 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h1><h2 id="3-6-1-if语句"><a href="#3-6-1-if语句" class="headerlink" title="3.6.1 if语句"></a>3.6.1 if语句</h2><p>…</p>
<h2 id="3-6-2-do-while语句"><a href="#3-6-2-do-while语句" class="headerlink" title="3.6.2 do-while语句"></a>3.6.2 do-while语句</h2><p>do {***} while(expression);</p>
<h2 id="3-6-3-while语句"><a href="#3-6-3-while语句" class="headerlink" title="3.6.3 while语句"></a>3.6.3 while语句</h2><p>let i = 0;<br>while(i &lt; 10) { i += 2};</p>
<h2 id="3-6-4-for语句"><a href="#3-6-4-for语句" class="headerlink" title="3.6.4 for语句"></a>3.6.4 for语句</h2><p>for(initialization;expression;post-loop-expression) statement</p>
<h2 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5 for-in语句"></a>3.6.5 for-in语句</h2><p>for(property in expression) statement<br>for(const propName in window) {document.write(propName)}//例子</p>
<h2 id="3-6-6-for-of语句"><a href="#3-6-6-for-of语句" class="headerlink" title="3.6.6 for-of语句"></a>3.6.6 for-of语句</h2><p>for(property of expression) statement<br>for(const el of [2,4,6,8]){document.write(el)}//例子</p>
<h2 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7 标签语句"></a>3.6.7 标签语句</h2><p>label:statement<br>start: for(let i = 0;i &lt; count;i++){console.log(i)}//start是一个标签，可在后面通过break，continue语句引用。</p>
<h2 id="3-6-8-break和continue语句"><a href="#3-6-8-break和continue语句" class="headerlink" title="3.6.8 break和continue语句"></a>3.6.8 break和continue语句</h2><p>break用于立即退出循环,强行执行循环后的下一条语句。<br>continue语句用于立即退出循环，但会从循环顶部开始执行。</p>
<h2 id="3-6-9-with语句"><a href="#3-6-9-with语句" class="headerlink" title="3.6.9 with语句"></a>3.6.9 with语句</h2><p>with(expression) statement;<br>let qs = location.search.substring(1);<br>let hostName = location.hostname;<br>let url = location.href;<br>with(location){<br>let qs = search.substring(1);<br>let hostName = hostname;<br>let url = href;<br>}<br>严格模式不允许使用</p>
<h2 id="3-6-10-switch语句"><a href="#3-6-10-switch语句" class="headerlink" title="3.6.10 switch语句"></a>3.6.10 switch语句</h2><p>switch(expression){<br>  case value1:<br>    statament<br>    break;<br>  case value2:<br>    statement<br>    break;<br>  …<br>  default:<br>    statement<br>}<br>//switch不会强制转换数据类型</p>
<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h2><p>function Name(arg0,arg1){ statements}<br>遇到return语句函数就会立即停止执行并退出。<br>函数不能以eval，arguments作为名称；<br>函数的参数不能叫eval，arguments；<br>两个命名参数不能拥有同一个名称。</p>
<h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h2><p>ES中基本数据类型包括：undefined,Null,Boolean,Number,String,Symbol<br>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。//声明方式<br>不指定返回值的函数实际上会返回特殊值undefined。</p>
<h1 id="4-变量、作用域与内存"><a href="#4-变量、作用域与内存" class="headerlink" title="4 变量、作用域与内存"></a>4 变量、作用域与内存</h1><h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1 原始值与引用值"></a>4.1 原始值与引用值</h2><p>变量有两种不同的类型：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。<br>原始值的变量是按值访问的，引用值是保存在内存中的对象，操作对象时，操作的是对该对象的引用而非实际的对象本身。</p>
<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h3><p>引用值可以随时添加、修改和删除其属性和方法。<br>只有引用值可以动态添加后面可以使用的属性。<br>原始类型的初始化可以只使用原始字面量形式。如果使用new则创建Object类型的实例。<br>let name1 = “wxc”;//typeof name1 == string<br>let name2 = new String(“Matt”);//typeof name2 == object</p>
<h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2 复制值"></a>4.1.2 复制值</h3><p>原始值的变量复制会创建新变量。//let name1 = “wxc”;let name2 = name1;<br>引用值的变量复制的是一个指针，两个变量指向同一个对象，一改则都改。</p>
<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p>函数的参数都是按值传递的，传递时，值会被复制到一个局部变量。<br>按引用传递参数时，值在内存中的位置会被保存在一个局部变量，对本地变量的修改会反映到函数外部。ES中函数的参数就是局部变量。</p>
<h3 id="4-1-4确定类型"><a href="#4-1-4确定类型" class="headerlink" title="4.1.4确定类型"></a>4.1.4确定类型</h3><p>typeof对于原始值有用，但对引用值不大。<br>引用值判断可以用instanceof<br>person instanceof Object<br>colors instanceof Array<br>pattern instanceof RegExp<br>instanceof对于原始值始终返回false，原始值不是对象。</p>
<h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2 执行上下文与作用域"></a>4.2 执行上下文与作用域</h2><p>每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。<br>浏览器中，全局上下文为window对象。var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。<br>每个函数也有自己的上下文，执行函数时，函数上下文被推倒一个上下文栈上，执行完后弹出。ES的执行流通过该上下文栈进行控制。<br>上下文中的代码在执行时，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链的下一个变量对象来自上级包含上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。<br>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>
<h3 id="4-2-1-作用域链增强"><a href="#4-2-1-作用域链增强" class="headerlink" title="4.2.1 作用域链增强"></a>4.2.1 作用域链增强</h3><p>代码执行到try/catch语句的catch块与with语句时，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>
<h3 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2 变量声明"></a>4.2.2 变量声明</h3><p>1.使用var声明变量，变量会被自动添加到最接近的上下文，最接近的上下文大多是函数的局部上下文，如果未声明就被初始化了，就被添加到全局上下文。如果在函数内声明变量添加到全局上下文，函数退出后依然可以访问。<br>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。变量提升。<br>2.使用let声明的块级作用域声明<br>块级作用域由最近的{}界定。<br>3.使用const的常量声明<br>const声明的同时必须初始化为某个值。声明后不能重新赋新值。<br>作用域与let声明一样。<br>建议多使用const，除非需要一个会重新赋值的变量。可以防止重新赋值的BUG。<br>4.标识符查找<br>特定上下文读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。//其实就是调用变量</p>
<h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3 垃圾回收"></a>4.3 垃圾回收</h2><p>JS使用垃圾回收，程序每隔一段就会自动运行。确定不会再使用的变量，释放内存。</p>
<h3 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1 标记清理"></a>4.3.1 标记清理</h3><p>常用策略是标记清理。程序运行时，标记内存中存储的所有变量，将所有上下文中的变量，以及被在上下文中的变量引用的标记去掉。再加上标记代表待删除，随后做一次内存清理，销毁带标记的所有值并回收内存。<br>IE，Firefox，Opera，Chrome，Safari都在JS实习标记清理，频率有所差异。</p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h3><p>对每个值记录引用次数。声明变量并赋一个引用值时，这个值的引用数为1。 如果保存对该值引用的变量被其他值给覆盖了，引用数-1。引用数为0时回收内存。</p>
<h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3 性能"></a>4.3.3 性能</h3><p>垃圾回收的时间调度很重要，变量太多会造成性能损失。JS引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果回收的内存不到已分配的15%，这些阈值会翻倍。如果一次回收的内存达到已分配的85%，则阈值重置为默认值。</p>
<h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4 内存管理"></a>4.3.4 内存管理</h3><p>保证在执行代码时只保存必要的数据。不在必要则设置为null，从而释放其引用。这也可以叫作解除引用。局部变量在超出作用域会自动解除引用，所以该建议更适合全局变量和全局对象。<br>1.通过const和let声明提升性能<br>块作用域，能更早让垃圾回收程序介入。<br>2.隐藏类和删除操作<br>对象与隐藏类会被关联起来，用于跟踪他们的属性特征。共享相同隐藏类的对象性能会更好。<br>function Article(){this.title = ‘go go go’}<br>let a1 = new Article();//隐藏类title<br>let a2 = new Article();//隐藏类title<br>a1.author = ‘Jake’//对应多出author隐藏类，可能对性能产生明显影响。<br>function Article(author){this.title=’go’,this.author=author}<br>let a2 = new Article(‘wxc’)//a2与a1相同，共享一个隐藏类。<br>delete a1.author//使用delete关键字会导致生成同样的隐藏类片段<br>a1.author = null; //保持共享，并达到垃圾回收的效果<br>3.内存泄漏<br>JS的内存泄漏大部分是不合理的引用导致的。<br>function(){name = ‘Jake’}意外声明全局变量是最常见也最容易修复的内存泄漏问题。无关键字声明。<br>定时器也会导致内存泄漏，定时器的回调通过闭包引用了外部变量。<br>使用闭包容易造成内存泄漏，如下：<br>let outer = function() {let name = ‘Jake’;return function() {return name};};<br>调用outer()会导致内存泄漏。只要返回的函数存在就不能清理name，因为闭包一直在引用，加入name的内容很大，就是个大问题。<br>4.静态分配与对象池<br>不要动态创建矢量对象<br>在初始化的时候，创建一个对象池，管理一组可回收的对象。使用完后回归对象池。</p>
<h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><p>原始值大小固定，因此保存在栈内存上。<br>引用值是对象，存储在堆内存上。<br>任何变量都存在于某个作用域（上下文）中，这个作用域决定了变量的声明周期，以及它们可以访问代码的哪些部分。<br>全局上下文：window，浏览器。<br>函数上下文：声明函数的{}内<br>块级上下文：最近的{}内<br>JS有垃圾回收，垃圾回收的方法有：引用计数，标记清理。主流为标记清理。<br>接触变量引用一般直接给变量赋值为null。</p>
<h1 id="5-基本引用类型"><a href="#5-基本引用类型" class="headerlink" title="5.基本引用类型"></a>5.基本引用类型</h1><p>引用值是某个特定引用类型的实例。<br>对象被认为是某个特定引用类型的实例。新对象通过使用new操作符跟一个构造函数来创建。<br>函数也是一种引用类型。</p>
<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h2><p>日期对象//let now = new Date();<br>可用Date.parse()转换成日期对象//let someDate = new Date(Date.parse(“May 23,2019”));如果字符串不表示日期，会返回NaN。<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55));//GMT时间——Date.UTC方法<br>ES提供了Date.now()方法，返回表示方法执行时日期。<br>let start = Date.now();//当前时间</p>
<h3 id="5-1-1-继承的方法"><a href="#5-1-1-继承的方法" class="headerlink" title="5.1.1 继承的方法"></a>5.1.1 继承的方法</h3><p>let date = new Date(2021,1,20);<br>toLocaleString()//–&gt;2021/2/20 上午12:00:00<br>toString()//–&gt;Sat Feb 20 2021 00:00:00 GMT+0800<br>valueOf()//–&gt;1613750400000</p>
<h3 id="5-1-2-日期格式化方法"><a href="#5-1-2-日期格式化方法" class="headerlink" title="5.1.2 日期格式化方法"></a>5.1.2 日期格式化方法</h3><p>Date格式化日期的方法：<br>toDateString()//显示日期中的周几，月，日，年<br>toTimeString()//显示日期中的时分秒和时区<br>toLocaleDateString()//显示日期中的周几 月 日 年<br>toLocaleTimeString()//显示日期中的时 分 秒<br>toUTCString()//显示完整的UTC日期</p>
<h3 id="5-1-3-日期-时间组件方法"><a href="#5-1-3-日期-时间组件方法" class="headerlink" title="5.1.3 日期/时间组件方法"></a>5.1.3 日期/时间组件方法</h3><p>主要应用：<br>getTime()//返回日期的毫秒表示，与valueOf相同<br>setTime(milliseconds)//设置日期的毫秒表示，从而修改整个日期<br>getFullYear()//返回四位年数<br>getMonth()//返回日期的月<br>getDate()//返回日期的日<br>getDay()//返回日期中表示周几的数值<br>getHours()//返回日期中的时<br>getMinutes()//返回日期中的分<br>getSeconds()//返回日期中的秒</p>
<h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2 RegExp"></a>5.2 RegExp</h2><p>ES通过RegExp类型支持正则表达式。<br>let expression = /pattern/flags;<br>匹配模式的标记：<br>1.g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。<br>2.i:不区分大小写，表示查找匹配时忽略pattern和字符串的大小写。<br>3.m:多行模式，表示查找到一行文本末尾时会继续查找。<br>4.y:粘附模式，表示只查找从lastIndex开始及之后的字符串。<br>5.u:Unicode模式，启用Unicode匹配。<br>6.s：dotAll模式，表示元字符匹配任何字符。(包括\n或\r)。<br>使用不同模式和标记可以创建出各种正则表达式，比如：<br>//匹配字符串中的所有”at”<br>let pattern1 = /at/g;<br>//匹配第一个”bat”或”cat” 忽略大小写<br>let pattern2 = /[bc]at/i<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi<br>元字符在模式中必须转义：<br>( ，[， {，\，^，$，|，)，]，}，？，*，+，- //这些符号前面需要\来转义<br>//匹配第一个”bat”或”cat”，忽略大小写<br>let pattern1 = /[bc]at/i;<br>//匹配第一个”[bc]at”，忽略大小写<br>let pattern2 = /[bc]at/i;<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi;<br>//匹配所有”.at”，忽略大小写<br>let pattern4 = /.at/gi;<br>也可使用RegExp构造函数来创建：<br>let pattern1 = /[bc]at/i   ==   new RegExp(“[bc]at”,”i”);<br>也可以使用实例，选择性修改标记<br>const re1 = /cat/g;<br>const re2 = new RegExp(re1);<br>const re3 = new RegExp(re1,”i”);</p>
<h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1 RegExp实例属性"></a>5.2.1 RegExp实例属性</h3><p>global:布尔值，表示是否设置了g标记。<br>ignoreCase:布尔值，表示是否设置了i标记。<br>unicode:布尔值，表示是否设置了u标记。<br>sticky:布尔值，表示是否设置了y标记。<br>lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。<br>multiline:布尔值，表示是否设置了m标记。<br>dotAll:布尔值，表示是否设置了s标记。<br>source:正则表达式的字面量字符串，没有开头和结尾的斜杠。<br>flags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回。</p>
<h3 id="5-2-2-RegExp实例方法"><a href="#5-2-2-RegExp实例方法" class="headerlink" title="5.2.2 RegExp实例方法"></a>5.2.2 RegExp实例方法</h3><p>exec()函数：<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);<br>  console.log(matchs);//cat<br>//设置了全局标记(g)，每次调用返回一个匹配的信息，如果没有设置全局标记，只会返回第一个匹配的信息。<br>//设置了g标记，每次调用exec()都会在字符中向前搜索下一个匹配项<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);//cat<br>  let matchs = pattern.exec(text);//bat<br>  let matchs = pattern.exec(text);//sat<br>  console.log(matchs);<br>//设置了y标记，每次调用会在lastIndex的位置上寻找匹配项。y标记覆盖g标记。<br>test()函数：//用于判断是否存在实际内容中，常在if判断语句中<br>let text = “000-00-00 00”;<br>let pattern = /\d{3}-\d{2}-\d(4)/;<br>if(pattern.test(text)) {console.log(“The pattern was matched.”)};<br>继承的方法toLocaleString()和toString()都返回字面量表示。<br>let pattern = new RegExp(“\[bc\]at”,”gt”);<br>console.log(pattern.toString());//  /[bc]at/gi<br>console.log(pattern.toLocaleString());//  /[bc]at/gi</p>
<h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3 RegExp构造函数属性"></a>5.2.3 RegExp构造函数属性</h3><p>input：$_   //最后搜索的字符串<br>lastMatch：$&amp;   //最后匹配的文本<br>lastParen：$+   //最后匹配的捕获组<br>leftContext：$`   //input字符串中出现在lastMatch前面的文本<br>rightContext：$’   //input字符串中出现在lastMatch后面的文本<br>let text = “this has been a short summer”;<br>let pattern = /(.)hort/g; //()–&gt;捕获组<br>if(pattern.test(text)) {<br>   console.log(RegExp.input); //this has been a short summer<br>   console.log(RegExp.leftContext); //this has been a<br>   console.log(RegExp.rightContext); //summer<br>   console.log(RegExp.lastMatch); //short<br>   console.log(RegExp.input); //s<br>}</p>
<p>if(pattern.test(text)) {<br>   console.log(RegExp.$_); //this has been a short summer<br>   console.log(RegExp[“$`”]); //this has been a<br>   console.log(RegExp[“$’”]); //summer<br>   console.log(RegExp[“$&amp;”]); //short<br>   console.log(RegExp[“$+”]); //s<br>}<br>let pattern = /(..)or(.)/g;</p>
<p>if(pattern.test(text)) {<br>   console.log(RegExp.$1); // sh<br>   console.log(RegExp.$2);// t<br>}</p>
<h3 id="5-2-4-模式局限"><a href="#5-2-4-模式局限" class="headerlink" title="5.2.4 模式局限"></a>5.2.4 模式局限</h3><p>ES对正则表达式的支持还缺少一些高级特性。</p>
<h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3 原始值包装类型"></a>5.3 原始值包装类型</h2><p>ES提供了3种特殊类型的引用类型：Boolean,Number,String。<br>以读模式访问字符串时，后台执行：<br>（1）创建一个String类型的实例；// let s1 = “some text”<br>（2）调用实例上的特点方法；// let s2 = s1.substring(2);<br>（3）销毁实例；// s1 = null;<br>let value = “25”;<br>let number = Number(value);   //转型函数<br>console.log(typeof number);   //“number”<br>let obj = new Number(value); // 构造函数<br>console.log(typeof obj); //“object”<br>变量obj保存一个Number实例。</p>
<h3 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1 Boolean"></a>5.3.1 Boolean</h3><p>let falseObject = new Boolean(false);// typeof == object<br>let result = falseObject &amp;&amp; true;<br>console.log(result); //true<br>let falseValue = false;//typeof == boolean 强烈建议永远不要使用<br>result = falseValue &amp;&amp; true;<br>console.log(result); //false</p>
<h3 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2 Number"></a>5.3.2 Number</h3><p>方法：toFix()//let num = 10;num.toFixed(2);// “10.00”<br>方法：toExponential()//let num = 10;num.toExponential(1);//“1.0e+1”<br>方法：toPrecision()//let num = 99;<br>num.toPrecision(1)//“1e+2”<br>num.toPrecision(2)//“99”<br>num.toPrecision(3)//“99.0”<br>方法：isInterger()//辨别一个数值是否保存为整数。<br>Number.isInterger(1);// true<br>Number.isInterger(1.00)//true<br>Number.isInterger(1.01)//false<br>方法：isSafeInterger()判断数值范围</p>
<h3 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3 String"></a>5.3.3 String</h3><p>每个字符用16位表示，基于16位码元完成操作。//基本多语言平面。<br>normalize()方法：用于判断规范性。<br>concat()：拼接//用加法运算符也可<br>Value = “hello world”;<br>slice()：<br>Value.slice(3)//“lo world”;<br>Value.slice(3,7)//“lo w”;<br>Value.slice(-3)//“rld” 等同于slice(8);(11-3)<br>Value.slice(3,-4)//“lo w” 等同于slice(3,7);(3+4)<br>substr()：<br>Value.substr(3)//“lo world”;<br>Value.substr(3,7)//“lo worl”;<br>Value.substr(-3)//“rld” 等同于substr(8);<br>Value.substr(3,-4)//“”等同于substr(3,0);<br>substring()：<br>Value.substring(3)//“lo world”;<br>Value.substring(3,7)//“lo w”;<br>Value.substring(-3)//“hello world” 等同于substring(0)<br>Value.substring(3,-4)//“hel”等同于substring(0,3)<br>indexOf():<br>Value.indexOf(“o”);// 4<br>Value.indexOf(“t”)// -1<br>Value.indexOf(“o”,6)//7<br>lastIndexOf():<br>Value.lastIndexOf(“o”)//7<br>Value.lastIndexOf(“t”)//-1<br>Value.lastIndexOf(“o”,6)//4<br>message = “foobarbaz”;<br>startWith():<br>message.startWith(“foo”);//true<br>message.startWith(“bar”);//false<br>endWith():<br>message.endWith(“baz”);//true<br>message.endWith(“bar”);//false<br>includes():<br>message.includes(“bar”);//true<br>message.includes(“qux”);//false<br>trim()://不影响原字符串，trimLeft(),trimRight()<br>let string = “   hello  world   “;<br>string.trim()//“hello  world”<br>repeat():<br>string = “abc”;<br>string.repeat(2)//“abcabc”;<br>padStart(),padEnd():<br>string = “foo”<br>string.padStart(6)//“   foo”;len=6<br>string.padStart(9,”.”)//“……foo”;len=9<br>string.padStart(8,”bar”)//“barbafoo”len=8<br>string.padEnd(6)//“foo   “;<br>string.padEnd(9,”.”)//“foo……”;<br>string.padEnd(8,”bar”)//“foobarba”;<br>迭代与解构<br>let message = “abc”;<br>Iterator = message<a href>Symbol.iterator</a>;<br>Iterator.next()//{value:”a”,done:false}<br>Iterator.next()//{value:”b”,done:false}<br>Iterator.next()//{value:”c”,done:false}<br>Iterator.next()//{value:”undefined”,done:true}<br>大小写转换<br>toLowerCase()//小写<br>toLocalLowerCase()//特定地区方法使用<br>toUpperCase()//大写<br>toLocalUpperCase()//特定地区方法使用<br>字符串模式匹配方法<br>match():与exec()方法一致<br>search():<br>let text = “cat, bat, sat, fat”;<br>let pos = text.search(/at/);//1第一个位置为1<br>replace():<br>let res = text.replace(“at”,”ond”);//“cond, bat, sat, fat”<br>let res = text.replace(/at/g,”ond”)//“cond, bond, sond, fond”<br>localeCompare():按字母表顺序比较返回值</p>
<h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4 单例内置对象"></a>5.4 单例内置对象</h2><p>包括Global,Math</p>
<h3 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1 Global"></a>5.4.1 Global</h3><p>全局作用域中定义的变量和函数都会成为Global对象的属性。<br>encodeURI(),encodeURIComponent()//编码统一资源标识符。<br>eval():<br>eval(“console.log(‘hi’)”);///console.log(“hi”);<br>eval(“function sayHi(){console.log(‘hi’);}”);///sayHi();<br>容易被XSS攻击。<br>对象属性：<br>undefined//特殊值<br>NaN//特殊值<br>Infinity//特殊值<br>Object//构造函数<br>Array//构造函数<br>Function//构造函数<br>….<br>window对象<br>window为Global对象的代理,全局变量和函数即为window的属性。</p>
<h3 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2 Math"></a>5.4.2 Math</h3><p>Math对象属性：<br>E //自然对数的基数e的值<br>LN10 //10为底的自然对数<br>LN2 //2为底的自然对数<br>LOG2E //以2为底e的对数<br>LOG10E //以10为底e的对数<br>PI //π的值<br>SQRT1_2 //1/2的平方根<br>SQRT2 //2的平方根<br>Math方法：<br>min():取最小值//配合数组可以使用扩展操作符<br>max():取最大值//max = Math.max(…array);<br>ceil():向上取<br>Math.ceil(25.9);//26<br>Math.ceil(25.5);//26<br>Math.ceil(25.1);//26<br>round():四舍五入<br>console.log(Math.round(25.9)); // 26<br>console.log(Math.round(25.5)); // 26<br>console.log(Math.round(25.1)); // 25<br>fround():取单精度浮点值<br>console.log(Math.fround(0.4)); // 0.4000000059604645<br>console.log(Math.fround(0.5)); // 0.5<br>console.log(Math.fround(25.9)); // 25.899999618530273<br>floor():向下取<br>console.log(Math.floor(25.9)); // 25<br>console.log(Math.floor(25.5)); // 25<br>console.log(Math.floor(25.1)); // 25<br>random()://返回小数0~1内<br>加密提高不确定性：建议使用window.crypto.getRandomValues()。<br>abs()//绝对值<br>exp()//次幂<br>log()//自然对数<br>….</p>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><p>对象为引用值，内置的引用类型可用于创建特定类型的对象。<br>RegExp是ES支持正则表达式的接口。<br>函数实际上是Function类型的实例，是对象。</p>
<h1 id="6-集合引用类型"><a href="#6-集合引用类型" class="headerlink" title="6 集合引用类型"></a>6 集合引用类型</h1><h2 id="6-1-Object"><a href="#6-1-Object" class="headerlink" title="6.1 Object"></a>6.1 Object</h2><p>let person = new Object();//构造函数<br>person.name = ‘micheal’;<br>let person = {name:’micheal’};//{}字面量表达式<br>person[“name”]//micheal<br>person.name//micheal</p>
<h2 id="6-2-Array"><a href="#6-2-Array" class="headerlink" title="6.2 Array"></a>6.2 Array</h2><h3 id="6-2-1-创建数组"><a href="#6-2-1-创建数组" class="headerlink" title="6.2.1 创建数组"></a>6.2.1 创建数组</h3><p>let colors = new Array();//可以传值创建初始length的数组，也可以传数组值<br>let colors = [“red”,”blue”]//字面量表达式<br>from():<br>Array.from(“Matt”)//[“M”,”a”,”t”,”t”]<br>适用于Map,Set,Array,iterator,arguments<br>of()://使用Array.prototype.slice.call(arguments)<br>Array.of(1,2,3,4)//[1,2,3,4]<br>Array.of(undefined)//[undefined]</p>
<h3 id="6-2-2-数组空位"><a href="#6-2-2-数组空位" class="headerlink" title="6.2.2 数组空位"></a>6.2.2 数组空位</h3><p>使用(,)创建数组空位<br>const options = [,,,,,]<br>options.length = 5<br>options //[,,,,,]<br>空值为undefined<br>options = [1,,,5];<br>options.map(()=&gt;6)//[6,,,6]<br>options.join(‘-‘)//“1—–5”</p>
<h3 id="6-2-3-数组索引"><a href="#6-2-3-数组索引" class="headerlink" title="6.2.3 数组索引"></a>6.2.3 数组索引</h3><p>colors[0]–&gt;第一个元素<br>给数组设置length会改变数组大小</p>
<h3 id="6-2-4-检测数组"><a href="#6-2-4-检测数组" class="headerlink" title="6.2.4 检测数组"></a>6.2.4 检测数组</h3><p>判断是否数组，使用instanceof<br>也可使用isArray()方法</p>
<h3 id="6-2-5-迭代器方法"><a href="#6-2-5-迭代器方法" class="headerlink" title="6.2.5 迭代器方法"></a>6.2.5 迭代器方法</h3><p>const a = [“a”,”b”,”c”,”d”];<br>keys()://返回数组索引的迭代器<br>const akeys = Array.from(a.keys()); // [0,1,2,3]<br>values()://返回数组元素的迭代器<br>const aValues = Array.from(a.Values());//[“a”,”b”,”c”,”d”]<br>entries()://返回索引/值对的迭代器<br>const aEntries = Array.from(a.entries());//[[0,”a”],[1,”b”],[2,”c”],[3,”d”]]<br>for(const [idx,element] of a.entries()){<br>alert(idx);<br>alert(element);<br>}<br>//0<br>//a<br>//1<br>//b<br>//2<br>//c<br>//3<br>//d</p>
<h3 id="6-2-6-复制和填充方法"><a href="#6-2-6-复制和填充方法" class="headerlink" title="6.2.6 复制和填充方法"></a>6.2.6 复制和填充方法</h3><p>copyWithin()//批量复制<br>fill()://填充<br>const a = [0,0,0,0,0];<br>zeros.fill(5)//[5,5,5,5,5];<br>zeros.fill(6,3)//[0,0,0,6,6]<br>zeros.fill(7,1,3)//[0,7,7,0,0]<br>索引过低，过高，反向都会被忽略<br>部门可用的索引，填充可用部分。<br>ints = [0,1,2,3,4,5,6,7,8,9];<br>ints.copyWithin(5) // [0,1,2,3,4,0,1,2,3,4];<br>ints.copyWithin(0,5)//[5,6,7,8,9,5,6,7,8,9];<br>ints.copyWithin(4,0,3)//[0,1,2,3,0,1,2,7,8,9];<br>ints.copyWithin(2,0,6)//[0,1,0,1,2,3,4,5,8,9];</p>
<h3 id="6-2-7-转换方法"><a href="#6-2-7-转换方法" class="headerlink" title="6.2.7 转换方法"></a>6.2.7 转换方法</h3><p>数组调用toString(),valueOf()方法相当于每个元素调用一次这个方法。</p>
<h3 id="6-2-8-栈方法"><a href="#6-2-8-栈方法" class="headerlink" title="6.2.8 栈方法"></a>6.2.8 栈方法</h3><p>push()//从最后推入数据<br>pop()//弹出最后一项并返回</p>
<h3 id="6-2-9-队列方法"><a href="#6-2-9-队列方法" class="headerlink" title="6.2.9 队列方法"></a>6.2.9 队列方法</h3><p>shift()://删除数组第一项并返回<br>push()://从最后推入数据<br>unshift()://从开头推入</p>
<h3 id="6-2-10-排序方法"><a href="#6-2-10-排序方法" class="headerlink" title="6.2.10 排序方法"></a>6.2.10 排序方法</h3><p>reverse()://反向排序<br>sort()://将元素转换成字符串比较</p>
<h3 id="6-1-11-操作方法"><a href="#6-1-11-操作方法" class="headerlink" title="6.1.11 操作方法"></a>6.1.11 操作方法</h3><p>concat():添加//直接使用会打平数组<br>slice():取值<br>splice()://可实现删除(两个参数)，插入(三个参数)，替换(三个参数)</p>
<h3 id="6-2-12-搜索和位置方法"><a href="#6-2-12-搜索和位置方法" class="headerlink" title="6.2.12 搜索和位置方法"></a>6.2.12 搜索和位置方法</h3><p>indexOf()//查找元素位置，返回<br>lastIndexOf()//查找元素位置，返回<br>includes()//返回布尔值，是否包含元素<br>find()//返回第一个匹配的元素<br>findIndex()//返回索引</p>
<h3 id="6-2-13-迭代方法"><a href="#6-2-13-迭代方法" class="headerlink" title="6.2.13 迭代方法"></a>6.2.13 迭代方法</h3><p>every():元素都匹配才会返回true<br>filter():返回true的元素组成数组返回<br>forEach():运行函数，无返回值<br>map():调用结果构成数组返回<br>some():如果有一项返回true，则返回true</p>
<h3 id="6-2-14-归并方法"><a href="#6-2-14-归并方法" class="headerlink" title="6.2.14 归并方法"></a>6.2.14 归并方法</h3><p>reduce():从头遍历,构建一个返回值<br>reduceRight():从尾遍历,构建一个返回值</p>
<h2 id="6-3-定型数组"><a href="#6-3-定型数组" class="headerlink" title="6.3 定型数组"></a>6.3 定型数组</h2><h3 id="6-3-1-历史"><a href="#6-3-1-历史" class="headerlink" title="6.3.1 历史"></a>6.3.1 历史</h3><p>WebGL用到，3D技术。<br>定型数组</p>
<h3 id="6-3-2-ArrayBuffer"><a href="#6-3-2-ArrayBuffer" class="headerlink" title="6.3.2 ArrayBuffer"></a>6.3.2 ArrayBuffer</h3><p>构造函数，用于内存中分配特定数量的字节空间。</p>
<h3 id="6-3-3-DataView"><a href="#6-3-3-DataView" class="headerlink" title="6.3.3 DataView"></a>6.3.3 DataView</h3><h3 id="6-3-4-定型数组"><a href="#6-3-4-定型数组" class="headerlink" title="6.3.4 定型数组"></a>6.3.4 定型数组</h3><h2 id="6-4-Map"><a href="#6-4-Map" class="headerlink" title="6.4 Map"></a>6.4 Map</h2><p>一种实现键值存储机制的集合类型。</p>
<h3 id="6-4-1-基本API"><a href="#6-4-1-基本API" class="headerlink" title="6.4.1 基本API"></a>6.4.1 基本API</h3><p>const m2 = new Map([[“key1”,”val1”][“key2”,”val2”][“key3”,”val3”]])<br>m1.size = 3<br>可使用has(),get()进行查询，delete(),clear()删除值。</p>
<h3 id="6-4-2-顺序与迭代"><a href="#6-4-2-顺序与迭代" class="headerlink" title="6.4.2 顺序与迭代"></a>6.4.2 顺序与迭代</h3><p>提供迭代器(Iterator),通过entries()获取<br>可以通过遍历获取。</p>
<h3 id="6-4-3-选择Object还是Map"><a href="#6-4-3-选择Object还是Map" class="headerlink" title="6.4.3 选择Object还是Map"></a>6.4.3 选择Object还是Map</h3><p>1.内存占用<br>Map占用更小<br>2.插入性能<br>Map插入性能更好<br>3.查找速度<br>Object优于Map<br>4.删除性能<br>Map更快，涉及大量删除 Map最佳。</p>
<h2 id="6-5-WeakMap"><a href="#6-5-WeakMap" class="headerlink" title="6.5 WeakMap"></a>6.5 WeakMap</h2><p>类似于Map，只能用对象作为键。<br>API与Map相同。<br>键不存在时，值会被垃圾回收。<br>无法迭代。</p>
<h2 id="6-6-Set"><a href="#6-6-Set" class="headerlink" title="6.6 Set"></a>6.6 Set</h2><h3 id="6-6-1-基本API"><a href="#6-6-1-基本API" class="headerlink" title="6.6.1 基本API"></a>6.6.1 基本API</h3><p>与Map相似，size长度，has()查询，delete()和clear()删除元素。<br>add()添加元素。</p>
<h3 id="6-6-2-顺序与迭代"><a href="#6-6-2-顺序与迭代" class="headerlink" title="6.6.2 顺序与迭代"></a>6.6.2 顺序与迭代</h3><p>可通过values()与keys()获取迭代器<br>可以使用遍历方法迭代。</p>
<h2 id="6-7-WeakSet"><a href="#6-7-WeakSet" class="headerlink" title="6.7 WeakSet"></a>6.7 WeakSet</h2><p>与WeakMap类型</p>
<h2 id="6-8-迭代与扩展操作"><a href="#6-8-迭代与扩展操作" class="headerlink" title="6.8 迭代与扩展操作"></a>6.8 迭代与扩展操作</h2><p>支持for-of循环<br>支持浅拷贝<br>let arr1 = […arr2];</p>
<h2 id="6-9-小结"><a href="#6-9-小结" class="headerlink" title="6.9 小结"></a>6.9 小结</h2><p>JS的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。<br>Object类型是一个基础类型，所有引用类型都继承了它的基本行为。<br>Array是一组有序的值，并提供了操作和转换值的能力。<br>定型数组包含一套不同的引用类型。<br>Date，日期类型。RegExp，正则表达式的接口。<br>ES6新增Map，WeakMap,Set,WeakSet。</p>
<h1 id="7-迭代器与生成器"><a href="#7-迭代器与生成器" class="headerlink" title="7 迭代器与生成器"></a>7 迭代器与生成器</h1><p>迭代即“重复”，“再来”。</p>
<h2 id="7-1-理解迭代"><a href="#7-1-理解迭代" class="headerlink" title="7.1 理解迭代"></a>7.1 理解迭代</h2><p>JS中，计数循环就是一种最简单的迭代：for（）<br>可以指定顺序，次数，在一个有序集合上进行。<br>需知道如何使用数据结构，遍历顺序不是数据结构固有的。</p>
<h2 id="7-2-迭代器模式"><a href="#7-2-迭代器模式" class="headerlink" title="7.2 迭代器模式"></a>7.2 迭代器模式</h2><p>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。<br>迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。</p>
<h3 id="7-2-1-可迭代协议"><a href="#7-2-1-可迭代协议" class="headerlink" title="7.2.1 可迭代协议"></a>7.2.1 可迭代协议</h3><p>实现了Iterable接口的内置类型：<br>1.字符串<br>2.数组<br>3.映射<br>4.集合<br>5.arguments对象<br>6.NodeList等DOM集合类型<br>接受可迭代对象的语言特性包括：<br>let arr = [“foo”,”bar”,”baz”];<br>1.for-of //for(let el of arr){el};<br>2.数组解构 //let [a,b,c] = arr;<br>3.扩展操作符 // let arr2 = […arr];<br>4.Array.from() //let arr3 = Array.from(arr);<br>5.创建集合 //let set = new Set(arr);<br>6.创建映射 //let pairs = arr.map((x,i)=&gt;[x,i]);<br>7.promise.all()<br>8.promise.race()<br>9.yield*操作符</p>
<h3 id="7-2-2-迭代器协议"><a href="#7-2-2-迭代器协议" class="headerlink" title="7.2.2 迭代器协议"></a>7.2.2 迭代器协议</h3><p>let arr = [“a”,”b”];<br>console.log(arr[Symbol.iterator]); //f values(){[native code]};<br>let iter = arr<a href>Symbol.iterator</a>;<br>console.log(iter);// ArrayIterator()<br>iter.next();//{done:false,value:”a”};</p>
<h3 id="7-2-3-自定义迭代器"><a href="#7-2-3-自定义迭代器" class="headerlink" title="7.2.3 自定义迭代器"></a>7.2.3 自定义迭代器</h3><p>自定义迭代方法</p>
<h3 id="7-2-4-提前终止迭代器"><a href="#7-2-4-提前终止迭代器" class="headerlink" title="7.2.4 提前终止迭代器"></a>7.2.4 提前终止迭代器</h3><p>return {done:true};<br>或break</p>
<h2 id="7-3-生成器"><a href="#7-3-生成器" class="headerlink" title="7.3 生成器"></a>7.3 生成器</h2><h3 id="7-3-1-生成器基础"><a href="#7-3-1-生成器基础" class="headerlink" title="7.3.1 生成器基础"></a>7.3.1 生成器基础</h3><h3 id="7-3-2-通过yield中断执行"><a href="#7-3-2-通过yield中断执行" class="headerlink" title="7.3.2 通过yield中断执行"></a>7.3.2 通过yield中断执行</h3><h3 id="7-3-3-生成器作为默认迭代器"><a href="#7-3-3-生成器作为默认迭代器" class="headerlink" title="7.3.3 生成器作为默认迭代器"></a>7.3.3 生成器作为默认迭代器</h3><h3 id="7-3-4-提前终止生成器"><a href="#7-3-4-提前终止生成器" class="headerlink" title="7.3.4 提前终止生成器"></a>7.3.4 提前终止生成器</h3><h2 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h2><p>由任意对象实现的接口，支持连续获取对象产出的每一个值。使用symbol.iterator获取，并且通过一些方法调用，例next(),for-of。</p>
<h1 id="8-对象、类与面向对象编程"><a href="#8-对象、类与面向对象编程" class="headerlink" title="8 对象、类与面向对象编程"></a>8 对象、类与面向对象编程</h1><p>无特定顺序的值。每个属性或方法都用名称标识。</p>
<h2 id="8-1-理解对象"><a href="#8-1-理解对象" class="headerlink" title="8.1 理解对象"></a>8.1 理解对象</h2><h3 id="8-1-1-属性的类型"><a href="#8-1-1-属性的类型" class="headerlink" title="8.1.1 属性的类型"></a>8.1.1 属性的类型</h3><p>数据属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Writable]]:表示属性的值是否可以被修改。<br>[[Value]]:表示属性的值。<br>访问器属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Get]]:获取函数，读取属性调用。<br>[[Set]]:设置函数，写入属性时调用。</p>
<h3 id="8-1-2-定义多个属性"><a href="#8-1-2-定义多个属性" class="headerlink" title="8.1.2 定义多个属性"></a>8.1.2 定义多个属性</h3><p>let book = {};<br>Object.defineProperties(book,{year:{value:2017},edition:{value:1},year:{get(){return this.year;}}});</p>
<h3 id="8-1-3-读取属性的特性"><a href="#8-1-3-读取属性的特性" class="headerlink" title="8.1.3 读取属性的特性"></a>8.1.3 读取属性的特性</h3><p>Object.getOwnPropertyDescriptor(object,’name’);<br>descriptor = Object.getOwnPropertyDescriptor(book,”year”);<br>Object.getOwnPropertyDescriptors(object);//获取所有</p>
<h3 id="8-1-4-合并对象"><a href="#8-1-4-合并对象" class="headerlink" title="8.1.4 合并对象"></a>8.1.4 合并对象</h3><p>Object.assgin();//浅拷贝,会覆盖重复的属性<br>result = Object.assign(object1,object2);<br>object === result<br>result = Object.assign(object1,object2,object3);</p>
<h3 id="8-1-5-对象标识及相等判定"><a href="#8-1-5-对象标识及相等判定" class="headerlink" title="8.1.5 对象标识及相等判定"></a>8.1.5 对象标识及相等判定</h3><p>Object.is()//需要两个参数<br>Object.is(+0,-0)//false</p>
<h3 id="8-1-6-增强的对象语法"><a href="#8-1-6-增强的对象语法" class="headerlink" title="8.1.6 增强的对象语法"></a>8.1.6 增强的对象语法</h3><p>let person = {name:name};  === let person = {name};//不建议<br>namekey = “name”;let person = {[namekey]:’Matt’};//[]内可以使用表达式，属性可计算<br>let person = {<a href="name">nameKey</a>{console.log(‘name’)}};//方法名兼容计算属性</p>
<h3 id="8-1-7-对象解构"><a href="#8-1-7-对象解构" class="headerlink" title="8.1.7 对象解构"></a>8.1.7 对象解构</h3><p>let person = {name:’matt’,age:27}//不解构<br>let personName = person.name,personAge = person.age;//解构<br>let {name:personName,age:personAge} = person;<br>null和undefined不支持解构</p>
<p>let person = {job:{title:’Software engineer’}};//嵌套解构<br>let personCopy={};<br>let({job:personCopy.job}=person);</p>
<p>前面的解构出错，后面的解构会失败。</p>
<p>let person = {name:’matt’,age:27}; function printPerson(foo,{name,age},bar)//参数解构，调用时传入对象</p>
<h2 id="8-2-创建对象"><a href="#8-2-创建对象" class="headerlink" title="8.2 创建对象"></a>8.2 创建对象</h2><h3 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1 概述"></a>8.2.1 概述</h3><p>与类不同，对象的巧妙运行可以实现与类相同的行为。</p>
<h3 id="8-2-2-工厂模式"><a href="#8-2-2-工厂模式" class="headerlink" title="8.2.2 工厂模式"></a>8.2.2 工厂模式</h3><p>设计模式之一<br>function createPerson(name,age,job){<br>   let o = new Object();<br>   o.name = name;<br>   o.age = age;<br>   o.job = job;<br>   o.sayName = function(){<br>       console.log(this.name);<br>   };<br>   return o;<br>}<br>解决创建多个类似对象的问题，但无解决对象标识问题（对象类型）。</p>
<h3 id="8-2-3-构造函数模式"><a href="#8-2-3-构造函数模式" class="headerlink" title="8.2.3 构造函数模式"></a>8.2.3 构造函数模式</h3><p>function Person(name,age,job){<br>   this.name = name;<br>   this.age = age;<br>   this.job = job;<br>   this.sayName = function(){<br>      console.log(this.name);<br>   }<br>}<br>与工厂模式类似,无return，无显式创建对象。<br>构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可。<br>let person = function(){};<br>let person1 = new person(…);<br>let person2 = new person(…);<br>person1 instanceof Object//true<br>person1 instanceof person//true<br>person2一样<br>构造函数也可以直接调用<br>person(…);window.sayName();//添加到了window<br>let o = new Object();<br>Person.call(o,”wxc”,25);o.sayName()//wxc 在另一个对象的作用域中调用<br>在构造函数内定义的函数实例化后相同名称确不相等，是两个不同的函数。<br>可以在外部定义函数，在内部赋值解决这个问题。</p>
<h3 id="8-2-4-原型模式"><a href="#8-2-4-原型模式" class="headerlink" title="8.2.4 原型模式"></a>8.2.4 原型模式</h3><p>prototype,这个属性为一个对象。包含由特定引用类型的实例共享的属性和方法。实际上是构造函数创建的原型。<br>在原型上定义的值可以共享。<br>Chrome暴露了<em>proto_属性，可通过这个属性访问对象的原型。prototype属性为对象。<br>原型链会终止与Object的原型链。<br>person.prototype._proto</em>.<em>proto</em> === null//true<br>构造函数、原型对象和实例，三个完全不同的对象。<br>实例通过_proto_链接到原型对象，实际指向[[Prototype]]<br>构造函数通过prototype属性链接到原型对象。<br>同一个构造函数创建的两个实例，共享一个原型对象。<br>isPrototypeOf()//用于判断实例原型对象与构造函数的原型相同否<br>getPrototypeOf()//用于获取[[prototype]]原型对象<br>setPrototypeOf()//用于给[[prototype]]对象写入新值,该方法调用可能会严重导致性能下降。<br>create()//用于创建新对象指定原型<br>访问对象属性时，如果未在对象实例本身找到则会沿着指针进入原型对象，在原型对象上查找。无法通过实例重写这些值，如果创建于原型对象中同名的属性，会在实例上创建这个属性，遮蔽原型对象上的属性，只有delete后才能继续搜索原型对象的该属性。<br>hasOwnProperty()//用于判断属性在实例或原型上<br>可以通过for-in判断通过对象能否访问到一个属性//“name” in person(true)<br>getOwnPropertyNames()//…按顺序进行枚举</p>
<h3 id="8-2-5-对象迭代"><a href="#8-2-5-对象迭代" class="headerlink" title="8.2.5 对象迭代"></a>8.2.5 对象迭代</h3><p>Object.values()//以数组的形式输出值<br>Object.entries()//以数组的形式输出键值和值<br>非字符串的属性会被转换为字符串输出，符号属性会被忽略。<br>重写了prototype的函数原型不默认指向constructor<br>ES语法需要使用defineProperty()来恢复constructor属性。<br>实例只有指向原型的指针，没有指向构造函数的指针。</p>
<h2 id="8-3-继承"><a href="#8-3-继承" class="headerlink" title="8.3 继承"></a>8.3 继承</h2><p>ES中只支持实现继承。</p>
<h3 id="8-3-1-原型链"><a href="#8-3-1-原型链" class="headerlink" title="8.3.1 原型链"></a>8.3.1 原型链</h3><p>通过原型继承多个引用类型的属性和方法。原型链为ES主要继承方式。<br>将A函数原型赋值为B函数的实例，A函数的实例可以通过原型访问到B函数实例的属性和方法。实际A函数可以通过原型与B函数的原型挂钩。在搜索属性时，会通过原型链访问到原型的原型，直到末端。<br>所有引用类型都继承自Object，任何函数的默认原型都是一个Object的实例，也是为什么自定义类型能够继承toString(),valueOf()方法的原因。调用toString()时，实际在调用Object.prototype上的方法。<br>通过instanceof返回原型与构造函数的原型关系。<br>通过isPrototypeOf返回原型链中是否含有这个原型。<br>添加属性或覆盖属性时需要在原型赋值后添加到原型上。<br>通过prototype字面量直接修改原型，会破坏之前的原型链。<br>原型链的问题：<br>1.使用原型实现继承后，函数原型对象的所有属性都会被函数实例共享。<br>2.子类型在实例化时不能给父类型的构造函数传参。</p>
<h3 id="8-3-2-盗用构造函数"><a href="#8-3-2-盗用构造函数" class="headerlink" title="8.3.2 盗用构造函数"></a>8.3.2 盗用构造函数</h3><p>通过call，apply来调用执行函数的构造函数，从而得到构造函数的属性和方法。<br>可以通过apply,call来向父类构造函数传值。<br>缺点：必须在构造函数中定义方法，函数无法重用。且子类无法访问父类原型的方法。（原型不是父类的实例对象）</p>
<h3 id="8-3-3-组合继承"><a href="#8-3-3-组合继承" class="headerlink" title="8.3.3 组合继承"></a>8.3.3 组合继承</h3><p>综合原型链和盗用构造函数，集中了优点。<br>利用call实现传值改变继承的值，并且属性不共用。</p>
<h3 id="8-3-4-原型式继承"><a href="#8-3-4-原型式继承" class="headerlink" title="8.3.4 原型式继承"></a>8.3.4 原型式继承</h3><p>实例一个对象作原型，使用Object.create()。</p>
<h3 id="8-3-5-寄生式继承"><a href="#8-3-5-寄生式继承" class="headerlink" title="8.3.5 寄生式继承"></a>8.3.5 寄生式继承</h3><p>创建一个对象，给对象添加属性和值，返回这个对象。</p>
<h3 id="8-3-6-寄生式组合继承"><a href="#8-3-6-寄生式组合继承" class="headerlink" title="8.3.6 寄生式组合继承"></a>8.3.6 寄生式组合继承</h3><p>会调用两次构造函数。</p>
<h2 id="8-4-类"><a href="#8-4-类" class="headerlink" title="8.4 类"></a>8.4 类</h2><h3 id="8-4-1-类定义"><a href="#8-4-1-类定义" class="headerlink" title="8.4.1 类定义"></a>8.4.1 类定义</h3><p>class Person{} // 类声明<br>class Animal = class {} // 类表达式<br>类定义无法声明提升，类受块作用域限制。<br>class Foo{<br>constructor(){} //构造函数<br>get myBaz(){} //有获取函数<br>static myQue(){} // 有静态方法<br>}<br>外部无法访问类名(标识符)</p>
<h3 id="8-4-2-类构造函数"><a href="#8-4-2-类构造函数" class="headerlink" title="8.4.2 类构造函数"></a>8.4.2 类构造函数</h3><p>new实例化步骤：<br>1.在内存中创建一个新对象<br>2.这个对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性<br>3.构造函数内部的this被赋值为这个新对象<br>4.执行构造函数内部的代码<br>5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象<br>调用类构造函数一定需要带new，可以类当成特殊函数。<br>类有prototype属性，typeof判断为function，原型也有一个constructor指向自身，也可以用instanceof检查是否存在于实例的原型链中。<br>但是类构造函数无法当做普通构造函数来使用。</p>
<h3 id="8-4-3-实例-原型和类成员"><a href="#8-4-3-实例-原型和类成员" class="headerlink" title="8.4.3 实例-原型和类成员"></a>8.4.3 实例-原型和类成员</h3><p>每个实例都对应唯一的成员对象，所有成员都不会在原型上共享。<br>类块中定义的方法作为原型方法，可以再实例间共享方法。<br>类也支持访问器，可以访问和获取类的属性。<br>静态类方法非常适合作为实例工厂。<br>类里支持定义迭代器和生成器方法。</p>
<h3 id="8-4-4-继承"><a href="#8-4-4-继承" class="headerlink" title="8.4.4 继承"></a>8.4.4 继承</h3><p>ES6中类支持单继承，使用extends继承构造函数(在原型链中)和原型。<br>子类可以通过super访问原型，super只能在子类中使用。仅限于构造函数，实例方法和静态方法内部。<br>类构造函数和静态方法添加了内部特性[[HomeObject]]，为一个指针，指向定义该方法的原型。<br>在类构造函数中，不能在调用super之前引用this。<br>在子类中定义了构造函数，则必须调用super或返回一个对象。<br>有一种类为抽象基类，可以被继承，但自身无法实例化。<br>P262</p>
<h1 id="9-代理与反射"><a href="#9-代理与反射" class="headerlink" title="9. 代理与反射"></a>9. 代理与反射</h1><h2 id="9-1-代理基础"><a href="#9-1-代理基础" class="headerlink" title="9.1 代理基础"></a>9.1 代理基础</h2><h3 id="9-1-1-创建空代理"><a href="#9-1-1-创建空代理" class="headerlink" title="9.1.1 创建空代理"></a>9.1.1 创建空代理</h3><p>使用Proxy构造函数创建代理。该函数接收两个参数：目标对象和处理程序对象。<br>代理对象与目标对象访问相同属性，赋值，但无原型。<br>可用===来区别代理和目标。</p>
<h3 id="9-1-2-定义捕获器"><a href="#9-1-2-定义捕获器" class="headerlink" title="9.1.2 定义捕获器"></a>9.1.2 定义捕获器</h3><p>使用代理的主要目的是可以定义捕获器。捕获器类似异步交互，在通过代理对象执行操作时，会触发捕获器(函数)的程序，捕获器会拦截方法。</p>
<h3 id="9-1-3-捕获器参数和反射API"><a href="#9-1-3-捕获器参数和反射API" class="headerlink" title="9.1.3 捕获器参数和反射API"></a>9.1.3 捕获器参数和反射API</h3><p>每个捕获器都有三个参数分别为目标对象，查询属性，代理对象。<br>可以捕获的方法都有对应的反射API(Reflect)，可以通过Reflect反射到目标对象上，通过该API访问目标对象的属性或函数。</p>
<h3 id="9-1-4-捕获器不变式"><a href="#9-1-4-捕获器不变式" class="headerlink" title="9.1.4 捕获器不变式"></a>9.1.4 捕获器不变式</h3><h3 id="9-1-5-可撤销代理"><a href="#9-1-5-可撤销代理" class="headerlink" title="9.1.5 可撤销代理"></a>9.1.5 可撤销代理</h3><h3 id="9-1-6-使用反射API"><a href="#9-1-6-使用反射API" class="headerlink" title="9.1.6 使用反射API"></a>9.1.6 使用反射API</h3><h3 id="9-1-7-代理另一个代理"><a href="#9-1-7-代理另一个代理" class="headerlink" title="9.1.7 代理另一个代理"></a>9.1.7 代理另一个代理</h3><h3 id="9-1-8-代理的问题与不足"><a href="#9-1-8-代理的问题与不足" class="headerlink" title="9.1.8 代理的问题与不足"></a>9.1.8 代理的问题与不足</h3><h2 id="9-2-代理捕获器与反射方法"><a href="#9-2-代理捕获器与反射方法" class="headerlink" title="9.2 代理捕获器与反射方法"></a>9.2 代理捕获器与反射方法</h2><h2 id="9-3-代理模式"><a href="#9-3-代理模式" class="headerlink" title="9.3 代理模式"></a>9.3 代理模式</h2><h2 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h2><h1 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h1><p>把函数名想象成指针，指向函数对象的指针。</p>
<h2 id="10-1-箭头函数"><a href="#10-1-箭头函数" class="headerlink" title="10.1 箭头函数"></a>10.1 箭头函数</h2><p>没有参数或多个参数需要括号，一个参数可以不用括号。<br>无大括号，函数只能有一行代码，并且会隐式返回这行代码的值。<br>箭头函数不能使用argument、super、new.target，也不能作构造函数，且没有原型。</p>
<h2 id="10-2-函数名"><a href="#10-2-函数名" class="headerlink" title="10.2 函数名"></a>10.2 函数名</h2><p>由于函数名是指针，所以一个函数可能有多个名称。<br>函数没有名称的话，他的名称为空字符串。<br>如果是获取函数，设置函数，或使用bind()实例化，那么名称前会加前缀。</p>
<h2 id="10-3-理解参数"><a href="#10-3-理解参数" class="headerlink" title="10.3 理解参数"></a>10.3 理解参数</h2><p>参数内部表现为一个数组，可以再函数内部访问arguments对象，获取参数值。<br>arguments是一个类数组对象，但不是Array的实例。<br>arguments可以跟命名参数一起用，如果改了有传值的参数对应的arguments，也会更改对应的命名参数。<br>箭头函数可以包装在普通函数中，提供arguments。</p>
<h2 id="10-4-没有重载"><a href="#10-4-没有重载" class="headerlink" title="10.4 没有重载"></a>10.4 没有重载</h2><p>同名函数，后面会覆盖前面的。</p>
<h2 id="10-5-默认参数值"><a href="#10-5-默认参数值" class="headerlink" title="10.5 默认参数值"></a>10.5 默认参数值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func name(name &#x3D; &#39;Henry&#39;,numerals&#x3D; name)&#123;return &#96;$&#123;name&#125;&#96;&#125;;</span><br></pre></td></tr></table></figure>
<p>//如上写不传第一个参数会报错</p>
<h2 id="10-6-参数扩展与收集"><a href="#10-6-参数扩展与收集" class="headerlink" title="10.6 参数扩展与收集"></a>10.6 参数扩展与收集</h2><p>扩展运算符可以用于参数内，且扩展的参数数组不能放第一位。<br>使用扩展运算符不影响arguments对象。</p>
<h2 id="10-7-函数声明与函数表达式"><a href="#10-7-函数声明与函数表达式" class="headerlink" title="10.7 函数声明与函数表达式"></a>10.7 函数声明与函数表达式</h2><p>函数声明会有函数提升，函数表达式不会提升。</p>
<h2 id="10-8-把函数作为值"><a href="#10-8-把函数作为值" class="headerlink" title="10.8 把函数作为值"></a>10.8 把函数作为值</h2><p>可以用做参数传入回调。<br>callSomeFunction(func,arguments)//默认调用func，arguments为调用的参数</p>
<h2 id="10-9-函数内部"><a href="#10-9-函数内部" class="headerlink" title="10.9 函数内部"></a>10.9 函数内部</h2><p>arguments有一个callee属性，指向arguments对象所在函数的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">if(num &lt;&#x3D; 1)&#123;</span><br><span class="line">    return 1</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">    return num*arguments.callee(num-1) &#x2F;&#x2F;函数阶乘</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在标准函数中，this为调用该函数的上下文对象。<br>在箭头函数中，this为定义箭头函数的上下文。<br>caller为调用当前函数的函数。<br>new.target在当函数被当做构造函数调用时，它指向被调用的构造函数。</p>
<h2 id="10-10-函数属性与方法"><a href="#10-10-函数属性与方法" class="headerlink" title="10.10 函数属性与方法"></a>10.10 函数属性与方法</h2><p>length为函数命名参数的个数，prototype为原型。<br>toString，valueOf，apply，call都在prototype里。</p>
<h2 id="10-11-函数表达式"><a href="#10-11-函数表达式" class="headerlink" title="10.11 函数表达式"></a>10.11 函数表达式</h2><p>函数声明可以提升，表达式可以用于判断声明。</p>
<h2 id="10-12-递归"><a href="#10-12-递归" class="headerlink" title="10.12 递归"></a>10.12 递归</h2><p>一个函数通过名称调用自己</p>
<h2 id="10-13-尾调用优化"><a href="#10-13-尾调用优化" class="headerlink" title="10.13 尾调用优化"></a>10.13 尾调用优化</h2><p>func1(){return func2};嵌套函数下的栈优化。<br>在递归下优化较为明显。</p>
<h2 id="10-14-闭包"><a href="#10-14-闭包" class="headerlink" title="10.14 闭包"></a>10.14 闭包</h2><p>引用了另一个函数作用域中变量的函数为闭包。通常在嵌套函数中。<br>闭包引用的活动对象会保存在内存中，知道函数销毁后才会被销毁。<br>引用闭包要注意内存泄漏。<br>内部函数无法直接访问this和arguments，可以将this赋值给that，保存到闭包中，用that访问。<br>每次函数的调用都会自动创建两个特殊变量，this和arguments。</p>
<h2 id="10-15-立即调用的函数表达式"><a href="#10-15-立即调用的函数表达式" class="headerlink" title="10.15 立即调用的函数表达式"></a>10.15 立即调用的函数表达式</h2><p>IIFE，立即调用的函数表达式，表达式内部相当于一个块级作用域。<br>可以用来锁定参数值。</p>
<h2 id="10-16-私有变量"><a href="#10-16-私有变量" class="headerlink" title="10.16 私有变量"></a>10.16 私有变量</h2><p>定义在函数或块中的变量，都可以认为是私有的。<br>通过闭包可以访问函数中的私有变量。称为特权方法(共有方法)。<br>特权方法可以再构造函数中实现(该方法为闭包)。或者在方法中定义函数，访问私有变量，形成闭包。使用构造函数模式的缺点是每个实例都会重新创建一遍新方法。<br>模块模式：单例对象需初始化，并且需要访问私有变量。<br>或者将能访问内部私有对象和方法赋值给一个对象，然后返回这个对象。</p>
<h2 id="10-17-小结"><a href="#10-17-小结" class="headerlink" title="10.17 小结"></a>10.17 小结</h2><ul>
<li>立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，其包含的所有变量都会被销毁。</li>
<li>可以通过闭包访问位于包含作用域中定义的变量</li>
<li>闭包作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象<h1 id="11-期约与异步函数"><a href="#11-期约与异步函数" class="headerlink" title="11. 期约与异步函数"></a>11. 期约与异步函数</h1><h2 id="11-1-异步编程"><a href="#11-1-异步编程" class="headerlink" title="11.1 异步编程"></a>11.1 异步编程</h2><h3 id="11-1-1-同步与异步"><a href="#11-1-1-同步与异步" class="headerlink" title="11.1.1 同步与异步"></a>11.1.1 同步与异步</h3>同步对应内存中顺序执行的处理器指令。<br>异步类似系统中断，当前进程外部的实体可以触发代码执行。在进程等待长时间操作的时候进行其他程序的执行。<h3 id="11-1-2-以往的异步编程"><a href="#11-1-2-以往的异步编程" class="headerlink" title="11.1.2 以往的异步编程"></a>11.1.2 以往的异步编程</h3>回调嵌套<br>给异步操作提供回调函数(包括失败回调和成功回调)<br>嵌套异步回调，反值依赖另一个异步返回值，情况复杂。<h2 id="11-2-期约"><a href="#11-2-期约" class="headerlink" title="11.2 期约"></a>11.2 期约</h2><h3 id="11-2-1-Promises-A-规范"><a href="#11-2-1-Promises-A-规范" class="headerlink" title="11.2.1 Promises/A+规范"></a>11.2.1 Promises/A+规范</h3>ES6版本的Promise规范<h3 id="11-2-2-期约基础"><a href="#11-2-2-期约基础" class="headerlink" title="11.2.2 期约基础"></a>11.2.2 期约基础</h3>用new初始化，创建时传入执行器函数作为参数。<br>期约有三种状态：</li>
<li>待定(pending)</li>
<li>兑现(fulfilled,resolved)</li>
<li>拒绝(rejected)<br>待定为最初状态，变成兑现和拒绝后都不可逆。期约的状态是私有的，无法通过JS检测到。<br>只要状态从待定切换，总会有一个私有的内部值。兑现则为值，拒绝则为理由。默认为undefined，达到落定状态都会收到该值。<br>期约通过resolve()和reject()转换状态，reject()会抛出错误。<br>避免期约卡在待定状态，可以添加一个定时退出功能。如setTimeout设置回调。<br>Promise.resolve()可以实例化一个解决的期约。也可以把任何值都转换为一个期约。只转换传入的第一个参数，其他会被忽略。且这个函数会保留传入的期约的状态。<br>Promise.reject()可以实例化一个拒绝的期约并抛出一个异步错误(这个错误无法用try/catch获取，只能通过拒绝处理程序捕获)。reject与resolve不同，如果给他传一个期约对象，这个期约会成为它拒绝的理由。<br>与期约交互只能使用异步结构(期约的方法)。<h3 id="11-2-3-期约的实例方法"><a href="#11-2-3-期约的实例方法" class="headerlink" title="11.2.3 期约的实例方法"></a>11.2.3 期约的实例方法</h3>ES的异步结构中，任何对象都有一个then()方法，实现了Thenable接口。</li>
<li>Promise.prototype.then()，<br>最多接收两个参数，onResolved，onRejected两个处理程序，并且传给then的非函数类型的参数会被忽略。<br>Promise.prototype.then返回一个新的期约实例，所以传入时onResolve/Reject时如果不需要，得传null，避免创建多余的对象。<br>onResolve：如果没有显示的返回语句，then会默认返回undefined。如果有显示的返回值，则Promise.resolve会包装这个值。抛出异常会返回拒绝的期约。<br>onReject：也会用Promise.resolve包装，与onResolve一样。</li>
<li>Promise.prototype.catch()<br>用于给期约添加拒绝处理程序，只接收一个参数：onRejected处理程序。相当于调用Promise.prototype.then(null,onRejected)</li>
<li>Promise.prototype/finally()<br>用于给期约添加onFinally处理程序，这个处理程序在状态改变时都会执行，可以避免onResolve/Reject出现冗余代码。但没办法知道状态，主要用于添加清理代码。这个方法返回一个新的实例期约，但这个期约为父期约的传递(父期约的状态与值)，如果传入一个期约，保留传入的期约。<br>Promise.then()会在同步代码后执行。为非重入方法，都是异步执行。<br>处理程序的执行顺序按添加他们的顺序。<br>拒绝与错误处理都会返回一个错误对象。且有一个副作用，异步抛出错误，并不会阻塞同步程序。错误只能通过onRejected获取。<h3 id="11-2-4-期约连锁与期约合成"><a href="#11-2-4-期约连锁与期约合成" class="headerlink" title="11.2.4 期约连锁与期约合成"></a>11.2.4 期约连锁与期约合成</h3>连串处理程序为期约连锁。<br>可以定义一个函数返回期约然后在then中调用。可以将异步串行化。<br>Promise.all()和Promise.race()可以将期约实例组合成一个期约的静态方法。</li>
<li>Promise.all()<br>该方法会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约。必须要传参，如果有一个拒绝，则合成的期约拒绝。如果有一个期约待定，那么合成的期约也会待定。一次拒绝会直接导致最终期约拒绝。拒绝理由为第一次拒绝的期约的理由。但其他拒绝也会处理。</li>
<li>Promise.race()<br>该方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。接收一个可迭代对象，也返回一个新期约。其余与all()相同。<h3 id="11-2-5-期约扩展"><a href="#11-2-5-期约扩展" class="headerlink" title="11.2.5 期约扩展"></a>11.2.5 期约扩展</h3>可以运用一个类添加方法取消期约。<br>扩展Promise类，添加notify()方法提醒进度。<h2 id="11-3-异步函数"><a href="#11-3-异步函数" class="headerlink" title="11.3 异步函数"></a>11.3 异步函数</h2>async/await(ES8)<h2 id="11-3-1-异步函数"><a href="#11-3-1-异步函数" class="headerlink" title="11.3.1 异步函数"></a>11.3.1 异步函数</h2></li>
<li>async<br>async用于声明异步函数，可以用在函数声明、函数表达式、箭头函数和方法上。如果异步函数使用return返回了值，则会被Promise.resolve()包装成一个期约对象。<br>如果异步函数中抛出错误会返回错误的期约，但期约不会被异步函数捕获。</li>
<li>await<br>await用于暂停异步函数代码的执行，如果等待一个值，那么该值为已经解决的期约。等待错误，会返回拒绝的期约。await必须在异步函数中使用。<h3 id="11-3-2-停止和恢复执行"><a href="#11-3-2-停止和恢复执行" class="headerlink" title="11.3.2 停止和恢复执行"></a>11.3.2 停止和恢复执行</h3>只要使用await则会触发异步求值，如果后面是一个期约，则比直接可用的值排后。<h3 id="11-3-3-异步函数策略"><a href="#11-3-3-异步函数策略" class="headerlink" title="11.3.3 异步函数策略"></a>11.3.3 异步函数策略</h3>可以使用异步函数实现sleep<br>async function sleep(delay){return new Promise((resolve) =&gt; setTimeout(resolve,delay));}<br>await sleep(1500)<br>平行执行，一起初始化，然后依次执行。<br>使用await实现串行执行期约。<br>await相对setTimeout有一定的性能提升<h2 id="11-4-小结"><a href="#11-4-小结" class="headerlink" title="11.4 小结"></a>11.4 小结</h2>期约与异步函数都是非常重要的工具。<br>期约可以被序列化、连锁使用、符合、扩展和重组。<br>P357<h1 id="24-网络请求与远程资源"><a href="#24-网络请求与远程资源" class="headerlink" title="24. 网络请求与远程资源"></a>24. 网络请求与远程资源</h1><h2 id="24-1-XMLHttpRequest对象"><a href="#24-1-XMLHttpRequest对象" class="headerlink" title="24.1 XMLHttpRequest对象"></a>24.1 XMLHttpRequest对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<h3 id="24-1-1-使用XHR"><a href="#24-1-1-使用XHR" class="headerlink" title="24.1.1 使用XHR"></a>24.1.1 使用XHR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&#39;get&#39;);&#x2F;&#x2F;还有post等，做好请求的准备，跨域会报错</span><br><span class="line">xhr.send(null);&#x2F;&#x2F;接受一个参数，为发送的数据，如果不需则传null，不然报错</span><br></pre></td></tr></table></figure></li>
<li>responseText:响应体返回的文本</li>
<li>responseXML:响应数据的XML DOM文档</li>
<li>status:响应的HTTP状态</li>
<li>statusText:状态描述</li>
<li>readyState:当前请求/响应过程的进行阶段</li>
</ul>
<ol>
<li>0:未初始化(Uninitialized),未调用open()</li>
<li>1:已打开(Open),已调用open(),未调用send()</li>
<li>2:已发送(Sent),已调用send(),尚未响应</li>
<li>3:接收中(Reveiving),已经部分响应</li>
<li>4:完成(Complete),所有响应，可以使用<br>取消请求可以用abort()方法<br>由于内存问题不推荐用XHR<h3 id="24-1-2-HTTP头部"><a href="#24-1-2-HTTP头部" class="headerlink" title="24.1.2 HTTP头部"></a>24.1.2 HTTP头部</h3></li>
</ol>
<ul>
<li>Accept：浏览器可以处理的内容类型</li>
<li>Accept-Charset：浏览器可以显示的字符集</li>
<li>Accept-Encoding：浏览器可以处理的压缩编码类型</li>
<li>Accept-Language：浏览器使用的语言</li>
<li>Connection：浏览器与服务器的连接类型</li>
<li>Cookie：页面中设置的Cookie</li>
<li>Host：发送请求的页面所在的域</li>
<li>Referer：发送请求的页面的URI</li>
<li>User-Agent：浏览器的用户代理字符串<br>也可以使用setRequestHeader()方法，传头部字段名称和值，在open之后，send之前调用，可以添加头部内容<br>可以使用getResponseHeader()或getAllResponseHeaders()获取头部<h3 id="24-1-3-GET请求"><a href="#24-1-3-GET请求" class="headerlink" title="24.1.3 GET请求"></a>24.1.3 GET请求</h3>需要在Get请求的URL后面添加查询字符串参数。查询字符串必须正确编码后添加到URL后面，再传给open()方法。<br>所有名/值对必须以和号(&amp;)分隔。//？name=value1&amp;name2=value2<h3 id="24-1-4-POST请求"><a href="#24-1-4-POST请求" class="headerlink" title="24.1.4 POST请求"></a>24.1.4 POST请求</h3>post请求可以包含非常多的数据，应该在请求体中携带提交的数据。<h3 id="24-1-5-XMLHttpRequest-Level-2"><a href="#24-1-5-XMLHttpRequest-Level-2" class="headerlink" title="24.1.5 XMLHttpRequest Level 2"></a>24.1.5 XMLHttpRequest Level 2</h3>新增了FormData类型，便于表单序列化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let data &#x3D; new FormData();</span><br><span class="line">data.append(&quot;name&quot;,&quot;Nicholas&quot;);</span><br><span class="line">let form &#x3D; doucment.getElementbById(&quot;user-info&quot;);</span><br><span class="line">new FormData(form);</span><br></pre></td></tr></table></figure>
timeout属性用于表示等待时间，可以设置，响应不成就中断请求。<br>可以调用ontimeout函数处理程序。<br>overrideMimeType()用于重写XHR响应的MIME类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.overrideMimeType(&quot;text&#x2F;xml&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="24-2-进度事件"><a href="#24-2-进度事件" class="headerlink" title="24.2 进度事件"></a>24.2 进度事件</h2></li>
<li>loadstart：接收到响应的第一个字节时触发</li>
<li>progress：接收响应期间反复触发<br>Mozilla在XHR对象上另一个创新是progress事件，接收三个参数：lengthComputable，position，totalSize。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress &#x3D; function(event)&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li>error：请求出错时触发</li>
<li>abort：调用abort()终止连接时触发</li>
<li>load：在成功接收完响应时触发<br>Firefox，Opera，Chrome，Safari都支持load事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload &#x3D; function()&#123;   &#x2F;&#x2F;需要判断XHR状态</span><br><span class="line">   if((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || (xhr.status &#x3D;&#x3D; 304))&#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>loadend：通信完成后，在error,abort,load后触发<h2 id="24-3-跨源资源共享"><a href="#24-3-跨源资源共享" class="headerlink" title="24.3 跨源资源共享"></a>24.3 跨源资源共享</h2>其实就是跨域，CORS：使用自定义的HTTP头部允许浏览器和服务器互相了解，以确实请求或响应成功还是失败。<br>一般会有额外的头部叫origin，包含发送请求页面的源(协议，域名和端口)，以便服务器确定是否为其提供响应。<br>头部Access-Control-Allow-Origin包含相同的源或公开资源(*)。表明会响应请求的源。<br>浏览器可以通过XHR的open传入一个绝对URL来触发CORS，运行访问status和statusText属性，但不能使用setRequestHeader自定义头部，不能发送和接收cookie，getAllResponseHeaders方法返回空字符串。<h3 id="24-3-1-预检请求"><a href="#24-3-1-预检请求" class="headerlink" title="24.3.1 预检请求"></a>24.3.1 预检请求</h3>CORS通过预检请求验证，是否自定义头部，发送除getpost之外的方法。该请求使用OPTIONS方法发送并包含以下头部：</li>
<li>Origin：与简单请求相同</li>
<li>Access-Control-Request-Method：请求希望使用的方法</li>
<li>Access-Control-Request-Headers：自定义头部列表</li>
<li>Access-Control-Max-Age：缓存预检请求的秒数<h3 id="24-3-2-凭据请求"><a href="#24-3-2-凭据请求" class="headerlink" title="24.3.2 凭据请求"></a>24.3.2 凭据请求</h3>默认下跨源请求不提供凭据(cookie、HTTP认证和客户端SSL证书)。可以通过将withCredentials属性设置为true来表明请求会发送凭据。允许则头部包含：Access-Control-Allow-Credentials：true<h2 id="24-4-替代性跨源技术"><a href="#24-4-替代性跨源技术" class="headerlink" title="24.4 替代性跨源技术"></a>24.4 替代性跨源技术</h2><h3 id="24-4-1-图片探测"><a href="#24-4-1-图片探测" class="headerlink" title="24.4.1 图片探测"></a>24.4.1 图片探测</h3>用img标签跨域加载图片不受限制的方式，设置src后通过进度事件获取响应数据并执行程序。只能发送Get，无法获取服务器响应的内容。<br>信标(Beacon)也是该方式发送，利用标签发送数据，无需响应。<h3 id="24-4-2-JSONP"><a href="#24-4-2-JSONP" class="headerlink" title="24.4.2 JSONP"></a>24.4.2 JSONP</h3>与img相似，动态创建script元素并未src属性指定跨域URL实现的，响应后指定回调函数执行程序。<br>安全性低，不好确定请求状态。<h2 id="24-5-Fetch-API"><a href="#24-5-Fetch-API" class="headerlink" title="24.5 Fetch API"></a>24.5 Fetch API</h2>Fetch是请求的优秀工具，可以应用在服务线程中，提供拦截，重定向和修改通过fetch()生成的请求接口。<h3 id="24-5-1-基本用法"><a href="#24-5-1-基本用法" class="headerlink" title="24.5.1 基本用法"></a>24.5.1 基本用法</h3>fetch只有一个必须的参数，’URL’。返回一个Promise。<br>P723</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/18/javaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarylWxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Aren.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarylWXC的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/18/javaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">javaScript设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-18T17:40:57+08:00">
                2020-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  147 words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开放封闭原则:<br>对稳定的东西进行封装，将可能会变动的东西分离出来，增加功能或者改动的时候增加代码即可，无需改动代码。<br>1.放置挂钩<br>hook（待研究）<br>2.使用回调函数<br>把回调函数当做参数传入一个稳定和封闭的函数中，当回调函数被执行的时候，程序会因为回调函数的内部逻辑不同，而产生不同的结果。<br>ajax异步请求是不变的，获取数据后的下一步可能变化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Aren.jpg"
                alt="DarylWxc" />
            
              <p class="site-author-name" itemprop="name">DarylWxc</p>
              <p class="site-description motion-element" itemprop="description">每日提升一点点</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives/%7C%7Carchive">
                <a href="/archives">
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=485347116&auto=1&height=66"></iframe>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wxc" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1498368314@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-qq"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                CSDN博客链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/weixin_43898759" title="CSDN主页" target="_blank">CSDN主页</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DarylWxc</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Wxc</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">L·O·V·E</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="true"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


<script type="text/javascript" 
color="0,0,0" opacity='1' zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
