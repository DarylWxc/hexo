{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-Aren.ico","path":"images/favicon-16x16-Aren.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/Aren.jpg","path":"images/Aren.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590112104000},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1588751732000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1588751732000},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1588751732000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1588751732000},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1588751732000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1588751732000},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1588751732000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1588751732000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1588751732000},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1588751732000},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1588751732000},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1588751732000},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1588751732000},{"_id":"themes/next/_config.yml","hash":"161413032e1bf0562f666d05425bdb38f7e5a75a","modified":1590116529000},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1588751732000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1588751732000},{"_id":"source/about/index.md","hash":"056da652ac94798edf870cd4e9bf90606bdf1e45","modified":1594188381000},{"_id":"source/_posts/Axure原型设计.md","hash":"f560169f03bf16f57d2397522d86e7e260b98198","modified":1595837111000},{"_id":"source/_posts/CSS样式.md","hash":"9f248010711b31991a51a8ab70021b0b25d401a0","modified":1605162780000},{"_id":"source/_posts/ES6语法知识点.md","hash":"374d675a4767da2341c1c6f492bf4f4ae499ed4a","modified":1596013122000},{"_id":"source/_posts/Flex布局.md","hash":"cf5412972a3362bce1be7f77223e4ffff8f31f0a","modified":1597304492000},{"_id":"source/_posts/Git和SVN的使用.md","hash":"5932583100114247597ed802dbf08caa3307f2de","modified":1611039092000},{"_id":"source/_posts/JavaScript高级程序设计.md","hash":"4d4fc8773b23ec11c0aeb0ed327f95ef0d255b2e","modified":1617272270915},{"_id":"source/_posts/MyWorkingDiary.md","hash":"c203b1a0d675e2b27aa3f092f6186ba02712e7de","modified":1602817010000},{"_id":"source/_posts/Nginx服务器的部署.md","hash":"57af26798a796b9ed0b20707db8f5cd29b6b274b","modified":1599112131000},{"_id":"source/_posts/SVN工具在编辑器上的使用.md","hash":"42c2c02c7a5ad581c0976321df1778b7dcbf6751","modified":1589424028000},{"_id":"source/_posts/Vue3-0经验.md","hash":"41bc0bbb51b36ecddaded80fe907d6132aeb3945","modified":1594776525000},{"_id":"source/_posts/PS技术研究.md","hash":"a75ec662184a8a1539cd00bb8f5653b837f23d26","modified":1597300974000},{"_id":"source/_posts/Vue各种原理.txt","hash":"eb461e874540c3358d31d5c91a32d06e514e7110","modified":1612424288000},{"_id":"source/_posts/Vue开发.md","hash":"e14751e69a073cc2104243bb11d091ff88155964","modified":1607494459000},{"_id":"source/_posts/Vue源码学习.md","hash":"c856d00d7076cbc5ed6b1eee36a26a713abe2def","modified":1594021395000},{"_id":"source/_posts/Web前端性能优化-页面加载.md","hash":"fec0268071ebb56f795392643772468208c2e527","modified":1589965362000},{"_id":"source/_posts/javaScript设计模式.md","hash":"a87578bc40c1252a4afc7a180bb98055ff6265f1","modified":1605692782000},{"_id":"source/_posts/learning.md","hash":"ee488378f33b3a7a7b61bacc40bf855e32b0c806","modified":1595830226000},{"_id":"source/_posts/使用HEXO搭建个人博客.md","hash":"4c671850530c6417f8b39ff8c4b49ebe48b4ff8d","modified":1593479927000},{"_id":"source/_posts/函数理解.md","hash":"3f1bd9d9906047c16f010d8d62928ae31ff7e23b","modified":1594092017000},{"_id":"source/_posts/前端进阶之道.md","hash":"66d07de8783e353f7be0e2bc5cf7cac23cb3fd01","modified":1618291971504},{"_id":"source/_posts/前端需求.md","hash":"f94b96a21a3b2145f5da63ede991651778e9ac90","modified":1612486672000},{"_id":"source/_posts/单页面和多页面.md","hash":"3f9c390b556b1285d4e29d33f0aaa147bee76f83","modified":1611196698000},{"_id":"source/_posts/小程序开发经验.md","hash":"f26f35fd31cfccc3abbceb2c9299dcacb7ff9eeb","modified":1591344597000},{"_id":"source/_posts/工作注意事项.md","hash":"b9ab03f4cadc48de88a656fb428bccc8d7df0aea","modified":1599795623000},{"_id":"source/_posts/性能优化.txt","hash":"e81cf0fffdc086a4cce2f9834b966eb57e4a539f","modified":1610514488000},{"_id":"source/_posts/构建空项目与个人网站.txt","hash":"51712b5d9ed97c2d4d74074178a63cb50f1a910f","modified":1610604330000},{"_id":"source/_posts/正则表达式.md","hash":"0ab37874ce0e6f2175d2161d16326fa026de31ea","modified":1589190213000},{"_id":"source/_posts/根据测试文档测试.md","hash":"377ad9e52bb3e6a401c8674c644c5a8a4e27fd42","modified":1590375543000},{"_id":"source/_posts/清除浮动的方法.md","hash":"9ff8b741fa56b0486e08389c18adcdeca3c78b63","modified":1589190184000},{"_id":"source/_posts/生成器和promise.md","hash":"2e0c775ee9031c4d21563eb59f09d67ab2e24496","modified":1593412856000},{"_id":"source/_posts/设计模式.md","hash":"fcf21d9d43a047f70aea1e7516f0ce65b4dc144a","modified":1599817589000},{"_id":"source/_posts/闭包.md","hash":"3648abde11864ab081673dee986b057eda5cbe78","modified":1592364626000},{"_id":"source/categories/index.md","hash":"76e47e74abebff4eafde8b8246752a6c17b120ee","modified":1589004037000},{"_id":"source/tags/index.md","hash":"d4e3be7c298b24721b29556f35d35a325b20c8ff","modified":1589004088000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1588751732000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1588751732000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1588751732000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1588751732000},{"_id":"themes/next/layout/_layout.swig","hash":"5247b2cc612edb697d9ba5f214f6f22b39fe734d","modified":1590117101000},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1588751732000},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1588751732000},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1588751732000},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1588751732000},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1588751732000},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1588751732000},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1588751732000},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1588751732000},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1588751732000},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1588751732000},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1588751732000},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1588751732000},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1588751732000},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1588751732000},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1588751732000},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1588751732000},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1588751732000},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1588751732000},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1588751732000},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1588751732000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1588751732000},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1588751732000},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1588751732000},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1588751732000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1588751732000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1588751732000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1588751732000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1588751732000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"source/_posts/Flex布局/Flex基本概念.png","hash":"2dba0c2338ea3e667f90a0bef5c55f82766b5986","modified":1589181675000},{"_id":"source/_posts/Flex布局/align-self.png","hash":"b92fe4f24afa9a62b488b4093f8dab0fbb8bc1f5","modified":1589182581000},{"_id":"source/_posts/Flex布局/Flex容器.png","hash":"f8cc630ba30e8534d44c969ce59d6501f15f8282","modified":1589181982000},{"_id":"source/_posts/Flex布局/Aren.jpg","hash":"6e7687485372fa073e31041ee1e9495b9c780bfd","modified":1589016335000},{"_id":"source/_posts/Flex布局/flex.png","hash":"fd4d855f19c6696194be38048689bb4594bf631e","modified":1589182507000},{"_id":"source/_posts/Flex布局/justify-content.png","hash":"2db5c86088829736fb0df55ba98ff3e6427798ac","modified":1589182123000},{"_id":"source/_posts/Flex布局/轴.png","hash":"1fa7f1ea90595c038605180ebf254c41bab5a0d3","modified":1589182775000},{"_id":"source/_posts/Flex布局/align-items.png","hash":"d2000d6d56e3279b7dc9ffb775cdd63fc4a38711","modified":1589182324000},{"_id":"source/_posts/JavaScript高级程序设计/文档树.png","hash":"242af0101d99048996c1a45f4237f0e41cb3a2ca","modified":1607913812000},{"_id":"source/_posts/Git和SVN的使用/svn-git.png","hash":"7d34f5fd935f35b92e77531f9ba6689c7335bbbf","modified":1593485754000},{"_id":"source/_posts/SVN工具在编辑器上的使用/SVN-3.png","hash":"84048566fd7bc201efdc126a86c20dc09ebc1c8a","modified":1589338299000},{"_id":"source/_posts/清除浮动的方法/浮动溢出.jpg","hash":"ff3b6dc8e7ccf1ba207375d10ac5a6b8c3792a9f","modified":1589187514000},{"_id":"source/_posts/闭包/过程.png","hash":"37c54ffc16d8bc54a312c26582dbe96e85649a05","modified":1592358822000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1588751732000},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1588751732000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1588751732000},{"_id":"themes/next/layout/_macro/post.swig","hash":"5bc8dcbc99874640dd539b6fc545e2551817e0ac","modified":1589173953000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1588751732000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1588751732000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"bf9c09695b0a3865fa639b6f31bda4a769faafcf","modified":1590458325000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1588751732000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"3e9c7313da1d27933d27f2d0d857dc7f998319e3","modified":1589015030000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1588751732000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1588751732000},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1588751732000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1588751732000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"20addd5c1f57fccb8b32cce913c7fabe07265bd8","modified":1590111213000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1588751732000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1588751732000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1588751732000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1588751732000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1588751732000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1588751732000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1588751732000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1588751732000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1588751732000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1588751732000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1588751732000},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1588751732000},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1588751732000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1588751732000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1588751732000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1588751732000},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1588751732000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1588751732000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1588751732000},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1588751732000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1588751732000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588751732000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1588751732000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1588751732000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1588751732000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1588751732000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1588751732000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1588751732000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1588751732000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1588751732000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1588751732000},{"_id":"themes/next/source/images/favicon-16x16-Aren.ico","hash":"87857949d58a990a8de8d89bfe05f70e32a8bfc0","modified":1589173485000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588751732000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588751732000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588751732000},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1588751732000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588751732000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1588751732000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1588751732000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1588751732000},{"_id":"source/_posts/Git和SVN的使用/git命令.jpg","hash":"9b0258b00ba3ae3c88df58b84d84b96f98adb51e","modified":1593485754000},{"_id":"source/_posts/SVN工具在编辑器上的使用/SVN-2.png","hash":"7ab0c315af550423d38616afbce1284937cf1a79","modified":1589338277000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588751732000},{"_id":"themes/next/source/images/Aren.jpg","hash":"6e7687485372fa073e31041ee1e9495b9c780bfd","modified":1589016335000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1588751732000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1588751732000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1588751732000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1588751732000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1588751732000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1588751732000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1588751732000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1588751732000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1588751732000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1588751732000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1588751732000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1588751732000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1588751732000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1588751732000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1588751732000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1588751732000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1588751732000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1588751732000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"ea028e5375a6c7cbb0b0383aa8746a15903cd111","modified":1590117371000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1588751732000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1588751732000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1588751732000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1588751732000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1588751732000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1588751732000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1588751732000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1588751732000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1588751732000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1588751732000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1588751732000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1588751732000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1588751732000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1588751732000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1588751732000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1588751732000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1588751732000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1588751732000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1588751732000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1588751732000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1588751732000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1588751732000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1588751732000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1588751732000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1588751732000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1588751732000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1588751732000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1588751732000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1588751732000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1588751732000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1588751732000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1588751732000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1588751732000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1588751732000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1588751732000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1588751732000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1588751732000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1588751732000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1588751732000},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1588751732000},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1588751732000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1588751732000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1588751732000},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1588751732000},{"_id":"source/_posts/SVN工具在编辑器上的使用/SVN-1.png","hash":"aa53340218f90be8a149821c59f72b65b75b3bd8","modified":1589338241000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1588751732000},{"_id":"source/_posts/Vue开发/vue.png","hash":"c4c76ecc525366ffdf9ce04e42aef59ba9651da2","modified":1590475516000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1588751732000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1588751732000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1588751732000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1588751732000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1588751732000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1588751732000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1588751732000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1588751732000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1588751732000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1588751732000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1588751732000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1588751732000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1588751732000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588751732000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0026b6f8f96d946cfad72a04e14e4ad0920849c3","modified":1589004237000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"cb070a9b7ee58464571a6465524269d65dd7275f","modified":1590115770000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1588751732000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1588751732000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1588751732000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1588751732000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588751732000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1588751732000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1588751732000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1588751732000},{"_id":"public/about/index.html","hash":"b1596d703ced8407140f3b23db91ad580b4fa9f3","modified":1618385203762},{"_id":"public/tags/index.html","hash":"d14a96c9c4d4c69763883a9c73289f3ca94b4a96","modified":1618385203762},{"_id":"public/categories/index.html","hash":"9815cd75e43069fac300ddcdf5f9f5b7f37324fb","modified":1618385203762},{"_id":"public/archives/2020/06/index.html","hash":"fd246bfd24bb43fcfb221eea03b5ed61de4292be","modified":1618385203762},{"_id":"public/archives/2020/05/page/2/index.html","hash":"cdaa7d5ab161c66fc1f60399f9875e47afc1a7c6","modified":1618385203762},{"_id":"public/archives/2020/07/index.html","hash":"13304d1abccf321e83706b46f8f890d4cab7a738","modified":1618385203762},{"_id":"public/archives/2020/08/index.html","hash":"8e2cebec666389680583cb165565754db40f0872","modified":1618385203762},{"_id":"public/archives/2020/09/index.html","hash":"5b0c6e42e3d17bef54662b2c74dbd12e313125fc","modified":1618385203762},{"_id":"public/archives/2021/index.html","hash":"5a4796239af287319b0e5625d27102785bb32fd0","modified":1618385203762},{"_id":"public/archives/2020/12/index.html","hash":"861bcd78d6047bc24a49f20910d4e56f13405322","modified":1618385203762},{"_id":"public/archives/2020/11/index.html","hash":"6b514f8d57e66ced02207108d779098161df7b2c","modified":1618385203762},{"_id":"public/archives/2021/01/index.html","hash":"f43d525cf76a2c6881d69f2e3d15519c01cfb3d6","modified":1618385203762},{"_id":"public/categories/产品/index.html","hash":"3e53900eb93d601c4f7d642d351ee1aa8a85fd5c","modified":1618385203762},{"_id":"public/categories/UI设计开发/index.html","hash":"02a00c07355f2460958354ef60c9c40ccfc3d5f6","modified":1618385203762},{"_id":"public/categories/javaScript高级程序设计/index.html","hash":"e786d18183b46325d7981cf9cc13bdb527854792","modified":1618385203762},{"_id":"public/categories/版本管理工具/index.html","hash":"d963a3a49469f53b87f8e4b80561ec9ca7daa3b7","modified":1618385203762},{"_id":"public/categories/想法/index.html","hash":"69048067389955e3c02479e06fd4c1a2df80ff51","modified":1618385203762},{"_id":"public/categories/经验/index.html","hash":"f024058dda7ae658690f11f49da9b40f3418770e","modified":1618385203762},{"_id":"public/categories/优化/index.html","hash":"0ba3a8e07aaefc8bab642dd6378e7e3dc7e60a31","modified":1618385203762},{"_id":"public/categories/javaScript设计模式/index.html","hash":"51fb0ac7c8f894307ac7092e08cdd257c112f74c","modified":1618385203762},{"_id":"public/categories/开发工具/index.html","hash":"d536417bce598541ee0e07f8fb445cf20c433334","modified":1618385203762},{"_id":"public/categories/搭建博客/index.html","hash":"5f355013f639cb5e4f6554ddc99f2e6cbd26170d","modified":1618385203762},{"_id":"public/categories/学习/index.html","hash":"86d1878cd1b655e4299319948ba570a2f0e7e2cb","modified":1618385203762},{"_id":"public/categories/前端/index.html","hash":"066bbd201a6e0e3aeaa305878c6d076690eceaf3","modified":1618385203762},{"_id":"public/categories/业务/index.html","hash":"82190c6ba11ba7a0fa3ad37876c3468ac8eccfd4","modified":1618385203762},{"_id":"public/categories/小程序开发/index.html","hash":"fac074452c31bd330335b8eff7c3d4f86771ad7a","modified":1618385203762},{"_id":"public/categories/工作注意事项/index.html","hash":"66ba71af2cebccbd3a1a06a07162a9e3890201cc","modified":1618385203762},{"_id":"public/categories/测试/index.html","hash":"57c719634fb1a11a95eb5e43726b1c68a1665323","modified":1618385203762},{"_id":"public/tags/原型设计/index.html","hash":"cd1f7afd0f37624aec691ef399922c1135c98866","modified":1618385203762},{"_id":"public/tags/Axure/index.html","hash":"a755dfc54d9984d8d6d57bbb46f58862eb76fb09","modified":1618385203762},{"_id":"public/tags/CSS/index.html","hash":"331e9ee242a42dc32ae814974af4fec27c0127f5","modified":1618385203762},{"_id":"public/tags/响应式布局/index.html","hash":"2b97ef77ae78edffec615941edad6347347ce89d","modified":1618385203762},{"_id":"public/tags/伸缩布局/index.html","hash":"df96c8d838101e19aecf1b9024cafbc4f32a934d","modified":1618385203762},{"_id":"public/tags/版本管理/index.html","hash":"9d19c64e5464d3239952e129fda8839efc368952","modified":1618385203762},{"_id":"public/tags/语法知识/index.html","hash":"75a3aed3d1ecdbd6bb539f49de1f724919bbfb87","modified":1618385203762},{"_id":"public/tags/JavaScript/index.html","hash":"12788fb1992eb4b32cc1fab522e5fd8304cdc61a","modified":1618385203762},{"_id":"public/tags/javaScript/index.html","hash":"890b43440dcd769b8221d6125e5532d3cbae44c8","modified":1618385203762},{"_id":"public/tags/diary/index.html","hash":"6f7f979b21c89f0deab73f6f08eebd37b951e5eb","modified":1618385203762},{"_id":"public/tags/日记/index.html","hash":"86794783f70968c2fd6884e83b3ba58a44745e30","modified":1618385203762},{"_id":"public/tags/前端开发/index.html","hash":"5e8d7f9e5cd65852fd698b57b7b98dff3569e3e2","modified":1618385203762},{"_id":"public/tags/图片编辑/index.html","hash":"4b1c2031a93ac9e6f27ad34f0b434840fa607e9c","modified":1618385203762},{"_id":"public/tags/代码管理/index.html","hash":"0ff131ca80cb7343544d9a8d562a08aeb77ea58b","modified":1618385203762},{"_id":"public/tags/前端框架/index.html","hash":"241ef1d3b2af1503d45ed5c9e6244d6400e86136","modified":1618385203762},{"_id":"public/tags/Web性能/index.html","hash":"5d17b4f6d9b0bdb3d3644bcf85edf77b95523f89","modified":1618385203762},{"_id":"public/tags/HEXO/index.html","hash":"4aae6e18317e92ce0295972effc6973fa83c8a99","modified":1618385203762},{"_id":"public/tags/学习/index.html","hash":"a3ed53a5e13b77a6dc27b32886e8e25e0002a102","modified":1618385203762},{"_id":"public/tags/学习需求/index.html","hash":"33e89b03a3ef042bdba7238be460a2b8f62b107b","modified":1618385203762},{"_id":"public/tags/前端学习/index.html","hash":"55202eb01680214952bc28decad6b764d7b32561","modified":1618385203762},{"_id":"public/tags/函数/index.html","hash":"1d6064cb7c596ccd912d84ca3614bc32970dcc9e","modified":1618385203762},{"_id":"public/tags/单页面与多页面应用/index.html","hash":"b09d08e05b1ef1cfd019680dcb8e69c44696fcac","modified":1618385203762},{"_id":"public/tags/Mpvue/index.html","hash":"aa3339ed2a72a933d5f1f2ce3ce66659b5eebd9c","modified":1618385203762},{"_id":"public/tags/开发者工具/index.html","hash":"0728ab82685fdc98c46109bf747c6a66a6035bf3","modified":1618385203762},{"_id":"public/tags/工作职责/index.html","hash":"6d6e9f3d0341444ec5ba18b0a18641e23f220c3f","modified":1618385203762},{"_id":"public/tags/正则表达式/index.html","hash":"030a1eb8c318274c3e5309f69f949ce1bacecc47","modified":1618385203762},{"_id":"public/tags/测试/index.html","hash":"283f1da485e11f0b18f459d114883240df0f1224","modified":1618385203762},{"_id":"public/tags/设计模式/index.html","hash":"90ca381c2012a9b95979886de8634ca3c7c61a2c","modified":1618385203762},{"_id":"public/index.html","hash":"8f288e7fd33af1bf147d737d25bba37ee8274c67","modified":1618385203762},{"_id":"public/2020/11/23/JavaScript高级程序设计/index.html","hash":"e1335101b431fe51e88077dccd13ac86f02d7fe1","modified":1618385203762},{"_id":"public/2020/12/04/前端进阶之道/index.html","hash":"e486080ba3e85dcacc368c337b7b680c9c463910","modified":1618385203762},{"_id":"public/2021/01/21/单页面和多页面/index.html","hash":"62f9e24cfc718a4181da54ee1656b3ac7802578b","modified":1618385203762},{"_id":"public/2020/11/18/javaScript设计模式/index.html","hash":"0f48c350bec71965115b008fc0a18481e05d7eb6","modified":1618385203762},{"_id":"public/2020/09/11/设计模式/index.html","hash":"fd8f67aee2a259493ccae98fc715fc7834bf7075","modified":1618385203762},{"_id":"public/2020/09/11/工作注意事项/index.html","hash":"ab02b89c3c0daff5af9682927129b9e2e806b84c","modified":1618385203762},{"_id":"public/2020/07/27/learning/index.html","hash":"59676553fd275d38d320c1569822558dd7e0c8bd","modified":1618385203762},{"_id":"public/2020/08/25/Nginx服务器的部署/index.html","hash":"cb603b21daf33506b2bab6adbaba868ec1e77410","modified":1618385203762},{"_id":"public/2020/08/20/前端需求/index.html","hash":"c9e28dd77249c2b20fd07199073389d64b4082dc","modified":1618385203762},{"_id":"public/2020/07/10/Vue3-0经验/index.html","hash":"532f118ff3edef324f2d8dd8feb2858f8729a411","modified":1618385203762},{"_id":"public/2020/07/08/MyWorkingDiary/index.html","hash":"12faf7342ae4e8af2db4cdcc2ecb3707cb7215d4","modified":1618385203762},{"_id":"public/2020/06/30/Git和SVN的使用/index.html","hash":"e65f1cd639ae7f9404f15143e4ce9168f1f36255","modified":1618385203762},{"_id":"public/2020/07/01/函数理解/index.html","hash":"eb547d0d0723adec485846944defd3b2859f8bf1","modified":1618385203762},{"_id":"public/2020/07/06/Vue源码学习/index.html","hash":"5e9fbfb41245625eb506cb10d1ff336350a817fb","modified":1618385203762},{"_id":"public/2020/06/23/生成器和promise/index.html","hash":"c55c1c55894adc4fc2fd9cba11c968cffc505139","modified":1618385203762},{"_id":"public/2020/06/16/闭包/index.html","hash":"fca041267034351a466796cc20cad3e72596253f","modified":1618385203762},{"_id":"public/2020/06/15/PS技术研究/index.html","hash":"c5491d52b3784ff42b9e1fccf7555d6d677f9346","modified":1618385203762},{"_id":"public/2020/05/20/Web前端性能优化-页面加载/index.html","hash":"0f0d31cf8da4a1f2231fc9caa7fd1a82087f822d","modified":1618385203762},{"_id":"public/2020/05/26/Vue开发/index.html","hash":"a2bad30c1799942e843799ce1ca7f668beafeead","modified":1618385203762},{"_id":"public/2020/06/05/Axure原型设计/index.html","hash":"7b7831db40ff9044b08a9dd32d33b6c11874707b","modified":1618385203762},{"_id":"public/2020/05/18/根据测试文档测试/index.html","hash":"3c335fc95f0b3ddba7ec0a446d5fabe3716beffb","modified":1618385203762},{"_id":"public/2020/05/13/ES6语法知识点/index.html","hash":"a13b1ee97b815225823ecf85ff4b478272bfd26b","modified":1618385203762},{"_id":"public/2020/05/12/SVN工具在编辑器上的使用/index.html","hash":"0d67a69cc8d62b0c1527fd3f4d07a0c4488f152b","modified":1618385203762},{"_id":"public/2020/05/11/正则表达式/index.html","hash":"abd54e586046d6abc43d0cdf42438eace4973240","modified":1618385203762},{"_id":"public/2020/05/11/Flex布局/index.html","hash":"010ef3cfae204d6f36ff0f772b481b06f7fa5cf4","modified":1618385203762},{"_id":"public/2020/05/11/清除浮动的方法/index.html","hash":"06b3ff95c2c3f95d360ca8df95a8e15989afe50a","modified":1618385203762},{"_id":"public/2020/05/09/使用HEXO搭建个人博客/index.html","hash":"7cc8b7636b8a6c8b3e445344d33d665b114834c0","modified":1618385203762},{"_id":"public/2020/05/09/CSS样式/index.html","hash":"73cc78900b96da7d490b6813807444037f162273","modified":1618385203762},{"_id":"public/2020/05/09/小程序开发经验/index.html","hash":"2dff15bf415c98ffe925432f9bd0060365d60cc3","modified":1618385203762},{"_id":"public/archives/page/3/index.html","hash":"f9b9b941eaf7fbc33018f598c6191a7b53efd3af","modified":1618385203762},{"_id":"public/archives/page/2/index.html","hash":"d1579d4977f5460d97b65c3408c52a24df5a62c9","modified":1618385203762},{"_id":"public/archives/index.html","hash":"05e779f1d3d7a6035e8dd80f8efccdb3aca9e3a1","modified":1618385203762},{"_id":"public/archives/2020/index.html","hash":"d8ce786fabed845ff3496425d6515a1704f9e174","modified":1618385203762},{"_id":"public/archives/2020/page/2/index.html","hash":"c3d5b7983fdf056500b772bae89c3181384de05a","modified":1618385203762},{"_id":"public/archives/2020/page/3/index.html","hash":"2bad3b0706bea998782af0bd0c6e1b2639c8a545","modified":1618385203762},{"_id":"public/archives/2020/05/index.html","hash":"a84a8137b0c36f23ed0505ad3b1dc07f998cc0f4","modified":1618385203762},{"_id":"public/categories/Web前端/index.html","hash":"419dfe7a162a67e9b7d5a17a94c9ae27a4e5870f","modified":1618385203762},{"_id":"public/page/2/index.html","hash":"0ff3ae2b9271c735de17541de5c5d82e9a8f7b06","modified":1618385203762},{"_id":"public/page/3/index.html","hash":"4c3a3c51bc1420f04e89da44ce41b8682a476df5","modified":1618385203762},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1612493322547},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1612493322547},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1612493322547},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1612493322547},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1612493322547},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1612493322547},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1612493322547},{"_id":"public/images/favicon-16x16-Aren.ico","hash":"87857949d58a990a8de8d89bfe05f70e32a8bfc0","modified":1612493322547},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1612493322547},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1612493322547},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1612493322547},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1612493322547},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1612493322547},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1612493322547},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1612493322547},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1612493322547},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1612493322547},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1612493322547},{"_id":"public/images/Aren.jpg","hash":"6e7687485372fa073e31041ee1e9495b9c780bfd","modified":1612493322547},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1612493322547},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1612493322547},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1612493322547},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1612493322547},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1612493322547},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1612493322547},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1612493322547},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1612493322547},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1612493322547},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1612493322547},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1612493322547},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1612493322547},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1612493322547},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1612493322547},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1612493322547},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1612493322547},{"_id":"public/2020/11/23/JavaScript高级程序设计/文档树.png","hash":"242af0101d99048996c1a45f4237f0e41cb3a2ca","modified":1612493322547},{"_id":"public/2020/06/30/Git和SVN的使用/svn-git.png","hash":"7d34f5fd935f35b92e77531f9ba6689c7335bbbf","modified":1612493322547},{"_id":"public/2020/06/30/Git和SVN的使用/git命令.jpg","hash":"9b0258b00ba3ae3c88df58b84d84b96f98adb51e","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/Flex容器.png","hash":"f8cc630ba30e8534d44c969ce59d6501f15f8282","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/Aren.jpg","hash":"6e7687485372fa073e31041ee1e9495b9c780bfd","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/Flex基本概念.png","hash":"2dba0c2338ea3e667f90a0bef5c55f82766b5986","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/align-self.png","hash":"b92fe4f24afa9a62b488b4093f8dab0fbb8bc1f5","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/align-items.png","hash":"d2000d6d56e3279b7dc9ffb775cdd63fc4a38711","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/justify-content.png","hash":"2db5c86088829736fb0df55ba98ff3e6427798ac","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/轴.png","hash":"1fa7f1ea90595c038605180ebf254c41bab5a0d3","modified":1612493322547},{"_id":"public/2020/05/11/Flex布局/flex.png","hash":"fd4d855f19c6696194be38048689bb4594bf631e","modified":1612493322547},{"_id":"public/2020/06/16/闭包/过程.png","hash":"37c54ffc16d8bc54a312c26582dbe96e85649a05","modified":1612493322547},{"_id":"public/2020/05/11/清除浮动的方法/浮动溢出.jpg","hash":"ff3b6dc8e7ccf1ba207375d10ac5a6b8c3792a9f","modified":1612493322547},{"_id":"public/css/main.css","hash":"c12d6908bf730adf9e421e8daf52acd5d7df67bc","modified":1612493322547},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1612493322547},{"_id":"public/2020/05/12/SVN工具在编辑器上的使用/SVN-2.png","hash":"7ab0c315af550423d38616afbce1284937cf1a79","modified":1612493322547},{"_id":"public/2020/05/12/SVN工具在编辑器上的使用/SVN-3.png","hash":"84048566fd7bc201efdc126a86c20dc09ebc1c8a","modified":1612493322547},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1612493322547},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1612493322547},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1612493322547},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1612493322547},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1612493322547},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1612493322547},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1612493322547},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1612493322547},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1612493322547},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1612493322547},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1612493322547},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1612493322547},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1612493322547},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1612493322547},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1612493322547},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1612493322547},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1612493322547},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1612493322547},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1612493322547},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1612493322547},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1612493322547},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1612493322547},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1612493322547},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1612493322547},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1612493322547},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1612493322547},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1612493322547},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1612493322547},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1612493322547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1612493322547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1612493322547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1612493322547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1612493322547},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1612493322547},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"7eecc5e472416b9870580c53b7ed0c44474ed23a","modified":1612493322547},{"_id":"public/lib/fastclick/README.html","hash":"b9e008af0866799103e596e2eda466a33d7dde18","modified":1612493322547},{"_id":"public/lib/jquery_lazyload/README.html","hash":"9c91bba4263a20004f2c10772d438cfa8312c308","modified":1612493322547},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1612493322547},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1612493322547},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1612493322547},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1612493322547},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1612493322547},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1612493322547},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1612493322547},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1612493322547},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1612493322547},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1612493322547},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1612493322547},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1612493322547},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1612493322547},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1612493322547},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1612493322547},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1612493322547},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1612493322547},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1612493322547},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1612493322547},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1612493322547},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1612493322547},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1612493322547},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1612493322547},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1612493322547},{"_id":"public/2020/05/12/SVN工具在编辑器上的使用/SVN-1.png","hash":"aa53340218f90be8a149821c59f72b65b75b3bd8","modified":1612493322547},{"_id":"public/2020/05/26/Vue开发/vue.png","hash":"c4c76ecc525366ffdf9ce04e42aef59ba9651da2","modified":1612493322547},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1612493322547},{"_id":"source/_posts/Vue-mixin.md","hash":"4b799d01b06646b4f26f95f53e656d153a136301","modified":1614240828622},{"_id":"source/_posts/Vue指令.md","hash":"a41dd38087bb8e53d75087209d4c770966f73537","modified":1614240855888},{"_id":"public/categories/web前端/index.html","hash":"eda249b73cac7e00209dba0702e39720f9b50e5f","modified":1618385203762},{"_id":"public/archives/page/4/index.html","hash":"fb54bc5189fc72623ae206b3b328458f0e78c912","modified":1618385203762},{"_id":"public/archives/2021/02/index.html","hash":"d2181b213190d75ab48bffd86ebe749687de3430","modified":1618385203762},{"_id":"public/tags/Vue/index.html","hash":"3fa64f28956c92f6a6c91ca9045c620266badd5f","modified":1618385203762},{"_id":"public/2021/02/25/Vue-mixin/index.html","hash":"85f30e0aa78f524749a86c8447fa625e85696967","modified":1618385203762},{"_id":"public/2021/02/25/Vue指令/index.html","hash":"e1f02965a32d3df29afaf9247b794ff63bfc3f6c","modified":1618385203762},{"_id":"public/page/4/index.html","hash":"ab2056f261320131539958f2aaef13d1881a7b96","modified":1618385203762},{"_id":"source/_posts/JavaScript基础.md","hash":"481e1ce586ee516409f04548e5a09899790f934d","modified":1616656047018},{"_id":"source/_posts/vue权限管理.md","hash":"4d29efca223b7cdfbce4408541dd3e8c3b139d45","modified":1614312211874},{"_id":"public/2021/02/26/vue权限管理/index.html","hash":"6534d52364026af84d71e62f21254a802d2c9fe9","modified":1618385203762},{"_id":"public/2021/02/26/JavaScript基础/index.html","hash":"4c51ad3e24665f5b23277c7f9b6e93c5a1e0b231","modified":1618385203762},{"_id":"source/_posts/CSS基础.md","hash":"1a48f09a320fc7b5ed71c2822d578cc8f262e3fb","modified":1617199157058},{"_id":"source/_posts/Vue响应式原理.md","hash":"16b6548a4901de52dc3470093a5862a21d20d316","modified":1615863831069},{"_id":"source/_posts/前端工程化.md","hash":"04becbd516f2bd8a23c186d4db6e7461ca5d53f0","modified":1616663447918},{"_id":"public/archives/2021/03/index.html","hash":"5ba9e4e88c4e63e3ea8a2eb1c6967de0eb7fed13","modified":1618385203762},{"_id":"public/tags/工程化/index.html","hash":"7d133731c72a020965a1175bdd698640cf744cc4","modified":1618385203762},{"_id":"public/categories/Web前端/page/2/index.html","hash":"44742b01ea9f9b4bd41c852e28ba029a8c539752","modified":1618385203762},{"_id":"public/categories/页面样式/index.html","hash":"6a4ded3fa3bb4b19530d1f2bfe212d50f1972d54","modified":1618385203762},{"_id":"public/2021/03/15/前端工程化/index.html","hash":"9c547dabd72326ecbf5ccc20724a0a1f393dafc6","modified":1618385203762},{"_id":"public/2021/03/15/Vue响应式原理/index.html","hash":"9fa3a2281c8b56e47cd92cd7f64497b2748d9f13","modified":1618385203762},{"_id":"public/2021/03/15/CSS基础/index.html","hash":"59cfe4aabc823637876bf2a136dc626d52258bb3","modified":1618385203762},{"_id":"source/_posts/Vue插槽.md","hash":"36326c4b6a8d55e11051df411aa84e6d0401e689","modified":1616062426644},{"_id":"source/_posts/computed和watch.md","hash":"c8643f11d1f95252cfc5764690c4268693221cd9","modified":1617166558504},{"_id":"public/2021/03/18/Vue插槽/index.html","hash":"fd82b99f956cf1e443fad93fff674928f4778223","modified":1618385203762},{"_id":"public/2021/03/16/computed和watch/index.html","hash":"0ea933e2b516d6d0839c16a659f3f7289e9131de","modified":1618385203762},{"_id":"source/_posts/单点登录SSO.md","hash":"3a1892c998af9688a46c2b9ca6878e887bd8ad30","modified":1617166482248},{"_id":"public/tags/前端/index.html","hash":"9edfc0ee156f1b812e2117f1b25f48418b61ccfe","modified":1618385203762},{"_id":"public/archives/2021/page/2/index.html","hash":"4ae41011bdb706e2101de571ce9cfa3794b94d06","modified":1618385203762},{"_id":"public/2021/03/25/单点登录SSO/index.html","hash":"a5a16898e5284aa9a05188e35faaf986924c748f","modified":1618385203762},{"_id":"source/_posts/uni-app初试.md","hash":"116a78fca3a3a8373ac0a8a0620c0d9fe3cc1389","modified":1617692620787},{"_id":"source/_posts/Web安全性.md","hash":"a2a0726b48cc7f635c49efc5112c865219e0f5c7","modified":1616745668767},{"_id":"public/categories/移动端/index.html","hash":"6e112f07cee99f251e4e968ee6f65276c2ea871d","modified":1618385203762},{"_id":"public/archives/page/5/index.html","hash":"01d806acccdece6552391928b91250cb791b8bde","modified":1618385203762},{"_id":"public/tags/移动端开发/index.html","hash":"d3c66c50e95aa2a8427474d46b68a4311ee6b1ff","modified":1618385203762},{"_id":"public/tags/网络安全/index.html","hash":"7d079d47f156915eae811df499a7314f58edace2","modified":1618385203762},{"_id":"public/2021/03/31/uni-app初试/index.html","hash":"a07eec9c790d19f892b8385e9a0aa3afcecde487","modified":1618385203762},{"_id":"public/2021/03/26/Web安全性/index.html","hash":"9b3b8b8e3d537a1b7d1f171379c4f43232913950","modified":1618385203762},{"_id":"public/page/5/index.html","hash":"201c57e1d38ec5932c20a46c5324bf67036c63bc","modified":1618385203762},{"_id":"source/_posts/不同情况下PX的区别.md","hash":"d9201a31c68048fba1fb2a2a94c3c0fcf777dfb5","modified":1617239999191},{"_id":"public/archives/2021/04/index.html","hash":"7214c64c6abac585303ac59a70bbee12a67eeb5b","modified":1618385203762},{"_id":"public/2021/04/01/不同情况下PX的区别/index.html","hash":"0f24725e4e7e03c6dfdbeb5a3fb6680588ef1d0c","modified":1618385203762},{"_id":"source/_posts/BFC.md","hash":"2217a44099cb6321b01d24fb2c8e2ce9d54f6766","modified":1617693625000},{"_id":"source/_posts/CSS隐藏元素.md","hash":"44a31ad2d5fb44b598ca4df73afa9f3156f8dd0e","modified":1617376652575},{"_id":"public/2021/04/06/BFC/index.html","hash":"35f7bc57a8321661de158b8a06da78737b711c35","modified":1618385203762},{"_id":"public/2021/04/02/CSS隐藏元素/index.html","hash":"1bfd6debc90631f437b64712c2f7c34876b118f4","modified":1618385203762},{"_id":"source/_posts/两栏布局和三栏布局.md","hash":"e49868b6869a8a54553669e1ca5d59105c09c39a","modified":1617956760488},{"_id":"source/_posts/水平垂直居中方式.md","hash":"74ab6ebaf8021228827071b5374ca58c7df82f82","modified":1617807684355},{"_id":"public/2021/04/08/两栏布局和三栏布局/index.html","hash":"b8e9d32f45efb645e78eb31fbacf783fd1c41e14","modified":1618385203762},{"_id":"public/2021/04/07/水平垂直居中方式/index.html","hash":"df990712af7b525d8a4bd508df4e70f1c000d806","modified":1618385203762},{"_id":"source/_posts/CSS3特性.md","hash":"6d8b1b7cbd112ec0a15bd563255369748de9fc84","modified":1618317696970},{"_id":"public/2021/04/13/CSS3特性/index.html","hash":"76dd77182a479bfeb37a548d4e25fcad21bf670a","modified":1618385203762},{"_id":"source/_posts/CSS动画.md","hash":"801037de616ac94097a16b0387fb45280e44fd61","modified":1618385133658},{"_id":"public/tags/CSS/page/2/index.html","hash":"372c70677d37d9d995572bf6d92ba108a35a97f3","modified":1618385203762},{"_id":"public/2021/04/14/CSS动画/index.html","hash":"7da1827b7a9138539ac9ce0ea6d58b1d669d73ce","modified":1618385203762}],"Category":[{"name":"产品","_id":"ckkrow33a0004pcva22v335gf"},{"name":"UI设计开发","_id":"ckkrow33f0009pcva3ge54cbc"},{"name":"版本管理工具","_id":"ckkrow33k000hpcvahrm26m1c"},{"name":"Web前端","_id":"ckkrow33l000lpcvaaviaej4h"},{"name":"javaScript高级程序设计","_id":"ckkrow33m000qpcva1nie5iar"},{"name":"想法","_id":"ckkrow3740018pcva722ibuva"},{"name":"经验","_id":"ckkrow377001dpcvagihb286u"},{"name":"开发工具","_id":"ckkrow379001jpcva2dqw8z2u"},{"name":"javaScript设计模式","_id":"ckkrow37e001spcvadexlay8e"},{"name":"优化","_id":"ckkrow37g0021pcva956a84wg"},{"name":"搭建博客","_id":"ckkrow37i0028pcva8zlg58s2"},{"name":"学习","_id":"ckkrow37k002epcvaaua9g7ot"},{"name":"前端","_id":"ckkrow37n002lpcva29346qjz"},{"name":"业务","_id":"ckkrow37p002tpcva5hr0d5al"},{"name":"小程序开发","_id":"ckkrow37r0032pcva2y4881tk"},{"name":"工作注意事项","_id":"ckkrow37s0038pcva6szah1rd"},{"name":"测试","_id":"ckkrow37t003dpcva6u9har7b"},{"name":"web前端","_id":"cklkl9v430002ksvaf36j60yv"},{"name":"页面样式","_id":"ckmafka750002qgva6g3zcjoh"},{"name":"移动端","_id":"ckmwz6dhd0002d4vab74ee57i"}],"Data":[],"Page":[{"_content":"","source":"index.md","raw":"","date":"2021-02-05T02:43:57.168Z","updated":"2020-05-22T01:48:24.000Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"ckkrow31r0000pcvacxq72nid","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2020-05-11T03:34:35.000Z","type":"about","_content":"\n### 个人信息\n\n英文名：Daryl\n中文名：王熙晨\n学历：本科\n状态：已就业\n爱好：跑步，计算机，音乐","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-05-11 11:34:35\ntype: \"about\"\n---\n\n### 个人信息\n\n英文名：Daryl\n中文名：王熙晨\n学历：本科\n状态：已就业\n爱好：跑步，计算机，音乐","updated":"2020-07-08T06:06:21.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckkrow3360001pcva2db8gsl0","content":"<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3><p>英文名：Daryl<br>中文名：王熙晨<br>学历：本科<br>状态：已就业<br>爱好：跑步，计算机，音乐</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3><p>英文名：Daryl<br>中文名：王熙晨<br>学历：本科<br>状态：已就业<br>爱好：跑步，计算机，音乐</p>\n"},{"title":"分类","date":"2020-05-09T05:59:27.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-05-09 13:59:27\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-05-09T06:00:37.000Z","path":"categories/index.html","layout":"page","_id":"ckkrow3700015pcvags2s334i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签页","date":"2020-05-09T06:01:02.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签页\ndate: 2020-05-09 14:01:02\ntype: \"tags\"\ncomments: false\n---\n","updated":"2020-05-09T06:01:28.000Z","path":"tags/index.html","layout":"page","_id":"ckkrow3730017pcvabdx9evnb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Axure原型设计","date":"2020-06-05T06:38:52.000Z","_content":"\n## 使用Axure设计相关产品原型，初略交互，查看产品效果\n\n在网上寻找相关元件，可以使用，方便设计，并且将一些常用元件保留，可以在Axure里面设置元件库。\n可以点击上方Group，使个别组件关联。\n通过设置事件变化和操作，进行简单的交互行为。\n常用：\n\non-click:跳转页面\nset类:设置组件值\nstyleeffect:改变组件样式\nMouseDown,MouseOver.\nSelected/Checked:需要Select Group，否则组件单独为一个选择状态。\n\n## 原型系统设计上遇到的问题\n考虑到产品合理化，功能的放置和功能点的情况，一些规律和产品思维。\n取色和资源的获取，对一些常用组件的独自封装。\n在设计原型时对设计时用的资源进行一些存储和备份，在实现时备用，提高实现效率。\n需要思考并且讨论产品的需求和产品的合理性，在考虑相对完善的情况下再去动手做，否则大部分都是无用功。\n美观需要多去参考网页上的一些app的样式，参考人家的产品思维。","source":"_posts/Axure原型设计.md","raw":"---\ntitle: Axure原型设计\ndate: 2020-06-05 14:38:52\ntags:\n - 原型设计\n - Axure\ncategories: 产品\n---\n\n## 使用Axure设计相关产品原型，初略交互，查看产品效果\n\n在网上寻找相关元件，可以使用，方便设计，并且将一些常用元件保留，可以在Axure里面设置元件库。\n可以点击上方Group，使个别组件关联。\n通过设置事件变化和操作，进行简单的交互行为。\n常用：\n\non-click:跳转页面\nset类:设置组件值\nstyleeffect:改变组件样式\nMouseDown,MouseOver.\nSelected/Checked:需要Select Group，否则组件单独为一个选择状态。\n\n## 原型系统设计上遇到的问题\n考虑到产品合理化，功能的放置和功能点的情况，一些规律和产品思维。\n取色和资源的获取，对一些常用组件的独自封装。\n在设计原型时对设计时用的资源进行一些存储和备份，在实现时备用，提高实现效率。\n需要思考并且讨论产品的需求和产品的合理性，在考虑相对完善的情况下再去动手做，否则大部分都是无用功。\n美观需要多去参考网页上的一些app的样式，参考人家的产品思维。","slug":"Axure原型设计","published":1,"updated":"2020-07-27T08:05:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow3370002pcva4a6nddk8","content":"<h2 id=\"使用Axure设计相关产品原型，初略交互，查看产品效果\"><a href=\"#使用Axure设计相关产品原型，初略交互，查看产品效果\" class=\"headerlink\" title=\"使用Axure设计相关产品原型，初略交互，查看产品效果\"></a>使用Axure设计相关产品原型，初略交互，查看产品效果</h2><p>在网上寻找相关元件，可以使用，方便设计，并且将一些常用元件保留，可以在Axure里面设置元件库。<br>可以点击上方Group，使个别组件关联。<br>通过设置事件变化和操作，进行简单的交互行为。<br>常用：</p>\n<p>on-click:跳转页面<br>set类:设置组件值<br>styleeffect:改变组件样式<br>MouseDown,MouseOver.<br>Selected/Checked:需要Select Group，否则组件单独为一个选择状态。</p>\n<h2 id=\"原型系统设计上遇到的问题\"><a href=\"#原型系统设计上遇到的问题\" class=\"headerlink\" title=\"原型系统设计上遇到的问题\"></a>原型系统设计上遇到的问题</h2><p>考虑到产品合理化，功能的放置和功能点的情况，一些规律和产品思维。<br>取色和资源的获取，对一些常用组件的独自封装。<br>在设计原型时对设计时用的资源进行一些存储和备份，在实现时备用，提高实现效率。<br>需要思考并且讨论产品的需求和产品的合理性，在考虑相对完善的情况下再去动手做，否则大部分都是无用功。<br>美观需要多去参考网页上的一些app的样式，参考人家的产品思维。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用Axure设计相关产品原型，初略交互，查看产品效果\"><a href=\"#使用Axure设计相关产品原型，初略交互，查看产品效果\" class=\"headerlink\" title=\"使用Axure设计相关产品原型，初略交互，查看产品效果\"></a>使用Axure设计相关产品原型，初略交互，查看产品效果</h2><p>在网上寻找相关元件，可以使用，方便设计，并且将一些常用元件保留，可以在Axure里面设置元件库。<br>可以点击上方Group，使个别组件关联。<br>通过设置事件变化和操作，进行简单的交互行为。<br>常用：</p>\n<p>on-click:跳转页面<br>set类:设置组件值<br>styleeffect:改变组件样式<br>MouseDown,MouseOver.<br>Selected/Checked:需要Select Group，否则组件单独为一个选择状态。</p>\n<h2 id=\"原型系统设计上遇到的问题\"><a href=\"#原型系统设计上遇到的问题\" class=\"headerlink\" title=\"原型系统设计上遇到的问题\"></a>原型系统设计上遇到的问题</h2><p>考虑到产品合理化，功能的放置和功能点的情况，一些规律和产品思维。<br>取色和资源的获取，对一些常用组件的独自封装。<br>在设计原型时对设计时用的资源进行一些存储和备份，在实现时备用，提高实现效率。<br>需要思考并且讨论产品的需求和产品的合理性，在考虑相对完善的情况下再去动手做，否则大部分都是无用功。<br>美观需要多去参考网页上的一些app的样式，参考人家的产品思维。</p>\n"},{"title":"CSS样式","date":"2020-05-09T06:59:08.000Z","_content":"\n页面UI设计与开发\n\n---\n\n## 2020/5/9 15:01 Write\n\n关键词：UI\n\n选择器优先权：important>内联>id>类>标签|伪类|属性选择|伪元素>通配符>继承\n\n注意可继承属性和不可继承属性\n\n```bash\ncursor: 改变光标的形式\nbox-sizing：使Padding往内伸缩\noutline：外边框\nfocus：获取焦点\nfont-size：0 （解决空格留白问题）\n```\n\n### 浮动的特点\n元素浮动后会脱离文档流\n浮动以后元素会一直向父元素的最上方移动\n直到遇到父元素的边框或者其他的浮动元素，会停止移动\n如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素\n浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐\n浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果\n\n### 元素浮动后的效果\n块元素：块元素脱离文档流以后（不会独占一行，宽度高度会被内容撑开）\n内联元素：脱离文档流后变成块元素\n\n### 定位\nrelative:相对于自己（相对定位）\n开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化\n相对定位元素对于自身在文档流中的位置来定位\n相对定位的元素不会脱离文档流\n相对定位不会改变元素的性质，块元素还是块元素\n相对定位的元素会提升一个层级\n使用top left right bottom偏移\n\nabsolute：相对于父标签\n同相对定位\n最近的开启了定位的祖先元素进行定位，如果所有的祖先元素没开启定位，则相对于浏览器窗口进行定位\n绝对定位的元素会完全脱离文档流\n绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行\n绝对定位会使元素提升一个层级\n\n\nfixed：相对于浏览器窗口\n特殊的绝对定位，相对于浏览器窗口定位\n永远相对于浏览器窗口进行定位，不会随滚动条滚动\n\n\n\n### 层级\n定位元素>浮动元素>文档流中的元素\n当元素开启了定位后，可以通过Z-index来设置层级\nz-index值越高越优先显示\n如果z-index值一样，或者都没有z-index则优先显示下边的元素\n父元素永远不会盖住子元素\n\n\n---\n### flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\n优点：flex布局容易上手\n缺点：浏览器兼容性比较差，只能兼容到ie9及以上\n常用属性：\nflex-direction ////控制主轴\njustify-content//主轴上的子项对齐方式\nalign-items//侧轴上的对齐方式\nflex-wrap///指定flex子项是否换行\nalign-content///适用于多行，\nalign-self////指定某个子项的对齐方式\n---\n### grid网格布局\n优点：灵活的区域网格容器和网格项\n缺点：兼容性不好\n指定display：grid\n行，列，单元格\nrepeat（重复属性），设置宽高（columns，rows）\nfr（片段），minmax（设置最大最小值）,grid-row-gap（行间隔）\ngrid-colunm-gap（设置列间隔）,grid-auto-flow（自定义排序）\n类flex布局的定位属性\n---\n### 浮动布局\n优点：元素浮动可以设置宽高，可以文字环绕图片\n缺点：元素浮动脱离文档流，容易造成父级元素高度塌陷\n元素浮动后产生BFC，靠子元素撑开高度，且浮动不能单个浮动，要多个。\n需要时还需清除浮动与闭合浮动\n浮动大多数位置靠上，靠左，靠右\n解决高度塌陷：\n开启父元素的BFC（默认关闭）\n在父元素最后添加一个DIV清除浮动\n使用after伪类清除浮动\n---\n### border style\n共八种样式：\ndotted\ndashed\nsolid\ndouble\ngroove\nridge\ninset\noutset\n\n### CSS3动画属性\n通过hover改变属性样式，在主选择器中使用transition进行动画过渡。\n包括宽度和背景颜色都可以。\n2D转换有包括：\n位移（translate）：顾名思义，在原有位置上移动\n旋转（rotate）：在原有位置上旋转，类似网易云音乐的碟盘\n变形：改变属性形状\n缩放（scale）：在原有位置上进行放大或者缩小\n也包括3D转换，属性使用不同。\n浮动：浮动后与浮动同向的margin会偏移两倍，反方向margin解决。\n浮动中间可以使用多一个div来隔开浮动的效果。\n父浮动，子不变。\n选择器的学习，需要深入。\n\n### 触发BFC：块级格式化上下文\n.body根元素\n.浮动元素：float除none以外的值\n.绝对定位元素：position（absolute，fixed）\n.display为inline-block，table-cells，flex\n.overflow除了visible以外的值（hidden，auto，scroll）\n1.BFC可以容纳浮动元素\n2.同一个BFC下外边距会发生折叠\n3.BFC可以阻止元素被浮动元素覆盖\n---\n### 层叠上下文（可以设置z-index来决定层叠）\nz-index仅在position定位和非static上起效果\n层叠等级和层级上下文决定堆叠顺序\n由html标签产生的根层叠上下文，决定权在z-index上\ninline/inline-block元素的层叠顺序要高于block/float元素\n层叠等级层叠顺序相同时，后面的覆盖前面的\n---\n### 边距折叠\n相邻的非浮动元素发生折叠\n折叠发生在垂直外边距上\n折叠后取最大的那个margin值作为最终值\n浮动元素不折叠\nmargin折叠只发生在块级元素上\n浮动元素不与其他元素margin折叠\nBFC不与它的子元素发生margin折叠\n绝对定位，根元素不与任何margin折叠\n---\n### 浏览器渲染机制\n1.HTML解析出DOM Tree\n2.CSS解析出Style Rules\n3.将二者关联生成Render Tree\n4.Layout根据Render Tree计算每个节点的信息\n5.Painting根据计算好的信息绘制整个页面\n回流（Reflow）：浏览器根据各自样式来计算结果并将元素放到它该出现的位置\n触发reflow：\n1.当增加，删除，修改DOM节点时，或是插入动画的时候\n2.当移动DOM的位置，或是插入动画的时候\n3.当修改CSS样式的时候\n4.当Resize窗口的时候，或是滚动的时候\n5.当修改网页的默认字体时\n重绘（Repaint）：盒子的各种属性确认后，浏览器按照各自的特性绘制。\n触发Repaint：\n1.DOM改动\n2.CSS改动\n回流必将引起重绘，重绘不一定会引起回流。\n### 白屏\n\n### FOUC（浏览器样式闪烁）\n只有在IE浏览器下才会出现， 原因有：\n1.使用import方法导入样式表\n2.将样式表放在底部\n3.有几个样式表，放在HTML结构的不同位置\n解决方法：使用link标签将样式表放在head中\n\n### 不同浏览器的默认样式\n例如：ul自带margin16px\n去除默认margin和padding\n在选择器处\n```bash\n* {\n margin:0;\n padding:0;\n}\n```\n### css3动画使用\n```bash\n<img class=\"goods animated\">\n.animated {\n  animation-name:move;//移动:keyframes定义的动画\n  animation-duation: 3s;//持续时间3s\n  animation-timing-function: linear;//线性移动\n  animation-iteration-count:infinite;//无限循环\n}\n@keyframes move{\n  from{\n    transform: translateX(0)//从0点位X轴方向\n  }\n  to{\n    transform: translateX(300px)//正向移动300px\n  }\n}\n```\n---\ncss：calc（）计算样式\n```bash\nwidth: calc(100% - 80px);//普通计算\n--widthA: 100px;\n  --widthB: calc(var(--widthA) / 2);\n  --widthC: calc(var(--widthB) / 2);\n  width: var(--widthC); //变量计算\n```\noutline:外边框\n---\n\nrelative定位参考链接：https://juejin.im/post/5afb7fc7518825426d2d4aff\nabsolute定位参考链接：https://juejin.im/post/5aed4d3951882567236ea42e\n","source":"_posts/CSS样式.md","raw":"---\ntitle: CSS样式\ndate: 2020-05-09 14:59:08\ntags:\n - CSS\n - 响应式布局\ncategories: UI设计开发\n---\n\n页面UI设计与开发\n\n---\n\n## 2020/5/9 15:01 Write\n\n关键词：UI\n\n选择器优先权：important>内联>id>类>标签|伪类|属性选择|伪元素>通配符>继承\n\n注意可继承属性和不可继承属性\n\n```bash\ncursor: 改变光标的形式\nbox-sizing：使Padding往内伸缩\noutline：外边框\nfocus：获取焦点\nfont-size：0 （解决空格留白问题）\n```\n\n### 浮动的特点\n元素浮动后会脱离文档流\n浮动以后元素会一直向父元素的最上方移动\n直到遇到父元素的边框或者其他的浮动元素，会停止移动\n如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素\n浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐\n浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果\n\n### 元素浮动后的效果\n块元素：块元素脱离文档流以后（不会独占一行，宽度高度会被内容撑开）\n内联元素：脱离文档流后变成块元素\n\n### 定位\nrelative:相对于自己（相对定位）\n开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化\n相对定位元素对于自身在文档流中的位置来定位\n相对定位的元素不会脱离文档流\n相对定位不会改变元素的性质，块元素还是块元素\n相对定位的元素会提升一个层级\n使用top left right bottom偏移\n\nabsolute：相对于父标签\n同相对定位\n最近的开启了定位的祖先元素进行定位，如果所有的祖先元素没开启定位，则相对于浏览器窗口进行定位\n绝对定位的元素会完全脱离文档流\n绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行\n绝对定位会使元素提升一个层级\n\n\nfixed：相对于浏览器窗口\n特殊的绝对定位，相对于浏览器窗口定位\n永远相对于浏览器窗口进行定位，不会随滚动条滚动\n\n\n\n### 层级\n定位元素>浮动元素>文档流中的元素\n当元素开启了定位后，可以通过Z-index来设置层级\nz-index值越高越优先显示\n如果z-index值一样，或者都没有z-index则优先显示下边的元素\n父元素永远不会盖住子元素\n\n\n---\n### flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\n优点：flex布局容易上手\n缺点：浏览器兼容性比较差，只能兼容到ie9及以上\n常用属性：\nflex-direction ////控制主轴\njustify-content//主轴上的子项对齐方式\nalign-items//侧轴上的对齐方式\nflex-wrap///指定flex子项是否换行\nalign-content///适用于多行，\nalign-self////指定某个子项的对齐方式\n---\n### grid网格布局\n优点：灵活的区域网格容器和网格项\n缺点：兼容性不好\n指定display：grid\n行，列，单元格\nrepeat（重复属性），设置宽高（columns，rows）\nfr（片段），minmax（设置最大最小值）,grid-row-gap（行间隔）\ngrid-colunm-gap（设置列间隔）,grid-auto-flow（自定义排序）\n类flex布局的定位属性\n---\n### 浮动布局\n优点：元素浮动可以设置宽高，可以文字环绕图片\n缺点：元素浮动脱离文档流，容易造成父级元素高度塌陷\n元素浮动后产生BFC，靠子元素撑开高度，且浮动不能单个浮动，要多个。\n需要时还需清除浮动与闭合浮动\n浮动大多数位置靠上，靠左，靠右\n解决高度塌陷：\n开启父元素的BFC（默认关闭）\n在父元素最后添加一个DIV清除浮动\n使用after伪类清除浮动\n---\n### border style\n共八种样式：\ndotted\ndashed\nsolid\ndouble\ngroove\nridge\ninset\noutset\n\n### CSS3动画属性\n通过hover改变属性样式，在主选择器中使用transition进行动画过渡。\n包括宽度和背景颜色都可以。\n2D转换有包括：\n位移（translate）：顾名思义，在原有位置上移动\n旋转（rotate）：在原有位置上旋转，类似网易云音乐的碟盘\n变形：改变属性形状\n缩放（scale）：在原有位置上进行放大或者缩小\n也包括3D转换，属性使用不同。\n浮动：浮动后与浮动同向的margin会偏移两倍，反方向margin解决。\n浮动中间可以使用多一个div来隔开浮动的效果。\n父浮动，子不变。\n选择器的学习，需要深入。\n\n### 触发BFC：块级格式化上下文\n.body根元素\n.浮动元素：float除none以外的值\n.绝对定位元素：position（absolute，fixed）\n.display为inline-block，table-cells，flex\n.overflow除了visible以外的值（hidden，auto，scroll）\n1.BFC可以容纳浮动元素\n2.同一个BFC下外边距会发生折叠\n3.BFC可以阻止元素被浮动元素覆盖\n---\n### 层叠上下文（可以设置z-index来决定层叠）\nz-index仅在position定位和非static上起效果\n层叠等级和层级上下文决定堆叠顺序\n由html标签产生的根层叠上下文，决定权在z-index上\ninline/inline-block元素的层叠顺序要高于block/float元素\n层叠等级层叠顺序相同时，后面的覆盖前面的\n---\n### 边距折叠\n相邻的非浮动元素发生折叠\n折叠发生在垂直外边距上\n折叠后取最大的那个margin值作为最终值\n浮动元素不折叠\nmargin折叠只发生在块级元素上\n浮动元素不与其他元素margin折叠\nBFC不与它的子元素发生margin折叠\n绝对定位，根元素不与任何margin折叠\n---\n### 浏览器渲染机制\n1.HTML解析出DOM Tree\n2.CSS解析出Style Rules\n3.将二者关联生成Render Tree\n4.Layout根据Render Tree计算每个节点的信息\n5.Painting根据计算好的信息绘制整个页面\n回流（Reflow）：浏览器根据各自样式来计算结果并将元素放到它该出现的位置\n触发reflow：\n1.当增加，删除，修改DOM节点时，或是插入动画的时候\n2.当移动DOM的位置，或是插入动画的时候\n3.当修改CSS样式的时候\n4.当Resize窗口的时候，或是滚动的时候\n5.当修改网页的默认字体时\n重绘（Repaint）：盒子的各种属性确认后，浏览器按照各自的特性绘制。\n触发Repaint：\n1.DOM改动\n2.CSS改动\n回流必将引起重绘，重绘不一定会引起回流。\n### 白屏\n\n### FOUC（浏览器样式闪烁）\n只有在IE浏览器下才会出现， 原因有：\n1.使用import方法导入样式表\n2.将样式表放在底部\n3.有几个样式表，放在HTML结构的不同位置\n解决方法：使用link标签将样式表放在head中\n\n### 不同浏览器的默认样式\n例如：ul自带margin16px\n去除默认margin和padding\n在选择器处\n```bash\n* {\n margin:0;\n padding:0;\n}\n```\n### css3动画使用\n```bash\n<img class=\"goods animated\">\n.animated {\n  animation-name:move;//移动:keyframes定义的动画\n  animation-duation: 3s;//持续时间3s\n  animation-timing-function: linear;//线性移动\n  animation-iteration-count:infinite;//无限循环\n}\n@keyframes move{\n  from{\n    transform: translateX(0)//从0点位X轴方向\n  }\n  to{\n    transform: translateX(300px)//正向移动300px\n  }\n}\n```\n---\ncss：calc（）计算样式\n```bash\nwidth: calc(100% - 80px);//普通计算\n--widthA: 100px;\n  --widthB: calc(var(--widthA) / 2);\n  --widthC: calc(var(--widthB) / 2);\n  width: var(--widthC); //变量计算\n```\noutline:外边框\n---\n\nrelative定位参考链接：https://juejin.im/post/5afb7fc7518825426d2d4aff\nabsolute定位参考链接：https://juejin.im/post/5aed4d3951882567236ea42e\n","slug":"CSS样式","published":1,"updated":"2020-11-12T06:33:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow3390003pcva2wa12eyr","content":"<p>页面UI设计与开发</p>\n<hr>\n<h2 id=\"2020-5-9-15-01-Write\"><a href=\"#2020-5-9-15-01-Write\" class=\"headerlink\" title=\"2020/5/9 15:01 Write\"></a>2020/5/9 15:01 Write</h2><p>关键词：UI</p>\n<p>选择器优先权：important&gt;内联&gt;id&gt;类&gt;标签|伪类|属性选择|伪元素&gt;通配符&gt;继承</p>\n<p>注意可继承属性和不可继承属性</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cursor: 改变光标的形式</span><br><span class=\"line\">box-sizing：使Padding往内伸缩</span><br><span class=\"line\">outline：外边框</span><br><span class=\"line\">focus：获取焦点</span><br><span class=\"line\">font-size：0 （解决空格留白问题）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"浮动的特点\"><a href=\"#浮动的特点\" class=\"headerlink\" title=\"浮动的特点\"></a>浮动的特点</h3><p>元素浮动后会脱离文档流<br>浮动以后元素会一直向父元素的最上方移动<br>直到遇到父元素的边框或者其他的浮动元素，会停止移动<br>如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素<br>浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐<br>浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果</p>\n<h3 id=\"元素浮动后的效果\"><a href=\"#元素浮动后的效果\" class=\"headerlink\" title=\"元素浮动后的效果\"></a>元素浮动后的效果</h3><p>块元素：块元素脱离文档流以后（不会独占一行，宽度高度会被内容撑开）<br>内联元素：脱离文档流后变成块元素</p>\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>relative:相对于自己（相对定位）<br>开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化<br>相对定位元素对于自身在文档流中的位置来定位<br>相对定位的元素不会脱离文档流<br>相对定位不会改变元素的性质，块元素还是块元素<br>相对定位的元素会提升一个层级<br>使用top left right bottom偏移</p>\n<p>absolute：相对于父标签<br>同相对定位<br>最近的开启了定位的祖先元素进行定位，如果所有的祖先元素没开启定位，则相对于浏览器窗口进行定位<br>绝对定位的元素会完全脱离文档流<br>绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行<br>绝对定位会使元素提升一个层级</p>\n<p>fixed：相对于浏览器窗口<br>特殊的绝对定位，相对于浏览器窗口定位<br>永远相对于浏览器窗口进行定位，不会随滚动条滚动</p>\n<h3 id=\"层级\"><a href=\"#层级\" class=\"headerlink\" title=\"层级\"></a>层级</h3><p>定位元素&gt;浮动元素&gt;文档流中的元素<br>当元素开启了定位后，可以通过Z-index来设置层级<br>z-index值越高越优先显示<br>如果z-index值一样，或者都没有z-index则优先显示下边的元素<br>父元素永远不会盖住子元素</p>\n<hr>\n<h3 id=\"flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\"><a href=\"#flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\" class=\"headerlink\" title=\"flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\"></a>flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素</h3><p>优点：flex布局容易上手<br>缺点：浏览器兼容性比较差，只能兼容到ie9及以上<br>常用属性：<br>flex-direction ////控制主轴<br>justify-content//主轴上的子项对齐方式<br>align-items//侧轴上的对齐方式<br>flex-wrap///指定flex子项是否换行<br>align-content///适用于多行，<br>align-self////指定某个子项的对齐方式</p>\n<hr>\n<h3 id=\"grid网格布局\"><a href=\"#grid网格布局\" class=\"headerlink\" title=\"grid网格布局\"></a>grid网格布局</h3><p>优点：灵活的区域网格容器和网格项<br>缺点：兼容性不好<br>指定display：grid<br>行，列，单元格<br>repeat（重复属性），设置宽高（columns，rows）<br>fr（片段），minmax（设置最大最小值）,grid-row-gap（行间隔）<br>grid-colunm-gap（设置列间隔）,grid-auto-flow（自定义排序）<br>类flex布局的定位属性</p>\n<hr>\n<h3 id=\"浮动布局\"><a href=\"#浮动布局\" class=\"headerlink\" title=\"浮动布局\"></a>浮动布局</h3><p>优点：元素浮动可以设置宽高，可以文字环绕图片<br>缺点：元素浮动脱离文档流，容易造成父级元素高度塌陷<br>元素浮动后产生BFC，靠子元素撑开高度，且浮动不能单个浮动，要多个。<br>需要时还需清除浮动与闭合浮动<br>浮动大多数位置靠上，靠左，靠右<br>解决高度塌陷：<br>开启父元素的BFC（默认关闭）<br>在父元素最后添加一个DIV清除浮动<br>使用after伪类清除浮动</p>\n<hr>\n<h3 id=\"border-style\"><a href=\"#border-style\" class=\"headerlink\" title=\"border style\"></a>border style</h3><p>共八种样式：<br>dotted<br>dashed<br>solid<br>double<br>groove<br>ridge<br>inset<br>outset</p>\n<h3 id=\"CSS3动画属性\"><a href=\"#CSS3动画属性\" class=\"headerlink\" title=\"CSS3动画属性\"></a>CSS3动画属性</h3><p>通过hover改变属性样式，在主选择器中使用transition进行动画过渡。<br>包括宽度和背景颜色都可以。<br>2D转换有包括：<br>位移（translate）：顾名思义，在原有位置上移动<br>旋转（rotate）：在原有位置上旋转，类似网易云音乐的碟盘<br>变形：改变属性形状<br>缩放（scale）：在原有位置上进行放大或者缩小<br>也包括3D转换，属性使用不同。<br>浮动：浮动后与浮动同向的margin会偏移两倍，反方向margin解决。<br>浮动中间可以使用多一个div来隔开浮动的效果。<br>父浮动，子不变。<br>选择器的学习，需要深入。</p>\n<h3 id=\"触发BFC：块级格式化上下文\"><a href=\"#触发BFC：块级格式化上下文\" class=\"headerlink\" title=\"触发BFC：块级格式化上下文\"></a>触发BFC：块级格式化上下文</h3><p>.body根元素<br>.浮动元素：float除none以外的值<br>.绝对定位元素：position（absolute，fixed）<br>.display为inline-block，table-cells，flex<br>.overflow除了visible以外的值（hidden，auto，scroll）<br>1.BFC可以容纳浮动元素<br>2.同一个BFC下外边距会发生折叠<br>3.BFC可以阻止元素被浮动元素覆盖</p>\n<hr>\n<h3 id=\"层叠上下文（可以设置z-index来决定层叠）\"><a href=\"#层叠上下文（可以设置z-index来决定层叠）\" class=\"headerlink\" title=\"层叠上下文（可以设置z-index来决定层叠）\"></a>层叠上下文（可以设置z-index来决定层叠）</h3><p>z-index仅在position定位和非static上起效果<br>层叠等级和层级上下文决定堆叠顺序<br>由html标签产生的根层叠上下文，决定权在z-index上<br>inline/inline-block元素的层叠顺序要高于block/float元素<br>层叠等级层叠顺序相同时，后面的覆盖前面的</p>\n<hr>\n<h3 id=\"边距折叠\"><a href=\"#边距折叠\" class=\"headerlink\" title=\"边距折叠\"></a>边距折叠</h3><p>相邻的非浮动元素发生折叠<br>折叠发生在垂直外边距上<br>折叠后取最大的那个margin值作为最终值<br>浮动元素不折叠<br>margin折叠只发生在块级元素上<br>浮动元素不与其他元素margin折叠<br>BFC不与它的子元素发生margin折叠<br>绝对定位，根元素不与任何margin折叠</p>\n<hr>\n<h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p>1.HTML解析出DOM Tree<br>2.CSS解析出Style Rules<br>3.将二者关联生成Render Tree<br>4.Layout根据Render Tree计算每个节点的信息<br>5.Painting根据计算好的信息绘制整个页面<br>回流（Reflow）：浏览器根据各自样式来计算结果并将元素放到它该出现的位置<br>触发reflow：<br>1.当增加，删除，修改DOM节点时，或是插入动画的时候<br>2.当移动DOM的位置，或是插入动画的时候<br>3.当修改CSS样式的时候<br>4.当Resize窗口的时候，或是滚动的时候<br>5.当修改网页的默认字体时<br>重绘（Repaint）：盒子的各种属性确认后，浏览器按照各自的特性绘制。<br>触发Repaint：<br>1.DOM改动<br>2.CSS改动<br>回流必将引起重绘，重绘不一定会引起回流。</p>\n<h3 id=\"白屏\"><a href=\"#白屏\" class=\"headerlink\" title=\"白屏\"></a>白屏</h3><h3 id=\"FOUC（浏览器样式闪烁）\"><a href=\"#FOUC（浏览器样式闪烁）\" class=\"headerlink\" title=\"FOUC（浏览器样式闪烁）\"></a>FOUC（浏览器样式闪烁）</h3><p>只有在IE浏览器下才会出现， 原因有：<br>1.使用import方法导入样式表<br>2.将样式表放在底部<br>3.有几个样式表，放在HTML结构的不同位置<br>解决方法：使用link标签将样式表放在head中</p>\n<h3 id=\"不同浏览器的默认样式\"><a href=\"#不同浏览器的默认样式\" class=\"headerlink\" title=\"不同浏览器的默认样式\"></a>不同浏览器的默认样式</h3><p>例如：ul自带margin16px<br>去除默认margin和padding<br>在选择器处</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\"> margin:0;</span><br><span class=\"line\"> padding:0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"css3动画使用\"><a href=\"#css3动画使用\" class=\"headerlink\" title=\"css3动画使用\"></a>css3动画使用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img class=<span class=\"string\">\"goods animated\"</span>&gt;</span><br><span class=\"line\">.animated &#123;</span><br><span class=\"line\">  animation-name:move;//移动:keyframes定义的动画</span><br><span class=\"line\">  animation-duation: 3s;//持续时间3s</span><br><span class=\"line\">  animation-timing-function: linear;//线性移动</span><br><span class=\"line\">  animation-iteration-count:infinite;//无限循环</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes move&#123;</span><br><span class=\"line\">  from&#123;</span><br><span class=\"line\">    transform: translateX(0)//从0点位X轴方向</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  to&#123;</span><br><span class=\"line\">    transform: translateX(300px)//正向移动300px</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>css：calc（）计算样式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width: calc(100% - 80px);//普通计算</span><br><span class=\"line\">--widthA: 100px;</span><br><span class=\"line\">  --widthB: calc(var(--widthA) / 2);</span><br><span class=\"line\">  --widthC: calc(var(--widthB) / 2);</span><br><span class=\"line\">  width: var(--widthC); //变量计算</span><br></pre></td></tr></table></figure>\n<h2 id=\"outline-外边框\"><a href=\"#outline-外边框\" class=\"headerlink\" title=\"outline:外边框\"></a>outline:外边框</h2><p>relative定位参考链接：<a href=\"https://juejin.im/post/5afb7fc7518825426d2d4aff\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5afb7fc7518825426d2d4aff</a><br>absolute定位参考链接：<a href=\"https://juejin.im/post/5aed4d3951882567236ea42e\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5aed4d3951882567236ea42e</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>页面UI设计与开发</p>\n<hr>\n<h2 id=\"2020-5-9-15-01-Write\"><a href=\"#2020-5-9-15-01-Write\" class=\"headerlink\" title=\"2020/5/9 15:01 Write\"></a>2020/5/9 15:01 Write</h2><p>关键词：UI</p>\n<p>选择器优先权：important&gt;内联&gt;id&gt;类&gt;标签|伪类|属性选择|伪元素&gt;通配符&gt;继承</p>\n<p>注意可继承属性和不可继承属性</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cursor: 改变光标的形式</span><br><span class=\"line\">box-sizing：使Padding往内伸缩</span><br><span class=\"line\">outline：外边框</span><br><span class=\"line\">focus：获取焦点</span><br><span class=\"line\">font-size：0 （解决空格留白问题）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"浮动的特点\"><a href=\"#浮动的特点\" class=\"headerlink\" title=\"浮动的特点\"></a>浮动的特点</h3><p>元素浮动后会脱离文档流<br>浮动以后元素会一直向父元素的最上方移动<br>直到遇到父元素的边框或者其他的浮动元素，会停止移动<br>如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素<br>浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐<br>浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果</p>\n<h3 id=\"元素浮动后的效果\"><a href=\"#元素浮动后的效果\" class=\"headerlink\" title=\"元素浮动后的效果\"></a>元素浮动后的效果</h3><p>块元素：块元素脱离文档流以后（不会独占一行，宽度高度会被内容撑开）<br>内联元素：脱离文档流后变成块元素</p>\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>relative:相对于自己（相对定位）<br>开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化<br>相对定位元素对于自身在文档流中的位置来定位<br>相对定位的元素不会脱离文档流<br>相对定位不会改变元素的性质，块元素还是块元素<br>相对定位的元素会提升一个层级<br>使用top left right bottom偏移</p>\n<p>absolute：相对于父标签<br>同相对定位<br>最近的开启了定位的祖先元素进行定位，如果所有的祖先元素没开启定位，则相对于浏览器窗口进行定位<br>绝对定位的元素会完全脱离文档流<br>绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行<br>绝对定位会使元素提升一个层级</p>\n<p>fixed：相对于浏览器窗口<br>特殊的绝对定位，相对于浏览器窗口定位<br>永远相对于浏览器窗口进行定位，不会随滚动条滚动</p>\n<h3 id=\"层级\"><a href=\"#层级\" class=\"headerlink\" title=\"层级\"></a>层级</h3><p>定位元素&gt;浮动元素&gt;文档流中的元素<br>当元素开启了定位后，可以通过Z-index来设置层级<br>z-index值越高越优先显示<br>如果z-index值一样，或者都没有z-index则优先显示下边的元素<br>父元素永远不会盖住子元素</p>\n<hr>\n<h3 id=\"flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\"><a href=\"#flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\" class=\"headerlink\" title=\"flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素\"></a>flex布局：（flex）弹性伸缩盒展示，用于块级元素——（inline-flex）用于行内元素</h3><p>优点：flex布局容易上手<br>缺点：浏览器兼容性比较差，只能兼容到ie9及以上<br>常用属性：<br>flex-direction ////控制主轴<br>justify-content//主轴上的子项对齐方式<br>align-items//侧轴上的对齐方式<br>flex-wrap///指定flex子项是否换行<br>align-content///适用于多行，<br>align-self////指定某个子项的对齐方式</p>\n<hr>\n<h3 id=\"grid网格布局\"><a href=\"#grid网格布局\" class=\"headerlink\" title=\"grid网格布局\"></a>grid网格布局</h3><p>优点：灵活的区域网格容器和网格项<br>缺点：兼容性不好<br>指定display：grid<br>行，列，单元格<br>repeat（重复属性），设置宽高（columns，rows）<br>fr（片段），minmax（设置最大最小值）,grid-row-gap（行间隔）<br>grid-colunm-gap（设置列间隔）,grid-auto-flow（自定义排序）<br>类flex布局的定位属性</p>\n<hr>\n<h3 id=\"浮动布局\"><a href=\"#浮动布局\" class=\"headerlink\" title=\"浮动布局\"></a>浮动布局</h3><p>优点：元素浮动可以设置宽高，可以文字环绕图片<br>缺点：元素浮动脱离文档流，容易造成父级元素高度塌陷<br>元素浮动后产生BFC，靠子元素撑开高度，且浮动不能单个浮动，要多个。<br>需要时还需清除浮动与闭合浮动<br>浮动大多数位置靠上，靠左，靠右<br>解决高度塌陷：<br>开启父元素的BFC（默认关闭）<br>在父元素最后添加一个DIV清除浮动<br>使用after伪类清除浮动</p>\n<hr>\n<h3 id=\"border-style\"><a href=\"#border-style\" class=\"headerlink\" title=\"border style\"></a>border style</h3><p>共八种样式：<br>dotted<br>dashed<br>solid<br>double<br>groove<br>ridge<br>inset<br>outset</p>\n<h3 id=\"CSS3动画属性\"><a href=\"#CSS3动画属性\" class=\"headerlink\" title=\"CSS3动画属性\"></a>CSS3动画属性</h3><p>通过hover改变属性样式，在主选择器中使用transition进行动画过渡。<br>包括宽度和背景颜色都可以。<br>2D转换有包括：<br>位移（translate）：顾名思义，在原有位置上移动<br>旋转（rotate）：在原有位置上旋转，类似网易云音乐的碟盘<br>变形：改变属性形状<br>缩放（scale）：在原有位置上进行放大或者缩小<br>也包括3D转换，属性使用不同。<br>浮动：浮动后与浮动同向的margin会偏移两倍，反方向margin解决。<br>浮动中间可以使用多一个div来隔开浮动的效果。<br>父浮动，子不变。<br>选择器的学习，需要深入。</p>\n<h3 id=\"触发BFC：块级格式化上下文\"><a href=\"#触发BFC：块级格式化上下文\" class=\"headerlink\" title=\"触发BFC：块级格式化上下文\"></a>触发BFC：块级格式化上下文</h3><p>.body根元素<br>.浮动元素：float除none以外的值<br>.绝对定位元素：position（absolute，fixed）<br>.display为inline-block，table-cells，flex<br>.overflow除了visible以外的值（hidden，auto，scroll）<br>1.BFC可以容纳浮动元素<br>2.同一个BFC下外边距会发生折叠<br>3.BFC可以阻止元素被浮动元素覆盖</p>\n<hr>\n<h3 id=\"层叠上下文（可以设置z-index来决定层叠）\"><a href=\"#层叠上下文（可以设置z-index来决定层叠）\" class=\"headerlink\" title=\"层叠上下文（可以设置z-index来决定层叠）\"></a>层叠上下文（可以设置z-index来决定层叠）</h3><p>z-index仅在position定位和非static上起效果<br>层叠等级和层级上下文决定堆叠顺序<br>由html标签产生的根层叠上下文，决定权在z-index上<br>inline/inline-block元素的层叠顺序要高于block/float元素<br>层叠等级层叠顺序相同时，后面的覆盖前面的</p>\n<hr>\n<h3 id=\"边距折叠\"><a href=\"#边距折叠\" class=\"headerlink\" title=\"边距折叠\"></a>边距折叠</h3><p>相邻的非浮动元素发生折叠<br>折叠发生在垂直外边距上<br>折叠后取最大的那个margin值作为最终值<br>浮动元素不折叠<br>margin折叠只发生在块级元素上<br>浮动元素不与其他元素margin折叠<br>BFC不与它的子元素发生margin折叠<br>绝对定位，根元素不与任何margin折叠</p>\n<hr>\n<h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p>1.HTML解析出DOM Tree<br>2.CSS解析出Style Rules<br>3.将二者关联生成Render Tree<br>4.Layout根据Render Tree计算每个节点的信息<br>5.Painting根据计算好的信息绘制整个页面<br>回流（Reflow）：浏览器根据各自样式来计算结果并将元素放到它该出现的位置<br>触发reflow：<br>1.当增加，删除，修改DOM节点时，或是插入动画的时候<br>2.当移动DOM的位置，或是插入动画的时候<br>3.当修改CSS样式的时候<br>4.当Resize窗口的时候，或是滚动的时候<br>5.当修改网页的默认字体时<br>重绘（Repaint）：盒子的各种属性确认后，浏览器按照各自的特性绘制。<br>触发Repaint：<br>1.DOM改动<br>2.CSS改动<br>回流必将引起重绘，重绘不一定会引起回流。</p>\n<h3 id=\"白屏\"><a href=\"#白屏\" class=\"headerlink\" title=\"白屏\"></a>白屏</h3><h3 id=\"FOUC（浏览器样式闪烁）\"><a href=\"#FOUC（浏览器样式闪烁）\" class=\"headerlink\" title=\"FOUC（浏览器样式闪烁）\"></a>FOUC（浏览器样式闪烁）</h3><p>只有在IE浏览器下才会出现， 原因有：<br>1.使用import方法导入样式表<br>2.将样式表放在底部<br>3.有几个样式表，放在HTML结构的不同位置<br>解决方法：使用link标签将样式表放在head中</p>\n<h3 id=\"不同浏览器的默认样式\"><a href=\"#不同浏览器的默认样式\" class=\"headerlink\" title=\"不同浏览器的默认样式\"></a>不同浏览器的默认样式</h3><p>例如：ul自带margin16px<br>去除默认margin和padding<br>在选择器处</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;</span><br><span class=\"line\"> margin:0;</span><br><span class=\"line\"> padding:0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"css3动画使用\"><a href=\"#css3动画使用\" class=\"headerlink\" title=\"css3动画使用\"></a>css3动画使用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img class=<span class=\"string\">\"goods animated\"</span>&gt;</span><br><span class=\"line\">.animated &#123;</span><br><span class=\"line\">  animation-name:move;//移动:keyframes定义的动画</span><br><span class=\"line\">  animation-duation: 3s;//持续时间3s</span><br><span class=\"line\">  animation-timing-function: linear;//线性移动</span><br><span class=\"line\">  animation-iteration-count:infinite;//无限循环</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes move&#123;</span><br><span class=\"line\">  from&#123;</span><br><span class=\"line\">    transform: translateX(0)//从0点位X轴方向</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  to&#123;</span><br><span class=\"line\">    transform: translateX(300px)//正向移动300px</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>css：calc（）计算样式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width: calc(100% - 80px);//普通计算</span><br><span class=\"line\">--widthA: 100px;</span><br><span class=\"line\">  --widthB: calc(var(--widthA) / 2);</span><br><span class=\"line\">  --widthC: calc(var(--widthB) / 2);</span><br><span class=\"line\">  width: var(--widthC); //变量计算</span><br></pre></td></tr></table></figure>\n<h2 id=\"outline-外边框\"><a href=\"#outline-外边框\" class=\"headerlink\" title=\"outline:外边框\"></a>outline:外边框</h2><p>relative定位参考链接：<a href=\"https://juejin.im/post/5afb7fc7518825426d2d4aff\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5afb7fc7518825426d2d4aff</a><br>absolute定位参考链接：<a href=\"https://juejin.im/post/5aed4d3951882567236ea42e\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5aed4d3951882567236ea42e</a></p>\n"},{"title":"Flex布局","date":"2020-05-11T07:18:18.000Z","_content":"\n页面CSS样式之Flex布局\n\n---\n\n## 2020/5/11 14:56 Write\n\n关键词：UI\n\n使用flex布局\n\n```bash\n在父容器设置属性 display: flex\n```\n![Flex基本概念](Flex基本概念.png)\nFlex的核心概念就是容器和轴。容器包括外层的父容器和内层的子容器，轴包括主轴和交叉轴，Flex的布局特性构建在这两个概念上（如上图）。\n\n## 1.容器\n容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。\n\n![Flex容器](Flex容器.png)\n### 1.1父容器\n\n·设置子容器沿主轴排列：justify-content\njustify-content 属性用于定义如何沿着主轴方向排列子容器。\n\n\n![justify-content](justify-content.png)\n```bash\nflex-start:  起始端对齐\nflex-end：末尾段对齐\ncenter：居中对齐\nspace-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半\nspace-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切\n```\n·设置子容器如何沿交叉轴排列：align-items\nalign-items 属性用于定义如何沿着交叉轴方向分配子容器的间距\n![align-items](align-items.png)\n```bash\nflex-start：起始端对齐\nflex-end：末尾段对齐\ncenter：居中对齐\nbaseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线\nstretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致\n```\n### 1.2子容器\n·在主轴上如何伸缩：flex\n子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。\n flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。\n 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。\n![flex](flex.png)\n·单独设置子容器如何沿交叉轴排列：align-self\n![align-self](align-self.png)\n每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。\n```bash\nflex-start：起始端对齐\nflex-end：末尾段对齐\ncenter：居中对齐\nbaseline：基线对齐\nstretch：拉伸对齐\n```\n## 2.轴\n如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。\n![轴](轴.png)\n### 主轴\n主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。\n```bash\n向右：flex-direction: row\n向下：flex-direction: column\n向左：flex-direction: row-reverse\n向上：flex-direction: column-reverse\n```\n### 交叉轴\n主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。\n\nflex：1；默认flex-grow，flex-shrink，flex-basis的值都为1，自动等分缩短和放大。\n\n上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。\n\n参考链接https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\n深入理解Flex布局:https://juejin.im/post/5dedb28ef265da33b12e98cd\n","source":"_posts/Flex布局.md","raw":"---\ntitle: Flex布局\ndate: 2020-05-11 15:18:18\ntags:\n - CSS\n - 伸缩布局\ncategories: UI设计开发\n---\n\n页面CSS样式之Flex布局\n\n---\n\n## 2020/5/11 14:56 Write\n\n关键词：UI\n\n使用flex布局\n\n```bash\n在父容器设置属性 display: flex\n```\n![Flex基本概念](Flex基本概念.png)\nFlex的核心概念就是容器和轴。容器包括外层的父容器和内层的子容器，轴包括主轴和交叉轴，Flex的布局特性构建在这两个概念上（如上图）。\n\n## 1.容器\n容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。\n\n![Flex容器](Flex容器.png)\n### 1.1父容器\n\n·设置子容器沿主轴排列：justify-content\njustify-content 属性用于定义如何沿着主轴方向排列子容器。\n\n\n![justify-content](justify-content.png)\n```bash\nflex-start:  起始端对齐\nflex-end：末尾段对齐\ncenter：居中对齐\nspace-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半\nspace-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切\n```\n·设置子容器如何沿交叉轴排列：align-items\nalign-items 属性用于定义如何沿着交叉轴方向分配子容器的间距\n![align-items](align-items.png)\n```bash\nflex-start：起始端对齐\nflex-end：末尾段对齐\ncenter：居中对齐\nbaseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线\nstretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致\n```\n### 1.2子容器\n·在主轴上如何伸缩：flex\n子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。\n flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。\n 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。\n![flex](flex.png)\n·单独设置子容器如何沿交叉轴排列：align-self\n![align-self](align-self.png)\n每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。\n```bash\nflex-start：起始端对齐\nflex-end：末尾段对齐\ncenter：居中对齐\nbaseline：基线对齐\nstretch：拉伸对齐\n```\n## 2.轴\n如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。\n![轴](轴.png)\n### 主轴\n主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。\n```bash\n向右：flex-direction: row\n向下：flex-direction: column\n向左：flex-direction: row-reverse\n向上：flex-direction: column-reverse\n```\n### 交叉轴\n主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。\n\nflex：1；默认flex-grow，flex-shrink，flex-basis的值都为1，自动等分缩短和放大。\n\n上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。\n\n参考链接https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\n深入理解Flex布局:https://juejin.im/post/5dedb28ef265da33b12e98cd\n","slug":"Flex布局","published":1,"updated":"2020-08-13T07:41:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow33c0006pcva70baddbt","content":"<p>页面CSS样式之Flex布局</p>\n<hr>\n<h2 id=\"2020-5-11-14-56-Write\"><a href=\"#2020-5-11-14-56-Write\" class=\"headerlink\" title=\"2020/5/11 14:56 Write\"></a>2020/5/11 14:56 Write</h2><p>关键词：UI</p>\n<p>使用flex布局</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在父容器设置属性 display: flex</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/Flex%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png\" alt=\"Flex基本概念\"><br>Flex的核心概念就是容器和轴。容器包括外层的父容器和内层的子容器，轴包括主轴和交叉轴，Flex的布局特性构建在这两个概念上（如上图）。</p>\n<h2 id=\"1-容器\"><a href=\"#1-容器\" class=\"headerlink\" title=\"1.容器\"></a>1.容器</h2><p>容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。</p>\n<p><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/Flex%E5%AE%B9%E5%99%A8.png\" alt=\"Flex容器\"></p>\n<h3 id=\"1-1父容器\"><a href=\"#1-1父容器\" class=\"headerlink\" title=\"1.1父容器\"></a>1.1父容器</h3><p>·设置子容器沿主轴排列：justify-content<br>justify-content 属性用于定义如何沿着主轴方向排列子容器。</p>\n<p><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/justify-content.png\" alt=\"justify-content\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start:  起始端对齐</span><br><span class=\"line\">flex-end：末尾段对齐</span><br><span class=\"line\">center：居中对齐</span><br><span class=\"line\">space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半</span><br><span class=\"line\">space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切</span><br></pre></td></tr></table></figure>\n<p>·设置子容器如何沿交叉轴排列：align-items<br>align-items 属性用于定义如何沿着交叉轴方向分配子容器的间距<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/align-items.png\" alt=\"align-items\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start：起始端对齐</span><br><span class=\"line\">flex-end：末尾段对齐</span><br><span class=\"line\">center：居中对齐</span><br><span class=\"line\">baseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线</span><br><span class=\"line\">stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2子容器\"><a href=\"#1-2子容器\" class=\"headerlink\" title=\"1.2子容器\"></a>1.2子容器</h3><p>·在主轴上如何伸缩：flex<br>子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。<br> flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。<br> 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/flex.png\" alt=\"flex\"><br>·单独设置子容器如何沿交叉轴排列：align-self<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/align-self.png\" alt=\"align-self\"><br>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start：起始端对齐</span><br><span class=\"line\">flex-end：末尾段对齐</span><br><span class=\"line\">center：居中对齐</span><br><span class=\"line\">baseline：基线对齐</span><br><span class=\"line\">stretch：拉伸对齐</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-轴\"><a href=\"#2-轴\" class=\"headerlink\" title=\"2.轴\"></a>2.轴</h2><p>如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/%E8%BD%B4.png\" alt=\"轴\"></p>\n<h3 id=\"主轴\"><a href=\"#主轴\" class=\"headerlink\" title=\"主轴\"></a>主轴</h3><p>主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">向右：flex-direction: row</span><br><span class=\"line\">向下：flex-direction: column</span><br><span class=\"line\">向左：flex-direction: row-reverse</span><br><span class=\"line\">向上：flex-direction: column-reverse</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉轴\"><a href=\"#交叉轴\" class=\"headerlink\" title=\"交叉轴\"></a>交叉轴</h3><p>主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。</p>\n<p>flex：1；默认flex-grow，flex-shrink，flex-basis的值都为1，自动等分缩短和放大。</p>\n<p>上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。</p>\n<p>参考链接<a href=\"https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb</a><br>深入理解Flex布局:<a href=\"https://juejin.im/post/5dedb28ef265da33b12e98cd\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5dedb28ef265da33b12e98cd</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>页面CSS样式之Flex布局</p>\n<hr>\n<h2 id=\"2020-5-11-14-56-Write\"><a href=\"#2020-5-11-14-56-Write\" class=\"headerlink\" title=\"2020/5/11 14:56 Write\"></a>2020/5/11 14:56 Write</h2><p>关键词：UI</p>\n<p>使用flex布局</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在父容器设置属性 display: flex</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/Flex%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png\" alt=\"Flex基本概念\"><br>Flex的核心概念就是容器和轴。容器包括外层的父容器和内层的子容器，轴包括主轴和交叉轴，Flex的布局特性构建在这两个概念上（如上图）。</p>\n<h2 id=\"1-容器\"><a href=\"#1-容器\" class=\"headerlink\" title=\"1.容器\"></a>1.容器</h2><p>容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。</p>\n<p><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/Flex%E5%AE%B9%E5%99%A8.png\" alt=\"Flex容器\"></p>\n<h3 id=\"1-1父容器\"><a href=\"#1-1父容器\" class=\"headerlink\" title=\"1.1父容器\"></a>1.1父容器</h3><p>·设置子容器沿主轴排列：justify-content<br>justify-content 属性用于定义如何沿着主轴方向排列子容器。</p>\n<p><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/justify-content.png\" alt=\"justify-content\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start:  起始端对齐</span><br><span class=\"line\">flex-end：末尾段对齐</span><br><span class=\"line\">center：居中对齐</span><br><span class=\"line\">space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半</span><br><span class=\"line\">space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切</span><br></pre></td></tr></table></figure>\n<p>·设置子容器如何沿交叉轴排列：align-items<br>align-items 属性用于定义如何沿着交叉轴方向分配子容器的间距<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/align-items.png\" alt=\"align-items\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start：起始端对齐</span><br><span class=\"line\">flex-end：末尾段对齐</span><br><span class=\"line\">center：居中对齐</span><br><span class=\"line\">baseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线</span><br><span class=\"line\">stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2子容器\"><a href=\"#1-2子容器\" class=\"headerlink\" title=\"1.2子容器\"></a>1.2子容器</h3><p>·在主轴上如何伸缩：flex<br>子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。<br> flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。<br> 虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/flex.png\" alt=\"flex\"><br>·单独设置子容器如何沿交叉轴排列：align-self<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/align-self.png\" alt=\"align-self\"><br>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-start：起始端对齐</span><br><span class=\"line\">flex-end：末尾段对齐</span><br><span class=\"line\">center：居中对齐</span><br><span class=\"line\">baseline：基线对齐</span><br><span class=\"line\">stretch：拉伸对齐</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-轴\"><a href=\"#2-轴\" class=\"headerlink\" title=\"2.轴\"></a>2.轴</h2><p>如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。<br><img src=\"/2020/05/11/Flex%E5%B8%83%E5%B1%80/%E8%BD%B4.png\" alt=\"轴\"></p>\n<h3 id=\"主轴\"><a href=\"#主轴\" class=\"headerlink\" title=\"主轴\"></a>主轴</h3><p>主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">向右：flex-direction: row</span><br><span class=\"line\">向下：flex-direction: column</span><br><span class=\"line\">向左：flex-direction: row-reverse</span><br><span class=\"line\">向上：flex-direction: column-reverse</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉轴\"><a href=\"#交叉轴\" class=\"headerlink\" title=\"交叉轴\"></a>交叉轴</h3><p>主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。</p>\n<p>flex：1；默认flex-grow，flex-shrink，flex-basis的值都为1，自动等分缩短和放大。</p>\n<p>上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。</p>\n<p>参考链接<a href=\"https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb</a><br>深入理解Flex布局:<a href=\"https://juejin.im/post/5dedb28ef265da33b12e98cd\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5dedb28ef265da33b12e98cd</a></p>\n"},{"title":"Git和SVN的使用","date":"2020-06-30T02:18:47.000Z","_content":"\n## git和svn的区别\n\n```bash\nGit是分布式的，SVN是集中式的。Git支持离线工作，SVN必须联网才能正常工作。\nGit复杂概念多，SVN简单易上手。Git分支是指针指向某次提交，而SVN分支是拷贝的目录，这个特性使Git的分支切换非常迅速，创建成本非常低。\nGit有本地分支，SVN无。\n```\n\n## git核心概念\n```bash\n工作流：工作区（Workspace）电脑中实际的目录，暂存区（Index）类似于缓存区域，仓库区（Repository）本地仓库和 远程仓库。\ngit add：从工作区提交到暂存区\ngit commit：从暂存区提交到本地仓库\ngit push或git SVN dcommit：从本地仓库提交到远程仓库\n以下为git命令\n```\n![Git命令](git命令.jpg)\n\n![SVN-Git](svn-git.png)\n## git-svn常用命令\n```bash\n# 下载一个 SVN 项目和它的整个代码历史，并初始化为 Git 代码库\n$ git svn clone -s [repository]\n# 查看当前版本库情况\n$ git svn info\n# 取回远程仓库所有分支的变化\n$ git svn fetch\n# 取回远程仓库当前分支的变化，并与本地分支变基合并\n$ git svn rebase\n# 上传当前分支的本地仓库到远程仓库\n$ git svn dcommit\n# 拉取新分支，并提交到远程仓库\n$ svn copy [remote_branch] [new_remote_branch] -m [message]\n# 创建远程分支对应的本地分支\n$ git checkout -b [local_branch] [remote_branch]\n```\n## Git命令指南\n```bash\n# 在当前目录新建一个Git代码库\n$ git init\n# 下载一个项目和它的整个代码历史 [Git only]\n$ git clone [url]\n# 列举所有配置\n$ git config -l\n# 为命令配置别名\n$ git config --global alias.co checkout\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n$ git config --global alias.br branch\n# 设置提交代码时的用户信息\n$ git config [--global] user.name [name]\n$ git config [--global] user.email [email address]\nGit 用户的配置文件位于 ~/.gitconfig\nGit 单个仓库的配置文件位于 ~/$PROJECT_PATH/.git/config\n# 添加当前目录的所有文件到暂存区\n$ git add .\n# 添加指定文件到暂存区\n$ git add <file1> <file2> ...\n# 添加指定目录到暂存区，包括其子目录\n$ git add <dir>\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n把文件名 file1 添加到 .gitignore 文件里，Git 会停止跟踪 file1 的状态。\n# 列出所有本地分支\n$ git branch\n# 列出所有本地分支和远程分支\n$ git branch -a\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n# 新建一个分支，并切换到该分支\n$ git checkout -b [new_branch] [remote-branch]\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n# 合并指定分支到当前分支\n$ git merge [branch]\n# 选择一个 commit，合并进当前分支\n$ git cherry-pick [commit]\n# 删除本地分支，-D 参数强制删除分支\n$ git branch -d [branch-name]\n# 删除远程分支\n$ git push [remote] :[remote-branch]\n# 提交暂存区到仓库区\n$ git commit -m [message]\n# 提交工作区与暂存区的变化直接到仓库区\n$ git commit -a\n# 提交时显示所有 diff 信息\n$ git commit -v\n# 提交暂存区修改到仓库区，合并到上次修改，并修改上次的提交信息\n$ git commit --amend -m [message]\n# 上传本地指定分支到远程仓库\n$ git push [remote] [remote-branch]\n# 下载远程仓库的所有变动 (Git only)\n$ git fetch [remote]\n# 显示所有远程仓库 (Git only)\n$ git remote -v\n# 显示某个远程仓库的信息 (Git only)\n$ git remote show [remote]\n# 增加一个新的远程仓库，并命名 (Git only)\n$ git remote add [remote-name] [url]\n# 取回远程仓库的变化，并与本地分支合并，(Git only), 若使用 Git-SVN，请查看第三节\n$ git pull [remote] [branch]\n# 取回远程仓库的变化，并与本地分支变基合并，(Git only), 若使用 Git-SVN，请查看第三节\n$ git pull --rebase [remote] [branch]\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n# 恢复暂存区当前目录的所有文件到工作区\n$ git checkout .\n# 恢复工作区到指定 commit\n$ git checkout [commit]\n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n$ git reset [file]\n# 重置暂存区与工作区，与上一次 commit 保持一致\n$ git reset --hard\n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n# 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n$ git reset --hard [commit]\n# 新建一个 commit，用于撤销指定 commit\n$ git revert [commit]\n# 将未提交的变化放在储藏区\n$ git stash\n# 将储藏区的内容恢复到当前工作区\n$ git stash pop\n# 查看工作区文件修改状态\n$ git status\n# 查看工作区文件修改具体内容\n$ git diff [file]\n# 查看暂存区文件修改内容\n$ git diff --cached [file]\n# 查看版本库修改记录\n$ git log\n# 查看某人提交记录\n$ git log --author=someone\n# 查看某个文件的历史具体修改内容\n$ git log -p [file]\n# 查看某次提交具体修改内容\n$ git show [commit]\n```\n2020/7/13 SVNupdate失败，本地文件中有打开更新的文件。\n报错：需要执行clean up命令，执行并勾选break lock，解决。\n\ngit常用指令地址:[git命令：阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)","source":"_posts/Git和SVN的使用.md","raw":"---\ntitle: Git和SVN的使用\ndate: 2020-06-30 10:18:47\ntags:\n - 版本管理\ncategories: 版本管理工具\n---\n\n## git和svn的区别\n\n```bash\nGit是分布式的，SVN是集中式的。Git支持离线工作，SVN必须联网才能正常工作。\nGit复杂概念多，SVN简单易上手。Git分支是指针指向某次提交，而SVN分支是拷贝的目录，这个特性使Git的分支切换非常迅速，创建成本非常低。\nGit有本地分支，SVN无。\n```\n\n## git核心概念\n```bash\n工作流：工作区（Workspace）电脑中实际的目录，暂存区（Index）类似于缓存区域，仓库区（Repository）本地仓库和 远程仓库。\ngit add：从工作区提交到暂存区\ngit commit：从暂存区提交到本地仓库\ngit push或git SVN dcommit：从本地仓库提交到远程仓库\n以下为git命令\n```\n![Git命令](git命令.jpg)\n\n![SVN-Git](svn-git.png)\n## git-svn常用命令\n```bash\n# 下载一个 SVN 项目和它的整个代码历史，并初始化为 Git 代码库\n$ git svn clone -s [repository]\n# 查看当前版本库情况\n$ git svn info\n# 取回远程仓库所有分支的变化\n$ git svn fetch\n# 取回远程仓库当前分支的变化，并与本地分支变基合并\n$ git svn rebase\n# 上传当前分支的本地仓库到远程仓库\n$ git svn dcommit\n# 拉取新分支，并提交到远程仓库\n$ svn copy [remote_branch] [new_remote_branch] -m [message]\n# 创建远程分支对应的本地分支\n$ git checkout -b [local_branch] [remote_branch]\n```\n## Git命令指南\n```bash\n# 在当前目录新建一个Git代码库\n$ git init\n# 下载一个项目和它的整个代码历史 [Git only]\n$ git clone [url]\n# 列举所有配置\n$ git config -l\n# 为命令配置别名\n$ git config --global alias.co checkout\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n$ git config --global alias.br branch\n# 设置提交代码时的用户信息\n$ git config [--global] user.name [name]\n$ git config [--global] user.email [email address]\nGit 用户的配置文件位于 ~/.gitconfig\nGit 单个仓库的配置文件位于 ~/$PROJECT_PATH/.git/config\n# 添加当前目录的所有文件到暂存区\n$ git add .\n# 添加指定文件到暂存区\n$ git add <file1> <file2> ...\n# 添加指定目录到暂存区，包括其子目录\n$ git add <dir>\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n把文件名 file1 添加到 .gitignore 文件里，Git 会停止跟踪 file1 的状态。\n# 列出所有本地分支\n$ git branch\n# 列出所有本地分支和远程分支\n$ git branch -a\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n# 新建一个分支，并切换到该分支\n$ git checkout -b [new_branch] [remote-branch]\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n# 合并指定分支到当前分支\n$ git merge [branch]\n# 选择一个 commit，合并进当前分支\n$ git cherry-pick [commit]\n# 删除本地分支，-D 参数强制删除分支\n$ git branch -d [branch-name]\n# 删除远程分支\n$ git push [remote] :[remote-branch]\n# 提交暂存区到仓库区\n$ git commit -m [message]\n# 提交工作区与暂存区的变化直接到仓库区\n$ git commit -a\n# 提交时显示所有 diff 信息\n$ git commit -v\n# 提交暂存区修改到仓库区，合并到上次修改，并修改上次的提交信息\n$ git commit --amend -m [message]\n# 上传本地指定分支到远程仓库\n$ git push [remote] [remote-branch]\n# 下载远程仓库的所有变动 (Git only)\n$ git fetch [remote]\n# 显示所有远程仓库 (Git only)\n$ git remote -v\n# 显示某个远程仓库的信息 (Git only)\n$ git remote show [remote]\n# 增加一个新的远程仓库，并命名 (Git only)\n$ git remote add [remote-name] [url]\n# 取回远程仓库的变化，并与本地分支合并，(Git only), 若使用 Git-SVN，请查看第三节\n$ git pull [remote] [branch]\n# 取回远程仓库的变化，并与本地分支变基合并，(Git only), 若使用 Git-SVN，请查看第三节\n$ git pull --rebase [remote] [branch]\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n# 恢复暂存区当前目录的所有文件到工作区\n$ git checkout .\n# 恢复工作区到指定 commit\n$ git checkout [commit]\n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n$ git reset [file]\n# 重置暂存区与工作区，与上一次 commit 保持一致\n$ git reset --hard\n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n# 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n$ git reset --hard [commit]\n# 新建一个 commit，用于撤销指定 commit\n$ git revert [commit]\n# 将未提交的变化放在储藏区\n$ git stash\n# 将储藏区的内容恢复到当前工作区\n$ git stash pop\n# 查看工作区文件修改状态\n$ git status\n# 查看工作区文件修改具体内容\n$ git diff [file]\n# 查看暂存区文件修改内容\n$ git diff --cached [file]\n# 查看版本库修改记录\n$ git log\n# 查看某人提交记录\n$ git log --author=someone\n# 查看某个文件的历史具体修改内容\n$ git log -p [file]\n# 查看某次提交具体修改内容\n$ git show [commit]\n```\n2020/7/13 SVNupdate失败，本地文件中有打开更新的文件。\n报错：需要执行clean up命令，执行并勾选break lock，解决。\n\ngit常用指令地址:[git命令：阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)","slug":"Git和SVN的使用","published":1,"updated":"2021-01-19T06:51:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow33d0007pcvadu38e1ea","content":"<h2 id=\"git和svn的区别\"><a href=\"#git和svn的区别\" class=\"headerlink\" title=\"git和svn的区别\"></a>git和svn的区别</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git是分布式的，SVN是集中式的。Git支持离线工作，SVN必须联网才能正常工作。</span><br><span class=\"line\">Git复杂概念多，SVN简单易上手。Git分支是指针指向某次提交，而SVN分支是拷贝的目录，这个特性使Git的分支切换非常迅速，创建成本非常低。</span><br><span class=\"line\">Git有本地分支，SVN无。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"git核心概念\"><a href=\"#git核心概念\" class=\"headerlink\" title=\"git核心概念\"></a>git核心概念</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工作流：工作区（Workspace）电脑中实际的目录，暂存区（Index）类似于缓存区域，仓库区（Repository）本地仓库和 远程仓库。</span><br><span class=\"line\">git add：从工作区提交到暂存区</span><br><span class=\"line\">git commit：从暂存区提交到本地仓库</span><br><span class=\"line\">git push或git SVN dcommit：从本地仓库提交到远程仓库</span><br><span class=\"line\">以下为git命令</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/06/30/Git%E5%92%8CSVN%E7%9A%84%E4%BD%BF%E7%94%A8/git%E5%91%BD%E4%BB%A4.jpg\" alt=\"Git命令\"></p>\n<p><img src=\"/2020/06/30/Git%E5%92%8CSVN%E7%9A%84%E4%BD%BF%E7%94%A8/svn-git.png\" alt=\"SVN-Git\"></p>\n<h2 id=\"git-svn常用命令\"><a href=\"#git-svn常用命令\" class=\"headerlink\" title=\"git-svn常用命令\"></a>git-svn常用命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载一个 SVN 项目和它的整个代码历史，并初始化为 Git 代码库</span></span><br><span class=\"line\">$ git svn <span class=\"built_in\">clone</span> -s [repository]</span><br><span class=\"line\"><span class=\"comment\"># 查看当前版本库情况</span></span><br><span class=\"line\">$ git svn info</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库所有分支的变化</span></span><br><span class=\"line\">$ git svn fetch</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库当前分支的变化，并与本地分支变基合并</span></span><br><span class=\"line\">$ git svn rebase</span><br><span class=\"line\"><span class=\"comment\"># 上传当前分支的本地仓库到远程仓库</span></span><br><span class=\"line\">$ git svn dcommit</span><br><span class=\"line\"><span class=\"comment\"># 拉取新分支，并提交到远程仓库</span></span><br><span class=\"line\">$ svn copy [remote_branch] [new_remote_branch] -m [message]</span><br><span class=\"line\"><span class=\"comment\"># 创建远程分支对应的本地分支</span></span><br><span class=\"line\">$ git checkout -b [local_branch] [remote_branch]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git命令指南\"><a href=\"#Git命令指南\" class=\"headerlink\" title=\"Git命令指南\"></a>Git命令指南</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在当前目录新建一个Git代码库</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\"><span class=\"comment\"># 下载一个项目和它的整个代码历史 [Git only]</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> [url]</span><br><span class=\"line\"><span class=\"comment\"># 列举所有配置</span></span><br><span class=\"line\">$ git config -l</span><br><span class=\"line\"><span class=\"comment\"># 为命令配置别名</span></span><br><span class=\"line\">$ git config --global alias.co checkout</span><br><span class=\"line\">$ git config --global alias.ci commit</span><br><span class=\"line\">$ git config --global alias.st status</span><br><span class=\"line\">$ git config --global alias.br branch</span><br><span class=\"line\"><span class=\"comment\"># 设置提交代码时的用户信息</span></span><br><span class=\"line\">$ git config [--global] user.name [name]</span><br><span class=\"line\">$ git config [--global] user.email [email address]</span><br><span class=\"line\">Git 用户的配置文件位于 ~/.gitconfig</span><br><span class=\"line\">Git 单个仓库的配置文件位于 ~/<span class=\"variable\">$PROJECT_PATH</span>/.git/config</span><br><span class=\"line\"><span class=\"comment\"># 添加当前目录的所有文件到暂存区</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"><span class=\"comment\"># 添加指定文件到暂存区</span></span><br><span class=\"line\">$ git add &lt;file1&gt; &lt;file2&gt; ...</span><br><span class=\"line\"><span class=\"comment\"># 添加指定目录到暂存区，包括其子目录</span></span><br><span class=\"line\">$ git add &lt;dir&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"><span class=\"comment\"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"><span class=\"comment\"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br><span class=\"line\">把文件名 file1 添加到 .gitignore 文件里，Git 会停止跟踪 file1 的状态。</span><br><span class=\"line\"><span class=\"comment\"># 列出所有本地分支</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"><span class=\"comment\"># 列出所有本地分支和远程分支</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但依然停留在当前分支</span></span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该分支</span></span><br><span class=\"line\">$ git checkout -b [new_branch] [remote-branch]</span><br><span class=\"line\"><span class=\"comment\"># 切换到指定分支，并更新工作区</span></span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"><span class=\"comment\"># 合并指定分支到当前分支</span></span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"><span class=\"comment\"># 选择一个 commit，合并进当前分支</span></span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"><span class=\"comment\"># 删除本地分支，-D 参数强制删除分支</span></span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">$ git push [remote] :[remote-branch]</span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区到仓库区</span></span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"><span class=\"comment\"># 提交工作区与暂存区的变化直接到仓库区</span></span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"><span class=\"comment\"># 提交时显示所有 diff 信息</span></span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区修改到仓库区，合并到上次修改，并修改上次的提交信息</span></span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"><span class=\"comment\"># 上传本地指定分支到远程仓库</span></span><br><span class=\"line\">$ git push [remote] [remote-branch]</span><br><span class=\"line\"><span class=\"comment\"># 下载远程仓库的所有变动 (Git only)</span></span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"><span class=\"comment\"># 显示所有远程仓库 (Git only)</span></span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"><span class=\"comment\"># 显示某个远程仓库的信息 (Git only)</span></span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"><span class=\"comment\"># 增加一个新的远程仓库，并命名 (Git only)</span></span><br><span class=\"line\">$ git remote add [remote-name] [url]</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库的变化，并与本地分支合并，(Git only), 若使用 Git-SVN，请查看第三节</span></span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库的变化，并与本地分支变基合并，(Git only), 若使用 Git-SVN，请查看第三节</span></span><br><span class=\"line\">$ git pull --rebase [remote] [branch]</span><br><span class=\"line\"><span class=\"comment\"># 恢复暂存区的指定文件到工作区</span></span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"><span class=\"comment\"># 恢复暂存区当前目录的所有文件到工作区</span></span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"><span class=\"comment\"># 恢复工作区到指定 commit</span></span><br><span class=\"line\">$ git checkout [commit]</span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span></span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区与工作区，与上一次 commit 保持一致</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span></span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span></span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"><span class=\"comment\"># 新建一个 commit，用于撤销指定 commit</span></span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"><span class=\"comment\"># 将未提交的变化放在储藏区</span></span><br><span class=\"line\">$ git stash</span><br><span class=\"line\"><span class=\"comment\"># 将储藏区的内容恢复到当前工作区</span></span><br><span class=\"line\">$ git stash pop</span><br><span class=\"line\"><span class=\"comment\"># 查看工作区文件修改状态</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># 查看工作区文件修改具体内容</span></span><br><span class=\"line\">$ git diff [file]</span><br><span class=\"line\"><span class=\"comment\"># 查看暂存区文件修改内容</span></span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"><span class=\"comment\"># 查看版本库修改记录</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"comment\"># 查看某人提交记录</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --author=someone</span><br><span class=\"line\"><span class=\"comment\"># 查看某个文件的历史具体修改内容</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -p [file]</span><br><span class=\"line\"><span class=\"comment\"># 查看某次提交具体修改内容</span></span><br><span class=\"line\">$ git show [commit]</span><br></pre></td></tr></table></figure>\n<p>2020/7/13 SVNupdate失败，本地文件中有打开更新的文件。<br>报错：需要执行clean up命令，执行并勾选break lock，解决。</p>\n<p>git常用指令地址:<a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">git命令：阮一峰</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"git和svn的区别\"><a href=\"#git和svn的区别\" class=\"headerlink\" title=\"git和svn的区别\"></a>git和svn的区别</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git是分布式的，SVN是集中式的。Git支持离线工作，SVN必须联网才能正常工作。</span><br><span class=\"line\">Git复杂概念多，SVN简单易上手。Git分支是指针指向某次提交，而SVN分支是拷贝的目录，这个特性使Git的分支切换非常迅速，创建成本非常低。</span><br><span class=\"line\">Git有本地分支，SVN无。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"git核心概念\"><a href=\"#git核心概念\" class=\"headerlink\" title=\"git核心概念\"></a>git核心概念</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工作流：工作区（Workspace）电脑中实际的目录，暂存区（Index）类似于缓存区域，仓库区（Repository）本地仓库和 远程仓库。</span><br><span class=\"line\">git add：从工作区提交到暂存区</span><br><span class=\"line\">git commit：从暂存区提交到本地仓库</span><br><span class=\"line\">git push或git SVN dcommit：从本地仓库提交到远程仓库</span><br><span class=\"line\">以下为git命令</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/06/30/Git%E5%92%8CSVN%E7%9A%84%E4%BD%BF%E7%94%A8/git%E5%91%BD%E4%BB%A4.jpg\" alt=\"Git命令\"></p>\n<p><img src=\"/2020/06/30/Git%E5%92%8CSVN%E7%9A%84%E4%BD%BF%E7%94%A8/svn-git.png\" alt=\"SVN-Git\"></p>\n<h2 id=\"git-svn常用命令\"><a href=\"#git-svn常用命令\" class=\"headerlink\" title=\"git-svn常用命令\"></a>git-svn常用命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载一个 SVN 项目和它的整个代码历史，并初始化为 Git 代码库</span></span><br><span class=\"line\">$ git svn <span class=\"built_in\">clone</span> -s [repository]</span><br><span class=\"line\"><span class=\"comment\"># 查看当前版本库情况</span></span><br><span class=\"line\">$ git svn info</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库所有分支的变化</span></span><br><span class=\"line\">$ git svn fetch</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库当前分支的变化，并与本地分支变基合并</span></span><br><span class=\"line\">$ git svn rebase</span><br><span class=\"line\"><span class=\"comment\"># 上传当前分支的本地仓库到远程仓库</span></span><br><span class=\"line\">$ git svn dcommit</span><br><span class=\"line\"><span class=\"comment\"># 拉取新分支，并提交到远程仓库</span></span><br><span class=\"line\">$ svn copy [remote_branch] [new_remote_branch] -m [message]</span><br><span class=\"line\"><span class=\"comment\"># 创建远程分支对应的本地分支</span></span><br><span class=\"line\">$ git checkout -b [local_branch] [remote_branch]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git命令指南\"><a href=\"#Git命令指南\" class=\"headerlink\" title=\"Git命令指南\"></a>Git命令指南</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在当前目录新建一个Git代码库</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\"><span class=\"comment\"># 下载一个项目和它的整个代码历史 [Git only]</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> [url]</span><br><span class=\"line\"><span class=\"comment\"># 列举所有配置</span></span><br><span class=\"line\">$ git config -l</span><br><span class=\"line\"><span class=\"comment\"># 为命令配置别名</span></span><br><span class=\"line\">$ git config --global alias.co checkout</span><br><span class=\"line\">$ git config --global alias.ci commit</span><br><span class=\"line\">$ git config --global alias.st status</span><br><span class=\"line\">$ git config --global alias.br branch</span><br><span class=\"line\"><span class=\"comment\"># 设置提交代码时的用户信息</span></span><br><span class=\"line\">$ git config [--global] user.name [name]</span><br><span class=\"line\">$ git config [--global] user.email [email address]</span><br><span class=\"line\">Git 用户的配置文件位于 ~/.gitconfig</span><br><span class=\"line\">Git 单个仓库的配置文件位于 ~/<span class=\"variable\">$PROJECT_PATH</span>/.git/config</span><br><span class=\"line\"><span class=\"comment\"># 添加当前目录的所有文件到暂存区</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"><span class=\"comment\"># 添加指定文件到暂存区</span></span><br><span class=\"line\">$ git add &lt;file1&gt; &lt;file2&gt; ...</span><br><span class=\"line\"><span class=\"comment\"># 添加指定目录到暂存区，包括其子目录</span></span><br><span class=\"line\">$ git add &lt;dir&gt;</span><br><span class=\"line\"><span class=\"comment\"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"><span class=\"comment\"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"><span class=\"comment\"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br><span class=\"line\">把文件名 file1 添加到 .gitignore 文件里，Git 会停止跟踪 file1 的状态。</span><br><span class=\"line\"><span class=\"comment\"># 列出所有本地分支</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"><span class=\"comment\"># 列出所有本地分支和远程分支</span></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但依然停留在当前分支</span></span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该分支</span></span><br><span class=\"line\">$ git checkout -b [new_branch] [remote-branch]</span><br><span class=\"line\"><span class=\"comment\"># 切换到指定分支，并更新工作区</span></span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"><span class=\"comment\"># 合并指定分支到当前分支</span></span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"><span class=\"comment\"># 选择一个 commit，合并进当前分支</span></span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"><span class=\"comment\"># 删除本地分支，-D 参数强制删除分支</span></span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">$ git push [remote] :[remote-branch]</span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区到仓库区</span></span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"><span class=\"comment\"># 提交工作区与暂存区的变化直接到仓库区</span></span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"><span class=\"comment\"># 提交时显示所有 diff 信息</span></span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区修改到仓库区，合并到上次修改，并修改上次的提交信息</span></span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"><span class=\"comment\"># 上传本地指定分支到远程仓库</span></span><br><span class=\"line\">$ git push [remote] [remote-branch]</span><br><span class=\"line\"><span class=\"comment\"># 下载远程仓库的所有变动 (Git only)</span></span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"><span class=\"comment\"># 显示所有远程仓库 (Git only)</span></span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"><span class=\"comment\"># 显示某个远程仓库的信息 (Git only)</span></span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"><span class=\"comment\"># 增加一个新的远程仓库，并命名 (Git only)</span></span><br><span class=\"line\">$ git remote add [remote-name] [url]</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库的变化，并与本地分支合并，(Git only), 若使用 Git-SVN，请查看第三节</span></span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"><span class=\"comment\"># 取回远程仓库的变化，并与本地分支变基合并，(Git only), 若使用 Git-SVN，请查看第三节</span></span><br><span class=\"line\">$ git pull --rebase [remote] [branch]</span><br><span class=\"line\"><span class=\"comment\"># 恢复暂存区的指定文件到工作区</span></span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"><span class=\"comment\"># 恢复暂存区当前目录的所有文件到工作区</span></span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"><span class=\"comment\"># 恢复工作区到指定 commit</span></span><br><span class=\"line\">$ git checkout [commit]</span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span></span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"><span class=\"comment\"># 重置暂存区与工作区，与上一次 commit 保持一致</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span></span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"><span class=\"comment\"># 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span></span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"><span class=\"comment\"># 新建一个 commit，用于撤销指定 commit</span></span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"><span class=\"comment\"># 将未提交的变化放在储藏区</span></span><br><span class=\"line\">$ git stash</span><br><span class=\"line\"><span class=\"comment\"># 将储藏区的内容恢复到当前工作区</span></span><br><span class=\"line\">$ git stash pop</span><br><span class=\"line\"><span class=\"comment\"># 查看工作区文件修改状态</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># 查看工作区文件修改具体内容</span></span><br><span class=\"line\">$ git diff [file]</span><br><span class=\"line\"><span class=\"comment\"># 查看暂存区文件修改内容</span></span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"><span class=\"comment\"># 查看版本库修改记录</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"comment\"># 查看某人提交记录</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --author=someone</span><br><span class=\"line\"><span class=\"comment\"># 查看某个文件的历史具体修改内容</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -p [file]</span><br><span class=\"line\"><span class=\"comment\"># 查看某次提交具体修改内容</span></span><br><span class=\"line\">$ git show [commit]</span><br></pre></td></tr></table></figure>\n<p>2020/7/13 SVNupdate失败，本地文件中有打开更新的文件。<br>报错：需要执行clean up命令，执行并勾选break lock，解决。</p>\n<p>git常用指令地址:<a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">git命令：阮一峰</a></p>\n"},{"title":"ES6语法知识点","date":"2020-05-13T06:01:50.000Z","_content":"学习ES6语法记录知识点\n---\n\n\n关键词：JavaScript\n\n## let和const命令\n\n```bash\nES6新增的let命令，用法类似于Var，let声明的变量只在let命令所在的代码块有效（作用域问题）。\nlet要先声明再调用，否则系统会报错。\nFor循环当中的i就很适合使用let命令，For循环当中设置变量那一块的作用域与循环体内部的作用域不同，相当于父子作用域。\nvar命令声明的变量在脚本运行时就存在，所以先调用对象不会报错，但是显示undefined。\nlet命令会绑定这个块级作用域，在声明之前无法改变变量的值。（暂时性死区）\nlet在相同作用域内不允许重复声明一个变量。\n注意块级作用域的问题，{{}}=>为两层作用域。\nES6中块级作用域声明的函数类似于Var，提升到全局作用域或函数作用域的头部。\nconst声明一个只读的常量，声明后无法改变，声明需要赋值，否则会报错。\nconst的作用域与let命令相同，同样存在暂时性死区，而且也无法重复声明。\nconst声明的变量的值并不是不得改动，变量指向那个内存地址所保存的数据不得改动。\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错\n将对象冻结可以使用Object.freeze方法。\nES6声明变量有六种方法：\nvar，function，let，const，import，class\nES6中，let，const，class命令声明的全局变量不属于顶层对象的属性，全局变量将逐步与顶层对象的属性脱钩。\nwindow.a(顶层变量) window->浏览器窗口对象\n任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n```\n\n## 变量的解构赋值\n```bash\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n以上为解构赋值的例子\nnull≠undefined（严格）\nlet { foo, bar } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n解构也可用于对象，字符串，数值和布尔值，函数参数\n注意圆括号问题\n用途：1.交换变量的值，2.函数返回多个值，3.函数参数的定义,4.提取JSON数据,5.函数参数的默认值，6.遍历Map解构，7.输入模块的指定方法\n```\n\n## 字符串的扩展\n```bash\nUnicode表示法\n\"\\u0061\"\n// \"a\"\n但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示\n\n新增字符串的遍历器接口\nU+005C：反斜杠（reverse solidus)\nU+000D：回车（carriage return）\nU+2028：行分隔符（line separator）\nU+2029：段分隔符（paragraph separator）\nU+000A：换行符（line feed）\n\nJSON.stringfy()的改造\n模板字符串，用反引号（`）标识，可以当做普通字符串使用，也可以定义多行字符串，或者在字符串中嵌入变量。\n如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n模板字符串之中还能调用函数。\ntag函数的使用，第一个参数是一个数组。\ntag可以用于字符转义，多语言转换。\n```\n\n## 字符串的新增方法\n```bash\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y',可以识别大于0xFFFF的字符，与codePointAt()方法相反。\nString.raw()用于模板字符串的处理方法。将所有变量替换，对斜杠进行转义。\nString.codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。\nnormalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\nincludes()：返回布尔值，表示是否找到了参数字符串。参数多一个n时，从第n个位置直到字符结束。\nstartsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。参数多一个n时，从第n个位置直到字符结束。\nendsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。参数多一个n时，针对前n个字符。\nrepeat方法返回一个新字符串，表示将原字符串重复n次。参数不得为负或Infinity。\npadStart()用于头部补全，padEnd()用于尾部补全。\nmatchAll()方法返回一个正则表达式在当前字符串的所有匹配。\ntrimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。\n```\n\n## 正则的扩展\n```bash\nregexp构造函数，参数为字符串或正则表达式，分别返回正则表达式的修饰符和原有正则表达式的拷贝。\n字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。\nUnicode模式（再看）\n新增了sticky和flags属性，分别返回（boolean）是否设置了y修饰符和正则表达式的修饰符。\n后行断言~~\n```\n## 数值的扩展\n```bash\n八进制使用前缀0o表示\n二进制使用前缀0b表示\nNumber.isFinite() //检查数值是否为有限的（finite），如果参数不是数值一律返回false\nNumber.isNaN()//检查一个值是否为NaN，如果参数类型不是NaN，一律返回false\nparseInt()，parseFloat()\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\nNumber.isInteger()//整数判断,数值精度太高会误判，返回true\nJavaScript 能够准确表示的整数范围在-2^53到2^53之间,Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内\nMath.trunc方法用于去除一个数的小数部分，返回整数部分。Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于空值和无法截取整数的值，返回NaN。\nMath.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值\n参数为正数，返回+1；\n参数为负数，返回-1；\n参数为 0，返回0；\n参数为-0，返回-0;\n其他值，返回NaN。\nMath.cbrt()方法用于计算一个数的立方根。\nMath.hypot方法返回所有参数的平方和的平方根。\nMath.expm1(x)返回 ex - 1，即Math.exp(x) - 1。\nMath.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。\nMath.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。//log2通用法\n```\n## 函数的扩展\n```bash\n函数参数默认值写法 log（x=‘111’） //直接写在参数定义的后面，默认声明后无法再次声明，参数无法同名。\n默认参数需要提供参数，否则（参数）默认一个空对象，当函数的参数是一个对象时->可以使用解构赋值传参。\n传入undefined会触发默认值，null无法触发。\n函数的length属性返回没有指定默认参数的个数。设置了参数默认值，初始化的时候参数有单独的作用域，初始化结束后作用域会消失。\nES6引入rest参数，形式为...变量名，用于获取函数的多余参数，不需要使用ar\nguments对象了。rest是一个数组对象。\nrest参数过后，不能再有其他参数，只能是最后一个，否则会报错。函数的length不包括rest。\nES2016后函数内部使用严格模式会报错\n函数的Name属性返回函数的函数名，const bar = function baz() {}; bar.name // \"baz\"\n箭头函数代码块多于一条语句，就要使用大括号将他们括起来，并使用return返回。\n如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n注意点：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数没有自己的this，他们的this指向外层。\n不可以当做构造函数，不可以使用new命令，否则会抛出错误。\n不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。\n不可以使用yield命令，因此函数箭头不用做Generator函数。\n尾调用：函数的最后一步操作是调用另一个函数。//函数尾调用在每次执行时，调用帧只有一项，这将大大节省内存，优化。//Chrome和Firefox不支持\n类似的还有尾递归，函数尾调用自身。ES6的尾调用只在严格模式下开启。蹦床函数？\ntoString方法返回函数代码本身。\nES6允许catch省略参数\n```\n\n## 数组的扩展\n```bash\n复制数组，只是复制了指针，而不是克隆一个全新的数组，改变该值会导致原值的变化。使用concat函数进行复制。\n也可以使用concat进行数组的合并，不过该方法为浅拷贝。\nIterator接口的对象，遍历器，用扩展运算符（...）转为真正的数组。\nArray.from（）方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象。与数组的Map相似。\nArray.of()方法用于将一组值转换为数组。Array.of() // []  ；  Array.of(undefined) // [undefined]\nArray.prototype.copyWithin(target, start = 0, end = this.length)\ntarget（必需）：从该位置开始替换数据。如果为负值，表示倒数。\nstart（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\nend（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n数组实例：find（）：用于找出第一个符合条件的数组成员，findIndex（）：返回第一个符合条件的数组成员的位置，如果都不符合条件，返回-1.\nfill（）用于补充空数组的初始化，可以选定位置，如果填充的类型为对象，那么赋值的是同一个内存地址的对象，改变其中的值会改变其他赋值的值。\nkeys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\nincludes方法返回一个布尔值，表示某个数组是否包含给定的值。\nMap 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。\nSet 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。\nflat（）函数，用于拉平数组，如果原数组里包含数组，将子数组成员取出来添加在原来的位置。需要设置层数。flat会跳过空位。\nflatMap（）参数为遍历函数，有第二个参数可以绑定遍历函数里面的this。\nArray(3) // [, , ,]具有3个空位的数组\nforEach(), filter(), reduce(), every() 和some()都会跳过空位。\nmap()会跳过空位，但会保留这个值\njoin()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串\n自带的sort（）排序不稳定\n```\n## 对象的扩展\n```bash\nobj['a' + 'bc'] = 123;//abc:123\n// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。\n(new Function()).name // \"anonymous\"\n\nvar doSomething = function() {\n  // ...\n};\ndoSomething.bind().name // \"bound doSomething\"\nfor...in循环：只遍历对象自身的和继承的可枚举的属性。\nObject.keys()：返回对象自身的所有可枚举的属性的键名。\nJSON.stringify()：只串行化对象自身的可枚举的属性。\nObject.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。\nES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。//只能用在对象的方法之中。\n如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式。\n扩展运算符后面可以为数组，如果是空对象，无效果。\n// 等同于 {...Object(1)}\n{...1} // {}不是对象，自动转为对象\n如果后面是字符串，它会自动转换成一个类似数组的对象，因此返回的不是空对象。\n对象的扩展运算符等同于使用Object.assign()方法。\n完整克隆对象的方法：\n// 写法一\nconst clone1 = {\n  __proto__: Object.getPrototypeOf(obj),\n  ...obj\n};\n\n// 写法二\nconst clone2 = Object.assign(\n  Object.create(Object.getPrototypeOf(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n)\n扩展运算符可以用于合并两个对象//let ab = { ...a, ...b };\n链判断运算符\nconst firstName = (message//读取message.body.user.firstName\n  && message.body//读取对象内部的某个属性，往往需要判断一下对象是否存在(也可以使用三元运算符)\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n引入了？？Null判断运算符，类似||，只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n```\n## 对象的新增方法\n```bash\nObject.is()比较聊个值是否相同，与===的行为基本一致。\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\nObject.assign()//方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象。\nObject.assign(target, source1, source2);//第一个参数是目标对象，后面的参数都是源对象\n如果只有一个参数，会直接返回该参数。如果该参数不是对象，则会先转成对象，然后返回。\nundefined和null无法转成对象，作为参数会报错。\nassign方法实行的是浅拷贝。同名的属性会进行替换。\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nObject.assign(target, source)\n// { a: { b: 'hello' } }\n数组处理，assign把数组视为属性名为0,1,2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1\nObject.assign([1, 2, 3], [4, 5])\n// [4, 5, 3]\n如果复制的值是一个取值函数，那么会求值后再复制。\nconst source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nObject.assign(target, source)\n// { foo: 1 }\nassign常见用途：\n（1）为对象添加属性\n（2）为对象添加方法\n（3）克隆对象\n（4）合并对象\n（5）为属性指定默认值\nObject.keys()//返回一个数组，成员是参数对象自身的所有可遍历属性的键名。\nObject.values()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值。\nObject.entries()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。\nObject.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象\n```\n## symbol\n```bash\nsymbol值通过Symbol函数生成。Symbol函数前不能使用New命令，否则会报错。因为Symbol是一个原始类型的值，不是对象。\nSymbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。\nSymbol值不能与其他类型进行运算，会报错。Symbol可以显式转为字符串，也可以转为布尔值，但不能转为数值。\n实例：消除魔术字符串\nObject.getOwnPropertySymbols()方法，获取指定对象的所有Symbol属性名。返回一个数组。\nReflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\n```\n参考文档：https://es6.ruanyifeng.com/\n","source":"_posts/ES6语法知识点.md","raw":"---\ntitle: ES6语法知识点\ndate: 2020-05-13 14:01:50\ntags:\n - 语法知识\n - JavaScript\ncategories: Web前端\n---\n学习ES6语法记录知识点\n---\n\n\n关键词：JavaScript\n\n## let和const命令\n\n```bash\nES6新增的let命令，用法类似于Var，let声明的变量只在let命令所在的代码块有效（作用域问题）。\nlet要先声明再调用，否则系统会报错。\nFor循环当中的i就很适合使用let命令，For循环当中设置变量那一块的作用域与循环体内部的作用域不同，相当于父子作用域。\nvar命令声明的变量在脚本运行时就存在，所以先调用对象不会报错，但是显示undefined。\nlet命令会绑定这个块级作用域，在声明之前无法改变变量的值。（暂时性死区）\nlet在相同作用域内不允许重复声明一个变量。\n注意块级作用域的问题，{{}}=>为两层作用域。\nES6中块级作用域声明的函数类似于Var，提升到全局作用域或函数作用域的头部。\nconst声明一个只读的常量，声明后无法改变，声明需要赋值，否则会报错。\nconst的作用域与let命令相同，同样存在暂时性死区，而且也无法重复声明。\nconst声明的变量的值并不是不得改动，变量指向那个内存地址所保存的数据不得改动。\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错\n将对象冻结可以使用Object.freeze方法。\nES6声明变量有六种方法：\nvar，function，let，const，import，class\nES6中，let，const，class命令声明的全局变量不属于顶层对象的属性，全局变量将逐步与顶层对象的属性脱钩。\nwindow.a(顶层变量) window->浏览器窗口对象\n任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n```\n\n## 变量的解构赋值\n```bash\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n以上为解构赋值的例子\nnull≠undefined（严格）\nlet { foo, bar } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n解构也可用于对象，字符串，数值和布尔值，函数参数\n注意圆括号问题\n用途：1.交换变量的值，2.函数返回多个值，3.函数参数的定义,4.提取JSON数据,5.函数参数的默认值，6.遍历Map解构，7.输入模块的指定方法\n```\n\n## 字符串的扩展\n```bash\nUnicode表示法\n\"\\u0061\"\n// \"a\"\n但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示\n\n新增字符串的遍历器接口\nU+005C：反斜杠（reverse solidus)\nU+000D：回车（carriage return）\nU+2028：行分隔符（line separator）\nU+2029：段分隔符（paragraph separator）\nU+000A：换行符（line feed）\n\nJSON.stringfy()的改造\n模板字符串，用反引号（`）标识，可以当做普通字符串使用，也可以定义多行字符串，或者在字符串中嵌入变量。\n如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n模板字符串之中还能调用函数。\ntag函数的使用，第一个参数是一个数组。\ntag可以用于字符转义，多语言转换。\n```\n\n## 字符串的新增方法\n```bash\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y',可以识别大于0xFFFF的字符，与codePointAt()方法相反。\nString.raw()用于模板字符串的处理方法。将所有变量替换，对斜杠进行转义。\nString.codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。\nnormalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\nincludes()：返回布尔值，表示是否找到了参数字符串。参数多一个n时，从第n个位置直到字符结束。\nstartsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。参数多一个n时，从第n个位置直到字符结束。\nendsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。参数多一个n时，针对前n个字符。\nrepeat方法返回一个新字符串，表示将原字符串重复n次。参数不得为负或Infinity。\npadStart()用于头部补全，padEnd()用于尾部补全。\nmatchAll()方法返回一个正则表达式在当前字符串的所有匹配。\ntrimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。\n```\n\n## 正则的扩展\n```bash\nregexp构造函数，参数为字符串或正则表达式，分别返回正则表达式的修饰符和原有正则表达式的拷贝。\n字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。\nUnicode模式（再看）\n新增了sticky和flags属性，分别返回（boolean）是否设置了y修饰符和正则表达式的修饰符。\n后行断言~~\n```\n## 数值的扩展\n```bash\n八进制使用前缀0o表示\n二进制使用前缀0b表示\nNumber.isFinite() //检查数值是否为有限的（finite），如果参数不是数值一律返回false\nNumber.isNaN()//检查一个值是否为NaN，如果参数类型不是NaN，一律返回false\nparseInt()，parseFloat()\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\nNumber.isInteger()//整数判断,数值精度太高会误判，返回true\nJavaScript 能够准确表示的整数范围在-2^53到2^53之间,Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内\nMath.trunc方法用于去除一个数的小数部分，返回整数部分。Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于空值和无法截取整数的值，返回NaN。\nMath.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值\n参数为正数，返回+1；\n参数为负数，返回-1；\n参数为 0，返回0；\n参数为-0，返回-0;\n其他值，返回NaN。\nMath.cbrt()方法用于计算一个数的立方根。\nMath.hypot方法返回所有参数的平方和的平方根。\nMath.expm1(x)返回 ex - 1，即Math.exp(x) - 1。\nMath.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。\nMath.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。//log2通用法\n```\n## 函数的扩展\n```bash\n函数参数默认值写法 log（x=‘111’） //直接写在参数定义的后面，默认声明后无法再次声明，参数无法同名。\n默认参数需要提供参数，否则（参数）默认一个空对象，当函数的参数是一个对象时->可以使用解构赋值传参。\n传入undefined会触发默认值，null无法触发。\n函数的length属性返回没有指定默认参数的个数。设置了参数默认值，初始化的时候参数有单独的作用域，初始化结束后作用域会消失。\nES6引入rest参数，形式为...变量名，用于获取函数的多余参数，不需要使用ar\nguments对象了。rest是一个数组对象。\nrest参数过后，不能再有其他参数，只能是最后一个，否则会报错。函数的length不包括rest。\nES2016后函数内部使用严格模式会报错\n函数的Name属性返回函数的函数名，const bar = function baz() {}; bar.name // \"baz\"\n箭头函数代码块多于一条语句，就要使用大括号将他们括起来，并使用return返回。\n如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n注意点：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数没有自己的this，他们的this指向外层。\n不可以当做构造函数，不可以使用new命令，否则会抛出错误。\n不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。\n不可以使用yield命令，因此函数箭头不用做Generator函数。\n尾调用：函数的最后一步操作是调用另一个函数。//函数尾调用在每次执行时，调用帧只有一项，这将大大节省内存，优化。//Chrome和Firefox不支持\n类似的还有尾递归，函数尾调用自身。ES6的尾调用只在严格模式下开启。蹦床函数？\ntoString方法返回函数代码本身。\nES6允许catch省略参数\n```\n\n## 数组的扩展\n```bash\n复制数组，只是复制了指针，而不是克隆一个全新的数组，改变该值会导致原值的变化。使用concat函数进行复制。\n也可以使用concat进行数组的合并，不过该方法为浅拷贝。\nIterator接口的对象，遍历器，用扩展运算符（...）转为真正的数组。\nArray.from（）方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象。与数组的Map相似。\nArray.of()方法用于将一组值转换为数组。Array.of() // []  ；  Array.of(undefined) // [undefined]\nArray.prototype.copyWithin(target, start = 0, end = this.length)\ntarget（必需）：从该位置开始替换数据。如果为负值，表示倒数。\nstart（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\nend（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n数组实例：find（）：用于找出第一个符合条件的数组成员，findIndex（）：返回第一个符合条件的数组成员的位置，如果都不符合条件，返回-1.\nfill（）用于补充空数组的初始化，可以选定位置，如果填充的类型为对象，那么赋值的是同一个内存地址的对象，改变其中的值会改变其他赋值的值。\nkeys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\nincludes方法返回一个布尔值，表示某个数组是否包含给定的值。\nMap 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。\nSet 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。\nflat（）函数，用于拉平数组，如果原数组里包含数组，将子数组成员取出来添加在原来的位置。需要设置层数。flat会跳过空位。\nflatMap（）参数为遍历函数，有第二个参数可以绑定遍历函数里面的this。\nArray(3) // [, , ,]具有3个空位的数组\nforEach(), filter(), reduce(), every() 和some()都会跳过空位。\nmap()会跳过空位，但会保留这个值\njoin()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串\n自带的sort（）排序不稳定\n```\n## 对象的扩展\n```bash\nobj['a' + 'bc'] = 123;//abc:123\n// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。\n(new Function()).name // \"anonymous\"\n\nvar doSomething = function() {\n  // ...\n};\ndoSomething.bind().name // \"bound doSomething\"\nfor...in循环：只遍历对象自身的和继承的可枚举的属性。\nObject.keys()：返回对象自身的所有可枚举的属性的键名。\nJSON.stringify()：只串行化对象自身的可枚举的属性。\nObject.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。\nES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。//只能用在对象的方法之中。\n如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式。\n扩展运算符后面可以为数组，如果是空对象，无效果。\n// 等同于 {...Object(1)}\n{...1} // {}不是对象，自动转为对象\n如果后面是字符串，它会自动转换成一个类似数组的对象，因此返回的不是空对象。\n对象的扩展运算符等同于使用Object.assign()方法。\n完整克隆对象的方法：\n// 写法一\nconst clone1 = {\n  __proto__: Object.getPrototypeOf(obj),\n  ...obj\n};\n\n// 写法二\nconst clone2 = Object.assign(\n  Object.create(Object.getPrototypeOf(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n)\n扩展运算符可以用于合并两个对象//let ab = { ...a, ...b };\n链判断运算符\nconst firstName = (message//读取message.body.user.firstName\n  && message.body//读取对象内部的某个属性，往往需要判断一下对象是否存在(也可以使用三元运算符)\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n引入了？？Null判断运算符，类似||，只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n```\n## 对象的新增方法\n```bash\nObject.is()比较聊个值是否相同，与===的行为基本一致。\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\nObject.assign()//方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象。\nObject.assign(target, source1, source2);//第一个参数是目标对象，后面的参数都是源对象\n如果只有一个参数，会直接返回该参数。如果该参数不是对象，则会先转成对象，然后返回。\nundefined和null无法转成对象，作为参数会报错。\nassign方法实行的是浅拷贝。同名的属性会进行替换。\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nObject.assign(target, source)\n// { a: { b: 'hello' } }\n数组处理，assign把数组视为属性名为0,1,2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1\nObject.assign([1, 2, 3], [4, 5])\n// [4, 5, 3]\n如果复制的值是一个取值函数，那么会求值后再复制。\nconst source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nObject.assign(target, source)\n// { foo: 1 }\nassign常见用途：\n（1）为对象添加属性\n（2）为对象添加方法\n（3）克隆对象\n（4）合并对象\n（5）为属性指定默认值\nObject.keys()//返回一个数组，成员是参数对象自身的所有可遍历属性的键名。\nObject.values()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值。\nObject.entries()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。\nObject.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象\n```\n## symbol\n```bash\nsymbol值通过Symbol函数生成。Symbol函数前不能使用New命令，否则会报错。因为Symbol是一个原始类型的值，不是对象。\nSymbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。\nSymbol值不能与其他类型进行运算，会报错。Symbol可以显式转为字符串，也可以转为布尔值，但不能转为数值。\n实例：消除魔术字符串\nObject.getOwnPropertySymbols()方法，获取指定对象的所有Symbol属性名。返回一个数组。\nReflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\n```\n参考文档：https://es6.ruanyifeng.com/\n","slug":"ES6语法知识点","published":1,"updated":"2020-07-29T08:58:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow33e0008pcva5c3wglf7","content":"<h2 id=\"学习ES6语法记录知识点\"><a href=\"#学习ES6语法记录知识点\" class=\"headerlink\" title=\"学习ES6语法记录知识点\"></a>学习ES6语法记录知识点</h2><p>关键词：JavaScript</p>\n<h2 id=\"let和const命令\"><a href=\"#let和const命令\" class=\"headerlink\" title=\"let和const命令\"></a>let和const命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ES6新增的<span class=\"built_in\">let</span>命令，用法类似于Var，<span class=\"built_in\">let</span>声明的变量只在<span class=\"built_in\">let</span>命令所在的代码块有效（作用域问题）。</span><br><span class=\"line\"><span class=\"built_in\">let</span>要先声明再调用，否则系统会报错。</span><br><span class=\"line\">For循环当中的i就很适合使用<span class=\"built_in\">let</span>命令，For循环当中设置变量那一块的作用域与循环体内部的作用域不同，相当于父子作用域。</span><br><span class=\"line\">var命令声明的变量在脚本运行时就存在，所以先调用对象不会报错，但是显示undefined。</span><br><span class=\"line\"><span class=\"built_in\">let</span>命令会绑定这个块级作用域，在声明之前无法改变变量的值。（暂时性死区）</span><br><span class=\"line\"><span class=\"built_in\">let</span>在相同作用域内不允许重复声明一个变量。</span><br><span class=\"line\">注意块级作用域的问题，&#123;&#123;&#125;&#125;=&gt;为两层作用域。</span><br><span class=\"line\">ES6中块级作用域声明的函数类似于Var，提升到全局作用域或函数作用域的头部。</span><br><span class=\"line\">const声明一个只读的常量，声明后无法改变，声明需要赋值，否则会报错。</span><br><span class=\"line\">const的作用域与<span class=\"built_in\">let</span>命令相同，同样存在暂时性死区，而且也无法重复声明。</span><br><span class=\"line\">const声明的变量的值并不是不得改动，变量指向那个内存地址所保存的数据不得改动。</span><br><span class=\"line\">const a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">'Hello'</span>); // 可执行</span><br><span class=\"line\">a.length = 0;    // 可执行</span><br><span class=\"line\">a = [<span class=\"string\">'Dave'</span>];    // 报错</span><br><span class=\"line\">上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错</span><br><span class=\"line\">将对象冻结可以使用Object.freeze方法。</span><br><span class=\"line\">ES6声明变量有六种方法：</span><br><span class=\"line\">var，<span class=\"keyword\">function</span>，<span class=\"built_in\">let</span>，const，import，class</span><br><span class=\"line\">ES6中，<span class=\"built_in\">let</span>，const，class命令声明的全局变量不属于顶层对象的属性，全局变量将逐步与顶层对象的属性脱钩。</span><br><span class=\"line\">window.a(顶层变量) window-&gt;浏览器窗口对象</span><br><span class=\"line\">任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class=\"line\">foo // 1</span><br><span class=\"line\">bar // 2</span><br><span class=\"line\">baz // 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>];</span><br><span class=\"line\">third // <span class=\"string\">\"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [x, , y] = [1, 2, 3];</span><br><span class=\"line\">x // 1</span><br><span class=\"line\">y // 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [head, ...tail] = [1, 2, 3, 4];</span><br><span class=\"line\">head // 1</span><br><span class=\"line\">tail // [2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [x, y, ...z] = [<span class=\"string\">'a'</span>];</span><br><span class=\"line\">x // <span class=\"string\">\"a\"</span></span><br><span class=\"line\">y // undefined</span><br><span class=\"line\">z // []</span><br><span class=\"line\">以上为解构赋值的例子</span><br><span class=\"line\">null≠undefined（严格）</span><br><span class=\"line\"><span class=\"built_in\">let</span> &#123; foo, bar &#125; = &#123; foo: <span class=\"string\">'aaa'</span>, bar: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\">foo // <span class=\"string\">\"aaa\"</span></span><br><span class=\"line\">bar // <span class=\"string\">\"bbb\"</span></span><br><span class=\"line\">解构也可用于对象，字符串，数值和布尔值，函数参数</span><br><span class=\"line\">注意圆括号问题</span><br><span class=\"line\">用途：1.交换变量的值，2.函数返回多个值，3.函数参数的定义,4.提取JSON数据,5.函数参数的默认值，6.遍历Map解构，7.输入模块的指定方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串的扩展\"><a href=\"#字符串的扩展\" class=\"headerlink\" title=\"字符串的扩展\"></a>字符串的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unicode表示法</span><br><span class=\"line\"><span class=\"string\">\"\\u0061\"</span></span><br><span class=\"line\">// <span class=\"string\">\"a\"</span></span><br><span class=\"line\">但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示</span><br><span class=\"line\"></span><br><span class=\"line\">新增字符串的遍历器接口</span><br><span class=\"line\">U+005C：反斜杠（reverse solidus)</span><br><span class=\"line\">U+000D：回车（carriage <span class=\"built_in\">return</span>）</span><br><span class=\"line\">U+2028：行分隔符（line separator）</span><br><span class=\"line\">U+2029：段分隔符（paragraph separator）</span><br><span class=\"line\">U+000A：换行符（line feed）</span><br><span class=\"line\"></span><br><span class=\"line\">JSON.stringfy()的改造</span><br><span class=\"line\">模板字符串，用反引号（`）标识，可以当做普通字符串使用，也可以定义多行字符串，或者在字符串中嵌入变量。</span><br><span class=\"line\">如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</span><br><span class=\"line\">模板字符串中嵌入变量，需要将变量名写在<span class=\"variable\">$&#123;&#125;</span>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</span><br><span class=\"line\">模板字符串之中还能调用函数。</span><br><span class=\"line\">tag函数的使用，第一个参数是一个数组。</span><br><span class=\"line\">tag可以用于字符转义，多语言转换。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串的新增方法\"><a href=\"#字符串的新增方法\" class=\"headerlink\" title=\"字符串的新增方法\"></a>字符串的新增方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.fromCodePoint(0x78, 0x1f680, 0x79) === <span class=\"string\">'x\\uD83D\\uDE80y'</span>,可以识别大于0xFFFF的字符，与codePointAt()方法相反。</span><br><span class=\"line\">String.raw()用于模板字符串的处理方法。将所有变量替换，对斜杠进行转义。</span><br><span class=\"line\">String.codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。</span><br><span class=\"line\">normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</span><br><span class=\"line\">includes()：返回布尔值，表示是否找到了参数字符串。参数多一个n时，从第n个位置直到字符结束。</span><br><span class=\"line\">startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。参数多一个n时，从第n个位置直到字符结束。</span><br><span class=\"line\">endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。参数多一个n时，针对前n个字符。</span><br><span class=\"line\">repeat方法返回一个新字符串，表示将原字符串重复n次。参数不得为负或Infinity。</span><br><span class=\"line\">padStart()用于头部补全，padEnd()用于尾部补全。</span><br><span class=\"line\">matchAll()方法返回一个正则表达式在当前字符串的所有匹配。</span><br><span class=\"line\">trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"正则的扩展\"><a href=\"#正则的扩展\" class=\"headerlink\" title=\"正则的扩展\"></a>正则的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regexp构造函数，参数为字符串或正则表达式，分别返回正则表达式的修饰符和原有正则表达式的拷贝。</span><br><span class=\"line\">字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</span><br><span class=\"line\">Unicode模式（再看）</span><br><span class=\"line\">新增了sticky和flags属性，分别返回（boolean）是否设置了y修饰符和正则表达式的修饰符。</span><br><span class=\"line\">后行断言~~</span><br></pre></td></tr></table></figure>\n<h2 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">八进制使用前缀0o表示</span><br><span class=\"line\">二进制使用前缀0b表示</span><br><span class=\"line\">Number.isFinite() //检查数值是否为有限的（finite），如果参数不是数值一律返回<span class=\"literal\">false</span></span><br><span class=\"line\">Number.isNaN()//检查一个值是否为NaN，如果参数类型不是NaN，一律返回<span class=\"literal\">false</span></span><br><span class=\"line\">parseInt()，parseFloat()</span><br><span class=\"line\">// ES6的写法</span><br><span class=\"line\">Number.parseInt(<span class=\"string\">'12.34'</span>) // 12</span><br><span class=\"line\">Number.parseFloat(<span class=\"string\">'123.45#'</span>) // 123.45</span><br><span class=\"line\">Number.isInteger()//整数判断,数值精度太高会误判，返回<span class=\"literal\">true</span></span><br><span class=\"line\">JavaScript 能够准确表示的整数范围在-2^53到2^53之间,Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内</span><br><span class=\"line\">Math.trunc方法用于去除一个数的小数部分，返回整数部分。Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于空值和无法截取整数的值，返回NaN。</span><br><span class=\"line\">Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值</span><br><span class=\"line\">参数为正数，返回+1；</span><br><span class=\"line\">参数为负数，返回-1；</span><br><span class=\"line\">参数为 0，返回0；</span><br><span class=\"line\">参数为-0，返回-0;</span><br><span class=\"line\">其他值，返回NaN。</span><br><span class=\"line\">Math.cbrt()方法用于计算一个数的立方根。</span><br><span class=\"line\">Math.hypot方法返回所有参数的平方和的平方根。</span><br><span class=\"line\">Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。</span><br><span class=\"line\">Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</span><br><span class=\"line\">Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。//log2通用法</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数参数默认值写法 <span class=\"built_in\">log</span>（x=‘111’） //直接写在参数定义的后面，默认声明后无法再次声明，参数无法同名。</span><br><span class=\"line\">默认参数需要提供参数，否则（参数）默认一个空对象，当函数的参数是一个对象时-&gt;可以使用解构赋值传参。</span><br><span class=\"line\">传入undefined会触发默认值，null无法触发。</span><br><span class=\"line\">函数的length属性返回没有指定默认参数的个数。设置了参数默认值，初始化的时候参数有单独的作用域，初始化结束后作用域会消失。</span><br><span class=\"line\">ES6引入rest参数，形式为...变量名，用于获取函数的多余参数，不需要使用ar</span><br><span class=\"line\">guments对象了。rest是一个数组对象。</span><br><span class=\"line\">rest参数过后，不能再有其他参数，只能是最后一个，否则会报错。函数的length不包括rest。</span><br><span class=\"line\">ES2016后函数内部使用严格模式会报错</span><br><span class=\"line\">函数的Name属性返回函数的函数名，const bar = <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">baz</span></span>() &#123;&#125;; bar.name // <span class=\"string\">\"baz\"</span></span><br><span class=\"line\">箭头函数代码块多于一条语句，就要使用大括号将他们括起来，并使用<span class=\"built_in\">return</span>返回。</span><br><span class=\"line\">如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</span><br><span class=\"line\">注意点：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数没有自己的this，他们的this指向外层。</span><br><span class=\"line\">不可以当做构造函数，不可以使用new命令，否则会抛出错误。</span><br><span class=\"line\">不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</span><br><span class=\"line\">不可以使用yield命令，因此函数箭头不用做Generator函数。</span><br><span class=\"line\">尾调用：函数的最后一步操作是调用另一个函数。//函数尾调用在每次执行时，调用帧只有一项，这将大大节省内存，优化。//Chrome和Firefox不支持</span><br><span class=\"line\">类似的还有尾递归，函数尾调用自身。ES6的尾调用只在严格模式下开启。蹦床函数？</span><br><span class=\"line\">toString方法返回函数代码本身。</span><br><span class=\"line\">ES6允许catch省略参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a>数组的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复制数组，只是复制了指针，而不是克隆一个全新的数组，改变该值会导致原值的变化。使用concat函数进行复制。</span><br><span class=\"line\">也可以使用concat进行数组的合并，不过该方法为浅拷贝。</span><br><span class=\"line\">Iterator接口的对象，遍历器，用扩展运算符（...）转为真正的数组。</span><br><span class=\"line\">Array.from（）方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象。与数组的Map相似。</span><br><span class=\"line\">Array.of()方法用于将一组值转换为数组。Array.of() // []  ；  Array.of(undefined) // [undefined]</span><br><span class=\"line\">Array.prototype.copyWithin(target, start = 0, end = this.length)</span><br><span class=\"line\">target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</span><br><span class=\"line\">start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</span><br><span class=\"line\">end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</span><br><span class=\"line\">数组实例：find（）：用于找出第一个符合条件的数组成员，findIndex（）：返回第一个符合条件的数组成员的位置，如果都不符合条件，返回-1.</span><br><span class=\"line\">fill（）用于补充空数组的初始化，可以选定位置，如果填充的类型为对象，那么赋值的是同一个内存地址的对象，改变其中的值会改变其他赋值的值。</span><br><span class=\"line\">keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</span><br><span class=\"line\">includes方法返回一个布尔值，表示某个数组是否包含给定的值。</span><br><span class=\"line\">Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</span><br><span class=\"line\">Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</span><br><span class=\"line\">flat（）函数，用于拉平数组，如果原数组里包含数组，将子数组成员取出来添加在原来的位置。需要设置层数。flat会跳过空位。</span><br><span class=\"line\">flatMap（）参数为遍历函数，有第二个参数可以绑定遍历函数里面的this。</span><br><span class=\"line\">Array(3) // [, , ,]具有3个空位的数组</span><br><span class=\"line\">forEach(), filter(), reduce(), every() 和some()都会跳过空位。</span><br><span class=\"line\">map()会跳过空位，但会保留这个值</span><br><span class=\"line\">join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串</span><br><span class=\"line\">自带的sort（）排序不稳定</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj[<span class=\"string\">'a'</span> + <span class=\"string\">'bc'</span>] = 123;//abc:123</span><br><span class=\"line\">// 报错</span><br><span class=\"line\">const foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">const bar = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">const baz = &#123; [foo] &#125;;</span><br><span class=\"line\">// 正确</span><br><span class=\"line\">const foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">const baz = &#123; [foo]: <span class=\"string\">'abc'</span>&#125;;</span><br><span class=\"line\">有两种特殊情况：<span class=\"built_in\">bind</span>方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</span><br><span class=\"line\">(new Function()).name // <span class=\"string\">\"anonymous\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">var doSomething = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">doSomething.bind().name // <span class=\"string\">\"bound doSomething\"</span></span><br><span class=\"line\">for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class=\"line\">Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class=\"line\">JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class=\"line\">Object.assign()： 忽略enumerable为<span class=\"literal\">false</span>的属性，只拷贝对象自身的可枚举的属性。</span><br><span class=\"line\">ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。//只能用在对象的方法之中。</span><br><span class=\"line\">如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式。</span><br><span class=\"line\">扩展运算符后面可以为数组，如果是空对象，无效果。</span><br><span class=\"line\">// 等同于 &#123;...Object(1)&#125;</span><br><span class=\"line\">&#123;...1&#125; // &#123;&#125;不是对象，自动转为对象</span><br><span class=\"line\">如果后面是字符串，它会自动转换成一个类似数组的对象，因此返回的不是空对象。</span><br><span class=\"line\">对象的扩展运算符等同于使用Object.assign()方法。</span><br><span class=\"line\">完整克隆对象的方法：</span><br><span class=\"line\">// 写法一</span><br><span class=\"line\">const clone1 = &#123;</span><br><span class=\"line\">  __proto__: Object.getPrototypeOf(obj),</span><br><span class=\"line\">  ...obj</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法二</span><br><span class=\"line\">const clone2 = Object.assign(</span><br><span class=\"line\">  Object.create(Object.getPrototypeOf(obj)),</span><br><span class=\"line\">  obj</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法三</span><br><span class=\"line\">const clone3 = Object.create(</span><br><span class=\"line\">  Object.getPrototypeOf(obj),</span><br><span class=\"line\">  Object.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">)</span><br><span class=\"line\">扩展运算符可以用于合并两个对象//<span class=\"built_in\">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class=\"line\">链判断运算符</span><br><span class=\"line\">const firstName = (message//读取message.body.user.firstName</span><br><span class=\"line\">  &amp;&amp; message.body//读取对象内部的某个属性，往往需要判断一下对象是否存在(也可以使用三元运算符)</span><br><span class=\"line\">  &amp;&amp; message.body.user</span><br><span class=\"line\">  &amp;&amp; message.body.user.firstName) || <span class=\"string\">'default'</span>;</span><br><span class=\"line\">引入了？？Null判断运算符，类似||，只有运算符左侧的值为null或undefined时，才会返回右侧的值。</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的新增方法\"><a href=\"#对象的新增方法\" class=\"headerlink\" title=\"对象的新增方法\"></a>对象的新增方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.is()比较聊个值是否相同，与===的行为基本一致。</span><br><span class=\"line\">Object.is(+0, -0) // <span class=\"literal\">false</span></span><br><span class=\"line\">Object.is(NaN, NaN) // <span class=\"literal\">true</span></span><br><span class=\"line\">Object.assign()//方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象。</span><br><span class=\"line\">Object.assign(target, source1, source2);//第一个参数是目标对象，后面的参数都是源对象</span><br><span class=\"line\">如果只有一个参数，会直接返回该参数。如果该参数不是对象，则会先转成对象，然后返回。</span><br><span class=\"line\">undefined和null无法转成对象，作为参数会报错。</span><br><span class=\"line\">assign方法实行的是浅拷贝。同名的属性会进行替换。</span><br><span class=\"line\">const target = &#123; a: &#123; b: <span class=\"string\">'c'</span>, d: <span class=\"string\">'e'</span> &#125; &#125;</span><br><span class=\"line\">const <span class=\"built_in\">source</span> = &#123; a: &#123; b: <span class=\"string\">'hello'</span> &#125; &#125;</span><br><span class=\"line\">Object.assign(target, <span class=\"built_in\">source</span>)</span><br><span class=\"line\">// &#123; a: &#123; b: <span class=\"string\">'hello'</span> &#125; &#125;</span><br><span class=\"line\">数组处理，assign把数组视为属性名为0,1,2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1</span><br><span class=\"line\">Object.assign([1, 2, 3], [4, 5])</span><br><span class=\"line\">// [4, 5, 3]</span><br><span class=\"line\">如果复制的值是一个取值函数，那么会求值后再复制。</span><br><span class=\"line\">const <span class=\"built_in\">source</span> = &#123;</span><br><span class=\"line\">  get <span class=\"function\"><span class=\"title\">foo</span></span>() &#123; <span class=\"built_in\">return</span> 1 &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const target = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(target, <span class=\"built_in\">source</span>)</span><br><span class=\"line\">// &#123; foo: 1 &#125;</span><br><span class=\"line\">assign常见用途：</span><br><span class=\"line\">（1）为对象添加属性</span><br><span class=\"line\">（2）为对象添加方法</span><br><span class=\"line\">（3）克隆对象</span><br><span class=\"line\">（4）合并对象</span><br><span class=\"line\">（5）为属性指定默认值</span><br><span class=\"line\">Object.keys()//返回一个数组，成员是参数对象自身的所有可遍历属性的键名。</span><br><span class=\"line\">Object.values()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值。</span><br><span class=\"line\">Object.entries()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。</span><br><span class=\"line\">Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象</span><br></pre></td></tr></table></figure>\n<h2 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">symbol值通过Symbol函数生成。Symbol函数前不能使用New命令，否则会报错。因为Symbol是一个原始类型的值，不是对象。</span><br><span class=\"line\">Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</span><br><span class=\"line\">Symbol值不能与其他类型进行运算，会报错。Symbol可以显式转为字符串，也可以转为布尔值，但不能转为数值。</span><br><span class=\"line\">实例：消除魔术字符串</span><br><span class=\"line\">Object.getOwnPropertySymbols()方法，获取指定对象的所有Symbol属性名。返回一个数组。</span><br><span class=\"line\">Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</span><br></pre></td></tr></table></figure>\n<p>参考文档：<a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">https://es6.ruanyifeng.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"学习ES6语法记录知识点\"><a href=\"#学习ES6语法记录知识点\" class=\"headerlink\" title=\"学习ES6语法记录知识点\"></a>学习ES6语法记录知识点</h2><p>关键词：JavaScript</p>\n<h2 id=\"let和const命令\"><a href=\"#let和const命令\" class=\"headerlink\" title=\"let和const命令\"></a>let和const命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ES6新增的<span class=\"built_in\">let</span>命令，用法类似于Var，<span class=\"built_in\">let</span>声明的变量只在<span class=\"built_in\">let</span>命令所在的代码块有效（作用域问题）。</span><br><span class=\"line\"><span class=\"built_in\">let</span>要先声明再调用，否则系统会报错。</span><br><span class=\"line\">For循环当中的i就很适合使用<span class=\"built_in\">let</span>命令，For循环当中设置变量那一块的作用域与循环体内部的作用域不同，相当于父子作用域。</span><br><span class=\"line\">var命令声明的变量在脚本运行时就存在，所以先调用对象不会报错，但是显示undefined。</span><br><span class=\"line\"><span class=\"built_in\">let</span>命令会绑定这个块级作用域，在声明之前无法改变变量的值。（暂时性死区）</span><br><span class=\"line\"><span class=\"built_in\">let</span>在相同作用域内不允许重复声明一个变量。</span><br><span class=\"line\">注意块级作用域的问题，&#123;&#123;&#125;&#125;=&gt;为两层作用域。</span><br><span class=\"line\">ES6中块级作用域声明的函数类似于Var，提升到全局作用域或函数作用域的头部。</span><br><span class=\"line\">const声明一个只读的常量，声明后无法改变，声明需要赋值，否则会报错。</span><br><span class=\"line\">const的作用域与<span class=\"built_in\">let</span>命令相同，同样存在暂时性死区，而且也无法重复声明。</span><br><span class=\"line\">const声明的变量的值并不是不得改动，变量指向那个内存地址所保存的数据不得改动。</span><br><span class=\"line\">const a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">'Hello'</span>); // 可执行</span><br><span class=\"line\">a.length = 0;    // 可执行</span><br><span class=\"line\">a = [<span class=\"string\">'Dave'</span>];    // 报错</span><br><span class=\"line\">上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错</span><br><span class=\"line\">将对象冻结可以使用Object.freeze方法。</span><br><span class=\"line\">ES6声明变量有六种方法：</span><br><span class=\"line\">var，<span class=\"keyword\">function</span>，<span class=\"built_in\">let</span>，const，import，class</span><br><span class=\"line\">ES6中，<span class=\"built_in\">let</span>，const，class命令声明的全局变量不属于顶层对象的属性，全局变量将逐步与顶层对象的属性脱钩。</span><br><span class=\"line\">window.a(顶层变量) window-&gt;浏览器窗口对象</span><br><span class=\"line\">任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class=\"line\">foo // 1</span><br><span class=\"line\">bar // 2</span><br><span class=\"line\">baz // 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>];</span><br><span class=\"line\">third // <span class=\"string\">\"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [x, , y] = [1, 2, 3];</span><br><span class=\"line\">x // 1</span><br><span class=\"line\">y // 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [head, ...tail] = [1, 2, 3, 4];</span><br><span class=\"line\">head // 1</span><br><span class=\"line\">tail // [2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> [x, y, ...z] = [<span class=\"string\">'a'</span>];</span><br><span class=\"line\">x // <span class=\"string\">\"a\"</span></span><br><span class=\"line\">y // undefined</span><br><span class=\"line\">z // []</span><br><span class=\"line\">以上为解构赋值的例子</span><br><span class=\"line\">null≠undefined（严格）</span><br><span class=\"line\"><span class=\"built_in\">let</span> &#123; foo, bar &#125; = &#123; foo: <span class=\"string\">'aaa'</span>, bar: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\">foo // <span class=\"string\">\"aaa\"</span></span><br><span class=\"line\">bar // <span class=\"string\">\"bbb\"</span></span><br><span class=\"line\">解构也可用于对象，字符串，数值和布尔值，函数参数</span><br><span class=\"line\">注意圆括号问题</span><br><span class=\"line\">用途：1.交换变量的值，2.函数返回多个值，3.函数参数的定义,4.提取JSON数据,5.函数参数的默认值，6.遍历Map解构，7.输入模块的指定方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串的扩展\"><a href=\"#字符串的扩展\" class=\"headerlink\" title=\"字符串的扩展\"></a>字符串的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unicode表示法</span><br><span class=\"line\"><span class=\"string\">\"\\u0061\"</span></span><br><span class=\"line\">// <span class=\"string\">\"a\"</span></span><br><span class=\"line\">但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示</span><br><span class=\"line\"></span><br><span class=\"line\">新增字符串的遍历器接口</span><br><span class=\"line\">U+005C：反斜杠（reverse solidus)</span><br><span class=\"line\">U+000D：回车（carriage <span class=\"built_in\">return</span>）</span><br><span class=\"line\">U+2028：行分隔符（line separator）</span><br><span class=\"line\">U+2029：段分隔符（paragraph separator）</span><br><span class=\"line\">U+000A：换行符（line feed）</span><br><span class=\"line\"></span><br><span class=\"line\">JSON.stringfy()的改造</span><br><span class=\"line\">模板字符串，用反引号（`）标识，可以当做普通字符串使用，也可以定义多行字符串，或者在字符串中嵌入变量。</span><br><span class=\"line\">如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</span><br><span class=\"line\">模板字符串中嵌入变量，需要将变量名写在<span class=\"variable\">$&#123;&#125;</span>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</span><br><span class=\"line\">模板字符串之中还能调用函数。</span><br><span class=\"line\">tag函数的使用，第一个参数是一个数组。</span><br><span class=\"line\">tag可以用于字符转义，多语言转换。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串的新增方法\"><a href=\"#字符串的新增方法\" class=\"headerlink\" title=\"字符串的新增方法\"></a>字符串的新增方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.fromCodePoint(0x78, 0x1f680, 0x79) === <span class=\"string\">'x\\uD83D\\uDE80y'</span>,可以识别大于0xFFFF的字符，与codePointAt()方法相反。</span><br><span class=\"line\">String.raw()用于模板字符串的处理方法。将所有变量替换，对斜杠进行转义。</span><br><span class=\"line\">String.codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。</span><br><span class=\"line\">normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</span><br><span class=\"line\">includes()：返回布尔值，表示是否找到了参数字符串。参数多一个n时，从第n个位置直到字符结束。</span><br><span class=\"line\">startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。参数多一个n时，从第n个位置直到字符结束。</span><br><span class=\"line\">endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。参数多一个n时，针对前n个字符。</span><br><span class=\"line\">repeat方法返回一个新字符串，表示将原字符串重复n次。参数不得为负或Infinity。</span><br><span class=\"line\">padStart()用于头部补全，padEnd()用于尾部补全。</span><br><span class=\"line\">matchAll()方法返回一个正则表达式在当前字符串的所有匹配。</span><br><span class=\"line\">trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"正则的扩展\"><a href=\"#正则的扩展\" class=\"headerlink\" title=\"正则的扩展\"></a>正则的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regexp构造函数，参数为字符串或正则表达式，分别返回正则表达式的修饰符和原有正则表达式的拷贝。</span><br><span class=\"line\">字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</span><br><span class=\"line\">Unicode模式（再看）</span><br><span class=\"line\">新增了sticky和flags属性，分别返回（boolean）是否设置了y修饰符和正则表达式的修饰符。</span><br><span class=\"line\">后行断言~~</span><br></pre></td></tr></table></figure>\n<h2 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">八进制使用前缀0o表示</span><br><span class=\"line\">二进制使用前缀0b表示</span><br><span class=\"line\">Number.isFinite() //检查数值是否为有限的（finite），如果参数不是数值一律返回<span class=\"literal\">false</span></span><br><span class=\"line\">Number.isNaN()//检查一个值是否为NaN，如果参数类型不是NaN，一律返回<span class=\"literal\">false</span></span><br><span class=\"line\">parseInt()，parseFloat()</span><br><span class=\"line\">// ES6的写法</span><br><span class=\"line\">Number.parseInt(<span class=\"string\">'12.34'</span>) // 12</span><br><span class=\"line\">Number.parseFloat(<span class=\"string\">'123.45#'</span>) // 123.45</span><br><span class=\"line\">Number.isInteger()//整数判断,数值精度太高会误判，返回<span class=\"literal\">true</span></span><br><span class=\"line\">JavaScript 能够准确表示的整数范围在-2^53到2^53之间,Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内</span><br><span class=\"line\">Math.trunc方法用于去除一个数的小数部分，返回整数部分。Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于空值和无法截取整数的值，返回NaN。</span><br><span class=\"line\">Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值</span><br><span class=\"line\">参数为正数，返回+1；</span><br><span class=\"line\">参数为负数，返回-1；</span><br><span class=\"line\">参数为 0，返回0；</span><br><span class=\"line\">参数为-0，返回-0;</span><br><span class=\"line\">其他值，返回NaN。</span><br><span class=\"line\">Math.cbrt()方法用于计算一个数的立方根。</span><br><span class=\"line\">Math.hypot方法返回所有参数的平方和的平方根。</span><br><span class=\"line\">Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。</span><br><span class=\"line\">Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</span><br><span class=\"line\">Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。//log2通用法</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数参数默认值写法 <span class=\"built_in\">log</span>（x=‘111’） //直接写在参数定义的后面，默认声明后无法再次声明，参数无法同名。</span><br><span class=\"line\">默认参数需要提供参数，否则（参数）默认一个空对象，当函数的参数是一个对象时-&gt;可以使用解构赋值传参。</span><br><span class=\"line\">传入undefined会触发默认值，null无法触发。</span><br><span class=\"line\">函数的length属性返回没有指定默认参数的个数。设置了参数默认值，初始化的时候参数有单独的作用域，初始化结束后作用域会消失。</span><br><span class=\"line\">ES6引入rest参数，形式为...变量名，用于获取函数的多余参数，不需要使用ar</span><br><span class=\"line\">guments对象了。rest是一个数组对象。</span><br><span class=\"line\">rest参数过后，不能再有其他参数，只能是最后一个，否则会报错。函数的length不包括rest。</span><br><span class=\"line\">ES2016后函数内部使用严格模式会报错</span><br><span class=\"line\">函数的Name属性返回函数的函数名，const bar = <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">baz</span></span>() &#123;&#125;; bar.name // <span class=\"string\">\"baz\"</span></span><br><span class=\"line\">箭头函数代码块多于一条语句，就要使用大括号将他们括起来，并使用<span class=\"built_in\">return</span>返回。</span><br><span class=\"line\">如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</span><br><span class=\"line\">注意点：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数没有自己的this，他们的this指向外层。</span><br><span class=\"line\">不可以当做构造函数，不可以使用new命令，否则会抛出错误。</span><br><span class=\"line\">不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</span><br><span class=\"line\">不可以使用yield命令，因此函数箭头不用做Generator函数。</span><br><span class=\"line\">尾调用：函数的最后一步操作是调用另一个函数。//函数尾调用在每次执行时，调用帧只有一项，这将大大节省内存，优化。//Chrome和Firefox不支持</span><br><span class=\"line\">类似的还有尾递归，函数尾调用自身。ES6的尾调用只在严格模式下开启。蹦床函数？</span><br><span class=\"line\">toString方法返回函数代码本身。</span><br><span class=\"line\">ES6允许catch省略参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a>数组的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复制数组，只是复制了指针，而不是克隆一个全新的数组，改变该值会导致原值的变化。使用concat函数进行复制。</span><br><span class=\"line\">也可以使用concat进行数组的合并，不过该方法为浅拷贝。</span><br><span class=\"line\">Iterator接口的对象，遍历器，用扩展运算符（...）转为真正的数组。</span><br><span class=\"line\">Array.from（）方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象。与数组的Map相似。</span><br><span class=\"line\">Array.of()方法用于将一组值转换为数组。Array.of() // []  ；  Array.of(undefined) // [undefined]</span><br><span class=\"line\">Array.prototype.copyWithin(target, start = 0, end = this.length)</span><br><span class=\"line\">target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</span><br><span class=\"line\">start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</span><br><span class=\"line\">end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</span><br><span class=\"line\">数组实例：find（）：用于找出第一个符合条件的数组成员，findIndex（）：返回第一个符合条件的数组成员的位置，如果都不符合条件，返回-1.</span><br><span class=\"line\">fill（）用于补充空数组的初始化，可以选定位置，如果填充的类型为对象，那么赋值的是同一个内存地址的对象，改变其中的值会改变其他赋值的值。</span><br><span class=\"line\">keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</span><br><span class=\"line\">includes方法返回一个布尔值，表示某个数组是否包含给定的值。</span><br><span class=\"line\">Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</span><br><span class=\"line\">Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</span><br><span class=\"line\">flat（）函数，用于拉平数组，如果原数组里包含数组，将子数组成员取出来添加在原来的位置。需要设置层数。flat会跳过空位。</span><br><span class=\"line\">flatMap（）参数为遍历函数，有第二个参数可以绑定遍历函数里面的this。</span><br><span class=\"line\">Array(3) // [, , ,]具有3个空位的数组</span><br><span class=\"line\">forEach(), filter(), reduce(), every() 和some()都会跳过空位。</span><br><span class=\"line\">map()会跳过空位，但会保留这个值</span><br><span class=\"line\">join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串</span><br><span class=\"line\">自带的sort（）排序不稳定</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj[<span class=\"string\">'a'</span> + <span class=\"string\">'bc'</span>] = 123;//abc:123</span><br><span class=\"line\">// 报错</span><br><span class=\"line\">const foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">const bar = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">const baz = &#123; [foo] &#125;;</span><br><span class=\"line\">// 正确</span><br><span class=\"line\">const foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">const baz = &#123; [foo]: <span class=\"string\">'abc'</span>&#125;;</span><br><span class=\"line\">有两种特殊情况：<span class=\"built_in\">bind</span>方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</span><br><span class=\"line\">(new Function()).name // <span class=\"string\">\"anonymous\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">var doSomething = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">doSomething.bind().name // <span class=\"string\">\"bound doSomething\"</span></span><br><span class=\"line\">for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class=\"line\">Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class=\"line\">JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class=\"line\">Object.assign()： 忽略enumerable为<span class=\"literal\">false</span>的属性，只拷贝对象自身的可枚举的属性。</span><br><span class=\"line\">ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。//只能用在对象的方法之中。</span><br><span class=\"line\">如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式。</span><br><span class=\"line\">扩展运算符后面可以为数组，如果是空对象，无效果。</span><br><span class=\"line\">// 等同于 &#123;...Object(1)&#125;</span><br><span class=\"line\">&#123;...1&#125; // &#123;&#125;不是对象，自动转为对象</span><br><span class=\"line\">如果后面是字符串，它会自动转换成一个类似数组的对象，因此返回的不是空对象。</span><br><span class=\"line\">对象的扩展运算符等同于使用Object.assign()方法。</span><br><span class=\"line\">完整克隆对象的方法：</span><br><span class=\"line\">// 写法一</span><br><span class=\"line\">const clone1 = &#123;</span><br><span class=\"line\">  __proto__: Object.getPrototypeOf(obj),</span><br><span class=\"line\">  ...obj</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法二</span><br><span class=\"line\">const clone2 = Object.assign(</span><br><span class=\"line\">  Object.create(Object.getPrototypeOf(obj)),</span><br><span class=\"line\">  obj</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法三</span><br><span class=\"line\">const clone3 = Object.create(</span><br><span class=\"line\">  Object.getPrototypeOf(obj),</span><br><span class=\"line\">  Object.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">)</span><br><span class=\"line\">扩展运算符可以用于合并两个对象//<span class=\"built_in\">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class=\"line\">链判断运算符</span><br><span class=\"line\">const firstName = (message//读取message.body.user.firstName</span><br><span class=\"line\">  &amp;&amp; message.body//读取对象内部的某个属性，往往需要判断一下对象是否存在(也可以使用三元运算符)</span><br><span class=\"line\">  &amp;&amp; message.body.user</span><br><span class=\"line\">  &amp;&amp; message.body.user.firstName) || <span class=\"string\">'default'</span>;</span><br><span class=\"line\">引入了？？Null判断运算符，类似||，只有运算符左侧的值为null或undefined时，才会返回右侧的值。</span><br></pre></td></tr></table></figure>\n<h2 id=\"对象的新增方法\"><a href=\"#对象的新增方法\" class=\"headerlink\" title=\"对象的新增方法\"></a>对象的新增方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.is()比较聊个值是否相同，与===的行为基本一致。</span><br><span class=\"line\">Object.is(+0, -0) // <span class=\"literal\">false</span></span><br><span class=\"line\">Object.is(NaN, NaN) // <span class=\"literal\">true</span></span><br><span class=\"line\">Object.assign()//方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象。</span><br><span class=\"line\">Object.assign(target, source1, source2);//第一个参数是目标对象，后面的参数都是源对象</span><br><span class=\"line\">如果只有一个参数，会直接返回该参数。如果该参数不是对象，则会先转成对象，然后返回。</span><br><span class=\"line\">undefined和null无法转成对象，作为参数会报错。</span><br><span class=\"line\">assign方法实行的是浅拷贝。同名的属性会进行替换。</span><br><span class=\"line\">const target = &#123; a: &#123; b: <span class=\"string\">'c'</span>, d: <span class=\"string\">'e'</span> &#125; &#125;</span><br><span class=\"line\">const <span class=\"built_in\">source</span> = &#123; a: &#123; b: <span class=\"string\">'hello'</span> &#125; &#125;</span><br><span class=\"line\">Object.assign(target, <span class=\"built_in\">source</span>)</span><br><span class=\"line\">// &#123; a: &#123; b: <span class=\"string\">'hello'</span> &#125; &#125;</span><br><span class=\"line\">数组处理，assign把数组视为属性名为0,1,2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1</span><br><span class=\"line\">Object.assign([1, 2, 3], [4, 5])</span><br><span class=\"line\">// [4, 5, 3]</span><br><span class=\"line\">如果复制的值是一个取值函数，那么会求值后再复制。</span><br><span class=\"line\">const <span class=\"built_in\">source</span> = &#123;</span><br><span class=\"line\">  get <span class=\"function\"><span class=\"title\">foo</span></span>() &#123; <span class=\"built_in\">return</span> 1 &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const target = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(target, <span class=\"built_in\">source</span>)</span><br><span class=\"line\">// &#123; foo: 1 &#125;</span><br><span class=\"line\">assign常见用途：</span><br><span class=\"line\">（1）为对象添加属性</span><br><span class=\"line\">（2）为对象添加方法</span><br><span class=\"line\">（3）克隆对象</span><br><span class=\"line\">（4）合并对象</span><br><span class=\"line\">（5）为属性指定默认值</span><br><span class=\"line\">Object.keys()//返回一个数组，成员是参数对象自身的所有可遍历属性的键名。</span><br><span class=\"line\">Object.values()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值。</span><br><span class=\"line\">Object.entries()//返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。</span><br><span class=\"line\">Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象</span><br></pre></td></tr></table></figure>\n<h2 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">symbol值通过Symbol函数生成。Symbol函数前不能使用New命令，否则会报错。因为Symbol是一个原始类型的值，不是对象。</span><br><span class=\"line\">Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</span><br><span class=\"line\">Symbol值不能与其他类型进行运算，会报错。Symbol可以显式转为字符串，也可以转为布尔值，但不能转为数值。</span><br><span class=\"line\">实例：消除魔术字符串</span><br><span class=\"line\">Object.getOwnPropertySymbols()方法，获取指定对象的所有Symbol属性名。返回一个数组。</span><br><span class=\"line\">Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</span><br></pre></td></tr></table></figure>\n<p>参考文档：<a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">https://es6.ruanyifeng.com/</a></p>\n"},{"title":"JavaScript高级程序设计","date":"2020-11-23T01:43:04.000Z","_content":"# 1.1 历史回顾\n网站数据量大，复杂。需要JS来解决，优化。\n# 1.2 JS实现\nJS = ECMAScript（核心） + DOM（文档对象模型） + BOM（浏览器对象模型）\n## 1.2.1（ECMAScript）\nES：网页提供ES的基准实现和与环境自身交互必须的扩展。\nES包括：语法、类型、语句、关键字、保留字、操作符、全局对象。\n大部分浏览器兼容ES6。\n## 1.2.2 DOM\n文档对象模型：是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。F12中常见的文档树。\n![文档树](文档树.png)\nDOM通过创建表示文档的树，让开发者可以更好地控制网页的内容和结构。使用DOM的API，可以轻松删除，添加，替换，修改节点。\nDOM视图：描述追踪文档不同视图的接口。\nDOM事件：描述事件及事件处理的接口。\nDOM样式：描述处理元素CSS样式的接口。\nDOM遍历的范围：描述遍历和操作DOM数的接口。\n其他DOM：可伸缩矢量图（SVG），数学标记语言（MathML），同步多媒体集成语言（SMIL）\nDOM有不同level（版本）:目前到了level3\n## 1.2.3 BOM\n浏览器对象模型：用于支持访问和操作浏览器的窗口。使用BOM，可以操控浏览器显示页面之外的部分，BOM针对浏览器窗口和子窗口。拓展：\n弹出新浏览器窗口的能力；\n移动、缩放和关闭浏览器窗口的能力；\nnavigator对象，提供关于浏览器的详尽信息；\nlocation对象，提供浏览器加载页面的详尽信息；\nscreen对象，提供关于用户屏幕分辨率的详尽信息；\nperformance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；\n对cookie的支持；\n其他自定义对象，XMLHttp，ActiveXObject；\n# 1.3 JavaScript版本\n# 1.4 小结\nJS是一门用来与网页交互的脚本语言，包含以下三个组成部分。\nES：有ECMA-262定义并提供核心功能。\n文档对象模型（DOM）:提供与网页内容交互的方法和接口。\n浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。\nJS这三个部门得到了五大Web浏览器不同程度的支持。所有浏览器基本上对ES5提供了完善的支持，ES6最佳。\n---\n# 2.1 script元素\n将Js插入HTML的主要方法是使用script元素。有下列8个属性：\n1.async：可选，表示立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。\n2.charset：可选，使用src属性指定的代码字符集。很少用。\n3.crossorigin：可选，配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。\ndefer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。\nintegrity：可选，允许比对接收到的资源和指定的加密签名以验证子资源完整性。\nlanguage：废弃。\nsrc：可选，表示包含要执行的代码的外部文件。（引入外部JS文件）\ntype：可选，代替language，表示代码块中脚本语言的内容类型（MIME类型）。按照惯例这个值始终都是“text/JavaScript”，MIME类型通常都是“application/x-javascript”，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。\n## 2.1.1 标签位置\n```\n<head>\n<script src='example1.js'></script>\n</head>\n```\n上述是把文件放在head里，不过这种写法以为着必须把所有JS代码都下载、解析和解释完成后，才能开始渲染页面，可能会导致页面渲染的明显延迟，所以通常把文件引用放在body元素中的页面内容后面。\n```\n<body>\n<script src='example2.js'></script>\n</body>\n```\n## 2.1.2 推迟执行脚本\n可用defer属性，可用推迟脚本执行。\n```\n<script defer src='example1.js'></script>\n```\n## 2.1.3 异步执行脚本\n```\n<script async src='example1.js'></script>\n```\n## 2.1.4 动态加载脚本\nJS可用使用DOM API ，通过向DOM中动态添加Script元素同样可用加载指定的脚本，只要创建一个Script元素并将其添加到DOM即可。如下：\nlet script = document.createElement('script');\nscript.src = 'gibbersh.js'\ndocument.head.appendChild(script);\n这个请求是异步的，不是所有浏览器都支持async属性，因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。\n添加：script.async = false;\n以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。这种可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：\n```\n<link rel=\"preload\" href=\"gibberish.js\">\n```\n## 2.1.5 XMHTL中的变化\nXHTML：可扩展超文本标记语言，是将HTML作为XML的应用重新包装的结果。在XHTML中使用JS必须制定type属性且值为text/javascript。\nXHTML比较少见。\n## 2.1.6 废弃的语法\n个别废弃的语法，可不看。\n# 2.2 行内代码与外部文件\n最佳实践是尽可能将JS代码放在外部文件中。推荐原因如下：\n可维护性：JS代码分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。\n缓存：浏览器会根据特定的设置缓存所有外部链接的JS文件，这意味着若干两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。\n适应未来：通过把JS放到外部文件中，就不比考虑用XHTML的或注释黑科技。包含外部JS文件的语法在HTML和XHTML是一样的。\n在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JS组件形式向客户端送达脚本更具优势。\n在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从同一个地方取得一批文件，并将他们逐个放到浏览器缓存中。从浏览器角度看，通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JS文件的 延迟差不多。\n在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。\n# 2.3 文档模式\n最初有两种模式：混杂模式，标准模式。\n第三种模式：准标准模式。\n# 2.4 noscript元素\n针对不支持JS的浏览器而出的元素。以下两种情况，浏览器将显示包含在noscript中的内容：\n浏览器不支持脚本；\n浏览器对脚本的支持被关闭；\n```\n <noscript> \n <p>This page requires a JavaScript-enabled browser.</p> \n </noscript>\n```\n# 2.5 小结\nJS通过script元素插入到HTML页面中。这个元素可以用于把JS代码嵌入到HTML页面汇总，跟其他标记混合在一起，也可以用与引入保存在外部文件中的JS。本章的重点如下：\n1.要包含外部JS文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。\n2.所有script元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在script元素中的代码必须严格按次序解释。\n3.对不推迟执行的脚本，浏览器必须解释完位于script元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常把script元素放到页面末尾，介于主内容之后及body标签之前。\n4.可以使用defer推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。\n5.可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。\n6.通过使用noscript元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则noscript元素中的任何内容都不会被渲染。\n# 3.1 语法\n## 3.1.1 区别大小写\nECMA中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。\ntypeof不能作为函数名，因为它是一个关键字。但Typeof可以用。\n## 3.1.2 标识符\n变量、函数、属性或函数参数的名称。可以由一个或多个下列字符组成：\n第一个字符必须是一个字母、下划线（_）或美元符号（$）;\n剩下的其他字符可以是字母、下划线、美元符号或数字。\n一般使用驼峰大小写形式。\n## 3.1.3 注释\n## 3.1.4 严格模式\n\"use strict\" //脚本开头加上这一行\n也可以在指定函数内加上开头。所有现代浏览器都支持严格模式。\n## 3.1.5 语句\n结尾建议加分号，建议语句块加{}\n## 3.2 关键字与保留字\nES6的关键字有：\nbreak \tdo \tin \ttypeof \ncase \telse \tinstanceof \tvar \ncatch \texport \tnew \tvoid \nclass \textends \treturn \twhile \nconst \tfinally \tsuper \twith \ncontinue   for \tswitch \tyield \ndebugger function    this \ndefault \tif \tthrow \ndelete \timport \ttry\nES6将来保留词汇：\n始终保留：\nenum\n严格模式下保留：\nimplements \tpackage \tpublic \ninterface\t protected \tstatic \nlet \tprivate\n模块代码中保留：\nawait\n这些词汇不能作标识符，但可以坐对象的属性名，推荐不用作属性名。\n# 3.3 变量\nECMA变量是松散类型的，变量可以用于保存任何类型的数据。每个变量不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var,const,let\nvar:声明完后可以赋值，但未标识类型。//声明提升\n//var message = \"hi\"; \n//message = 100; // 合法，但不推荐。\n//作用域在声明的环境下的函数作用域，例在函数内定义，调用完函数随即被销毁。\n//在函数内定义时省略var操作符，可以创建一个全局变量。不推荐这么做。\nlet:块作用域，同一个块内不能重复声明。变量在作用域中无声明提升。\n//有暂时性死区。\n//无法全局声明，声明的变量不会成为window对象的属性。\n//ES6不能依赖条件声明模式\nconst:与let基本相同，区别是声明变量时必须同时初始化变量，且无法修改const声明的变量。\n## 3.3.4 声明风格及最佳实践\n1.不使用var\n2.const优先，let次之\n# 3.4 数据类型\nES6有6种简单的数据类型（原始类型）：undefined,null,boolean,number,String,Symbol。Symbol是ES6新增的。还有一种复杂的数据类型叫Object（对象）。Object是一种无序名值对的集合。\n## 3.4.1 typeof操作符\n不需要参数（但可以使用参数），严格来说，函数也是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。可以用typeof区分。\n## 3.4.2 Undefined类型\n变量未初始化即是Undefined，相当于给变量赋值了Undefined。\n建议在声明时初始化，出现undefined可以更好辨别。\n## 3.4.4 Null类型\nNull类型同样只有一个值，即特殊值null。null值表示一个空对象指针，typeof null返回Object。\n在定义将来要保存对象值的变量时，建议初始化为null。\n## 3.4.4 Boolean类型\n有两个字面值：true，false。\nTrue和False是有效的标识符，不是布尔值。//区分大小写\n使用Boolean()来转换类型\n## 3.4.5 Number类型\n1.浮点值\n//小数点后面必须带数字，不然当整数处理。\n2.值的范围\n//Number.MIN_VALUE:5e-324\nNumber.MAX_VALUE:1.7976931348623157e+308\n超出以上范围会表示为Infinity或-Infinity,该值无法用于计算。\n可使用isFinite()函数进行判断\n3.NaN\nNaN表示\"不是数值\",用于表示本来要返回数值的操作失败了（不是抛出错误）。\n例：0除任意数值\nconsole.log(0/0) // NaN\nconsole.log(5/0) //Infinity\nconsole.log(5/-0)//-Infinity\n任何涉及NaN的操作始终返回NaN，NaN不等于任何值。//(NaN == NaN)-->false\n可用isNaN()函数判断是否不是数值\nisNaN(NaN)//true\nisNaN(10)//false\nisNaN(\"10\")//false,可转换为数值10\nisNaN(\"blue\")//true,无法转换为数值\nisNaN(true)//false,可以转换为1\n4.数值转换\n有3个函数可以将非数值转换为数值：\nNumber(),parseInt(),parseFloat()\nNumber()是转型函数，可用于任何数据类型。后两个主要用于将字符串转为数值。\nNumber()有如下规则：\n(true)->1,(false)->0,(null)->0,(undefined)->NaN,数值直接返回\n如果字符串包含数值字符，包括数值字符前面带加号、减号的情况，则转换为一个十进制数值。\n如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值（同样，忽略前面的0）。\n如果字符串包含有效的十六进制格式如\"0xf\"，则会转换为与该十六进制值对应的十进制整数值。\n如果是空字符串（不包含字符），则返回0。\n如果字符串包含上述情况之外的其他字符，则返回NaN。\n通常使用parseInt（）\n## 3.4.6 String类型\n字符串使用：双引号，单引号，反引号都合法，引号类型前后必须一致。\n1.字面量：\n\\n  换行\n\\t   制表\n\\b  退格\n\\r   回车\n\\f   换页等\n2.特点\n不可变，一旦创建，值不能变。要修改某个变量的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。\n3.转换为字符串\ntoString()//函数\n还可以传入参数输出不同进制\nlet num = 10;\nnum.toString() // \"10\"\nnum.toString(2) // \"1010\"\nnum.toString(8) // \"12\"\n4.模板字面量\n可以使用换行字符，可以跨行定义字符串。\n使用反引号会保持引号内部的空格，字面量，length会增加。\n5.字符串插值\n可以在定义中插入一个或多个值。\n通过反引号中使用 ${}插入，插入的值都会通过toString转换为字符串\n插值表达式中可以调用函数和方法：\nfoo = {toString:() => 'Wrold'};`hello,${foo}` // hello world\ncapitalize(word) =>return `${word[0].toUpperCase()}`   // `${capitalize('hello')}`//->Hello\n6.模板字面量标签函数\n支持定义标签函数，通过标签函数可以自定义插值行为。\n7.原始字符串\nUnicode字符\n使用String.raw获取原始字符串\n'\\u00A9' // 版权符号\nString.raw`\\u00A9`// \\u00A9\n## 3.4.7 Symbol类型\nSymbol是ES6新增的，且实例是唯一，不可变的。用于创建唯一记号，进而用作非字符串形式的对象属性。\n1.基本用法\nlet sym = Symbol(); type of sym//symbol\n也可以传入字符串参数作为对symbol的描述，可通过这个字符串来调试代码。但这个字符串参数与符号定义或标识无关。\n符号无法与new关键字一起作为构造函数使用。\n可以使用符号包装对象，借用Object函数()函数：\nlet mySymbol = Symbol();\nlet myWrappedSymbol = Object (mySymbol);\nconsole.log(typeof myWrappedSymbol); // \"object\"\n2.使用全局符号注册表\n如果运行时的不同部分需要共享和 重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。\n需要使用Symbol.for()方法。\n## 3.4.8 Object类型\n对象其实就是一组数据和功能的集合。可以通过new来创建实例对象。\n每个对象都有如下属性和方法：\nconstructor：用于创建当前对象的函数，构造函数。\nhasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性。\nisPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。\npropertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用。\ntoLacaleString():返回对象的字符串表示,反映对象所在本地化执行环境。\ntoString():返回对象的字符串表示。\nvalueOf():返回对象对应的字符串、数值或布尔值表示。\n# 3.5 操作符\n## 3.5.1 一元操作符\n只操作一个值的操作符叫一元操作符。\n++,--;  //操作中会自行转换类型,(递增和递减)\n+,-//一元加减符，可以用于运算和转换\n## 3.5.2 位操作符\n...\n## 3.5.3 布尔操作符\n逻辑非，逻辑与逻辑或\n1.逻辑非 ：！（感叹号）\n!false // true\n!\"blue\" //false\n!0 //true\n!NaN //true\n!\"\" //true\n!12345 //false\n也可以用两个感叹号:!!,相当于调用了转型函数Boolean()。第一个返回布尔值，第二个对该布尔值取反。\n相当于如上例子，布尔值取反。\n2.逻辑与\n由&&表示 // true && true为true  其余都为false\n3.逻辑或\n由||表示 //有一个是true为true，false || false为false\n## 3.5.4 乘性操作符\n乘法(*)，除法(/)，取模(%)。\n乘法(*):都为数值则计算，有一项为NaN则返回NaN，如果是Infinity*0=NaN,Infinity*(-/+)num=(-)Infinity，Infinity*Infinity=Infinity,如果不是数值会转换后再近些操作。\n除法(/):\n0 / 0 = NaN,Infinity / Infinity = NaN,-(number)/0 = (-)Infinity,Infinity / (-)Number = (-)Infinity\n取模(%):类似除\n## 3.5.5 指数操作符\nES7新增的操作符 (**)//Math.pow(3,2) == 3 ** 2 == 9\nsquared ** = 2 //9\n## 3.5.6 加性操作符\n（+），（-）\n## 3.5.7 关系操作符\n（<）,（>）,（<=），（>=）\n## 3.5.8 相等操作符\n（==），（!=），（===）,（!==）\n## 3.5.9 条件操作符\n（?）// let max = （num1 > num2）? num1 : num2\n## 3.5.10 赋值操作符\n（=），（*=），（/=），（%=），（+=）,（-=）,（<<=）,（>>=）,（>>>=）\n# 3.6 语句\n## 3.6.1 if语句\n...\n## 3.6.2 do-while语句\ndo {***} while(expression);\n## 3.6.3 while语句\nlet i = 0;\nwhile(i < 10) { i += 2};\n## 3.6.4 for语句\nfor(initialization;expression;post-loop-expression) statement\n## 3.6.5 for-in语句\nfor(property in expression) statement\nfor(const propName in window) {document.write(propName)}//例子\n## 3.6.6 for-of语句\nfor(property of expression) statement\nfor(const el of [2,4,6,8]){document.write(el)}//例子\n## 3.6.7 标签语句\nlabel:statement\nstart: for(let i = 0;i < count;i++){console.log(i)}//start是一个标签，可在后面通过break，continue语句引用。\n## 3.6.8 break和continue语句\nbreak用于立即退出循环,强行执行循环后的下一条语句。\ncontinue语句用于立即退出循环，但会从循环顶部开始执行。\n## 3.6.9 with语句\nwith(expression) statement;\nlet qs = location.search.substring(1);\nlet hostName = location.hostname;\nlet url = location.href;\nwith(location){\nlet qs = search.substring(1);\nlet hostName = hostname;\nlet url = href;\n}\n严格模式不允许使用\n## 3.6.10 switch语句\nswitch(expression){\n  case value1:\n    statament\n    break;\n  case value2:\n    statement\n    break;\n  ...\n  default:\n    statement\n}\n//switch不会强制转换数据类型\n## 3.7 函数\nfunction Name(arg0,arg1){ statements}\n遇到return语句函数就会立即停止执行并退出。\n函数不能以eval，arguments作为名称；\n函数的参数不能叫eval，arguments；\n两个命名参数不能拥有同一个名称。\n## 3.8 小结\nES中基本数据类型包括：undefined,Null,Boolean,Number,String,Symbol\n不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。//声明方式\n不指定返回值的函数实际上会返回特殊值undefined。\n# 4 变量、作用域与内存\n## 4.1 原始值与引用值\n变量有两种不同的类型：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。\n原始值的变量是按值访问的，引用值是保存在内存中的对象，操作对象时，操作的是对该对象的引用而非实际的对象本身。\n### 4.1.1 动态属性\n引用值可以随时添加、修改和删除其属性和方法。\n只有引用值可以动态添加后面可以使用的属性。\n原始类型的初始化可以只使用原始字面量形式。如果使用new则创建Object类型的实例。\nlet name1 = \"wxc\";//typeof name1 == string\nlet name2 = new String(\"Matt\");//typeof name2 == object\n### 4.1.2 复制值\n原始值的变量复制会创建新变量。//let name1 = \"wxc\";let name2 = name1;\n引用值的变量复制的是一个指针，两个变量指向同一个对象，一改则都改。\n### 4.1.3 传递参数\n函数的参数都是按值传递的，传递时，值会被复制到一个局部变量。\n按引用传递参数时，值在内存中的位置会被保存在一个局部变量，对本地变量的修改会反映到函数外部。ES中函数的参数就是局部变量。\n### 4.1.4确定类型\ntypeof对于原始值有用，但对引用值不大。\n引用值判断可以用instanceof\nperson instanceof Object\ncolors instanceof Array\npattern instanceof RegExp\ninstanceof对于原始值始终返回false，原始值不是对象。\n## 4.2 执行上下文与作用域\n每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。\n浏览器中，全局上下文为window对象。var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。\n每个函数也有自己的上下文，执行函数时，函数上下文被推倒一个上下文栈上，执行完后弹出。ES的执行流通过该上下文栈进行控制。\n上下文中的代码在执行时，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链的下一个变量对象来自上级包含上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。\n局部作用域中定义的变量可用于在局部上下文中替换全局变量。\n### 4.2.1 作用域链增强\n代码执行到try/catch语句的catch块与with语句时，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。\n### 4.2.2 变量声明\n1.使用var声明变量，变量会被自动添加到最接近的上下文，最接近的上下文大多是函数的局部上下文，如果未声明就被初始化了，就被添加到全局上下文。如果在函数内声明变量添加到全局上下文，函数退出后依然可以访问。\nvar声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。变量提升。\n2.使用let声明的块级作用域声明\n块级作用域由最近的{}界定。\n3.使用const的常量声明\nconst声明的同时必须初始化为某个值。声明后不能重新赋新值。\n作用域与let声明一样。\n建议多使用const，除非需要一个会重新赋值的变量。可以防止重新赋值的BUG。\n4.标识符查找\n特定上下文读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。//其实就是调用变量\n## 4.3 垃圾回收\nJS使用垃圾回收，程序每隔一段就会自动运行。确定不会再使用的变量，释放内存。\n### 4.3.1 标记清理\n常用策略是标记清理。程序运行时，标记内存中存储的所有变量，将所有上下文中的变量，以及被在上下文中的变量引用的标记去掉。再加上标记代表待删除，随后做一次内存清理，销毁带标记的所有值并回收内存。\nIE，Firefox，Opera，Chrome，Safari都在JS实习标记清理，频率有所差异。\n### 4.3.2 引用计数\n对每个值记录引用次数。声明变量并赋一个引用值时，这个值的引用数为1。 如果保存对该值引用的变量被其他值给覆盖了，引用数-1。引用数为0时回收内存。\n### 4.3.3 性能\n垃圾回收的时间调度很重要，变量太多会造成性能损失。JS引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果回收的内存不到已分配的15%，这些阈值会翻倍。如果一次回收的内存达到已分配的85%，则阈值重置为默认值。\n### 4.3.4 内存管理\n保证在执行代码时只保存必要的数据。不在必要则设置为null，从而释放其引用。这也可以叫作解除引用。局部变量在超出作用域会自动解除引用，所以该建议更适合全局变量和全局对象。\n1.通过const和let声明提升性能\n块作用域，能更早让垃圾回收程序介入。\n2.隐藏类和删除操作\n对象与隐藏类会被关联起来，用于跟踪他们的属性特征。共享相同隐藏类的对象性能会更好。\nfunction Article(){this.title = 'go go go'}\nlet a1 = new Article();//隐藏类title\nlet a2 = new Article();//隐藏类title\na1.author = 'Jake'//对应多出author隐藏类，可能对性能产生明显影响。\nfunction Article(author){this.title='go',this.author=author}\nlet a2 = new Article('wxc')//a2与a1相同，共享一个隐藏类。\ndelete a1.author//使用delete关键字会导致生成同样的隐藏类片段\na1.author = null; //保持共享，并达到垃圾回收的效果\n3.内存泄漏\nJS的内存泄漏大部分是不合理的引用导致的。\nfunction(){name = 'Jake'}意外声明全局变量是最常见也最容易修复的内存泄漏问题。无关键字声明。\n定时器也会导致内存泄漏，定时器的回调通过闭包引用了外部变量。\n使用闭包容易造成内存泄漏，如下：\nlet outer = function() {let name = 'Jake';return function() {return name};};\n调用outer()会导致内存泄漏。只要返回的函数存在就不能清理name，因为闭包一直在引用，加入name的内容很大，就是个大问题。\n4.静态分配与对象池\n不要动态创建矢量对象\n在初始化的时候，创建一个对象池，管理一组可回收的对象。使用完后回归对象池。\n## 4.4 小结\n原始值大小固定，因此保存在栈内存上。\n引用值是对象，存储在堆内存上。\n任何变量都存在于某个作用域（上下文）中，这个作用域决定了变量的声明周期，以及它们可以访问代码的哪些部分。\n全局上下文：window，浏览器。\n函数上下文：声明函数的{}内\n块级上下文：最近的{}内\nJS有垃圾回收，垃圾回收的方法有：引用计数，标记清理。主流为标记清理。\n接触变量引用一般直接给变量赋值为null。\n# 5.基本引用类型\n引用值是某个特定引用类型的实例。\n对象被认为是某个特定引用类型的实例。新对象通过使用new操作符跟一个构造函数来创建。\n函数也是一种引用类型。\n## 5.1 Date\n日期对象//let now = new Date();\n可用Date.parse()转换成日期对象//let someDate = new Date(Date.parse(\"May 23,2019\"));如果字符串不表示日期，会返回NaN。\nlet allFives = new Date(Date.UTC(2005,4,5,17,55,55));//GMT时间——Date.UTC方法\nES提供了Date.now()方法，返回表示方法执行时日期。\nlet start = Date.now();//当前时间\n### 5.1.1 继承的方法\nlet date = new Date(2021,1,20);\ntoLocaleString()//-->2021/2/20 上午12:00:00\ntoString()//-->Sat Feb 20 2021 00:00:00 GMT+0800\nvalueOf()//-->1613750400000\n### 5.1.2 日期格式化方法\nDate格式化日期的方法：\ntoDateString()//显示日期中的周几，月，日，年\ntoTimeString()//显示日期中的时分秒和时区\ntoLocaleDateString()//显示日期中的周几 月 日 年\ntoLocaleTimeString()//显示日期中的时 分 秒\ntoUTCString()//显示完整的UTC日期\n### 5.1.3 日期/时间组件方法\n主要应用：\ngetTime()//返回日期的毫秒表示，与valueOf相同\nsetTime(milliseconds)//设置日期的毫秒表示，从而修改整个日期\ngetFullYear()//返回四位年数\ngetMonth()//返回日期的月\ngetDate()//返回日期的日\ngetDay()//返回日期中表示周几的数值\ngetHours()//返回日期中的时\ngetMinutes()//返回日期中的分\ngetSeconds()//返回日期中的秒\n## 5.2 RegExp\nES通过RegExp类型支持正则表达式。\nlet expression = /pattern/flags;\n匹配模式的标记：\n1.g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。\n2.i:不区分大小写，表示查找匹配时忽略pattern和字符串的大小写。\n3.m:多行模式，表示查找到一行文本末尾时会继续查找。\n4.y:粘附模式，表示只查找从lastIndex开始及之后的字符串。\n5.u:Unicode模式，启用Unicode匹配。\n6.s：dotAll模式，表示元字符匹配任何字符。(包括\\n或\\r)。\n使用不同模式和标记可以创建出各种正则表达式，比如：\n//匹配字符串中的所有\"at\"\nlet pattern1 = /at/g;\n//匹配第一个\"bat\"或\"cat\" 忽略大小写\nlet pattern2 = /[bc]at/i\n//匹配所有以\"at\"结尾的三字符组合，忽略大小写\nlet pattern3 = /.at/gi\n元字符在模式中必须转义：\n( ，[， {，\\，^，$，|，)，]，}，？，*，+，- //这些符号前面需要\\来转义\n//匹配第一个\"bat\"或\"cat\"，忽略大小写\nlet pattern1 = /[bc]at/i;\n//匹配第一个\"[bc]at\"，忽略大小写\nlet pattern2 = /\\[bc\\]at/i;\n//匹配所有以\"at\"结尾的三字符组合，忽略大小写\nlet pattern3 = /.at/gi;\n//匹配所有\".at\"，忽略大小写\nlet pattern4 = /\\.at/gi;\n也可使用RegExp构造函数来创建：\nlet pattern1 = /[bc]at/i   ==   new RegExp(\"[bc]at\",\"i\");\n也可以使用实例，选择性修改标记\nconst re1 = /cat/g;\nconst re2 = new RegExp(re1);\nconst re3 = new RegExp(re1,\"i\");\n### 5.2.1 RegExp实例属性\nglobal:布尔值，表示是否设置了g标记。\nignoreCase:布尔值，表示是否设置了i标记。\nunicode:布尔值，表示是否设置了u标记。\nsticky:布尔值，表示是否设置了y标记。\nlastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。\nmultiline:布尔值，表示是否设置了m标记。\ndotAll:布尔值，表示是否设置了s标记。\nsource:正则表达式的字面量字符串，没有开头和结尾的斜杠。\nflags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回。\n### 5.2.2 RegExp实例方法\nexec()函数：\nlet text = 'cat, bat, sat, fat';\n  let pattern = /.at/gi;\n  let matchs = pattern.exec(text);\n  console.log(matchs);//cat\n//设置了全局标记(g)，每次调用返回一个匹配的信息，如果没有设置全局标记，只会返回第一个匹配的信息。\n//设置了g标记，每次调用exec()都会在字符中向前搜索下一个匹配项\nlet text = 'cat, bat, sat, fat';\n  let pattern = /.at/gi;\n  let matchs = pattern.exec(text);//cat\n  let matchs = pattern.exec(text);//bat\n  let matchs = pattern.exec(text);//sat\n  console.log(matchs);\n//设置了y标记，每次调用会在lastIndex的位置上寻找匹配项。y标记覆盖g标记。\ntest()函数：//用于判断是否存在实际内容中，常在if判断语句中\nlet text = \"000-00-00 00\";\nlet pattern = /\\d{3}-\\d{2}-\\d(4)/;\nif(pattern.test(text)) {console.log(\"The pattern was matched.\")};\n继承的方法toLocaleString()和toString()都返回字面量表示。\nlet pattern = new RegExp(\"\\\\[bc\\\\]at\",\"gt\");\nconsole.log(pattern.toString());//  /\\[bc\\]at/gi\nconsole.log(pattern.toLocaleString());//  /\\[bc\\]at/gi\n### 5.2.3 RegExp构造函数属性\ninput：$_   //最后搜索的字符串\nlastMatch：$&   //最后匹配的文本\nlastParen：$+   //最后匹配的捕获组\nleftContext：$`   //input字符串中出现在lastMatch前面的文本\nrightContext：$'   //input字符串中出现在lastMatch后面的文本\nlet text = \"this has been a short summer\";\nlet pattern = /(.)hort/g; //()-->捕获组\nif(pattern.test(text)) {\n   console.log(RegExp.input); //this has been a short summer\n   console.log(RegExp.leftContext); //this has been a\n   console.log(RegExp.rightContext); //summer\n   console.log(RegExp.lastMatch); //short\n   console.log(RegExp.input); //s\n}\n\nif(pattern.test(text)) {\n   console.log(RegExp.$_); //this has been a short summer\n   console.log(RegExp[\"$`\"]); //this has been a\n   console.log(RegExp[\"$'\"]); //summer\n   console.log(RegExp[\"$&\"]); //short\n   console.log(RegExp[\"$+\"]); //s\n}\nlet pattern = /(..)or(.)/g;\n\nif(pattern.test(text)) {\n   console.log(RegExp.$1); // sh\n   console.log(RegExp.$2);// t\n}\n### 5.2.4 模式局限\nES对正则表达式的支持还缺少一些高级特性。\n## 5.3 原始值包装类型\nES提供了3种特殊类型的引用类型：Boolean,Number,String。\n以读模式访问字符串时，后台执行：\n（1）创建一个String类型的实例；// let s1 = \"some text\"\n（2）调用实例上的特点方法；// let s2 = s1.substring(2);\n（3）销毁实例；// s1 = null;\nlet value = \"25\";\nlet number = Number(value);   //转型函数\nconsole.log(typeof number);   //\"number\"\nlet obj = new Number(value); // 构造函数\nconsole.log(typeof obj); //\"object\"\n变量obj保存一个Number实例。\n### 5.3.1 Boolean\nlet falseObject = new Boolean(false);// typeof == object\nlet result = falseObject && true;\nconsole.log(result); //true  \nlet falseValue = false;//typeof == boolean 强烈建议永远不要使用\nresult = falseValue && true;\nconsole.log(result); //false\n### 5.3.2 Number\n方法：toFix()//let num = 10;num.toFixed(2);// \"10.00\"\n方法：toExponential()//let num = 10;num.toExponential(1);//\"1.0e+1\"\n方法：toPrecision()//let num = 99;\nnum.toPrecision(1)//\"1e+2\"\nnum.toPrecision(2)//\"99\"\nnum.toPrecision(3)//\"99.0\"\n方法：isInterger()//辨别一个数值是否保存为整数。\nNumber.isInterger(1);// true\nNumber.isInterger(1.00)//true\nNumber.isInterger(1.01)//false\n方法：isSafeInterger()判断数值范围\n### 5.3.3 String\n每个字符用16位表示，基于16位码元完成操作。//基本多语言平面。\nnormalize()方法：用于判断规范性。\nconcat()：拼接//用加法运算符也可\nValue = \"hello world\";\nslice()：\nValue.slice(3)//\"lo world\";\nValue.slice(3,7)//\"lo w\";\nValue.slice(-3)//\"rld\" 等同于slice(8);(11-3)\nValue.slice(3,-4)//\"lo w\" 等同于slice(3,7);(3+4)\nsubstr()：\nValue.substr(3)//\"lo world\";\nValue.substr(3,7)//\"lo worl\";\nValue.substr(-3)//\"rld\" 等同于substr(8);\nValue.substr(3,-4)//\"\"等同于substr(3,0);\nsubstring()：\nValue.substring(3)//\"lo world\";\nValue.substring(3,7)//\"lo w\";\nValue.substring(-3)//\"hello world\" 等同于substring(0)\nValue.substring(3,-4)//\"hel\"等同于substring(0,3)\nindexOf():\nValue.indexOf(\"o\");// 4\nValue.indexOf(\"t\")// -1\nValue.indexOf(\"o\",6)//7\nlastIndexOf():\nValue.lastIndexOf(\"o\")//7\nValue.lastIndexOf(\"t\")//-1\nValue.lastIndexOf(\"o\",6)//4\nmessage = \"foobarbaz\";\nstartWith():\nmessage.startWith(\"foo\");//true\nmessage.startWith(\"bar\");//false\nendWith():\nmessage.endWith(\"baz\");//true\nmessage.endWith(\"bar\");//false\nincludes():\nmessage.includes(\"bar\");//true\nmessage.includes(\"qux\");//false\ntrim()://不影响原字符串，trimLeft(),trimRight()\nlet string = \"   hello  world   \";\nstring.trim()//\"hello  world\"\nrepeat():\nstring = \"abc\";\nstring.repeat(2)//\"abcabc\";\npadStart(),padEnd():\nstring = \"foo\"\nstring.padStart(6)//\"   foo\";len=6\nstring.padStart(9,\".\")//\"......foo\";len=9\nstring.padStart(8,\"bar\")//\"barbafoo\"len=8\nstring.padEnd(6)//\"foo   \";\nstring.padEnd(9,\".\")//\"foo......\";\nstring.padEnd(8,\"bar\")//\"foobarba\";\n迭代与解构\nlet message = \"abc\";\nIterator = message[Symbol.iterator]();\nIterator.next()//{value:\"a\",done:false}\nIterator.next()//{value:\"b\",done:false}\nIterator.next()//{value:\"c\",done:false}\nIterator.next()//{value:\"undefined\",done:true}\n大小写转换\ntoLowerCase()//小写\ntoLocalLowerCase()//特定地区方法使用\ntoUpperCase()//大写\ntoLocalUpperCase()//特定地区方法使用\n字符串模式匹配方法\nmatch():与exec()方法一致\nsearch():\nlet text = \"cat, bat, sat, fat\";\nlet pos = text.search(/at/);//1第一个位置为1\nreplace():\nlet res = text.replace(\"at\",\"ond\");//\"cond, bat, sat, fat\"\nlet res = text.replace(/at/g,\"ond\")//\"cond, bond, sond, fond\"\nlocaleCompare():按字母表顺序比较返回值\n## 5.4 单例内置对象\n包括Global,Math\n### 5.4.1 Global\n全局作用域中定义的变量和函数都会成为Global对象的属性。\nencodeURI(),encodeURIComponent()//编码统一资源标识符。\neval():\neval(\"console.log('hi')\");///console.log(\"hi\");\neval(\"function sayHi(){console.log('hi');}\");///sayHi();\n容易被XSS攻击。\n对象属性：\nundefined//特殊值\nNaN//特殊值\nInfinity//特殊值\nObject//构造函数\nArray//构造函数\nFunction//构造函数\n....\nwindow对象\nwindow为Global对象的代理,全局变量和函数即为window的属性。\n### 5.4.2 Math\nMath对象属性：\nE //自然对数的基数e的值\nLN10 //10为底的自然对数\nLN2 //2为底的自然对数\nLOG2E //以2为底e的对数\nLOG10E //以10为底e的对数\nPI //π的值\nSQRT1_2 //1/2的平方根\nSQRT2 //2的平方根\nMath方法：\nmin():取最小值//配合数组可以使用扩展操作符\nmax():取最大值//max = Math.max(...array);\nceil():向上取\nMath.ceil(25.9);//26\nMath.ceil(25.5);//26\nMath.ceil(25.1);//26\nround():四舍五入\nconsole.log(Math.round(25.9)); // 26 \nconsole.log(Math.round(25.5)); // 26 \nconsole.log(Math.round(25.1)); // 25\nfround():取单精度浮点值\nconsole.log(Math.fround(0.4)); // 0.4000000059604645 \nconsole.log(Math.fround(0.5)); // 0.5 \nconsole.log(Math.fround(25.9)); // 25.899999618530273\nfloor():向下取\nconsole.log(Math.floor(25.9)); // 25 \nconsole.log(Math.floor(25.5)); // 25 \nconsole.log(Math.floor(25.1)); // 25\nrandom()://返回小数0~1内\n加密提高不确定性：建议使用window.crypto.getRandomValues()。\nabs()//绝对值\nexp()//次幂\nlog()//自然对数\n....\n## 5.5 小结\n对象为引用值，内置的引用类型可用于创建特定类型的对象。\nRegExp是ES支持正则表达式的接口。\n函数实际上是Function类型的实例，是对象。\n# 6 集合引用类型\n## 6.1 Object\nlet person = new Object();//构造函数\nperson.name = 'micheal';\nlet person = {name:'micheal'};//{}字面量表达式\nperson[\"name\"]//micheal\nperson.name//micheal\n## 6.2 Array\n### 6.2.1 创建数组\nlet colors = new Array();//可以传值创建初始length的数组，也可以传数组值\nlet colors = [\"red\",\"blue\"]//字面量表达式\nfrom():\nArray.from(\"Matt\")//[\"M\",\"a\",\"t\",\"t\"]\n适用于Map,Set,Array,iterator,arguments\nof()://使用Array.prototype.slice.call(arguments)\nArray.of(1,2,3,4)//[1,2,3,4]\nArray.of(undefined)//[undefined]\n### 6.2.2 数组空位\n使用(,)创建数组空位\nconst options = [,,,,,]\noptions.length = 5\noptions //[,,,,,]\n空值为undefined\noptions = [1,,,5];\noptions.map(()=>6)//[6,,,6]\noptions.join('-')//\"1-----5\"\n### 6.2.3 数组索引\ncolors[0]-->第一个元素\n给数组设置length会改变数组大小\n### 6.2.4 检测数组\n判断是否数组，使用instanceof\n也可使用isArray()方法\n### 6.2.5 迭代器方法\nconst a = [\"a\",\"b\",\"c\",\"d\"];\nkeys()://返回数组索引的迭代器\nconst akeys = Array.from(a.keys()); // [0,1,2,3]\nvalues()://返回数组元素的迭代器\nconst aValues = Array.from(a.Values());//[\"a\",\"b\",\"c\",\"d\"]\nentries()://返回索引/值对的迭代器\nconst aEntries = Array.from(a.entries());//[[0,\"a\"],[1,\"b\"],[2,\"c\"],[3,\"d\"]]\nfor(const [idx,element] of a.entries()){\nalert(idx);\nalert(element);\n}\n//0\n//a\n//1\n//b\n//2\n//c\n//3\n//d\n### 6.2.6 复制和填充方法\ncopyWithin()//批量复制\nfill()://填充\nconst a = [0,0,0,0,0];\nzeros.fill(5)//[5,5,5,5,5];\nzeros.fill(6,3)//[0,0,0,6,6]\nzeros.fill(7,1,3)//[0,7,7,0,0]\n索引过低，过高，反向都会被忽略\n部门可用的索引，填充可用部分。\nints = [0,1,2,3,4,5,6,7,8,9];\nints.copyWithin(5) // [0,1,2,3,4,0,1,2,3,4];\nints.copyWithin(0,5)//[5,6,7,8,9,5,6,7,8,9];\nints.copyWithin(4,0,3)//[0,1,2,3,0,1,2,7,8,9];\nints.copyWithin(2,0,6)//[0,1,0,1,2,3,4,5,8,9];\n### 6.2.7 转换方法\n数组调用toString(),valueOf()方法相当于每个元素调用一次这个方法。\n### 6.2.8 栈方法\npush()//从最后推入数据\npop()//弹出最后一项并返回\n### 6.2.9 队列方法\nshift()://删除数组第一项并返回\npush()://从最后推入数据\nunshift()://从开头推入\n### 6.2.10 排序方法\nreverse()://反向排序\nsort()://将元素转换成字符串比较\n### 6.1.11 操作方法\nconcat():添加//直接使用会打平数组\nslice():取值\nsplice()://可实现删除(两个参数)，插入(三个参数)，替换(三个参数)\n### 6.2.12 搜索和位置方法\nindexOf()//查找元素位置，返回\nlastIndexOf()//查找元素位置，返回\nincludes()//返回布尔值，是否包含元素\nfind()//返回第一个匹配的元素\nfindIndex()//返回索引\n### 6.2.13 迭代方法\nevery():元素都匹配才会返回true\nfilter():返回true的元素组成数组返回\nforEach():运行函数，无返回值\nmap():调用结果构成数组返回\nsome():如果有一项返回true，则返回true\n### 6.2.14 归并方法\nreduce():从头遍历,构建一个返回值\nreduceRight():从尾遍历,构建一个返回值\n## 6.3 定型数组\n### 6.3.1 历史\nWebGL用到，3D技术。\n定型数组\n### 6.3.2 ArrayBuffer\n构造函数，用于内存中分配特定数量的字节空间。\n### 6.3.3 DataView\n### 6.3.4 定型数组\n## 6.4 Map\n一种实现键值存储机制的集合类型。\n### 6.4.1 基本API\nconst m2 = new Map([[\"key1\",\"val1\"][\"key2\",\"val2\"][\"key3\",\"val3\"]])\nm1.size = 3\n可使用has(),get()进行查询，delete(),clear()删除值。\n### 6.4.2 顺序与迭代\n提供迭代器(Iterator),通过entries()获取\n可以通过遍历获取。\n### 6.4.3 选择Object还是Map\n1.内存占用\nMap占用更小\n2.插入性能\nMap插入性能更好\n3.查找速度\nObject优于Map\n4.删除性能\nMap更快，涉及大量删除 Map最佳。\n## 6.5 WeakMap\n类似于Map，只能用对象作为键。\nAPI与Map相同。\n键不存在时，值会被垃圾回收。\n无法迭代。\n## 6.6 Set\n### 6.6.1 基本API\n与Map相似，size长度，has()查询，delete()和clear()删除元素。\nadd()添加元素。\n### 6.6.2 顺序与迭代\n可通过values()与keys()获取迭代器\n可以使用遍历方法迭代。\n## 6.7 WeakSet\n与WeakMap类型\n## 6.8 迭代与扩展操作\n支持for-of循环\n支持浅拷贝\nlet arr1 = [...arr2];\n## 6.9 小结\nJS的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。\nObject类型是一个基础类型，所有引用类型都继承了它的基本行为。\nArray是一组有序的值，并提供了操作和转换值的能力。\n定型数组包含一套不同的引用类型。\nDate，日期类型。RegExp，正则表达式的接口。\nES6新增Map，WeakMap,Set,WeakSet。\n# 7 迭代器与生成器\n迭代即“重复”，“再来”。\n## 7.1 理解迭代\nJS中，计数循环就是一种最简单的迭代：for（）\n可以指定顺序，次数，在一个有序集合上进行。\n需知道如何使用数据结构，遍历顺序不是数据结构固有的。\n## 7.2 迭代器模式\n任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。\n迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。\n### 7.2.1 可迭代协议\n实现了Iterable接口的内置类型：\n1.字符串\n2.数组\n3.映射\n4.集合\n5.arguments对象\n6.NodeList等DOM集合类型\n接受可迭代对象的语言特性包括：\nlet arr = [\"foo\",\"bar\",\"baz\"];\n1.for-of //for(let el of arr){el};\n2.数组解构 //let [a,b,c] = arr;\n3.扩展操作符 // let arr2 = [...arr];\n4.Array.from() //let arr3 = Array.from(arr); \n5.创建集合 //let set = new Set(arr);\n6.创建映射 //let pairs = arr.map((x,i)=>[x,i]);\n7.promise.all()\n8.promise.race()\n9.yield*操作符\n### 7.2.2 迭代器协议\nlet arr = [\"a\",\"b\"];\nconsole.log(arr[Symbol.iterator]); //f values(){[native code]};\nlet iter = arr[Symbol.iterator]();\nconsole.log(iter);// ArrayIterator()\niter.next();//{done:false,value:\"a\"};\n### 7.2.3 自定义迭代器\n自定义迭代方法\n### 7.2.4 提前终止迭代器\nreturn {done:true};\n或break\n## 7.3 生成器\n### 7.3.1 生成器基础\n### 7.3.2 通过yield中断执行\n### 7.3.3 生成器作为默认迭代器\n### 7.3.4 提前终止生成器\n## 7.4 小结\n由任意对象实现的接口，支持连续获取对象产出的每一个值。使用symbol.iterator获取，并且通过一些方法调用，例next(),for-of。\n# 8 对象、类与面向对象编程\n无特定顺序的值。每个属性或方法都用名称标识。\n## 8.1 理解对象\n### 8.1.1 属性的类型\n数据属性：\n[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。\n[[Enumerable]]:表示属性是否可以通过for-in循环返回。\n[[Writable]]:表示属性的值是否可以被修改。\n[[Value]]:表示属性的值。\n访问器属性：\n[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。\n[[Enumerable]]:表示属性是否可以通过for-in循环返回。\n[[Get]]:获取函数，读取属性调用。\n[[Set]]:设置函数，写入属性时调用。\n### 8.1.2 定义多个属性\nlet book = {};\nObject.defineProperties(book,{year:{value:2017},edition:{value:1},year:{get(){return this.year;}}});\n### 8.1.3 读取属性的特性\nObject.getOwnPropertyDescriptor(object,'name');\ndescriptor = Object.getOwnPropertyDescriptor(book,\"year\");\nObject.getOwnPropertyDescriptors(object);//获取所有\n### 8.1.4 合并对象\nObject.assgin();//浅拷贝,会覆盖重复的属性\nresult = Object.assign(object1,object2);\nobject === result\nresult = Object.assign(object1,object2,object3);\n### 8.1.5 对象标识及相等判定\nObject.is()//需要两个参数\nObject.is(+0,-0)//false\n### 8.1.6 增强的对象语法\nlet person = {name:name};  === let person = {name};//不建议\nnamekey = \"name\";let person = {[namekey]:'Matt'};//[]内可以使用表达式，属性可计算\nlet person = {[nameKey](name){console.log('name')}};//方法名兼容计算属性\n### 8.1.7 对象解构\nlet person = {name:'matt',age:27}//不解构\nlet personName = person.name,personAge = person.age;//解构\nlet {name:personName,age:personAge} = person;\nnull和undefined不支持解构\n\nlet person = {job:{title:'Software engineer'}};//嵌套解构\nlet personCopy={};\nlet({job:personCopy.job}=person);\n\n前面的解构出错，后面的解构会失败。\n\nlet person = {name:'matt',age:27}; function printPerson(foo,{name,age},bar)//参数解构，调用时传入对象\n## 8.2 创建对象\n### 8.2.1 概述\n与类不同，对象的巧妙运行可以实现与类相同的行为。\n### 8.2.2 工厂模式\n设计模式之一\nfunction createPerson(name,age,job){\n   let o = new Object();\n   o.name = name;\n   o.age = age;\n   o.job = job;\n   o.sayName = function(){\n       console.log(this.name);\n   };\n   return o;\n}\n解决创建多个类似对象的问题，但无解决对象标识问题（对象类型）。\n### 8.2.3 构造函数模式\nfunction Person(name,age,job){\n   this.name = name;\n   this.age = age;\n   this.job = job;\n   this.sayName = function(){\n      console.log(this.name);\n   }\n}\n与工厂模式类似,无return，无显式创建对象。\n构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可。\nlet person = function(){};\nlet person1 = new person(...);\nlet person2 = new person(...);\nperson1 instanceof Object//true\nperson1 instanceof person//true\nperson2一样\n构造函数也可以直接调用\nperson(...);window.sayName();//添加到了window\nlet o = new Object();\nPerson.call(o,\"wxc\",25);o.sayName()//wxc 在另一个对象的作用域中调用\n在构造函数内定义的函数实例化后相同名称确不相等，是两个不同的函数。\n可以在外部定义函数，在内部赋值解决这个问题。\n### 8.2.4 原型模式\nprototype,这个属性为一个对象。包含由特定引用类型的实例共享的属性和方法。实际上是构造函数创建的原型。\n在原型上定义的值可以共享。\nChrome暴露了_proto_属性，可通过这个属性访问对象的原型。prototype属性为对象。\n原型链会终止与Object的原型链。\nperson.prototype._proto_._proto_ === null//true\n构造函数、原型对象和实例，三个完全不同的对象。\n实例通过_proto_链接到原型对象，实际指向[[Prototype]]\n构造函数通过prototype属性链接到原型对象。\n同一个构造函数创建的两个实例，共享一个原型对象。\nisPrototypeOf()//用于判断实例原型对象与构造函数的原型相同否\ngetPrototypeOf()//用于获取[[prototype]]原型对象\nsetPrototypeOf()//用于给[[prototype]]对象写入新值,该方法调用可能会严重导致性能下降。\ncreate()//用于创建新对象指定原型\n访问对象属性时，如果未在对象实例本身找到则会沿着指针进入原型对象，在原型对象上查找。无法通过实例重写这些值，如果创建于原型对象中同名的属性，会在实例上创建这个属性，遮蔽原型对象上的属性，只有delete后才能继续搜索原型对象的该属性。\nhasOwnProperty()//用于判断属性在实例或原型上\n可以通过for-in判断通过对象能否访问到一个属性//\"name\" in person(true)\ngetOwnPropertyNames()//...按顺序进行枚举\n### 8.2.5 对象迭代\nObject.values()//以数组的形式输出值\nObject.entries()//以数组的形式输出键值和值\n非字符串的属性会被转换为字符串输出，符号属性会被忽略。\n重写了prototype的函数原型不默认指向constructor\nES语法需要使用defineProperty()来恢复constructor属性。\n实例只有指向原型的指针，没有指向构造函数的指针。\n## 8.3 继承\nES中只支持实现继承。\n### 8.3.1 原型链\n通过原型继承多个引用类型的属性和方法。原型链为ES主要继承方式。\n将A函数原型赋值为B函数的实例，A函数的实例可以通过原型访问到B函数实例的属性和方法。实际A函数可以通过原型与B函数的原型挂钩。在搜索属性时，会通过原型链访问到原型的原型，直到末端。\n所有引用类型都继承自Object，任何函数的默认原型都是一个Object的实例，也是为什么自定义类型能够继承toString(),valueOf()方法的原因。调用toString()时，实际在调用Object.prototype上的方法。\n通过instanceof返回原型与构造函数的原型关系。\n通过isPrototypeOf返回原型链中是否含有这个原型。\n添加属性或覆盖属性时需要在原型赋值后添加到原型上。\n通过prototype字面量直接修改原型，会破坏之前的原型链。\n原型链的问题：\n1.使用原型实现继承后，函数原型对象的所有属性都会被函数实例共享。\n2.子类型在实例化时不能给父类型的构造函数传参。\n### 8.3.2 盗用构造函数\n通过call，apply来调用执行函数的构造函数，从而得到构造函数的属性和方法。\n可以通过apply,call来向父类构造函数传值。\n缺点：必须在构造函数中定义方法，函数无法重用。且子类无法访问父类原型的方法。（原型不是父类的实例对象）\n### 8.3.3 组合继承\n综合原型链和盗用构造函数，集中了优点。\n利用call实现传值改变继承的值，并且属性不共用。\n### 8.3.4 原型式继承\n实例一个对象作原型，使用Object.create()。\n### 8.3.5 寄生式继承\n创建一个对象，给对象添加属性和值，返回这个对象。\n### 8.3.6 寄生式组合继承\n会调用两次构造函数。\n## 8.4 类\n### 8.4.1 类定义\nclass Person{} // 类声明\nclass Animal = class {} // 类表达式\n类定义无法声明提升，类受块作用域限制。\nclass Foo{ \nconstructor(){} //构造函数\nget myBaz(){} //有获取函数\nstatic myQue(){} // 有静态方法\n}\n外部无法访问类名(标识符)\n### 8.4.2 类构造函数\nP250\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JavaScript高级程序设计.md","raw":"---\ntitle: JavaScript高级程序设计\ndate: 2020-11-23 09:43:04\ntags:\n - javaScript\ncategories: javaScript高级程序设计\n---\n# 1.1 历史回顾\n网站数据量大，复杂。需要JS来解决，优化。\n# 1.2 JS实现\nJS = ECMAScript（核心） + DOM（文档对象模型） + BOM（浏览器对象模型）\n## 1.2.1（ECMAScript）\nES：网页提供ES的基准实现和与环境自身交互必须的扩展。\nES包括：语法、类型、语句、关键字、保留字、操作符、全局对象。\n大部分浏览器兼容ES6。\n## 1.2.2 DOM\n文档对象模型：是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。F12中常见的文档树。\n![文档树](文档树.png)\nDOM通过创建表示文档的树，让开发者可以更好地控制网页的内容和结构。使用DOM的API，可以轻松删除，添加，替换，修改节点。\nDOM视图：描述追踪文档不同视图的接口。\nDOM事件：描述事件及事件处理的接口。\nDOM样式：描述处理元素CSS样式的接口。\nDOM遍历的范围：描述遍历和操作DOM数的接口。\n其他DOM：可伸缩矢量图（SVG），数学标记语言（MathML），同步多媒体集成语言（SMIL）\nDOM有不同level（版本）:目前到了level3\n## 1.2.3 BOM\n浏览器对象模型：用于支持访问和操作浏览器的窗口。使用BOM，可以操控浏览器显示页面之外的部分，BOM针对浏览器窗口和子窗口。拓展：\n弹出新浏览器窗口的能力；\n移动、缩放和关闭浏览器窗口的能力；\nnavigator对象，提供关于浏览器的详尽信息；\nlocation对象，提供浏览器加载页面的详尽信息；\nscreen对象，提供关于用户屏幕分辨率的详尽信息；\nperformance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；\n对cookie的支持；\n其他自定义对象，XMLHttp，ActiveXObject；\n# 1.3 JavaScript版本\n# 1.4 小结\nJS是一门用来与网页交互的脚本语言，包含以下三个组成部分。\nES：有ECMA-262定义并提供核心功能。\n文档对象模型（DOM）:提供与网页内容交互的方法和接口。\n浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。\nJS这三个部门得到了五大Web浏览器不同程度的支持。所有浏览器基本上对ES5提供了完善的支持，ES6最佳。\n---\n# 2.1 script元素\n将Js插入HTML的主要方法是使用script元素。有下列8个属性：\n1.async：可选，表示立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。\n2.charset：可选，使用src属性指定的代码字符集。很少用。\n3.crossorigin：可选，配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。\ndefer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。\nintegrity：可选，允许比对接收到的资源和指定的加密签名以验证子资源完整性。\nlanguage：废弃。\nsrc：可选，表示包含要执行的代码的外部文件。（引入外部JS文件）\ntype：可选，代替language，表示代码块中脚本语言的内容类型（MIME类型）。按照惯例这个值始终都是“text/JavaScript”，MIME类型通常都是“application/x-javascript”，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。\n## 2.1.1 标签位置\n```\n<head>\n<script src='example1.js'></script>\n</head>\n```\n上述是把文件放在head里，不过这种写法以为着必须把所有JS代码都下载、解析和解释完成后，才能开始渲染页面，可能会导致页面渲染的明显延迟，所以通常把文件引用放在body元素中的页面内容后面。\n```\n<body>\n<script src='example2.js'></script>\n</body>\n```\n## 2.1.2 推迟执行脚本\n可用defer属性，可用推迟脚本执行。\n```\n<script defer src='example1.js'></script>\n```\n## 2.1.3 异步执行脚本\n```\n<script async src='example1.js'></script>\n```\n## 2.1.4 动态加载脚本\nJS可用使用DOM API ，通过向DOM中动态添加Script元素同样可用加载指定的脚本，只要创建一个Script元素并将其添加到DOM即可。如下：\nlet script = document.createElement('script');\nscript.src = 'gibbersh.js'\ndocument.head.appendChild(script);\n这个请求是异步的，不是所有浏览器都支持async属性，因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。\n添加：script.async = false;\n以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。这种可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：\n```\n<link rel=\"preload\" href=\"gibberish.js\">\n```\n## 2.1.5 XMHTL中的变化\nXHTML：可扩展超文本标记语言，是将HTML作为XML的应用重新包装的结果。在XHTML中使用JS必须制定type属性且值为text/javascript。\nXHTML比较少见。\n## 2.1.6 废弃的语法\n个别废弃的语法，可不看。\n# 2.2 行内代码与外部文件\n最佳实践是尽可能将JS代码放在外部文件中。推荐原因如下：\n可维护性：JS代码分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。\n缓存：浏览器会根据特定的设置缓存所有外部链接的JS文件，这意味着若干两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。\n适应未来：通过把JS放到外部文件中，就不比考虑用XHTML的或注释黑科技。包含外部JS文件的语法在HTML和XHTML是一样的。\n在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JS组件形式向客户端送达脚本更具优势。\n在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从同一个地方取得一批文件，并将他们逐个放到浏览器缓存中。从浏览器角度看，通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JS文件的 延迟差不多。\n在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。\n# 2.3 文档模式\n最初有两种模式：混杂模式，标准模式。\n第三种模式：准标准模式。\n# 2.4 noscript元素\n针对不支持JS的浏览器而出的元素。以下两种情况，浏览器将显示包含在noscript中的内容：\n浏览器不支持脚本；\n浏览器对脚本的支持被关闭；\n```\n <noscript> \n <p>This page requires a JavaScript-enabled browser.</p> \n </noscript>\n```\n# 2.5 小结\nJS通过script元素插入到HTML页面中。这个元素可以用于把JS代码嵌入到HTML页面汇总，跟其他标记混合在一起，也可以用与引入保存在外部文件中的JS。本章的重点如下：\n1.要包含外部JS文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。\n2.所有script元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在script元素中的代码必须严格按次序解释。\n3.对不推迟执行的脚本，浏览器必须解释完位于script元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常把script元素放到页面末尾，介于主内容之后及body标签之前。\n4.可以使用defer推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。\n5.可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。\n6.通过使用noscript元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则noscript元素中的任何内容都不会被渲染。\n# 3.1 语法\n## 3.1.1 区别大小写\nECMA中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。\ntypeof不能作为函数名，因为它是一个关键字。但Typeof可以用。\n## 3.1.2 标识符\n变量、函数、属性或函数参数的名称。可以由一个或多个下列字符组成：\n第一个字符必须是一个字母、下划线（_）或美元符号（$）;\n剩下的其他字符可以是字母、下划线、美元符号或数字。\n一般使用驼峰大小写形式。\n## 3.1.3 注释\n## 3.1.4 严格模式\n\"use strict\" //脚本开头加上这一行\n也可以在指定函数内加上开头。所有现代浏览器都支持严格模式。\n## 3.1.5 语句\n结尾建议加分号，建议语句块加{}\n## 3.2 关键字与保留字\nES6的关键字有：\nbreak \tdo \tin \ttypeof \ncase \telse \tinstanceof \tvar \ncatch \texport \tnew \tvoid \nclass \textends \treturn \twhile \nconst \tfinally \tsuper \twith \ncontinue   for \tswitch \tyield \ndebugger function    this \ndefault \tif \tthrow \ndelete \timport \ttry\nES6将来保留词汇：\n始终保留：\nenum\n严格模式下保留：\nimplements \tpackage \tpublic \ninterface\t protected \tstatic \nlet \tprivate\n模块代码中保留：\nawait\n这些词汇不能作标识符，但可以坐对象的属性名，推荐不用作属性名。\n# 3.3 变量\nECMA变量是松散类型的，变量可以用于保存任何类型的数据。每个变量不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var,const,let\nvar:声明完后可以赋值，但未标识类型。//声明提升\n//var message = \"hi\"; \n//message = 100; // 合法，但不推荐。\n//作用域在声明的环境下的函数作用域，例在函数内定义，调用完函数随即被销毁。\n//在函数内定义时省略var操作符，可以创建一个全局变量。不推荐这么做。\nlet:块作用域，同一个块内不能重复声明。变量在作用域中无声明提升。\n//有暂时性死区。\n//无法全局声明，声明的变量不会成为window对象的属性。\n//ES6不能依赖条件声明模式\nconst:与let基本相同，区别是声明变量时必须同时初始化变量，且无法修改const声明的变量。\n## 3.3.4 声明风格及最佳实践\n1.不使用var\n2.const优先，let次之\n# 3.4 数据类型\nES6有6种简单的数据类型（原始类型）：undefined,null,boolean,number,String,Symbol。Symbol是ES6新增的。还有一种复杂的数据类型叫Object（对象）。Object是一种无序名值对的集合。\n## 3.4.1 typeof操作符\n不需要参数（但可以使用参数），严格来说，函数也是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。可以用typeof区分。\n## 3.4.2 Undefined类型\n变量未初始化即是Undefined，相当于给变量赋值了Undefined。\n建议在声明时初始化，出现undefined可以更好辨别。\n## 3.4.4 Null类型\nNull类型同样只有一个值，即特殊值null。null值表示一个空对象指针，typeof null返回Object。\n在定义将来要保存对象值的变量时，建议初始化为null。\n## 3.4.4 Boolean类型\n有两个字面值：true，false。\nTrue和False是有效的标识符，不是布尔值。//区分大小写\n使用Boolean()来转换类型\n## 3.4.5 Number类型\n1.浮点值\n//小数点后面必须带数字，不然当整数处理。\n2.值的范围\n//Number.MIN_VALUE:5e-324\nNumber.MAX_VALUE:1.7976931348623157e+308\n超出以上范围会表示为Infinity或-Infinity,该值无法用于计算。\n可使用isFinite()函数进行判断\n3.NaN\nNaN表示\"不是数值\",用于表示本来要返回数值的操作失败了（不是抛出错误）。\n例：0除任意数值\nconsole.log(0/0) // NaN\nconsole.log(5/0) //Infinity\nconsole.log(5/-0)//-Infinity\n任何涉及NaN的操作始终返回NaN，NaN不等于任何值。//(NaN == NaN)-->false\n可用isNaN()函数判断是否不是数值\nisNaN(NaN)//true\nisNaN(10)//false\nisNaN(\"10\")//false,可转换为数值10\nisNaN(\"blue\")//true,无法转换为数值\nisNaN(true)//false,可以转换为1\n4.数值转换\n有3个函数可以将非数值转换为数值：\nNumber(),parseInt(),parseFloat()\nNumber()是转型函数，可用于任何数据类型。后两个主要用于将字符串转为数值。\nNumber()有如下规则：\n(true)->1,(false)->0,(null)->0,(undefined)->NaN,数值直接返回\n如果字符串包含数值字符，包括数值字符前面带加号、减号的情况，则转换为一个十进制数值。\n如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值（同样，忽略前面的0）。\n如果字符串包含有效的十六进制格式如\"0xf\"，则会转换为与该十六进制值对应的十进制整数值。\n如果是空字符串（不包含字符），则返回0。\n如果字符串包含上述情况之外的其他字符，则返回NaN。\n通常使用parseInt（）\n## 3.4.6 String类型\n字符串使用：双引号，单引号，反引号都合法，引号类型前后必须一致。\n1.字面量：\n\\n  换行\n\\t   制表\n\\b  退格\n\\r   回车\n\\f   换页等\n2.特点\n不可变，一旦创建，值不能变。要修改某个变量的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。\n3.转换为字符串\ntoString()//函数\n还可以传入参数输出不同进制\nlet num = 10;\nnum.toString() // \"10\"\nnum.toString(2) // \"1010\"\nnum.toString(8) // \"12\"\n4.模板字面量\n可以使用换行字符，可以跨行定义字符串。\n使用反引号会保持引号内部的空格，字面量，length会增加。\n5.字符串插值\n可以在定义中插入一个或多个值。\n通过反引号中使用 ${}插入，插入的值都会通过toString转换为字符串\n插值表达式中可以调用函数和方法：\nfoo = {toString:() => 'Wrold'};`hello,${foo}` // hello world\ncapitalize(word) =>return `${word[0].toUpperCase()}`   // `${capitalize('hello')}`//->Hello\n6.模板字面量标签函数\n支持定义标签函数，通过标签函数可以自定义插值行为。\n7.原始字符串\nUnicode字符\n使用String.raw获取原始字符串\n'\\u00A9' // 版权符号\nString.raw`\\u00A9`// \\u00A9\n## 3.4.7 Symbol类型\nSymbol是ES6新增的，且实例是唯一，不可变的。用于创建唯一记号，进而用作非字符串形式的对象属性。\n1.基本用法\nlet sym = Symbol(); type of sym//symbol\n也可以传入字符串参数作为对symbol的描述，可通过这个字符串来调试代码。但这个字符串参数与符号定义或标识无关。\n符号无法与new关键字一起作为构造函数使用。\n可以使用符号包装对象，借用Object函数()函数：\nlet mySymbol = Symbol();\nlet myWrappedSymbol = Object (mySymbol);\nconsole.log(typeof myWrappedSymbol); // \"object\"\n2.使用全局符号注册表\n如果运行时的不同部分需要共享和 重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。\n需要使用Symbol.for()方法。\n## 3.4.8 Object类型\n对象其实就是一组数据和功能的集合。可以通过new来创建实例对象。\n每个对象都有如下属性和方法：\nconstructor：用于创建当前对象的函数，构造函数。\nhasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性。\nisPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。\npropertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用。\ntoLacaleString():返回对象的字符串表示,反映对象所在本地化执行环境。\ntoString():返回对象的字符串表示。\nvalueOf():返回对象对应的字符串、数值或布尔值表示。\n# 3.5 操作符\n## 3.5.1 一元操作符\n只操作一个值的操作符叫一元操作符。\n++,--;  //操作中会自行转换类型,(递增和递减)\n+,-//一元加减符，可以用于运算和转换\n## 3.5.2 位操作符\n...\n## 3.5.3 布尔操作符\n逻辑非，逻辑与逻辑或\n1.逻辑非 ：！（感叹号）\n!false // true\n!\"blue\" //false\n!0 //true\n!NaN //true\n!\"\" //true\n!12345 //false\n也可以用两个感叹号:!!,相当于调用了转型函数Boolean()。第一个返回布尔值，第二个对该布尔值取反。\n相当于如上例子，布尔值取反。\n2.逻辑与\n由&&表示 // true && true为true  其余都为false\n3.逻辑或\n由||表示 //有一个是true为true，false || false为false\n## 3.5.4 乘性操作符\n乘法(*)，除法(/)，取模(%)。\n乘法(*):都为数值则计算，有一项为NaN则返回NaN，如果是Infinity*0=NaN,Infinity*(-/+)num=(-)Infinity，Infinity*Infinity=Infinity,如果不是数值会转换后再近些操作。\n除法(/):\n0 / 0 = NaN,Infinity / Infinity = NaN,-(number)/0 = (-)Infinity,Infinity / (-)Number = (-)Infinity\n取模(%):类似除\n## 3.5.5 指数操作符\nES7新增的操作符 (**)//Math.pow(3,2) == 3 ** 2 == 9\nsquared ** = 2 //9\n## 3.5.6 加性操作符\n（+），（-）\n## 3.5.7 关系操作符\n（<）,（>）,（<=），（>=）\n## 3.5.8 相等操作符\n（==），（!=），（===）,（!==）\n## 3.5.9 条件操作符\n（?）// let max = （num1 > num2）? num1 : num2\n## 3.5.10 赋值操作符\n（=），（*=），（/=），（%=），（+=）,（-=）,（<<=）,（>>=）,（>>>=）\n# 3.6 语句\n## 3.6.1 if语句\n...\n## 3.6.2 do-while语句\ndo {***} while(expression);\n## 3.6.3 while语句\nlet i = 0;\nwhile(i < 10) { i += 2};\n## 3.6.4 for语句\nfor(initialization;expression;post-loop-expression) statement\n## 3.6.5 for-in语句\nfor(property in expression) statement\nfor(const propName in window) {document.write(propName)}//例子\n## 3.6.6 for-of语句\nfor(property of expression) statement\nfor(const el of [2,4,6,8]){document.write(el)}//例子\n## 3.6.7 标签语句\nlabel:statement\nstart: for(let i = 0;i < count;i++){console.log(i)}//start是一个标签，可在后面通过break，continue语句引用。\n## 3.6.8 break和continue语句\nbreak用于立即退出循环,强行执行循环后的下一条语句。\ncontinue语句用于立即退出循环，但会从循环顶部开始执行。\n## 3.6.9 with语句\nwith(expression) statement;\nlet qs = location.search.substring(1);\nlet hostName = location.hostname;\nlet url = location.href;\nwith(location){\nlet qs = search.substring(1);\nlet hostName = hostname;\nlet url = href;\n}\n严格模式不允许使用\n## 3.6.10 switch语句\nswitch(expression){\n  case value1:\n    statament\n    break;\n  case value2:\n    statement\n    break;\n  ...\n  default:\n    statement\n}\n//switch不会强制转换数据类型\n## 3.7 函数\nfunction Name(arg0,arg1){ statements}\n遇到return语句函数就会立即停止执行并退出。\n函数不能以eval，arguments作为名称；\n函数的参数不能叫eval，arguments；\n两个命名参数不能拥有同一个名称。\n## 3.8 小结\nES中基本数据类型包括：undefined,Null,Boolean,Number,String,Symbol\n不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。//声明方式\n不指定返回值的函数实际上会返回特殊值undefined。\n# 4 变量、作用域与内存\n## 4.1 原始值与引用值\n变量有两种不同的类型：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。\n原始值的变量是按值访问的，引用值是保存在内存中的对象，操作对象时，操作的是对该对象的引用而非实际的对象本身。\n### 4.1.1 动态属性\n引用值可以随时添加、修改和删除其属性和方法。\n只有引用值可以动态添加后面可以使用的属性。\n原始类型的初始化可以只使用原始字面量形式。如果使用new则创建Object类型的实例。\nlet name1 = \"wxc\";//typeof name1 == string\nlet name2 = new String(\"Matt\");//typeof name2 == object\n### 4.1.2 复制值\n原始值的变量复制会创建新变量。//let name1 = \"wxc\";let name2 = name1;\n引用值的变量复制的是一个指针，两个变量指向同一个对象，一改则都改。\n### 4.1.3 传递参数\n函数的参数都是按值传递的，传递时，值会被复制到一个局部变量。\n按引用传递参数时，值在内存中的位置会被保存在一个局部变量，对本地变量的修改会反映到函数外部。ES中函数的参数就是局部变量。\n### 4.1.4确定类型\ntypeof对于原始值有用，但对引用值不大。\n引用值判断可以用instanceof\nperson instanceof Object\ncolors instanceof Array\npattern instanceof RegExp\ninstanceof对于原始值始终返回false，原始值不是对象。\n## 4.2 执行上下文与作用域\n每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。\n浏览器中，全局上下文为window对象。var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。\n每个函数也有自己的上下文，执行函数时，函数上下文被推倒一个上下文栈上，执行完后弹出。ES的执行流通过该上下文栈进行控制。\n上下文中的代码在执行时，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链的下一个变量对象来自上级包含上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。\n局部作用域中定义的变量可用于在局部上下文中替换全局变量。\n### 4.2.1 作用域链增强\n代码执行到try/catch语句的catch块与with语句时，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。\n### 4.2.2 变量声明\n1.使用var声明变量，变量会被自动添加到最接近的上下文，最接近的上下文大多是函数的局部上下文，如果未声明就被初始化了，就被添加到全局上下文。如果在函数内声明变量添加到全局上下文，函数退出后依然可以访问。\nvar声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。变量提升。\n2.使用let声明的块级作用域声明\n块级作用域由最近的{}界定。\n3.使用const的常量声明\nconst声明的同时必须初始化为某个值。声明后不能重新赋新值。\n作用域与let声明一样。\n建议多使用const，除非需要一个会重新赋值的变量。可以防止重新赋值的BUG。\n4.标识符查找\n特定上下文读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。//其实就是调用变量\n## 4.3 垃圾回收\nJS使用垃圾回收，程序每隔一段就会自动运行。确定不会再使用的变量，释放内存。\n### 4.3.1 标记清理\n常用策略是标记清理。程序运行时，标记内存中存储的所有变量，将所有上下文中的变量，以及被在上下文中的变量引用的标记去掉。再加上标记代表待删除，随后做一次内存清理，销毁带标记的所有值并回收内存。\nIE，Firefox，Opera，Chrome，Safari都在JS实习标记清理，频率有所差异。\n### 4.3.2 引用计数\n对每个值记录引用次数。声明变量并赋一个引用值时，这个值的引用数为1。 如果保存对该值引用的变量被其他值给覆盖了，引用数-1。引用数为0时回收内存。\n### 4.3.3 性能\n垃圾回收的时间调度很重要，变量太多会造成性能损失。JS引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果回收的内存不到已分配的15%，这些阈值会翻倍。如果一次回收的内存达到已分配的85%，则阈值重置为默认值。\n### 4.3.4 内存管理\n保证在执行代码时只保存必要的数据。不在必要则设置为null，从而释放其引用。这也可以叫作解除引用。局部变量在超出作用域会自动解除引用，所以该建议更适合全局变量和全局对象。\n1.通过const和let声明提升性能\n块作用域，能更早让垃圾回收程序介入。\n2.隐藏类和删除操作\n对象与隐藏类会被关联起来，用于跟踪他们的属性特征。共享相同隐藏类的对象性能会更好。\nfunction Article(){this.title = 'go go go'}\nlet a1 = new Article();//隐藏类title\nlet a2 = new Article();//隐藏类title\na1.author = 'Jake'//对应多出author隐藏类，可能对性能产生明显影响。\nfunction Article(author){this.title='go',this.author=author}\nlet a2 = new Article('wxc')//a2与a1相同，共享一个隐藏类。\ndelete a1.author//使用delete关键字会导致生成同样的隐藏类片段\na1.author = null; //保持共享，并达到垃圾回收的效果\n3.内存泄漏\nJS的内存泄漏大部分是不合理的引用导致的。\nfunction(){name = 'Jake'}意外声明全局变量是最常见也最容易修复的内存泄漏问题。无关键字声明。\n定时器也会导致内存泄漏，定时器的回调通过闭包引用了外部变量。\n使用闭包容易造成内存泄漏，如下：\nlet outer = function() {let name = 'Jake';return function() {return name};};\n调用outer()会导致内存泄漏。只要返回的函数存在就不能清理name，因为闭包一直在引用，加入name的内容很大，就是个大问题。\n4.静态分配与对象池\n不要动态创建矢量对象\n在初始化的时候，创建一个对象池，管理一组可回收的对象。使用完后回归对象池。\n## 4.4 小结\n原始值大小固定，因此保存在栈内存上。\n引用值是对象，存储在堆内存上。\n任何变量都存在于某个作用域（上下文）中，这个作用域决定了变量的声明周期，以及它们可以访问代码的哪些部分。\n全局上下文：window，浏览器。\n函数上下文：声明函数的{}内\n块级上下文：最近的{}内\nJS有垃圾回收，垃圾回收的方法有：引用计数，标记清理。主流为标记清理。\n接触变量引用一般直接给变量赋值为null。\n# 5.基本引用类型\n引用值是某个特定引用类型的实例。\n对象被认为是某个特定引用类型的实例。新对象通过使用new操作符跟一个构造函数来创建。\n函数也是一种引用类型。\n## 5.1 Date\n日期对象//let now = new Date();\n可用Date.parse()转换成日期对象//let someDate = new Date(Date.parse(\"May 23,2019\"));如果字符串不表示日期，会返回NaN。\nlet allFives = new Date(Date.UTC(2005,4,5,17,55,55));//GMT时间——Date.UTC方法\nES提供了Date.now()方法，返回表示方法执行时日期。\nlet start = Date.now();//当前时间\n### 5.1.1 继承的方法\nlet date = new Date(2021,1,20);\ntoLocaleString()//-->2021/2/20 上午12:00:00\ntoString()//-->Sat Feb 20 2021 00:00:00 GMT+0800\nvalueOf()//-->1613750400000\n### 5.1.2 日期格式化方法\nDate格式化日期的方法：\ntoDateString()//显示日期中的周几，月，日，年\ntoTimeString()//显示日期中的时分秒和时区\ntoLocaleDateString()//显示日期中的周几 月 日 年\ntoLocaleTimeString()//显示日期中的时 分 秒\ntoUTCString()//显示完整的UTC日期\n### 5.1.3 日期/时间组件方法\n主要应用：\ngetTime()//返回日期的毫秒表示，与valueOf相同\nsetTime(milliseconds)//设置日期的毫秒表示，从而修改整个日期\ngetFullYear()//返回四位年数\ngetMonth()//返回日期的月\ngetDate()//返回日期的日\ngetDay()//返回日期中表示周几的数值\ngetHours()//返回日期中的时\ngetMinutes()//返回日期中的分\ngetSeconds()//返回日期中的秒\n## 5.2 RegExp\nES通过RegExp类型支持正则表达式。\nlet expression = /pattern/flags;\n匹配模式的标记：\n1.g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。\n2.i:不区分大小写，表示查找匹配时忽略pattern和字符串的大小写。\n3.m:多行模式，表示查找到一行文本末尾时会继续查找。\n4.y:粘附模式，表示只查找从lastIndex开始及之后的字符串。\n5.u:Unicode模式，启用Unicode匹配。\n6.s：dotAll模式，表示元字符匹配任何字符。(包括\\n或\\r)。\n使用不同模式和标记可以创建出各种正则表达式，比如：\n//匹配字符串中的所有\"at\"\nlet pattern1 = /at/g;\n//匹配第一个\"bat\"或\"cat\" 忽略大小写\nlet pattern2 = /[bc]at/i\n//匹配所有以\"at\"结尾的三字符组合，忽略大小写\nlet pattern3 = /.at/gi\n元字符在模式中必须转义：\n( ，[， {，\\，^，$，|，)，]，}，？，*，+，- //这些符号前面需要\\来转义\n//匹配第一个\"bat\"或\"cat\"，忽略大小写\nlet pattern1 = /[bc]at/i;\n//匹配第一个\"[bc]at\"，忽略大小写\nlet pattern2 = /\\[bc\\]at/i;\n//匹配所有以\"at\"结尾的三字符组合，忽略大小写\nlet pattern3 = /.at/gi;\n//匹配所有\".at\"，忽略大小写\nlet pattern4 = /\\.at/gi;\n也可使用RegExp构造函数来创建：\nlet pattern1 = /[bc]at/i   ==   new RegExp(\"[bc]at\",\"i\");\n也可以使用实例，选择性修改标记\nconst re1 = /cat/g;\nconst re2 = new RegExp(re1);\nconst re3 = new RegExp(re1,\"i\");\n### 5.2.1 RegExp实例属性\nglobal:布尔值，表示是否设置了g标记。\nignoreCase:布尔值，表示是否设置了i标记。\nunicode:布尔值，表示是否设置了u标记。\nsticky:布尔值，表示是否设置了y标记。\nlastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。\nmultiline:布尔值，表示是否设置了m标记。\ndotAll:布尔值，表示是否设置了s标记。\nsource:正则表达式的字面量字符串，没有开头和结尾的斜杠。\nflags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回。\n### 5.2.2 RegExp实例方法\nexec()函数：\nlet text = 'cat, bat, sat, fat';\n  let pattern = /.at/gi;\n  let matchs = pattern.exec(text);\n  console.log(matchs);//cat\n//设置了全局标记(g)，每次调用返回一个匹配的信息，如果没有设置全局标记，只会返回第一个匹配的信息。\n//设置了g标记，每次调用exec()都会在字符中向前搜索下一个匹配项\nlet text = 'cat, bat, sat, fat';\n  let pattern = /.at/gi;\n  let matchs = pattern.exec(text);//cat\n  let matchs = pattern.exec(text);//bat\n  let matchs = pattern.exec(text);//sat\n  console.log(matchs);\n//设置了y标记，每次调用会在lastIndex的位置上寻找匹配项。y标记覆盖g标记。\ntest()函数：//用于判断是否存在实际内容中，常在if判断语句中\nlet text = \"000-00-00 00\";\nlet pattern = /\\d{3}-\\d{2}-\\d(4)/;\nif(pattern.test(text)) {console.log(\"The pattern was matched.\")};\n继承的方法toLocaleString()和toString()都返回字面量表示。\nlet pattern = new RegExp(\"\\\\[bc\\\\]at\",\"gt\");\nconsole.log(pattern.toString());//  /\\[bc\\]at/gi\nconsole.log(pattern.toLocaleString());//  /\\[bc\\]at/gi\n### 5.2.3 RegExp构造函数属性\ninput：$_   //最后搜索的字符串\nlastMatch：$&   //最后匹配的文本\nlastParen：$+   //最后匹配的捕获组\nleftContext：$`   //input字符串中出现在lastMatch前面的文本\nrightContext：$'   //input字符串中出现在lastMatch后面的文本\nlet text = \"this has been a short summer\";\nlet pattern = /(.)hort/g; //()-->捕获组\nif(pattern.test(text)) {\n   console.log(RegExp.input); //this has been a short summer\n   console.log(RegExp.leftContext); //this has been a\n   console.log(RegExp.rightContext); //summer\n   console.log(RegExp.lastMatch); //short\n   console.log(RegExp.input); //s\n}\n\nif(pattern.test(text)) {\n   console.log(RegExp.$_); //this has been a short summer\n   console.log(RegExp[\"$`\"]); //this has been a\n   console.log(RegExp[\"$'\"]); //summer\n   console.log(RegExp[\"$&\"]); //short\n   console.log(RegExp[\"$+\"]); //s\n}\nlet pattern = /(..)or(.)/g;\n\nif(pattern.test(text)) {\n   console.log(RegExp.$1); // sh\n   console.log(RegExp.$2);// t\n}\n### 5.2.4 模式局限\nES对正则表达式的支持还缺少一些高级特性。\n## 5.3 原始值包装类型\nES提供了3种特殊类型的引用类型：Boolean,Number,String。\n以读模式访问字符串时，后台执行：\n（1）创建一个String类型的实例；// let s1 = \"some text\"\n（2）调用实例上的特点方法；// let s2 = s1.substring(2);\n（3）销毁实例；// s1 = null;\nlet value = \"25\";\nlet number = Number(value);   //转型函数\nconsole.log(typeof number);   //\"number\"\nlet obj = new Number(value); // 构造函数\nconsole.log(typeof obj); //\"object\"\n变量obj保存一个Number实例。\n### 5.3.1 Boolean\nlet falseObject = new Boolean(false);// typeof == object\nlet result = falseObject && true;\nconsole.log(result); //true  \nlet falseValue = false;//typeof == boolean 强烈建议永远不要使用\nresult = falseValue && true;\nconsole.log(result); //false\n### 5.3.2 Number\n方法：toFix()//let num = 10;num.toFixed(2);// \"10.00\"\n方法：toExponential()//let num = 10;num.toExponential(1);//\"1.0e+1\"\n方法：toPrecision()//let num = 99;\nnum.toPrecision(1)//\"1e+2\"\nnum.toPrecision(2)//\"99\"\nnum.toPrecision(3)//\"99.0\"\n方法：isInterger()//辨别一个数值是否保存为整数。\nNumber.isInterger(1);// true\nNumber.isInterger(1.00)//true\nNumber.isInterger(1.01)//false\n方法：isSafeInterger()判断数值范围\n### 5.3.3 String\n每个字符用16位表示，基于16位码元完成操作。//基本多语言平面。\nnormalize()方法：用于判断规范性。\nconcat()：拼接//用加法运算符也可\nValue = \"hello world\";\nslice()：\nValue.slice(3)//\"lo world\";\nValue.slice(3,7)//\"lo w\";\nValue.slice(-3)//\"rld\" 等同于slice(8);(11-3)\nValue.slice(3,-4)//\"lo w\" 等同于slice(3,7);(3+4)\nsubstr()：\nValue.substr(3)//\"lo world\";\nValue.substr(3,7)//\"lo worl\";\nValue.substr(-3)//\"rld\" 等同于substr(8);\nValue.substr(3,-4)//\"\"等同于substr(3,0);\nsubstring()：\nValue.substring(3)//\"lo world\";\nValue.substring(3,7)//\"lo w\";\nValue.substring(-3)//\"hello world\" 等同于substring(0)\nValue.substring(3,-4)//\"hel\"等同于substring(0,3)\nindexOf():\nValue.indexOf(\"o\");// 4\nValue.indexOf(\"t\")// -1\nValue.indexOf(\"o\",6)//7\nlastIndexOf():\nValue.lastIndexOf(\"o\")//7\nValue.lastIndexOf(\"t\")//-1\nValue.lastIndexOf(\"o\",6)//4\nmessage = \"foobarbaz\";\nstartWith():\nmessage.startWith(\"foo\");//true\nmessage.startWith(\"bar\");//false\nendWith():\nmessage.endWith(\"baz\");//true\nmessage.endWith(\"bar\");//false\nincludes():\nmessage.includes(\"bar\");//true\nmessage.includes(\"qux\");//false\ntrim()://不影响原字符串，trimLeft(),trimRight()\nlet string = \"   hello  world   \";\nstring.trim()//\"hello  world\"\nrepeat():\nstring = \"abc\";\nstring.repeat(2)//\"abcabc\";\npadStart(),padEnd():\nstring = \"foo\"\nstring.padStart(6)//\"   foo\";len=6\nstring.padStart(9,\".\")//\"......foo\";len=9\nstring.padStart(8,\"bar\")//\"barbafoo\"len=8\nstring.padEnd(6)//\"foo   \";\nstring.padEnd(9,\".\")//\"foo......\";\nstring.padEnd(8,\"bar\")//\"foobarba\";\n迭代与解构\nlet message = \"abc\";\nIterator = message[Symbol.iterator]();\nIterator.next()//{value:\"a\",done:false}\nIterator.next()//{value:\"b\",done:false}\nIterator.next()//{value:\"c\",done:false}\nIterator.next()//{value:\"undefined\",done:true}\n大小写转换\ntoLowerCase()//小写\ntoLocalLowerCase()//特定地区方法使用\ntoUpperCase()//大写\ntoLocalUpperCase()//特定地区方法使用\n字符串模式匹配方法\nmatch():与exec()方法一致\nsearch():\nlet text = \"cat, bat, sat, fat\";\nlet pos = text.search(/at/);//1第一个位置为1\nreplace():\nlet res = text.replace(\"at\",\"ond\");//\"cond, bat, sat, fat\"\nlet res = text.replace(/at/g,\"ond\")//\"cond, bond, sond, fond\"\nlocaleCompare():按字母表顺序比较返回值\n## 5.4 单例内置对象\n包括Global,Math\n### 5.4.1 Global\n全局作用域中定义的变量和函数都会成为Global对象的属性。\nencodeURI(),encodeURIComponent()//编码统一资源标识符。\neval():\neval(\"console.log('hi')\");///console.log(\"hi\");\neval(\"function sayHi(){console.log('hi');}\");///sayHi();\n容易被XSS攻击。\n对象属性：\nundefined//特殊值\nNaN//特殊值\nInfinity//特殊值\nObject//构造函数\nArray//构造函数\nFunction//构造函数\n....\nwindow对象\nwindow为Global对象的代理,全局变量和函数即为window的属性。\n### 5.4.2 Math\nMath对象属性：\nE //自然对数的基数e的值\nLN10 //10为底的自然对数\nLN2 //2为底的自然对数\nLOG2E //以2为底e的对数\nLOG10E //以10为底e的对数\nPI //π的值\nSQRT1_2 //1/2的平方根\nSQRT2 //2的平方根\nMath方法：\nmin():取最小值//配合数组可以使用扩展操作符\nmax():取最大值//max = Math.max(...array);\nceil():向上取\nMath.ceil(25.9);//26\nMath.ceil(25.5);//26\nMath.ceil(25.1);//26\nround():四舍五入\nconsole.log(Math.round(25.9)); // 26 \nconsole.log(Math.round(25.5)); // 26 \nconsole.log(Math.round(25.1)); // 25\nfround():取单精度浮点值\nconsole.log(Math.fround(0.4)); // 0.4000000059604645 \nconsole.log(Math.fround(0.5)); // 0.5 \nconsole.log(Math.fround(25.9)); // 25.899999618530273\nfloor():向下取\nconsole.log(Math.floor(25.9)); // 25 \nconsole.log(Math.floor(25.5)); // 25 \nconsole.log(Math.floor(25.1)); // 25\nrandom()://返回小数0~1内\n加密提高不确定性：建议使用window.crypto.getRandomValues()。\nabs()//绝对值\nexp()//次幂\nlog()//自然对数\n....\n## 5.5 小结\n对象为引用值，内置的引用类型可用于创建特定类型的对象。\nRegExp是ES支持正则表达式的接口。\n函数实际上是Function类型的实例，是对象。\n# 6 集合引用类型\n## 6.1 Object\nlet person = new Object();//构造函数\nperson.name = 'micheal';\nlet person = {name:'micheal'};//{}字面量表达式\nperson[\"name\"]//micheal\nperson.name//micheal\n## 6.2 Array\n### 6.2.1 创建数组\nlet colors = new Array();//可以传值创建初始length的数组，也可以传数组值\nlet colors = [\"red\",\"blue\"]//字面量表达式\nfrom():\nArray.from(\"Matt\")//[\"M\",\"a\",\"t\",\"t\"]\n适用于Map,Set,Array,iterator,arguments\nof()://使用Array.prototype.slice.call(arguments)\nArray.of(1,2,3,4)//[1,2,3,4]\nArray.of(undefined)//[undefined]\n### 6.2.2 数组空位\n使用(,)创建数组空位\nconst options = [,,,,,]\noptions.length = 5\noptions //[,,,,,]\n空值为undefined\noptions = [1,,,5];\noptions.map(()=>6)//[6,,,6]\noptions.join('-')//\"1-----5\"\n### 6.2.3 数组索引\ncolors[0]-->第一个元素\n给数组设置length会改变数组大小\n### 6.2.4 检测数组\n判断是否数组，使用instanceof\n也可使用isArray()方法\n### 6.2.5 迭代器方法\nconst a = [\"a\",\"b\",\"c\",\"d\"];\nkeys()://返回数组索引的迭代器\nconst akeys = Array.from(a.keys()); // [0,1,2,3]\nvalues()://返回数组元素的迭代器\nconst aValues = Array.from(a.Values());//[\"a\",\"b\",\"c\",\"d\"]\nentries()://返回索引/值对的迭代器\nconst aEntries = Array.from(a.entries());//[[0,\"a\"],[1,\"b\"],[2,\"c\"],[3,\"d\"]]\nfor(const [idx,element] of a.entries()){\nalert(idx);\nalert(element);\n}\n//0\n//a\n//1\n//b\n//2\n//c\n//3\n//d\n### 6.2.6 复制和填充方法\ncopyWithin()//批量复制\nfill()://填充\nconst a = [0,0,0,0,0];\nzeros.fill(5)//[5,5,5,5,5];\nzeros.fill(6,3)//[0,0,0,6,6]\nzeros.fill(7,1,3)//[0,7,7,0,0]\n索引过低，过高，反向都会被忽略\n部门可用的索引，填充可用部分。\nints = [0,1,2,3,4,5,6,7,8,9];\nints.copyWithin(5) // [0,1,2,3,4,0,1,2,3,4];\nints.copyWithin(0,5)//[5,6,7,8,9,5,6,7,8,9];\nints.copyWithin(4,0,3)//[0,1,2,3,0,1,2,7,8,9];\nints.copyWithin(2,0,6)//[0,1,0,1,2,3,4,5,8,9];\n### 6.2.7 转换方法\n数组调用toString(),valueOf()方法相当于每个元素调用一次这个方法。\n### 6.2.8 栈方法\npush()//从最后推入数据\npop()//弹出最后一项并返回\n### 6.2.9 队列方法\nshift()://删除数组第一项并返回\npush()://从最后推入数据\nunshift()://从开头推入\n### 6.2.10 排序方法\nreverse()://反向排序\nsort()://将元素转换成字符串比较\n### 6.1.11 操作方法\nconcat():添加//直接使用会打平数组\nslice():取值\nsplice()://可实现删除(两个参数)，插入(三个参数)，替换(三个参数)\n### 6.2.12 搜索和位置方法\nindexOf()//查找元素位置，返回\nlastIndexOf()//查找元素位置，返回\nincludes()//返回布尔值，是否包含元素\nfind()//返回第一个匹配的元素\nfindIndex()//返回索引\n### 6.2.13 迭代方法\nevery():元素都匹配才会返回true\nfilter():返回true的元素组成数组返回\nforEach():运行函数，无返回值\nmap():调用结果构成数组返回\nsome():如果有一项返回true，则返回true\n### 6.2.14 归并方法\nreduce():从头遍历,构建一个返回值\nreduceRight():从尾遍历,构建一个返回值\n## 6.3 定型数组\n### 6.3.1 历史\nWebGL用到，3D技术。\n定型数组\n### 6.3.2 ArrayBuffer\n构造函数，用于内存中分配特定数量的字节空间。\n### 6.3.3 DataView\n### 6.3.4 定型数组\n## 6.4 Map\n一种实现键值存储机制的集合类型。\n### 6.4.1 基本API\nconst m2 = new Map([[\"key1\",\"val1\"][\"key2\",\"val2\"][\"key3\",\"val3\"]])\nm1.size = 3\n可使用has(),get()进行查询，delete(),clear()删除值。\n### 6.4.2 顺序与迭代\n提供迭代器(Iterator),通过entries()获取\n可以通过遍历获取。\n### 6.4.3 选择Object还是Map\n1.内存占用\nMap占用更小\n2.插入性能\nMap插入性能更好\n3.查找速度\nObject优于Map\n4.删除性能\nMap更快，涉及大量删除 Map最佳。\n## 6.5 WeakMap\n类似于Map，只能用对象作为键。\nAPI与Map相同。\n键不存在时，值会被垃圾回收。\n无法迭代。\n## 6.6 Set\n### 6.6.1 基本API\n与Map相似，size长度，has()查询，delete()和clear()删除元素。\nadd()添加元素。\n### 6.6.2 顺序与迭代\n可通过values()与keys()获取迭代器\n可以使用遍历方法迭代。\n## 6.7 WeakSet\n与WeakMap类型\n## 6.8 迭代与扩展操作\n支持for-of循环\n支持浅拷贝\nlet arr1 = [...arr2];\n## 6.9 小结\nJS的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。\nObject类型是一个基础类型，所有引用类型都继承了它的基本行为。\nArray是一组有序的值，并提供了操作和转换值的能力。\n定型数组包含一套不同的引用类型。\nDate，日期类型。RegExp，正则表达式的接口。\nES6新增Map，WeakMap,Set,WeakSet。\n# 7 迭代器与生成器\n迭代即“重复”，“再来”。\n## 7.1 理解迭代\nJS中，计数循环就是一种最简单的迭代：for（）\n可以指定顺序，次数，在一个有序集合上进行。\n需知道如何使用数据结构，遍历顺序不是数据结构固有的。\n## 7.2 迭代器模式\n任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。\n迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。\n### 7.2.1 可迭代协议\n实现了Iterable接口的内置类型：\n1.字符串\n2.数组\n3.映射\n4.集合\n5.arguments对象\n6.NodeList等DOM集合类型\n接受可迭代对象的语言特性包括：\nlet arr = [\"foo\",\"bar\",\"baz\"];\n1.for-of //for(let el of arr){el};\n2.数组解构 //let [a,b,c] = arr;\n3.扩展操作符 // let arr2 = [...arr];\n4.Array.from() //let arr3 = Array.from(arr); \n5.创建集合 //let set = new Set(arr);\n6.创建映射 //let pairs = arr.map((x,i)=>[x,i]);\n7.promise.all()\n8.promise.race()\n9.yield*操作符\n### 7.2.2 迭代器协议\nlet arr = [\"a\",\"b\"];\nconsole.log(arr[Symbol.iterator]); //f values(){[native code]};\nlet iter = arr[Symbol.iterator]();\nconsole.log(iter);// ArrayIterator()\niter.next();//{done:false,value:\"a\"};\n### 7.2.3 自定义迭代器\n自定义迭代方法\n### 7.2.4 提前终止迭代器\nreturn {done:true};\n或break\n## 7.3 生成器\n### 7.3.1 生成器基础\n### 7.3.2 通过yield中断执行\n### 7.3.3 生成器作为默认迭代器\n### 7.3.4 提前终止生成器\n## 7.4 小结\n由任意对象实现的接口，支持连续获取对象产出的每一个值。使用symbol.iterator获取，并且通过一些方法调用，例next(),for-of。\n# 8 对象、类与面向对象编程\n无特定顺序的值。每个属性或方法都用名称标识。\n## 8.1 理解对象\n### 8.1.1 属性的类型\n数据属性：\n[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。\n[[Enumerable]]:表示属性是否可以通过for-in循环返回。\n[[Writable]]:表示属性的值是否可以被修改。\n[[Value]]:表示属性的值。\n访问器属性：\n[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。\n[[Enumerable]]:表示属性是否可以通过for-in循环返回。\n[[Get]]:获取函数，读取属性调用。\n[[Set]]:设置函数，写入属性时调用。\n### 8.1.2 定义多个属性\nlet book = {};\nObject.defineProperties(book,{year:{value:2017},edition:{value:1},year:{get(){return this.year;}}});\n### 8.1.3 读取属性的特性\nObject.getOwnPropertyDescriptor(object,'name');\ndescriptor = Object.getOwnPropertyDescriptor(book,\"year\");\nObject.getOwnPropertyDescriptors(object);//获取所有\n### 8.1.4 合并对象\nObject.assgin();//浅拷贝,会覆盖重复的属性\nresult = Object.assign(object1,object2);\nobject === result\nresult = Object.assign(object1,object2,object3);\n### 8.1.5 对象标识及相等判定\nObject.is()//需要两个参数\nObject.is(+0,-0)//false\n### 8.1.6 增强的对象语法\nlet person = {name:name};  === let person = {name};//不建议\nnamekey = \"name\";let person = {[namekey]:'Matt'};//[]内可以使用表达式，属性可计算\nlet person = {[nameKey](name){console.log('name')}};//方法名兼容计算属性\n### 8.1.7 对象解构\nlet person = {name:'matt',age:27}//不解构\nlet personName = person.name,personAge = person.age;//解构\nlet {name:personName,age:personAge} = person;\nnull和undefined不支持解构\n\nlet person = {job:{title:'Software engineer'}};//嵌套解构\nlet personCopy={};\nlet({job:personCopy.job}=person);\n\n前面的解构出错，后面的解构会失败。\n\nlet person = {name:'matt',age:27}; function printPerson(foo,{name,age},bar)//参数解构，调用时传入对象\n## 8.2 创建对象\n### 8.2.1 概述\n与类不同，对象的巧妙运行可以实现与类相同的行为。\n### 8.2.2 工厂模式\n设计模式之一\nfunction createPerson(name,age,job){\n   let o = new Object();\n   o.name = name;\n   o.age = age;\n   o.job = job;\n   o.sayName = function(){\n       console.log(this.name);\n   };\n   return o;\n}\n解决创建多个类似对象的问题，但无解决对象标识问题（对象类型）。\n### 8.2.3 构造函数模式\nfunction Person(name,age,job){\n   this.name = name;\n   this.age = age;\n   this.job = job;\n   this.sayName = function(){\n      console.log(this.name);\n   }\n}\n与工厂模式类似,无return，无显式创建对象。\n构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可。\nlet person = function(){};\nlet person1 = new person(...);\nlet person2 = new person(...);\nperson1 instanceof Object//true\nperson1 instanceof person//true\nperson2一样\n构造函数也可以直接调用\nperson(...);window.sayName();//添加到了window\nlet o = new Object();\nPerson.call(o,\"wxc\",25);o.sayName()//wxc 在另一个对象的作用域中调用\n在构造函数内定义的函数实例化后相同名称确不相等，是两个不同的函数。\n可以在外部定义函数，在内部赋值解决这个问题。\n### 8.2.4 原型模式\nprototype,这个属性为一个对象。包含由特定引用类型的实例共享的属性和方法。实际上是构造函数创建的原型。\n在原型上定义的值可以共享。\nChrome暴露了_proto_属性，可通过这个属性访问对象的原型。prototype属性为对象。\n原型链会终止与Object的原型链。\nperson.prototype._proto_._proto_ === null//true\n构造函数、原型对象和实例，三个完全不同的对象。\n实例通过_proto_链接到原型对象，实际指向[[Prototype]]\n构造函数通过prototype属性链接到原型对象。\n同一个构造函数创建的两个实例，共享一个原型对象。\nisPrototypeOf()//用于判断实例原型对象与构造函数的原型相同否\ngetPrototypeOf()//用于获取[[prototype]]原型对象\nsetPrototypeOf()//用于给[[prototype]]对象写入新值,该方法调用可能会严重导致性能下降。\ncreate()//用于创建新对象指定原型\n访问对象属性时，如果未在对象实例本身找到则会沿着指针进入原型对象，在原型对象上查找。无法通过实例重写这些值，如果创建于原型对象中同名的属性，会在实例上创建这个属性，遮蔽原型对象上的属性，只有delete后才能继续搜索原型对象的该属性。\nhasOwnProperty()//用于判断属性在实例或原型上\n可以通过for-in判断通过对象能否访问到一个属性//\"name\" in person(true)\ngetOwnPropertyNames()//...按顺序进行枚举\n### 8.2.5 对象迭代\nObject.values()//以数组的形式输出值\nObject.entries()//以数组的形式输出键值和值\n非字符串的属性会被转换为字符串输出，符号属性会被忽略。\n重写了prototype的函数原型不默认指向constructor\nES语法需要使用defineProperty()来恢复constructor属性。\n实例只有指向原型的指针，没有指向构造函数的指针。\n## 8.3 继承\nES中只支持实现继承。\n### 8.3.1 原型链\n通过原型继承多个引用类型的属性和方法。原型链为ES主要继承方式。\n将A函数原型赋值为B函数的实例，A函数的实例可以通过原型访问到B函数实例的属性和方法。实际A函数可以通过原型与B函数的原型挂钩。在搜索属性时，会通过原型链访问到原型的原型，直到末端。\n所有引用类型都继承自Object，任何函数的默认原型都是一个Object的实例，也是为什么自定义类型能够继承toString(),valueOf()方法的原因。调用toString()时，实际在调用Object.prototype上的方法。\n通过instanceof返回原型与构造函数的原型关系。\n通过isPrototypeOf返回原型链中是否含有这个原型。\n添加属性或覆盖属性时需要在原型赋值后添加到原型上。\n通过prototype字面量直接修改原型，会破坏之前的原型链。\n原型链的问题：\n1.使用原型实现继承后，函数原型对象的所有属性都会被函数实例共享。\n2.子类型在实例化时不能给父类型的构造函数传参。\n### 8.3.2 盗用构造函数\n通过call，apply来调用执行函数的构造函数，从而得到构造函数的属性和方法。\n可以通过apply,call来向父类构造函数传值。\n缺点：必须在构造函数中定义方法，函数无法重用。且子类无法访问父类原型的方法。（原型不是父类的实例对象）\n### 8.3.3 组合继承\n综合原型链和盗用构造函数，集中了优点。\n利用call实现传值改变继承的值，并且属性不共用。\n### 8.3.4 原型式继承\n实例一个对象作原型，使用Object.create()。\n### 8.3.5 寄生式继承\n创建一个对象，给对象添加属性和值，返回这个对象。\n### 8.3.6 寄生式组合继承\n会调用两次构造函数。\n## 8.4 类\n### 8.4.1 类定义\nclass Person{} // 类声明\nclass Animal = class {} // 类表达式\n类定义无法声明提升，类受块作用域限制。\nclass Foo{ \nconstructor(){} //构造函数\nget myBaz(){} //有获取函数\nstatic myQue(){} // 有静态方法\n}\n外部无法访问类名(标识符)\n### 8.4.2 类构造函数\nP250\n\n\n\n\n\n\n\n\n\n\n\n","slug":"JavaScript高级程序设计","published":1,"updated":"2021-04-01T10:17:50.915Z","_id":"ckkrow33g000bpcva1bifgyqa","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-1-历史回顾\"><a href=\"#1-1-历史回顾\" class=\"headerlink\" title=\"1.1 历史回顾\"></a>1.1 历史回顾</h1><p>网站数据量大，复杂。需要JS来解决，优化。</p>\n<h1 id=\"1-2-JS实现\"><a href=\"#1-2-JS实现\" class=\"headerlink\" title=\"1.2 JS实现\"></a>1.2 JS实现</h1><p>JS = ECMAScript（核心） + DOM（文档对象模型） + BOM（浏览器对象模型）</p>\n<h2 id=\"1-2-1（ECMAScript）\"><a href=\"#1-2-1（ECMAScript）\" class=\"headerlink\" title=\"1.2.1（ECMAScript）\"></a>1.2.1（ECMAScript）</h2><p>ES：网页提供ES的基准实现和与环境自身交互必须的扩展。<br>ES包括：语法、类型、语句、关键字、保留字、操作符、全局对象。<br>大部分浏览器兼容ES6。</p>\n<h2 id=\"1-2-2-DOM\"><a href=\"#1-2-2-DOM\" class=\"headerlink\" title=\"1.2.2 DOM\"></a>1.2.2 DOM</h2><p>文档对象模型：是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。F12中常见的文档树。<br><img src=\"/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%96%87%E6%A1%A3%E6%A0%91.png\" alt=\"文档树\"><br>DOM通过创建表示文档的树，让开发者可以更好地控制网页的内容和结构。使用DOM的API，可以轻松删除，添加，替换，修改节点。<br>DOM视图：描述追踪文档不同视图的接口。<br>DOM事件：描述事件及事件处理的接口。<br>DOM样式：描述处理元素CSS样式的接口。<br>DOM遍历的范围：描述遍历和操作DOM数的接口。<br>其他DOM：可伸缩矢量图（SVG），数学标记语言（MathML），同步多媒体集成语言（SMIL）<br>DOM有不同level（版本）:目前到了level3</p>\n<h2 id=\"1-2-3-BOM\"><a href=\"#1-2-3-BOM\" class=\"headerlink\" title=\"1.2.3 BOM\"></a>1.2.3 BOM</h2><p>浏览器对象模型：用于支持访问和操作浏览器的窗口。使用BOM，可以操控浏览器显示页面之外的部分，BOM针对浏览器窗口和子窗口。拓展：<br>弹出新浏览器窗口的能力；<br>移动、缩放和关闭浏览器窗口的能力；<br>navigator对象，提供关于浏览器的详尽信息；<br>location对象，提供浏览器加载页面的详尽信息；<br>screen对象，提供关于用户屏幕分辨率的详尽信息；<br>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；<br>对cookie的支持；<br>其他自定义对象，XMLHttp，ActiveXObject；</p>\n<h1 id=\"1-3-JavaScript版本\"><a href=\"#1-3-JavaScript版本\" class=\"headerlink\" title=\"1.3 JavaScript版本\"></a>1.3 JavaScript版本</h1><h1 id=\"1-4-小结\"><a href=\"#1-4-小结\" class=\"headerlink\" title=\"1.4 小结\"></a>1.4 小结</h1><p>JS是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br>ES：有ECMA-262定义并提供核心功能。<br>文档对象模型（DOM）:提供与网页内容交互的方法和接口。<br>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。<br>JS这三个部门得到了五大Web浏览器不同程度的支持。所有浏览器基本上对ES5提供了完善的支持，ES6最佳。</p>\n<hr>\n<h1 id=\"2-1-script元素\"><a href=\"#2-1-script元素\" class=\"headerlink\" title=\"2.1 script元素\"></a>2.1 script元素</h1><p>将Js插入HTML的主要方法是使用script元素。有下列8个属性：<br>1.async：可选，表示立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。<br>2.charset：可选，使用src属性指定的代码字符集。很少用。<br>3.crossorigin：可选，配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。<br>defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。<br>integrity：可选，允许比对接收到的资源和指定的加密签名以验证子资源完整性。<br>language：废弃。<br>src：可选，表示包含要执行的代码的外部文件。（引入外部JS文件）<br>type：可选，代替language，表示代码块中脚本语言的内容类型（MIME类型）。按照惯例这个值始终都是“text/JavaScript”，MIME类型通常都是“application/x-javascript”，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。</p>\n<h2 id=\"2-1-1-标签位置\"><a href=\"#2-1-1-标签位置\" class=\"headerlink\" title=\"2.1.1 标签位置\"></a>2.1.1 标签位置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>\n<p>上述是把文件放在head里，不过这种写法以为着必须把所有JS代码都下载、解析和解释完成后，才能开始渲染页面，可能会导致页面渲染的明显延迟，所以通常把文件引用放在body元素中的页面内容后面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&#39;example2.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-2-推迟执行脚本\"><a href=\"#2-1-2-推迟执行脚本\" class=\"headerlink\" title=\"2.1.2 推迟执行脚本\"></a>2.1.2 推迟执行脚本</h2><p>可用defer属性，可用推迟脚本执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script defer src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-3-异步执行脚本\"><a href=\"#2-1-3-异步执行脚本\" class=\"headerlink\" title=\"2.1.3 异步执行脚本\"></a>2.1.3 异步执行脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-4-动态加载脚本\"><a href=\"#2-1-4-动态加载脚本\" class=\"headerlink\" title=\"2.1.4 动态加载脚本\"></a>2.1.4 动态加载脚本</h2><p>JS可用使用DOM API ，通过向DOM中动态添加Script元素同样可用加载指定的脚本，只要创建一个Script元素并将其添加到DOM即可。如下：<br>let script = document.createElement(‘script’);<br>script.src = ‘gibbersh.js’<br>document.head.appendChild(script);<br>这个请求是异步的，不是所有浏览器都支持async属性，因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。<br>添加：script.async = false;<br>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。这种可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;gibberish.js&quot;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-5-XMHTL中的变化\"><a href=\"#2-1-5-XMHTL中的变化\" class=\"headerlink\" title=\"2.1.5 XMHTL中的变化\"></a>2.1.5 XMHTL中的变化</h2><p>XHTML：可扩展超文本标记语言，是将HTML作为XML的应用重新包装的结果。在XHTML中使用JS必须制定type属性且值为text/javascript。<br>XHTML比较少见。</p>\n<h2 id=\"2-1-6-废弃的语法\"><a href=\"#2-1-6-废弃的语法\" class=\"headerlink\" title=\"2.1.6 废弃的语法\"></a>2.1.6 废弃的语法</h2><p>个别废弃的语法，可不看。</p>\n<h1 id=\"2-2-行内代码与外部文件\"><a href=\"#2-2-行内代码与外部文件\" class=\"headerlink\" title=\"2.2 行内代码与外部文件\"></a>2.2 行内代码与外部文件</h1><p>最佳实践是尽可能将JS代码放在外部文件中。推荐原因如下：<br>可维护性：JS代码分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。<br>缓存：浏览器会根据特定的设置缓存所有外部链接的JS文件，这意味着若干两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。<br>适应未来：通过把JS放到外部文件中，就不比考虑用XHTML的或注释黑科技。包含外部JS文件的语法在HTML和XHTML是一样的。<br>在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JS组件形式向客户端送达脚本更具优势。<br>在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从同一个地方取得一批文件，并将他们逐个放到浏览器缓存中。从浏览器角度看，通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JS文件的 延迟差不多。<br>在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。</p>\n<h1 id=\"2-3-文档模式\"><a href=\"#2-3-文档模式\" class=\"headerlink\" title=\"2.3 文档模式\"></a>2.3 文档模式</h1><p>最初有两种模式：混杂模式，标准模式。<br>第三种模式：准标准模式。</p>\n<h1 id=\"2-4-noscript元素\"><a href=\"#2-4-noscript元素\" class=\"headerlink\" title=\"2.4 noscript元素\"></a>2.4 noscript元素</h1><p>针对不支持JS的浏览器而出的元素。以下两种情况，浏览器将显示包含在noscript中的内容：<br>浏览器不支持脚本；<br>浏览器对脚本的支持被关闭；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;noscript&gt; </span><br><span class=\"line\">&lt;p&gt;This page requires a JavaScript-enabled browser.&lt;&#x2F;p&gt; </span><br><span class=\"line\">&lt;&#x2F;noscript&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-5-小结\"><a href=\"#2-5-小结\" class=\"headerlink\" title=\"2.5 小结\"></a>2.5 小结</h1><p>JS通过script元素插入到HTML页面中。这个元素可以用于把JS代码嵌入到HTML页面汇总，跟其他标记混合在一起，也可以用与引入保存在外部文件中的JS。本章的重点如下：<br>1.要包含外部JS文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。<br>2.所有script元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在script元素中的代码必须严格按次序解释。<br>3.对不推迟执行的脚本，浏览器必须解释完位于script元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常把script元素放到页面末尾，介于主内容之后及body标签之前。<br>4.可以使用defer推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。<br>5.可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。<br>6.通过使用noscript元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则noscript元素中的任何内容都不会被渲染。</p>\n<h1 id=\"3-1-语法\"><a href=\"#3-1-语法\" class=\"headerlink\" title=\"3.1 语法\"></a>3.1 语法</h1><h2 id=\"3-1-1-区别大小写\"><a href=\"#3-1-1-区别大小写\" class=\"headerlink\" title=\"3.1.1 区别大小写\"></a>3.1.1 区别大小写</h2><p>ECMA中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。<br>typeof不能作为函数名，因为它是一个关键字。但Typeof可以用。</p>\n<h2 id=\"3-1-2-标识符\"><a href=\"#3-1-2-标识符\" class=\"headerlink\" title=\"3.1.2 标识符\"></a>3.1.2 标识符</h2><p>变量、函数、属性或函数参数的名称。可以由一个或多个下列字符组成：<br>第一个字符必须是一个字母、下划线（_）或美元符号（$）;<br>剩下的其他字符可以是字母、下划线、美元符号或数字。<br>一般使用驼峰大小写形式。</p>\n<h2 id=\"3-1-3-注释\"><a href=\"#3-1-3-注释\" class=\"headerlink\" title=\"3.1.3 注释\"></a>3.1.3 注释</h2><h2 id=\"3-1-4-严格模式\"><a href=\"#3-1-4-严格模式\" class=\"headerlink\" title=\"3.1.4 严格模式\"></a>3.1.4 严格模式</h2><p>“use strict” //脚本开头加上这一行<br>也可以在指定函数内加上开头。所有现代浏览器都支持严格模式。</p>\n<h2 id=\"3-1-5-语句\"><a href=\"#3-1-5-语句\" class=\"headerlink\" title=\"3.1.5 语句\"></a>3.1.5 语句</h2><p>结尾建议加分号，建议语句块加{}</p>\n<h2 id=\"3-2-关键字与保留字\"><a href=\"#3-2-关键字与保留字\" class=\"headerlink\" title=\"3.2 关键字与保留字\"></a>3.2 关键字与保留字</h2><p>ES6的关键字有：<br>break     do     in     typeof<br>case     else     instanceof     var<br>catch     export     new     void<br>class     extends     return     while<br>const     finally     super     with<br>continue   for     switch     yield<br>debugger function    this<br>default     if     throw<br>delete     import     try<br>ES6将来保留词汇：<br>始终保留：<br>enum<br>严格模式下保留：<br>implements     package     public<br>interface     protected     static<br>let     private<br>模块代码中保留：<br>await<br>这些词汇不能作标识符，但可以坐对象的属性名，推荐不用作属性名。</p>\n<h1 id=\"3-3-变量\"><a href=\"#3-3-变量\" class=\"headerlink\" title=\"3.3 变量\"></a>3.3 变量</h1><p>ECMA变量是松散类型的，变量可以用于保存任何类型的数据。每个变量不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var,const,let<br>var:声明完后可以赋值，但未标识类型。//声明提升<br>//var message = “hi”;<br>//message = 100; // 合法，但不推荐。<br>//作用域在声明的环境下的函数作用域，例在函数内定义，调用完函数随即被销毁。<br>//在函数内定义时省略var操作符，可以创建一个全局变量。不推荐这么做。<br>let:块作用域，同一个块内不能重复声明。变量在作用域中无声明提升。<br>//有暂时性死区。<br>//无法全局声明，声明的变量不会成为window对象的属性。<br>//ES6不能依赖条件声明模式<br>const:与let基本相同，区别是声明变量时必须同时初始化变量，且无法修改const声明的变量。</p>\n<h2 id=\"3-3-4-声明风格及最佳实践\"><a href=\"#3-3-4-声明风格及最佳实践\" class=\"headerlink\" title=\"3.3.4 声明风格及最佳实践\"></a>3.3.4 声明风格及最佳实践</h2><p>1.不使用var<br>2.const优先，let次之</p>\n<h1 id=\"3-4-数据类型\"><a href=\"#3-4-数据类型\" class=\"headerlink\" title=\"3.4 数据类型\"></a>3.4 数据类型</h1><p>ES6有6种简单的数据类型（原始类型）：undefined,null,boolean,number,String,Symbol。Symbol是ES6新增的。还有一种复杂的数据类型叫Object（对象）。Object是一种无序名值对的集合。</p>\n<h2 id=\"3-4-1-typeof操作符\"><a href=\"#3-4-1-typeof操作符\" class=\"headerlink\" title=\"3.4.1 typeof操作符\"></a>3.4.1 typeof操作符</h2><p>不需要参数（但可以使用参数），严格来说，函数也是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。可以用typeof区分。</p>\n<h2 id=\"3-4-2-Undefined类型\"><a href=\"#3-4-2-Undefined类型\" class=\"headerlink\" title=\"3.4.2 Undefined类型\"></a>3.4.2 Undefined类型</h2><p>变量未初始化即是Undefined，相当于给变量赋值了Undefined。<br>建议在声明时初始化，出现undefined可以更好辨别。</p>\n<h2 id=\"3-4-4-Null类型\"><a href=\"#3-4-4-Null类型\" class=\"headerlink\" title=\"3.4.4 Null类型\"></a>3.4.4 Null类型</h2><p>Null类型同样只有一个值，即特殊值null。null值表示一个空对象指针，typeof null返回Object。<br>在定义将来要保存对象值的变量时，建议初始化为null。</p>\n<h2 id=\"3-4-4-Boolean类型\"><a href=\"#3-4-4-Boolean类型\" class=\"headerlink\" title=\"3.4.4 Boolean类型\"></a>3.4.4 Boolean类型</h2><p>有两个字面值：true，false。<br>True和False是有效的标识符，不是布尔值。//区分大小写<br>使用Boolean()来转换类型</p>\n<h2 id=\"3-4-5-Number类型\"><a href=\"#3-4-5-Number类型\" class=\"headerlink\" title=\"3.4.5 Number类型\"></a>3.4.5 Number类型</h2><p>1.浮点值<br>//小数点后面必须带数字，不然当整数处理。<br>2.值的范围<br>//Number.MIN_VALUE:5e-324<br>Number.MAX_VALUE:1.7976931348623157e+308<br>超出以上范围会表示为Infinity或-Infinity,该值无法用于计算。<br>可使用isFinite()函数进行判断<br>3.NaN<br>NaN表示”不是数值”,用于表示本来要返回数值的操作失败了（不是抛出错误）。<br>例：0除任意数值<br>console.log(0/0) // NaN<br>console.log(5/0) //Infinity<br>console.log(5/-0)//-Infinity<br>任何涉及NaN的操作始终返回NaN，NaN不等于任何值。//(NaN == NaN)–&gt;false<br>可用isNaN()函数判断是否不是数值<br>isNaN(NaN)//true<br>isNaN(10)//false<br>isNaN(“10”)//false,可转换为数值10<br>isNaN(“blue”)//true,无法转换为数值<br>isNaN(true)//false,可以转换为1<br>4.数值转换<br>有3个函数可以将非数值转换为数值：<br>Number(),parseInt(),parseFloat()<br>Number()是转型函数，可用于任何数据类型。后两个主要用于将字符串转为数值。<br>Number()有如下规则：<br>(true)-&gt;1,(false)-&gt;0,(null)-&gt;0,(undefined)-&gt;NaN,数值直接返回<br>如果字符串包含数值字符，包括数值字符前面带加号、减号的情况，则转换为一个十进制数值。<br>如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值（同样，忽略前面的0）。<br>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。<br>如果是空字符串（不包含字符），则返回0。<br>如果字符串包含上述情况之外的其他字符，则返回NaN。<br>通常使用parseInt（）</p>\n<h2 id=\"3-4-6-String类型\"><a href=\"#3-4-6-String类型\" class=\"headerlink\" title=\"3.4.6 String类型\"></a>3.4.6 String类型</h2><p>字符串使用：双引号，单引号，反引号都合法，引号类型前后必须一致。<br>1.字面量：<br>\\n  换行<br>\\t   制表<br>\\b  退格<br>\\r   回车<br>\\f   换页等<br>2.特点<br>不可变，一旦创建，值不能变。要修改某个变量的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。<br>3.转换为字符串<br>toString()//函数<br>还可以传入参数输出不同进制<br>let num = 10;<br>num.toString() // “10”<br>num.toString(2) // “1010”<br>num.toString(8) // “12”<br>4.模板字面量<br>可以使用换行字符，可以跨行定义字符串。<br>使用反引号会保持引号内部的空格，字面量，length会增加。<br>5.字符串插值<br>可以在定义中插入一个或多个值。<br>通过反引号中使用 ${}插入，插入的值都会通过toString转换为字符串<br>插值表达式中可以调用函数和方法：<br>foo = {toString:() =&gt; ‘Wrold’};<code>hello,${foo}</code> // hello world<br>capitalize(word) =&gt;return <code>${word[0].toUpperCase()}</code>   // <code>${capitalize(&#39;hello&#39;)}</code>//-&gt;Hello<br>6.模板字面量标签函数<br>支持定义标签函数，通过标签函数可以自定义插值行为。<br>7.原始字符串<br>Unicode字符<br>使用String.raw获取原始字符串<br>‘\\u00A9’ // 版权符号<br>String.raw<code>\\u00A9</code>// \\u00A9</p>\n<h2 id=\"3-4-7-Symbol类型\"><a href=\"#3-4-7-Symbol类型\" class=\"headerlink\" title=\"3.4.7 Symbol类型\"></a>3.4.7 Symbol类型</h2><p>Symbol是ES6新增的，且实例是唯一，不可变的。用于创建唯一记号，进而用作非字符串形式的对象属性。<br>1.基本用法<br>let sym = Symbol(); type of sym//symbol<br>也可以传入字符串参数作为对symbol的描述，可通过这个字符串来调试代码。但这个字符串参数与符号定义或标识无关。<br>符号无法与new关键字一起作为构造函数使用。<br>可以使用符号包装对象，借用Object函数()函数：<br>let mySymbol = Symbol();<br>let myWrappedSymbol = Object (mySymbol);<br>console.log(typeof myWrappedSymbol); // “object”<br>2.使用全局符号注册表<br>如果运行时的不同部分需要共享和 重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br>需要使用Symbol.for()方法。</p>\n<h2 id=\"3-4-8-Object类型\"><a href=\"#3-4-8-Object类型\" class=\"headerlink\" title=\"3.4.8 Object类型\"></a>3.4.8 Object类型</h2><p>对象其实就是一组数据和功能的集合。可以通过new来创建实例对象。<br>每个对象都有如下属性和方法：<br>constructor：用于创建当前对象的函数，构造函数。<br>hasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性。<br>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。<br>propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用。<br>toLacaleString():返回对象的字符串表示,反映对象所在本地化执行环境。<br>toString():返回对象的字符串表示。<br>valueOf():返回对象对应的字符串、数值或布尔值表示。</p>\n<h1 id=\"3-5-操作符\"><a href=\"#3-5-操作符\" class=\"headerlink\" title=\"3.5 操作符\"></a>3.5 操作符</h1><h2 id=\"3-5-1-一元操作符\"><a href=\"#3-5-1-一元操作符\" class=\"headerlink\" title=\"3.5.1 一元操作符\"></a>3.5.1 一元操作符</h2><p>只操作一个值的操作符叫一元操作符。<br>++,–;  //操作中会自行转换类型,(递增和递减)<br>+,-//一元加减符，可以用于运算和转换</p>\n<h2 id=\"3-5-2-位操作符\"><a href=\"#3-5-2-位操作符\" class=\"headerlink\" title=\"3.5.2 位操作符\"></a>3.5.2 位操作符</h2><p>…</p>\n<h2 id=\"3-5-3-布尔操作符\"><a href=\"#3-5-3-布尔操作符\" class=\"headerlink\" title=\"3.5.3 布尔操作符\"></a>3.5.3 布尔操作符</h2><p>逻辑非，逻辑与逻辑或<br>1.逻辑非 ：！（感叹号）<br>!false // true<br>!”blue” //false<br>!0 //true<br>!NaN //true<br>!”” //true<br>!12345 //false<br>也可以用两个感叹号:!!,相当于调用了转型函数Boolean()。第一个返回布尔值，第二个对该布尔值取反。<br>相当于如上例子，布尔值取反。<br>2.逻辑与<br>由&amp;&amp;表示 // true &amp;&amp; true为true  其余都为false<br>3.逻辑或<br>由||表示 //有一个是true为true，false || false为false</p>\n<h2 id=\"3-5-4-乘性操作符\"><a href=\"#3-5-4-乘性操作符\" class=\"headerlink\" title=\"3.5.4 乘性操作符\"></a>3.5.4 乘性操作符</h2><p>乘法(<em>)，除法(/)，取模(%)。<br>乘法(</em>):都为数值则计算，有一项为NaN则返回NaN，如果是Infinity<em>0=NaN,Infinity</em>(-/+)num=(-)Infinity，Infinity*Infinity=Infinity,如果不是数值会转换后再近些操作。<br>除法(/):<br>0 / 0 = NaN,Infinity / Infinity = NaN,-(number)/0 = (-)Infinity,Infinity / (-)Number = (-)Infinity<br>取模(%):类似除</p>\n<h2 id=\"3-5-5-指数操作符\"><a href=\"#3-5-5-指数操作符\" class=\"headerlink\" title=\"3.5.5 指数操作符\"></a>3.5.5 指数操作符</h2><p>ES7新增的操作符 (*<em>)//Math.pow(3,2) == 3 *</em> 2 == 9<br>squared ** = 2 //9</p>\n<h2 id=\"3-5-6-加性操作符\"><a href=\"#3-5-6-加性操作符\" class=\"headerlink\" title=\"3.5.6 加性操作符\"></a>3.5.6 加性操作符</h2><p>（+），（-）</p>\n<h2 id=\"3-5-7-关系操作符\"><a href=\"#3-5-7-关系操作符\" class=\"headerlink\" title=\"3.5.7 关系操作符\"></a>3.5.7 关系操作符</h2><p>（&lt;）,（&gt;）,（&lt;=），（&gt;=）</p>\n<h2 id=\"3-5-8-相等操作符\"><a href=\"#3-5-8-相等操作符\" class=\"headerlink\" title=\"3.5.8 相等操作符\"></a>3.5.8 相等操作符</h2><p>（==），（!=），（===）,（!==）</p>\n<h2 id=\"3-5-9-条件操作符\"><a href=\"#3-5-9-条件操作符\" class=\"headerlink\" title=\"3.5.9 条件操作符\"></a>3.5.9 条件操作符</h2><p>（?）// let max = （num1 &gt; num2）? num1 : num2</p>\n<h2 id=\"3-5-10-赋值操作符\"><a href=\"#3-5-10-赋值操作符\" class=\"headerlink\" title=\"3.5.10 赋值操作符\"></a>3.5.10 赋值操作符</h2><p>（=），（*=），（/=），（%=），（+=）,（-=）,（&lt;&lt;=）,（&gt;&gt;=）,（&gt;&gt;&gt;=）</p>\n<h1 id=\"3-6-语句\"><a href=\"#3-6-语句\" class=\"headerlink\" title=\"3.6 语句\"></a>3.6 语句</h1><h2 id=\"3-6-1-if语句\"><a href=\"#3-6-1-if语句\" class=\"headerlink\" title=\"3.6.1 if语句\"></a>3.6.1 if语句</h2><p>…</p>\n<h2 id=\"3-6-2-do-while语句\"><a href=\"#3-6-2-do-while语句\" class=\"headerlink\" title=\"3.6.2 do-while语句\"></a>3.6.2 do-while语句</h2><p>do {***} while(expression);</p>\n<h2 id=\"3-6-3-while语句\"><a href=\"#3-6-3-while语句\" class=\"headerlink\" title=\"3.6.3 while语句\"></a>3.6.3 while语句</h2><p>let i = 0;<br>while(i &lt; 10) { i += 2};</p>\n<h2 id=\"3-6-4-for语句\"><a href=\"#3-6-4-for语句\" class=\"headerlink\" title=\"3.6.4 for语句\"></a>3.6.4 for语句</h2><p>for(initialization;expression;post-loop-expression) statement</p>\n<h2 id=\"3-6-5-for-in语句\"><a href=\"#3-6-5-for-in语句\" class=\"headerlink\" title=\"3.6.5 for-in语句\"></a>3.6.5 for-in语句</h2><p>for(property in expression) statement<br>for(const propName in window) {document.write(propName)}//例子</p>\n<h2 id=\"3-6-6-for-of语句\"><a href=\"#3-6-6-for-of语句\" class=\"headerlink\" title=\"3.6.6 for-of语句\"></a>3.6.6 for-of语句</h2><p>for(property of expression) statement<br>for(const el of [2,4,6,8]){document.write(el)}//例子</p>\n<h2 id=\"3-6-7-标签语句\"><a href=\"#3-6-7-标签语句\" class=\"headerlink\" title=\"3.6.7 标签语句\"></a>3.6.7 标签语句</h2><p>label:statement<br>start: for(let i = 0;i &lt; count;i++){console.log(i)}//start是一个标签，可在后面通过break，continue语句引用。</p>\n<h2 id=\"3-6-8-break和continue语句\"><a href=\"#3-6-8-break和continue语句\" class=\"headerlink\" title=\"3.6.8 break和continue语句\"></a>3.6.8 break和continue语句</h2><p>break用于立即退出循环,强行执行循环后的下一条语句。<br>continue语句用于立即退出循环，但会从循环顶部开始执行。</p>\n<h2 id=\"3-6-9-with语句\"><a href=\"#3-6-9-with语句\" class=\"headerlink\" title=\"3.6.9 with语句\"></a>3.6.9 with语句</h2><p>with(expression) statement;<br>let qs = location.search.substring(1);<br>let hostName = location.hostname;<br>let url = location.href;<br>with(location){<br>let qs = search.substring(1);<br>let hostName = hostname;<br>let url = href;<br>}<br>严格模式不允许使用</p>\n<h2 id=\"3-6-10-switch语句\"><a href=\"#3-6-10-switch语句\" class=\"headerlink\" title=\"3.6.10 switch语句\"></a>3.6.10 switch语句</h2><p>switch(expression){<br>  case value1:<br>    statament<br>    break;<br>  case value2:<br>    statement<br>    break;<br>  …<br>  default:<br>    statement<br>}<br>//switch不会强制转换数据类型</p>\n<h2 id=\"3-7-函数\"><a href=\"#3-7-函数\" class=\"headerlink\" title=\"3.7 函数\"></a>3.7 函数</h2><p>function Name(arg0,arg1){ statements}<br>遇到return语句函数就会立即停止执行并退出。<br>函数不能以eval，arguments作为名称；<br>函数的参数不能叫eval，arguments；<br>两个命名参数不能拥有同一个名称。</p>\n<h2 id=\"3-8-小结\"><a href=\"#3-8-小结\" class=\"headerlink\" title=\"3.8 小结\"></a>3.8 小结</h2><p>ES中基本数据类型包括：undefined,Null,Boolean,Number,String,Symbol<br>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。//声明方式<br>不指定返回值的函数实际上会返回特殊值undefined。</p>\n<h1 id=\"4-变量、作用域与内存\"><a href=\"#4-变量、作用域与内存\" class=\"headerlink\" title=\"4 变量、作用域与内存\"></a>4 变量、作用域与内存</h1><h2 id=\"4-1-原始值与引用值\"><a href=\"#4-1-原始值与引用值\" class=\"headerlink\" title=\"4.1 原始值与引用值\"></a>4.1 原始值与引用值</h2><p>变量有两种不同的类型：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。<br>原始值的变量是按值访问的，引用值是保存在内存中的对象，操作对象时，操作的是对该对象的引用而非实际的对象本身。</p>\n<h3 id=\"4-1-1-动态属性\"><a href=\"#4-1-1-动态属性\" class=\"headerlink\" title=\"4.1.1 动态属性\"></a>4.1.1 动态属性</h3><p>引用值可以随时添加、修改和删除其属性和方法。<br>只有引用值可以动态添加后面可以使用的属性。<br>原始类型的初始化可以只使用原始字面量形式。如果使用new则创建Object类型的实例。<br>let name1 = “wxc”;//typeof name1 == string<br>let name2 = new String(“Matt”);//typeof name2 == object</p>\n<h3 id=\"4-1-2-复制值\"><a href=\"#4-1-2-复制值\" class=\"headerlink\" title=\"4.1.2 复制值\"></a>4.1.2 复制值</h3><p>原始值的变量复制会创建新变量。//let name1 = “wxc”;let name2 = name1;<br>引用值的变量复制的是一个指针，两个变量指向同一个对象，一改则都改。</p>\n<h3 id=\"4-1-3-传递参数\"><a href=\"#4-1-3-传递参数\" class=\"headerlink\" title=\"4.1.3 传递参数\"></a>4.1.3 传递参数</h3><p>函数的参数都是按值传递的，传递时，值会被复制到一个局部变量。<br>按引用传递参数时，值在内存中的位置会被保存在一个局部变量，对本地变量的修改会反映到函数外部。ES中函数的参数就是局部变量。</p>\n<h3 id=\"4-1-4确定类型\"><a href=\"#4-1-4确定类型\" class=\"headerlink\" title=\"4.1.4确定类型\"></a>4.1.4确定类型</h3><p>typeof对于原始值有用，但对引用值不大。<br>引用值判断可以用instanceof<br>person instanceof Object<br>colors instanceof Array<br>pattern instanceof RegExp<br>instanceof对于原始值始终返回false，原始值不是对象。</p>\n<h2 id=\"4-2-执行上下文与作用域\"><a href=\"#4-2-执行上下文与作用域\" class=\"headerlink\" title=\"4.2 执行上下文与作用域\"></a>4.2 执行上下文与作用域</h2><p>每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。<br>浏览器中，全局上下文为window对象。var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。<br>每个函数也有自己的上下文，执行函数时，函数上下文被推倒一个上下文栈上，执行完后弹出。ES的执行流通过该上下文栈进行控制。<br>上下文中的代码在执行时，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链的下一个变量对象来自上级包含上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。<br>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>\n<h3 id=\"4-2-1-作用域链增强\"><a href=\"#4-2-1-作用域链增强\" class=\"headerlink\" title=\"4.2.1 作用域链增强\"></a>4.2.1 作用域链增强</h3><p>代码执行到try/catch语句的catch块与with语句时，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>\n<h3 id=\"4-2-2-变量声明\"><a href=\"#4-2-2-变量声明\" class=\"headerlink\" title=\"4.2.2 变量声明\"></a>4.2.2 变量声明</h3><p>1.使用var声明变量，变量会被自动添加到最接近的上下文，最接近的上下文大多是函数的局部上下文，如果未声明就被初始化了，就被添加到全局上下文。如果在函数内声明变量添加到全局上下文，函数退出后依然可以访问。<br>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。变量提升。<br>2.使用let声明的块级作用域声明<br>块级作用域由最近的{}界定。<br>3.使用const的常量声明<br>const声明的同时必须初始化为某个值。声明后不能重新赋新值。<br>作用域与let声明一样。<br>建议多使用const，除非需要一个会重新赋值的变量。可以防止重新赋值的BUG。<br>4.标识符查找<br>特定上下文读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。//其实就是调用变量</p>\n<h2 id=\"4-3-垃圾回收\"><a href=\"#4-3-垃圾回收\" class=\"headerlink\" title=\"4.3 垃圾回收\"></a>4.3 垃圾回收</h2><p>JS使用垃圾回收，程序每隔一段就会自动运行。确定不会再使用的变量，释放内存。</p>\n<h3 id=\"4-3-1-标记清理\"><a href=\"#4-3-1-标记清理\" class=\"headerlink\" title=\"4.3.1 标记清理\"></a>4.3.1 标记清理</h3><p>常用策略是标记清理。程序运行时，标记内存中存储的所有变量，将所有上下文中的变量，以及被在上下文中的变量引用的标记去掉。再加上标记代表待删除，随后做一次内存清理，销毁带标记的所有值并回收内存。<br>IE，Firefox，Opera，Chrome，Safari都在JS实习标记清理，频率有所差异。</p>\n<h3 id=\"4-3-2-引用计数\"><a href=\"#4-3-2-引用计数\" class=\"headerlink\" title=\"4.3.2 引用计数\"></a>4.3.2 引用计数</h3><p>对每个值记录引用次数。声明变量并赋一个引用值时，这个值的引用数为1。 如果保存对该值引用的变量被其他值给覆盖了，引用数-1。引用数为0时回收内存。</p>\n<h3 id=\"4-3-3-性能\"><a href=\"#4-3-3-性能\" class=\"headerlink\" title=\"4.3.3 性能\"></a>4.3.3 性能</h3><p>垃圾回收的时间调度很重要，变量太多会造成性能损失。JS引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果回收的内存不到已分配的15%，这些阈值会翻倍。如果一次回收的内存达到已分配的85%，则阈值重置为默认值。</p>\n<h3 id=\"4-3-4-内存管理\"><a href=\"#4-3-4-内存管理\" class=\"headerlink\" title=\"4.3.4 内存管理\"></a>4.3.4 内存管理</h3><p>保证在执行代码时只保存必要的数据。不在必要则设置为null，从而释放其引用。这也可以叫作解除引用。局部变量在超出作用域会自动解除引用，所以该建议更适合全局变量和全局对象。<br>1.通过const和let声明提升性能<br>块作用域，能更早让垃圾回收程序介入。<br>2.隐藏类和删除操作<br>对象与隐藏类会被关联起来，用于跟踪他们的属性特征。共享相同隐藏类的对象性能会更好。<br>function Article(){this.title = ‘go go go’}<br>let a1 = new Article();//隐藏类title<br>let a2 = new Article();//隐藏类title<br>a1.author = ‘Jake’//对应多出author隐藏类，可能对性能产生明显影响。<br>function Article(author){this.title=’go’,this.author=author}<br>let a2 = new Article(‘wxc’)//a2与a1相同，共享一个隐藏类。<br>delete a1.author//使用delete关键字会导致生成同样的隐藏类片段<br>a1.author = null; //保持共享，并达到垃圾回收的效果<br>3.内存泄漏<br>JS的内存泄漏大部分是不合理的引用导致的。<br>function(){name = ‘Jake’}意外声明全局变量是最常见也最容易修复的内存泄漏问题。无关键字声明。<br>定时器也会导致内存泄漏，定时器的回调通过闭包引用了外部变量。<br>使用闭包容易造成内存泄漏，如下：<br>let outer = function() {let name = ‘Jake’;return function() {return name};};<br>调用outer()会导致内存泄漏。只要返回的函数存在就不能清理name，因为闭包一直在引用，加入name的内容很大，就是个大问题。<br>4.静态分配与对象池<br>不要动态创建矢量对象<br>在初始化的时候，创建一个对象池，管理一组可回收的对象。使用完后回归对象池。</p>\n<h2 id=\"4-4-小结\"><a href=\"#4-4-小结\" class=\"headerlink\" title=\"4.4 小结\"></a>4.4 小结</h2><p>原始值大小固定，因此保存在栈内存上。<br>引用值是对象，存储在堆内存上。<br>任何变量都存在于某个作用域（上下文）中，这个作用域决定了变量的声明周期，以及它们可以访问代码的哪些部分。<br>全局上下文：window，浏览器。<br>函数上下文：声明函数的{}内<br>块级上下文：最近的{}内<br>JS有垃圾回收，垃圾回收的方法有：引用计数，标记清理。主流为标记清理。<br>接触变量引用一般直接给变量赋值为null。</p>\n<h1 id=\"5-基本引用类型\"><a href=\"#5-基本引用类型\" class=\"headerlink\" title=\"5.基本引用类型\"></a>5.基本引用类型</h1><p>引用值是某个特定引用类型的实例。<br>对象被认为是某个特定引用类型的实例。新对象通过使用new操作符跟一个构造函数来创建。<br>函数也是一种引用类型。</p>\n<h2 id=\"5-1-Date\"><a href=\"#5-1-Date\" class=\"headerlink\" title=\"5.1 Date\"></a>5.1 Date</h2><p>日期对象//let now = new Date();<br>可用Date.parse()转换成日期对象//let someDate = new Date(Date.parse(“May 23,2019”));如果字符串不表示日期，会返回NaN。<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55));//GMT时间——Date.UTC方法<br>ES提供了Date.now()方法，返回表示方法执行时日期。<br>let start = Date.now();//当前时间</p>\n<h3 id=\"5-1-1-继承的方法\"><a href=\"#5-1-1-继承的方法\" class=\"headerlink\" title=\"5.1.1 继承的方法\"></a>5.1.1 继承的方法</h3><p>let date = new Date(2021,1,20);<br>toLocaleString()//–&gt;2021/2/20 上午12:00:00<br>toString()//–&gt;Sat Feb 20 2021 00:00:00 GMT+0800<br>valueOf()//–&gt;1613750400000</p>\n<h3 id=\"5-1-2-日期格式化方法\"><a href=\"#5-1-2-日期格式化方法\" class=\"headerlink\" title=\"5.1.2 日期格式化方法\"></a>5.1.2 日期格式化方法</h3><p>Date格式化日期的方法：<br>toDateString()//显示日期中的周几，月，日，年<br>toTimeString()//显示日期中的时分秒和时区<br>toLocaleDateString()//显示日期中的周几 月 日 年<br>toLocaleTimeString()//显示日期中的时 分 秒<br>toUTCString()//显示完整的UTC日期</p>\n<h3 id=\"5-1-3-日期-时间组件方法\"><a href=\"#5-1-3-日期-时间组件方法\" class=\"headerlink\" title=\"5.1.3 日期/时间组件方法\"></a>5.1.3 日期/时间组件方法</h3><p>主要应用：<br>getTime()//返回日期的毫秒表示，与valueOf相同<br>setTime(milliseconds)//设置日期的毫秒表示，从而修改整个日期<br>getFullYear()//返回四位年数<br>getMonth()//返回日期的月<br>getDate()//返回日期的日<br>getDay()//返回日期中表示周几的数值<br>getHours()//返回日期中的时<br>getMinutes()//返回日期中的分<br>getSeconds()//返回日期中的秒</p>\n<h2 id=\"5-2-RegExp\"><a href=\"#5-2-RegExp\" class=\"headerlink\" title=\"5.2 RegExp\"></a>5.2 RegExp</h2><p>ES通过RegExp类型支持正则表达式。<br>let expression = /pattern/flags;<br>匹配模式的标记：<br>1.g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。<br>2.i:不区分大小写，表示查找匹配时忽略pattern和字符串的大小写。<br>3.m:多行模式，表示查找到一行文本末尾时会继续查找。<br>4.y:粘附模式，表示只查找从lastIndex开始及之后的字符串。<br>5.u:Unicode模式，启用Unicode匹配。<br>6.s：dotAll模式，表示元字符匹配任何字符。(包括\\n或\\r)。<br>使用不同模式和标记可以创建出各种正则表达式，比如：<br>//匹配字符串中的所有”at”<br>let pattern1 = /at/g;<br>//匹配第一个”bat”或”cat” 忽略大小写<br>let pattern2 = /[bc]at/i<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi<br>元字符在模式中必须转义：<br>( ，[， {，\\，^，$，|，)，]，}，？，*，+，- //这些符号前面需要\\来转义<br>//匹配第一个”bat”或”cat”，忽略大小写<br>let pattern1 = /[bc]at/i;<br>//匹配第一个”[bc]at”，忽略大小写<br>let pattern2 = /[bc]at/i;<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi;<br>//匹配所有”.at”，忽略大小写<br>let pattern4 = /.at/gi;<br>也可使用RegExp构造函数来创建：<br>let pattern1 = /[bc]at/i   ==   new RegExp(“[bc]at”,”i”);<br>也可以使用实例，选择性修改标记<br>const re1 = /cat/g;<br>const re2 = new RegExp(re1);<br>const re3 = new RegExp(re1,”i”);</p>\n<h3 id=\"5-2-1-RegExp实例属性\"><a href=\"#5-2-1-RegExp实例属性\" class=\"headerlink\" title=\"5.2.1 RegExp实例属性\"></a>5.2.1 RegExp实例属性</h3><p>global:布尔值，表示是否设置了g标记。<br>ignoreCase:布尔值，表示是否设置了i标记。<br>unicode:布尔值，表示是否设置了u标记。<br>sticky:布尔值，表示是否设置了y标记。<br>lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。<br>multiline:布尔值，表示是否设置了m标记。<br>dotAll:布尔值，表示是否设置了s标记。<br>source:正则表达式的字面量字符串，没有开头和结尾的斜杠。<br>flags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回。</p>\n<h3 id=\"5-2-2-RegExp实例方法\"><a href=\"#5-2-2-RegExp实例方法\" class=\"headerlink\" title=\"5.2.2 RegExp实例方法\"></a>5.2.2 RegExp实例方法</h3><p>exec()函数：<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);<br>  console.log(matchs);//cat<br>//设置了全局标记(g)，每次调用返回一个匹配的信息，如果没有设置全局标记，只会返回第一个匹配的信息。<br>//设置了g标记，每次调用exec()都会在字符中向前搜索下一个匹配项<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);//cat<br>  let matchs = pattern.exec(text);//bat<br>  let matchs = pattern.exec(text);//sat<br>  console.log(matchs);<br>//设置了y标记，每次调用会在lastIndex的位置上寻找匹配项。y标记覆盖g标记。<br>test()函数：//用于判断是否存在实际内容中，常在if判断语句中<br>let text = “000-00-00 00”;<br>let pattern = /\\d{3}-\\d{2}-\\d(4)/;<br>if(pattern.test(text)) {console.log(“The pattern was matched.”)};<br>继承的方法toLocaleString()和toString()都返回字面量表示。<br>let pattern = new RegExp(“\\[bc\\]at”,”gt”);<br>console.log(pattern.toString());//  /[bc]at/gi<br>console.log(pattern.toLocaleString());//  /[bc]at/gi</p>\n<h3 id=\"5-2-3-RegExp构造函数属性\"><a href=\"#5-2-3-RegExp构造函数属性\" class=\"headerlink\" title=\"5.2.3 RegExp构造函数属性\"></a>5.2.3 RegExp构造函数属性</h3><p>input：$_   //最后搜索的字符串<br>lastMatch：$&amp;   //最后匹配的文本<br>lastParen：$+   //最后匹配的捕获组<br>leftContext：$`   //input字符串中出现在lastMatch前面的文本<br>rightContext：$’   //input字符串中出现在lastMatch后面的文本<br>let text = “this has been a short summer”;<br>let pattern = /(.)hort/g; //()–&gt;捕获组<br>if(pattern.test(text)) {<br>   console.log(RegExp.input); //this has been a short summer<br>   console.log(RegExp.leftContext); //this has been a<br>   console.log(RegExp.rightContext); //summer<br>   console.log(RegExp.lastMatch); //short<br>   console.log(RegExp.input); //s<br>}</p>\n<p>if(pattern.test(text)) {<br>   console.log(RegExp.$_); //this has been a short summer<br>   console.log(RegExp[“$`”]); //this has been a<br>   console.log(RegExp[“$’”]); //summer<br>   console.log(RegExp[“$&amp;”]); //short<br>   console.log(RegExp[“$+”]); //s<br>}<br>let pattern = /(..)or(.)/g;</p>\n<p>if(pattern.test(text)) {<br>   console.log(RegExp.$1); // sh<br>   console.log(RegExp.$2);// t<br>}</p>\n<h3 id=\"5-2-4-模式局限\"><a href=\"#5-2-4-模式局限\" class=\"headerlink\" title=\"5.2.4 模式局限\"></a>5.2.4 模式局限</h3><p>ES对正则表达式的支持还缺少一些高级特性。</p>\n<h2 id=\"5-3-原始值包装类型\"><a href=\"#5-3-原始值包装类型\" class=\"headerlink\" title=\"5.3 原始值包装类型\"></a>5.3 原始值包装类型</h2><p>ES提供了3种特殊类型的引用类型：Boolean,Number,String。<br>以读模式访问字符串时，后台执行：<br>（1）创建一个String类型的实例；// let s1 = “some text”<br>（2）调用实例上的特点方法；// let s2 = s1.substring(2);<br>（3）销毁实例；// s1 = null;<br>let value = “25”;<br>let number = Number(value);   //转型函数<br>console.log(typeof number);   //“number”<br>let obj = new Number(value); // 构造函数<br>console.log(typeof obj); //“object”<br>变量obj保存一个Number实例。</p>\n<h3 id=\"5-3-1-Boolean\"><a href=\"#5-3-1-Boolean\" class=\"headerlink\" title=\"5.3.1 Boolean\"></a>5.3.1 Boolean</h3><p>let falseObject = new Boolean(false);// typeof == object<br>let result = falseObject &amp;&amp; true;<br>console.log(result); //true<br>let falseValue = false;//typeof == boolean 强烈建议永远不要使用<br>result = falseValue &amp;&amp; true;<br>console.log(result); //false</p>\n<h3 id=\"5-3-2-Number\"><a href=\"#5-3-2-Number\" class=\"headerlink\" title=\"5.3.2 Number\"></a>5.3.2 Number</h3><p>方法：toFix()//let num = 10;num.toFixed(2);// “10.00”<br>方法：toExponential()//let num = 10;num.toExponential(1);//“1.0e+1”<br>方法：toPrecision()//let num = 99;<br>num.toPrecision(1)//“1e+2”<br>num.toPrecision(2)//“99”<br>num.toPrecision(3)//“99.0”<br>方法：isInterger()//辨别一个数值是否保存为整数。<br>Number.isInterger(1);// true<br>Number.isInterger(1.00)//true<br>Number.isInterger(1.01)//false<br>方法：isSafeInterger()判断数值范围</p>\n<h3 id=\"5-3-3-String\"><a href=\"#5-3-3-String\" class=\"headerlink\" title=\"5.3.3 String\"></a>5.3.3 String</h3><p>每个字符用16位表示，基于16位码元完成操作。//基本多语言平面。<br>normalize()方法：用于判断规范性。<br>concat()：拼接//用加法运算符也可<br>Value = “hello world”;<br>slice()：<br>Value.slice(3)//“lo world”;<br>Value.slice(3,7)//“lo w”;<br>Value.slice(-3)//“rld” 等同于slice(8);(11-3)<br>Value.slice(3,-4)//“lo w” 等同于slice(3,7);(3+4)<br>substr()：<br>Value.substr(3)//“lo world”;<br>Value.substr(3,7)//“lo worl”;<br>Value.substr(-3)//“rld” 等同于substr(8);<br>Value.substr(3,-4)//“”等同于substr(3,0);<br>substring()：<br>Value.substring(3)//“lo world”;<br>Value.substring(3,7)//“lo w”;<br>Value.substring(-3)//“hello world” 等同于substring(0)<br>Value.substring(3,-4)//“hel”等同于substring(0,3)<br>indexOf():<br>Value.indexOf(“o”);// 4<br>Value.indexOf(“t”)// -1<br>Value.indexOf(“o”,6)//7<br>lastIndexOf():<br>Value.lastIndexOf(“o”)//7<br>Value.lastIndexOf(“t”)//-1<br>Value.lastIndexOf(“o”,6)//4<br>message = “foobarbaz”;<br>startWith():<br>message.startWith(“foo”);//true<br>message.startWith(“bar”);//false<br>endWith():<br>message.endWith(“baz”);//true<br>message.endWith(“bar”);//false<br>includes():<br>message.includes(“bar”);//true<br>message.includes(“qux”);//false<br>trim()://不影响原字符串，trimLeft(),trimRight()<br>let string = “   hello  world   “;<br>string.trim()//“hello  world”<br>repeat():<br>string = “abc”;<br>string.repeat(2)//“abcabc”;<br>padStart(),padEnd():<br>string = “foo”<br>string.padStart(6)//“   foo”;len=6<br>string.padStart(9,”.”)//“……foo”;len=9<br>string.padStart(8,”bar”)//“barbafoo”len=8<br>string.padEnd(6)//“foo   “;<br>string.padEnd(9,”.”)//“foo……”;<br>string.padEnd(8,”bar”)//“foobarba”;<br>迭代与解构<br>let message = “abc”;<br>Iterator = message<a href>Symbol.iterator</a>;<br>Iterator.next()//{value:”a”,done:false}<br>Iterator.next()//{value:”b”,done:false}<br>Iterator.next()//{value:”c”,done:false}<br>Iterator.next()//{value:”undefined”,done:true}<br>大小写转换<br>toLowerCase()//小写<br>toLocalLowerCase()//特定地区方法使用<br>toUpperCase()//大写<br>toLocalUpperCase()//特定地区方法使用<br>字符串模式匹配方法<br>match():与exec()方法一致<br>search():<br>let text = “cat, bat, sat, fat”;<br>let pos = text.search(/at/);//1第一个位置为1<br>replace():<br>let res = text.replace(“at”,”ond”);//“cond, bat, sat, fat”<br>let res = text.replace(/at/g,”ond”)//“cond, bond, sond, fond”<br>localeCompare():按字母表顺序比较返回值</p>\n<h2 id=\"5-4-单例内置对象\"><a href=\"#5-4-单例内置对象\" class=\"headerlink\" title=\"5.4 单例内置对象\"></a>5.4 单例内置对象</h2><p>包括Global,Math</p>\n<h3 id=\"5-4-1-Global\"><a href=\"#5-4-1-Global\" class=\"headerlink\" title=\"5.4.1 Global\"></a>5.4.1 Global</h3><p>全局作用域中定义的变量和函数都会成为Global对象的属性。<br>encodeURI(),encodeURIComponent()//编码统一资源标识符。<br>eval():<br>eval(“console.log(‘hi’)”);///console.log(“hi”);<br>eval(“function sayHi(){console.log(‘hi’);}”);///sayHi();<br>容易被XSS攻击。<br>对象属性：<br>undefined//特殊值<br>NaN//特殊值<br>Infinity//特殊值<br>Object//构造函数<br>Array//构造函数<br>Function//构造函数<br>….<br>window对象<br>window为Global对象的代理,全局变量和函数即为window的属性。</p>\n<h3 id=\"5-4-2-Math\"><a href=\"#5-4-2-Math\" class=\"headerlink\" title=\"5.4.2 Math\"></a>5.4.2 Math</h3><p>Math对象属性：<br>E //自然对数的基数e的值<br>LN10 //10为底的自然对数<br>LN2 //2为底的自然对数<br>LOG2E //以2为底e的对数<br>LOG10E //以10为底e的对数<br>PI //π的值<br>SQRT1_2 //1/2的平方根<br>SQRT2 //2的平方根<br>Math方法：<br>min():取最小值//配合数组可以使用扩展操作符<br>max():取最大值//max = Math.max(…array);<br>ceil():向上取<br>Math.ceil(25.9);//26<br>Math.ceil(25.5);//26<br>Math.ceil(25.1);//26<br>round():四舍五入<br>console.log(Math.round(25.9)); // 26<br>console.log(Math.round(25.5)); // 26<br>console.log(Math.round(25.1)); // 25<br>fround():取单精度浮点值<br>console.log(Math.fround(0.4)); // 0.4000000059604645<br>console.log(Math.fround(0.5)); // 0.5<br>console.log(Math.fround(25.9)); // 25.899999618530273<br>floor():向下取<br>console.log(Math.floor(25.9)); // 25<br>console.log(Math.floor(25.5)); // 25<br>console.log(Math.floor(25.1)); // 25<br>random()://返回小数0~1内<br>加密提高不确定性：建议使用window.crypto.getRandomValues()。<br>abs()//绝对值<br>exp()//次幂<br>log()//自然对数<br>….</p>\n<h2 id=\"5-5-小结\"><a href=\"#5-5-小结\" class=\"headerlink\" title=\"5.5 小结\"></a>5.5 小结</h2><p>对象为引用值，内置的引用类型可用于创建特定类型的对象。<br>RegExp是ES支持正则表达式的接口。<br>函数实际上是Function类型的实例，是对象。</p>\n<h1 id=\"6-集合引用类型\"><a href=\"#6-集合引用类型\" class=\"headerlink\" title=\"6 集合引用类型\"></a>6 集合引用类型</h1><h2 id=\"6-1-Object\"><a href=\"#6-1-Object\" class=\"headerlink\" title=\"6.1 Object\"></a>6.1 Object</h2><p>let person = new Object();//构造函数<br>person.name = ‘micheal’;<br>let person = {name:’micheal’};//{}字面量表达式<br>person[“name”]//micheal<br>person.name//micheal</p>\n<h2 id=\"6-2-Array\"><a href=\"#6-2-Array\" class=\"headerlink\" title=\"6.2 Array\"></a>6.2 Array</h2><h3 id=\"6-2-1-创建数组\"><a href=\"#6-2-1-创建数组\" class=\"headerlink\" title=\"6.2.1 创建数组\"></a>6.2.1 创建数组</h3><p>let colors = new Array();//可以传值创建初始length的数组，也可以传数组值<br>let colors = [“red”,”blue”]//字面量表达式<br>from():<br>Array.from(“Matt”)//[“M”,”a”,”t”,”t”]<br>适用于Map,Set,Array,iterator,arguments<br>of()://使用Array.prototype.slice.call(arguments)<br>Array.of(1,2,3,4)//[1,2,3,4]<br>Array.of(undefined)//[undefined]</p>\n<h3 id=\"6-2-2-数组空位\"><a href=\"#6-2-2-数组空位\" class=\"headerlink\" title=\"6.2.2 数组空位\"></a>6.2.2 数组空位</h3><p>使用(,)创建数组空位<br>const options = [,,,,,]<br>options.length = 5<br>options //[,,,,,]<br>空值为undefined<br>options = [1,,,5];<br>options.map(()=&gt;6)//[6,,,6]<br>options.join(‘-‘)//“1—–5”</p>\n<h3 id=\"6-2-3-数组索引\"><a href=\"#6-2-3-数组索引\" class=\"headerlink\" title=\"6.2.3 数组索引\"></a>6.2.3 数组索引</h3><p>colors[0]–&gt;第一个元素<br>给数组设置length会改变数组大小</p>\n<h3 id=\"6-2-4-检测数组\"><a href=\"#6-2-4-检测数组\" class=\"headerlink\" title=\"6.2.4 检测数组\"></a>6.2.4 检测数组</h3><p>判断是否数组，使用instanceof<br>也可使用isArray()方法</p>\n<h3 id=\"6-2-5-迭代器方法\"><a href=\"#6-2-5-迭代器方法\" class=\"headerlink\" title=\"6.2.5 迭代器方法\"></a>6.2.5 迭代器方法</h3><p>const a = [“a”,”b”,”c”,”d”];<br>keys()://返回数组索引的迭代器<br>const akeys = Array.from(a.keys()); // [0,1,2,3]<br>values()://返回数组元素的迭代器<br>const aValues = Array.from(a.Values());//[“a”,”b”,”c”,”d”]<br>entries()://返回索引/值对的迭代器<br>const aEntries = Array.from(a.entries());//[[0,”a”],[1,”b”],[2,”c”],[3,”d”]]<br>for(const [idx,element] of a.entries()){<br>alert(idx);<br>alert(element);<br>}<br>//0<br>//a<br>//1<br>//b<br>//2<br>//c<br>//3<br>//d</p>\n<h3 id=\"6-2-6-复制和填充方法\"><a href=\"#6-2-6-复制和填充方法\" class=\"headerlink\" title=\"6.2.6 复制和填充方法\"></a>6.2.6 复制和填充方法</h3><p>copyWithin()//批量复制<br>fill()://填充<br>const a = [0,0,0,0,0];<br>zeros.fill(5)//[5,5,5,5,5];<br>zeros.fill(6,3)//[0,0,0,6,6]<br>zeros.fill(7,1,3)//[0,7,7,0,0]<br>索引过低，过高，反向都会被忽略<br>部门可用的索引，填充可用部分。<br>ints = [0,1,2,3,4,5,6,7,8,9];<br>ints.copyWithin(5) // [0,1,2,3,4,0,1,2,3,4];<br>ints.copyWithin(0,5)//[5,6,7,8,9,5,6,7,8,9];<br>ints.copyWithin(4,0,3)//[0,1,2,3,0,1,2,7,8,9];<br>ints.copyWithin(2,0,6)//[0,1,0,1,2,3,4,5,8,9];</p>\n<h3 id=\"6-2-7-转换方法\"><a href=\"#6-2-7-转换方法\" class=\"headerlink\" title=\"6.2.7 转换方法\"></a>6.2.7 转换方法</h3><p>数组调用toString(),valueOf()方法相当于每个元素调用一次这个方法。</p>\n<h3 id=\"6-2-8-栈方法\"><a href=\"#6-2-8-栈方法\" class=\"headerlink\" title=\"6.2.8 栈方法\"></a>6.2.8 栈方法</h3><p>push()//从最后推入数据<br>pop()//弹出最后一项并返回</p>\n<h3 id=\"6-2-9-队列方法\"><a href=\"#6-2-9-队列方法\" class=\"headerlink\" title=\"6.2.9 队列方法\"></a>6.2.9 队列方法</h3><p>shift()://删除数组第一项并返回<br>push()://从最后推入数据<br>unshift()://从开头推入</p>\n<h3 id=\"6-2-10-排序方法\"><a href=\"#6-2-10-排序方法\" class=\"headerlink\" title=\"6.2.10 排序方法\"></a>6.2.10 排序方法</h3><p>reverse()://反向排序<br>sort()://将元素转换成字符串比较</p>\n<h3 id=\"6-1-11-操作方法\"><a href=\"#6-1-11-操作方法\" class=\"headerlink\" title=\"6.1.11 操作方法\"></a>6.1.11 操作方法</h3><p>concat():添加//直接使用会打平数组<br>slice():取值<br>splice()://可实现删除(两个参数)，插入(三个参数)，替换(三个参数)</p>\n<h3 id=\"6-2-12-搜索和位置方法\"><a href=\"#6-2-12-搜索和位置方法\" class=\"headerlink\" title=\"6.2.12 搜索和位置方法\"></a>6.2.12 搜索和位置方法</h3><p>indexOf()//查找元素位置，返回<br>lastIndexOf()//查找元素位置，返回<br>includes()//返回布尔值，是否包含元素<br>find()//返回第一个匹配的元素<br>findIndex()//返回索引</p>\n<h3 id=\"6-2-13-迭代方法\"><a href=\"#6-2-13-迭代方法\" class=\"headerlink\" title=\"6.2.13 迭代方法\"></a>6.2.13 迭代方法</h3><p>every():元素都匹配才会返回true<br>filter():返回true的元素组成数组返回<br>forEach():运行函数，无返回值<br>map():调用结果构成数组返回<br>some():如果有一项返回true，则返回true</p>\n<h3 id=\"6-2-14-归并方法\"><a href=\"#6-2-14-归并方法\" class=\"headerlink\" title=\"6.2.14 归并方法\"></a>6.2.14 归并方法</h3><p>reduce():从头遍历,构建一个返回值<br>reduceRight():从尾遍历,构建一个返回值</p>\n<h2 id=\"6-3-定型数组\"><a href=\"#6-3-定型数组\" class=\"headerlink\" title=\"6.3 定型数组\"></a>6.3 定型数组</h2><h3 id=\"6-3-1-历史\"><a href=\"#6-3-1-历史\" class=\"headerlink\" title=\"6.3.1 历史\"></a>6.3.1 历史</h3><p>WebGL用到，3D技术。<br>定型数组</p>\n<h3 id=\"6-3-2-ArrayBuffer\"><a href=\"#6-3-2-ArrayBuffer\" class=\"headerlink\" title=\"6.3.2 ArrayBuffer\"></a>6.3.2 ArrayBuffer</h3><p>构造函数，用于内存中分配特定数量的字节空间。</p>\n<h3 id=\"6-3-3-DataView\"><a href=\"#6-3-3-DataView\" class=\"headerlink\" title=\"6.3.3 DataView\"></a>6.3.3 DataView</h3><h3 id=\"6-3-4-定型数组\"><a href=\"#6-3-4-定型数组\" class=\"headerlink\" title=\"6.3.4 定型数组\"></a>6.3.4 定型数组</h3><h2 id=\"6-4-Map\"><a href=\"#6-4-Map\" class=\"headerlink\" title=\"6.4 Map\"></a>6.4 Map</h2><p>一种实现键值存储机制的集合类型。</p>\n<h3 id=\"6-4-1-基本API\"><a href=\"#6-4-1-基本API\" class=\"headerlink\" title=\"6.4.1 基本API\"></a>6.4.1 基本API</h3><p>const m2 = new Map([[“key1”,”val1”][“key2”,”val2”][“key3”,”val3”]])<br>m1.size = 3<br>可使用has(),get()进行查询，delete(),clear()删除值。</p>\n<h3 id=\"6-4-2-顺序与迭代\"><a href=\"#6-4-2-顺序与迭代\" class=\"headerlink\" title=\"6.4.2 顺序与迭代\"></a>6.4.2 顺序与迭代</h3><p>提供迭代器(Iterator),通过entries()获取<br>可以通过遍历获取。</p>\n<h3 id=\"6-4-3-选择Object还是Map\"><a href=\"#6-4-3-选择Object还是Map\" class=\"headerlink\" title=\"6.4.3 选择Object还是Map\"></a>6.4.3 选择Object还是Map</h3><p>1.内存占用<br>Map占用更小<br>2.插入性能<br>Map插入性能更好<br>3.查找速度<br>Object优于Map<br>4.删除性能<br>Map更快，涉及大量删除 Map最佳。</p>\n<h2 id=\"6-5-WeakMap\"><a href=\"#6-5-WeakMap\" class=\"headerlink\" title=\"6.5 WeakMap\"></a>6.5 WeakMap</h2><p>类似于Map，只能用对象作为键。<br>API与Map相同。<br>键不存在时，值会被垃圾回收。<br>无法迭代。</p>\n<h2 id=\"6-6-Set\"><a href=\"#6-6-Set\" class=\"headerlink\" title=\"6.6 Set\"></a>6.6 Set</h2><h3 id=\"6-6-1-基本API\"><a href=\"#6-6-1-基本API\" class=\"headerlink\" title=\"6.6.1 基本API\"></a>6.6.1 基本API</h3><p>与Map相似，size长度，has()查询，delete()和clear()删除元素。<br>add()添加元素。</p>\n<h3 id=\"6-6-2-顺序与迭代\"><a href=\"#6-6-2-顺序与迭代\" class=\"headerlink\" title=\"6.6.2 顺序与迭代\"></a>6.6.2 顺序与迭代</h3><p>可通过values()与keys()获取迭代器<br>可以使用遍历方法迭代。</p>\n<h2 id=\"6-7-WeakSet\"><a href=\"#6-7-WeakSet\" class=\"headerlink\" title=\"6.7 WeakSet\"></a>6.7 WeakSet</h2><p>与WeakMap类型</p>\n<h2 id=\"6-8-迭代与扩展操作\"><a href=\"#6-8-迭代与扩展操作\" class=\"headerlink\" title=\"6.8 迭代与扩展操作\"></a>6.8 迭代与扩展操作</h2><p>支持for-of循环<br>支持浅拷贝<br>let arr1 = […arr2];</p>\n<h2 id=\"6-9-小结\"><a href=\"#6-9-小结\" class=\"headerlink\" title=\"6.9 小结\"></a>6.9 小结</h2><p>JS的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。<br>Object类型是一个基础类型，所有引用类型都继承了它的基本行为。<br>Array是一组有序的值，并提供了操作和转换值的能力。<br>定型数组包含一套不同的引用类型。<br>Date，日期类型。RegExp，正则表达式的接口。<br>ES6新增Map，WeakMap,Set,WeakSet。</p>\n<h1 id=\"7-迭代器与生成器\"><a href=\"#7-迭代器与生成器\" class=\"headerlink\" title=\"7 迭代器与生成器\"></a>7 迭代器与生成器</h1><p>迭代即“重复”，“再来”。</p>\n<h2 id=\"7-1-理解迭代\"><a href=\"#7-1-理解迭代\" class=\"headerlink\" title=\"7.1 理解迭代\"></a>7.1 理解迭代</h2><p>JS中，计数循环就是一种最简单的迭代：for（）<br>可以指定顺序，次数，在一个有序集合上进行。<br>需知道如何使用数据结构，遍历顺序不是数据结构固有的。</p>\n<h2 id=\"7-2-迭代器模式\"><a href=\"#7-2-迭代器模式\" class=\"headerlink\" title=\"7.2 迭代器模式\"></a>7.2 迭代器模式</h2><p>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。<br>迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。</p>\n<h3 id=\"7-2-1-可迭代协议\"><a href=\"#7-2-1-可迭代协议\" class=\"headerlink\" title=\"7.2.1 可迭代协议\"></a>7.2.1 可迭代协议</h3><p>实现了Iterable接口的内置类型：<br>1.字符串<br>2.数组<br>3.映射<br>4.集合<br>5.arguments对象<br>6.NodeList等DOM集合类型<br>接受可迭代对象的语言特性包括：<br>let arr = [“foo”,”bar”,”baz”];<br>1.for-of //for(let el of arr){el};<br>2.数组解构 //let [a,b,c] = arr;<br>3.扩展操作符 // let arr2 = […arr];<br>4.Array.from() //let arr3 = Array.from(arr);<br>5.创建集合 //let set = new Set(arr);<br>6.创建映射 //let pairs = arr.map((x,i)=&gt;[x,i]);<br>7.promise.all()<br>8.promise.race()<br>9.yield*操作符</p>\n<h3 id=\"7-2-2-迭代器协议\"><a href=\"#7-2-2-迭代器协议\" class=\"headerlink\" title=\"7.2.2 迭代器协议\"></a>7.2.2 迭代器协议</h3><p>let arr = [“a”,”b”];<br>console.log(arr[Symbol.iterator]); //f values(){[native code]};<br>let iter = arr<a href>Symbol.iterator</a>;<br>console.log(iter);// ArrayIterator()<br>iter.next();//{done:false,value:”a”};</p>\n<h3 id=\"7-2-3-自定义迭代器\"><a href=\"#7-2-3-自定义迭代器\" class=\"headerlink\" title=\"7.2.3 自定义迭代器\"></a>7.2.3 自定义迭代器</h3><p>自定义迭代方法</p>\n<h3 id=\"7-2-4-提前终止迭代器\"><a href=\"#7-2-4-提前终止迭代器\" class=\"headerlink\" title=\"7.2.4 提前终止迭代器\"></a>7.2.4 提前终止迭代器</h3><p>return {done:true};<br>或break</p>\n<h2 id=\"7-3-生成器\"><a href=\"#7-3-生成器\" class=\"headerlink\" title=\"7.3 生成器\"></a>7.3 生成器</h2><h3 id=\"7-3-1-生成器基础\"><a href=\"#7-3-1-生成器基础\" class=\"headerlink\" title=\"7.3.1 生成器基础\"></a>7.3.1 生成器基础</h3><h3 id=\"7-3-2-通过yield中断执行\"><a href=\"#7-3-2-通过yield中断执行\" class=\"headerlink\" title=\"7.3.2 通过yield中断执行\"></a>7.3.2 通过yield中断执行</h3><h3 id=\"7-3-3-生成器作为默认迭代器\"><a href=\"#7-3-3-生成器作为默认迭代器\" class=\"headerlink\" title=\"7.3.3 生成器作为默认迭代器\"></a>7.3.3 生成器作为默认迭代器</h3><h3 id=\"7-3-4-提前终止生成器\"><a href=\"#7-3-4-提前终止生成器\" class=\"headerlink\" title=\"7.3.4 提前终止生成器\"></a>7.3.4 提前终止生成器</h3><h2 id=\"7-4-小结\"><a href=\"#7-4-小结\" class=\"headerlink\" title=\"7.4 小结\"></a>7.4 小结</h2><p>由任意对象实现的接口，支持连续获取对象产出的每一个值。使用symbol.iterator获取，并且通过一些方法调用，例next(),for-of。</p>\n<h1 id=\"8-对象、类与面向对象编程\"><a href=\"#8-对象、类与面向对象编程\" class=\"headerlink\" title=\"8 对象、类与面向对象编程\"></a>8 对象、类与面向对象编程</h1><p>无特定顺序的值。每个属性或方法都用名称标识。</p>\n<h2 id=\"8-1-理解对象\"><a href=\"#8-1-理解对象\" class=\"headerlink\" title=\"8.1 理解对象\"></a>8.1 理解对象</h2><h3 id=\"8-1-1-属性的类型\"><a href=\"#8-1-1-属性的类型\" class=\"headerlink\" title=\"8.1.1 属性的类型\"></a>8.1.1 属性的类型</h3><p>数据属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Writable]]:表示属性的值是否可以被修改。<br>[[Value]]:表示属性的值。<br>访问器属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Get]]:获取函数，读取属性调用。<br>[[Set]]:设置函数，写入属性时调用。</p>\n<h3 id=\"8-1-2-定义多个属性\"><a href=\"#8-1-2-定义多个属性\" class=\"headerlink\" title=\"8.1.2 定义多个属性\"></a>8.1.2 定义多个属性</h3><p>let book = {};<br>Object.defineProperties(book,{year:{value:2017},edition:{value:1},year:{get(){return this.year;}}});</p>\n<h3 id=\"8-1-3-读取属性的特性\"><a href=\"#8-1-3-读取属性的特性\" class=\"headerlink\" title=\"8.1.3 读取属性的特性\"></a>8.1.3 读取属性的特性</h3><p>Object.getOwnPropertyDescriptor(object,’name’);<br>descriptor = Object.getOwnPropertyDescriptor(book,”year”);<br>Object.getOwnPropertyDescriptors(object);//获取所有</p>\n<h3 id=\"8-1-4-合并对象\"><a href=\"#8-1-4-合并对象\" class=\"headerlink\" title=\"8.1.4 合并对象\"></a>8.1.4 合并对象</h3><p>Object.assgin();//浅拷贝,会覆盖重复的属性<br>result = Object.assign(object1,object2);<br>object === result<br>result = Object.assign(object1,object2,object3);</p>\n<h3 id=\"8-1-5-对象标识及相等判定\"><a href=\"#8-1-5-对象标识及相等判定\" class=\"headerlink\" title=\"8.1.5 对象标识及相等判定\"></a>8.1.5 对象标识及相等判定</h3><p>Object.is()//需要两个参数<br>Object.is(+0,-0)//false</p>\n<h3 id=\"8-1-6-增强的对象语法\"><a href=\"#8-1-6-增强的对象语法\" class=\"headerlink\" title=\"8.1.6 增强的对象语法\"></a>8.1.6 增强的对象语法</h3><p>let person = {name:name};  === let person = {name};//不建议<br>namekey = “name”;let person = {[namekey]:’Matt’};//[]内可以使用表达式，属性可计算<br>let person = {<a href=\"name\">nameKey</a>{console.log(‘name’)}};//方法名兼容计算属性</p>\n<h3 id=\"8-1-7-对象解构\"><a href=\"#8-1-7-对象解构\" class=\"headerlink\" title=\"8.1.7 对象解构\"></a>8.1.7 对象解构</h3><p>let person = {name:’matt’,age:27}//不解构<br>let personName = person.name,personAge = person.age;//解构<br>let {name:personName,age:personAge} = person;<br>null和undefined不支持解构</p>\n<p>let person = {job:{title:’Software engineer’}};//嵌套解构<br>let personCopy={};<br>let({job:personCopy.job}=person);</p>\n<p>前面的解构出错，后面的解构会失败。</p>\n<p>let person = {name:’matt’,age:27}; function printPerson(foo,{name,age},bar)//参数解构，调用时传入对象</p>\n<h2 id=\"8-2-创建对象\"><a href=\"#8-2-创建对象\" class=\"headerlink\" title=\"8.2 创建对象\"></a>8.2 创建对象</h2><h3 id=\"8-2-1-概述\"><a href=\"#8-2-1-概述\" class=\"headerlink\" title=\"8.2.1 概述\"></a>8.2.1 概述</h3><p>与类不同，对象的巧妙运行可以实现与类相同的行为。</p>\n<h3 id=\"8-2-2-工厂模式\"><a href=\"#8-2-2-工厂模式\" class=\"headerlink\" title=\"8.2.2 工厂模式\"></a>8.2.2 工厂模式</h3><p>设计模式之一<br>function createPerson(name,age,job){<br>   let o = new Object();<br>   o.name = name;<br>   o.age = age;<br>   o.job = job;<br>   o.sayName = function(){<br>       console.log(this.name);<br>   };<br>   return o;<br>}<br>解决创建多个类似对象的问题，但无解决对象标识问题（对象类型）。</p>\n<h3 id=\"8-2-3-构造函数模式\"><a href=\"#8-2-3-构造函数模式\" class=\"headerlink\" title=\"8.2.3 构造函数模式\"></a>8.2.3 构造函数模式</h3><p>function Person(name,age,job){<br>   this.name = name;<br>   this.age = age;<br>   this.job = job;<br>   this.sayName = function(){<br>      console.log(this.name);<br>   }<br>}<br>与工厂模式类似,无return，无显式创建对象。<br>构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可。<br>let person = function(){};<br>let person1 = new person(…);<br>let person2 = new person(…);<br>person1 instanceof Object//true<br>person1 instanceof person//true<br>person2一样<br>构造函数也可以直接调用<br>person(…);window.sayName();//添加到了window<br>let o = new Object();<br>Person.call(o,”wxc”,25);o.sayName()//wxc 在另一个对象的作用域中调用<br>在构造函数内定义的函数实例化后相同名称确不相等，是两个不同的函数。<br>可以在外部定义函数，在内部赋值解决这个问题。</p>\n<h3 id=\"8-2-4-原型模式\"><a href=\"#8-2-4-原型模式\" class=\"headerlink\" title=\"8.2.4 原型模式\"></a>8.2.4 原型模式</h3><p>prototype,这个属性为一个对象。包含由特定引用类型的实例共享的属性和方法。实际上是构造函数创建的原型。<br>在原型上定义的值可以共享。<br>Chrome暴露了<em>proto_属性，可通过这个属性访问对象的原型。prototype属性为对象。<br>原型链会终止与Object的原型链。<br>person.prototype._proto</em>.<em>proto</em> === null//true<br>构造函数、原型对象和实例，三个完全不同的对象。<br>实例通过_proto_链接到原型对象，实际指向[[Prototype]]<br>构造函数通过prototype属性链接到原型对象。<br>同一个构造函数创建的两个实例，共享一个原型对象。<br>isPrototypeOf()//用于判断实例原型对象与构造函数的原型相同否<br>getPrototypeOf()//用于获取[[prototype]]原型对象<br>setPrototypeOf()//用于给[[prototype]]对象写入新值,该方法调用可能会严重导致性能下降。<br>create()//用于创建新对象指定原型<br>访问对象属性时，如果未在对象实例本身找到则会沿着指针进入原型对象，在原型对象上查找。无法通过实例重写这些值，如果创建于原型对象中同名的属性，会在实例上创建这个属性，遮蔽原型对象上的属性，只有delete后才能继续搜索原型对象的该属性。<br>hasOwnProperty()//用于判断属性在实例或原型上<br>可以通过for-in判断通过对象能否访问到一个属性//“name” in person(true)<br>getOwnPropertyNames()//…按顺序进行枚举</p>\n<h3 id=\"8-2-5-对象迭代\"><a href=\"#8-2-5-对象迭代\" class=\"headerlink\" title=\"8.2.5 对象迭代\"></a>8.2.5 对象迭代</h3><p>Object.values()//以数组的形式输出值<br>Object.entries()//以数组的形式输出键值和值<br>非字符串的属性会被转换为字符串输出，符号属性会被忽略。<br>重写了prototype的函数原型不默认指向constructor<br>ES语法需要使用defineProperty()来恢复constructor属性。<br>实例只有指向原型的指针，没有指向构造函数的指针。</p>\n<h2 id=\"8-3-继承\"><a href=\"#8-3-继承\" class=\"headerlink\" title=\"8.3 继承\"></a>8.3 继承</h2><p>ES中只支持实现继承。</p>\n<h3 id=\"8-3-1-原型链\"><a href=\"#8-3-1-原型链\" class=\"headerlink\" title=\"8.3.1 原型链\"></a>8.3.1 原型链</h3><p>通过原型继承多个引用类型的属性和方法。原型链为ES主要继承方式。<br>将A函数原型赋值为B函数的实例，A函数的实例可以通过原型访问到B函数实例的属性和方法。实际A函数可以通过原型与B函数的原型挂钩。在搜索属性时，会通过原型链访问到原型的原型，直到末端。<br>所有引用类型都继承自Object，任何函数的默认原型都是一个Object的实例，也是为什么自定义类型能够继承toString(),valueOf()方法的原因。调用toString()时，实际在调用Object.prototype上的方法。<br>通过instanceof返回原型与构造函数的原型关系。<br>通过isPrototypeOf返回原型链中是否含有这个原型。<br>添加属性或覆盖属性时需要在原型赋值后添加到原型上。<br>通过prototype字面量直接修改原型，会破坏之前的原型链。<br>原型链的问题：<br>1.使用原型实现继承后，函数原型对象的所有属性都会被函数实例共享。<br>2.子类型在实例化时不能给父类型的构造函数传参。</p>\n<h3 id=\"8-3-2-盗用构造函数\"><a href=\"#8-3-2-盗用构造函数\" class=\"headerlink\" title=\"8.3.2 盗用构造函数\"></a>8.3.2 盗用构造函数</h3><p>通过call，apply来调用执行函数的构造函数，从而得到构造函数的属性和方法。<br>可以通过apply,call来向父类构造函数传值。<br>缺点：必须在构造函数中定义方法，函数无法重用。且子类无法访问父类原型的方法。（原型不是父类的实例对象）</p>\n<h3 id=\"8-3-3-组合继承\"><a href=\"#8-3-3-组合继承\" class=\"headerlink\" title=\"8.3.3 组合继承\"></a>8.3.3 组合继承</h3><p>综合原型链和盗用构造函数，集中了优点。<br>利用call实现传值改变继承的值，并且属性不共用。</p>\n<h3 id=\"8-3-4-原型式继承\"><a href=\"#8-3-4-原型式继承\" class=\"headerlink\" title=\"8.3.4 原型式继承\"></a>8.3.4 原型式继承</h3><p>实例一个对象作原型，使用Object.create()。</p>\n<h3 id=\"8-3-5-寄生式继承\"><a href=\"#8-3-5-寄生式继承\" class=\"headerlink\" title=\"8.3.5 寄生式继承\"></a>8.3.5 寄生式继承</h3><p>创建一个对象，给对象添加属性和值，返回这个对象。</p>\n<h3 id=\"8-3-6-寄生式组合继承\"><a href=\"#8-3-6-寄生式组合继承\" class=\"headerlink\" title=\"8.3.6 寄生式组合继承\"></a>8.3.6 寄生式组合继承</h3><p>会调用两次构造函数。</p>\n<h2 id=\"8-4-类\"><a href=\"#8-4-类\" class=\"headerlink\" title=\"8.4 类\"></a>8.4 类</h2><h3 id=\"8-4-1-类定义\"><a href=\"#8-4-1-类定义\" class=\"headerlink\" title=\"8.4.1 类定义\"></a>8.4.1 类定义</h3><p>class Person{} // 类声明<br>class Animal = class {} // 类表达式<br>类定义无法声明提升，类受块作用域限制。<br>class Foo{<br>constructor(){} //构造函数<br>get myBaz(){} //有获取函数<br>static myQue(){} // 有静态方法<br>}<br>外部无法访问类名(标识符)</p>\n<h3 id=\"8-4-2-类构造函数\"><a href=\"#8-4-2-类构造函数\" class=\"headerlink\" title=\"8.4.2 类构造函数\"></a>8.4.2 类构造函数</h3><p>P250</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-1-历史回顾\"><a href=\"#1-1-历史回顾\" class=\"headerlink\" title=\"1.1 历史回顾\"></a>1.1 历史回顾</h1><p>网站数据量大，复杂。需要JS来解决，优化。</p>\n<h1 id=\"1-2-JS实现\"><a href=\"#1-2-JS实现\" class=\"headerlink\" title=\"1.2 JS实现\"></a>1.2 JS实现</h1><p>JS = ECMAScript（核心） + DOM（文档对象模型） + BOM（浏览器对象模型）</p>\n<h2 id=\"1-2-1（ECMAScript）\"><a href=\"#1-2-1（ECMAScript）\" class=\"headerlink\" title=\"1.2.1（ECMAScript）\"></a>1.2.1（ECMAScript）</h2><p>ES：网页提供ES的基准实现和与环境自身交互必须的扩展。<br>ES包括：语法、类型、语句、关键字、保留字、操作符、全局对象。<br>大部分浏览器兼容ES6。</p>\n<h2 id=\"1-2-2-DOM\"><a href=\"#1-2-2-DOM\" class=\"headerlink\" title=\"1.2.2 DOM\"></a>1.2.2 DOM</h2><p>文档对象模型：是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。F12中常见的文档树。<br><img src=\"/2020/11/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%96%87%E6%A1%A3%E6%A0%91.png\" alt=\"文档树\"><br>DOM通过创建表示文档的树，让开发者可以更好地控制网页的内容和结构。使用DOM的API，可以轻松删除，添加，替换，修改节点。<br>DOM视图：描述追踪文档不同视图的接口。<br>DOM事件：描述事件及事件处理的接口。<br>DOM样式：描述处理元素CSS样式的接口。<br>DOM遍历的范围：描述遍历和操作DOM数的接口。<br>其他DOM：可伸缩矢量图（SVG），数学标记语言（MathML），同步多媒体集成语言（SMIL）<br>DOM有不同level（版本）:目前到了level3</p>\n<h2 id=\"1-2-3-BOM\"><a href=\"#1-2-3-BOM\" class=\"headerlink\" title=\"1.2.3 BOM\"></a>1.2.3 BOM</h2><p>浏览器对象模型：用于支持访问和操作浏览器的窗口。使用BOM，可以操控浏览器显示页面之外的部分，BOM针对浏览器窗口和子窗口。拓展：<br>弹出新浏览器窗口的能力；<br>移动、缩放和关闭浏览器窗口的能力；<br>navigator对象，提供关于浏览器的详尽信息；<br>location对象，提供浏览器加载页面的详尽信息；<br>screen对象，提供关于用户屏幕分辨率的详尽信息；<br>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；<br>对cookie的支持；<br>其他自定义对象，XMLHttp，ActiveXObject；</p>\n<h1 id=\"1-3-JavaScript版本\"><a href=\"#1-3-JavaScript版本\" class=\"headerlink\" title=\"1.3 JavaScript版本\"></a>1.3 JavaScript版本</h1><h1 id=\"1-4-小结\"><a href=\"#1-4-小结\" class=\"headerlink\" title=\"1.4 小结\"></a>1.4 小结</h1><p>JS是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br>ES：有ECMA-262定义并提供核心功能。<br>文档对象模型（DOM）:提供与网页内容交互的方法和接口。<br>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。<br>JS这三个部门得到了五大Web浏览器不同程度的支持。所有浏览器基本上对ES5提供了完善的支持，ES6最佳。</p>\n<hr>\n<h1 id=\"2-1-script元素\"><a href=\"#2-1-script元素\" class=\"headerlink\" title=\"2.1 script元素\"></a>2.1 script元素</h1><p>将Js插入HTML的主要方法是使用script元素。有下列8个属性：<br>1.async：可选，表示立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。<br>2.charset：可选，使用src属性指定的代码字符集。很少用。<br>3.crossorigin：可选，配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。<br>defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。<br>integrity：可选，允许比对接收到的资源和指定的加密签名以验证子资源完整性。<br>language：废弃。<br>src：可选，表示包含要执行的代码的外部文件。（引入外部JS文件）<br>type：可选，代替language，表示代码块中脚本语言的内容类型（MIME类型）。按照惯例这个值始终都是“text/JavaScript”，MIME类型通常都是“application/x-javascript”，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。</p>\n<h2 id=\"2-1-1-标签位置\"><a href=\"#2-1-1-标签位置\" class=\"headerlink\" title=\"2.1.1 标签位置\"></a>2.1.1 标签位置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>\n<p>上述是把文件放在head里，不过这种写法以为着必须把所有JS代码都下载、解析和解释完成后，才能开始渲染页面，可能会导致页面渲染的明显延迟，所以通常把文件引用放在body元素中的页面内容后面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&#39;example2.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-2-推迟执行脚本\"><a href=\"#2-1-2-推迟执行脚本\" class=\"headerlink\" title=\"2.1.2 推迟执行脚本\"></a>2.1.2 推迟执行脚本</h2><p>可用defer属性，可用推迟脚本执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script defer src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-3-异步执行脚本\"><a href=\"#2-1-3-异步执行脚本\" class=\"headerlink\" title=\"2.1.3 异步执行脚本\"></a>2.1.3 异步执行脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src&#x3D;&#39;example1.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-4-动态加载脚本\"><a href=\"#2-1-4-动态加载脚本\" class=\"headerlink\" title=\"2.1.4 动态加载脚本\"></a>2.1.4 动态加载脚本</h2><p>JS可用使用DOM API ，通过向DOM中动态添加Script元素同样可用加载指定的脚本，只要创建一个Script元素并将其添加到DOM即可。如下：<br>let script = document.createElement(‘script’);<br>script.src = ‘gibbersh.js’<br>document.head.appendChild(script);<br>这个请求是异步的，不是所有浏览器都支持async属性，因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。<br>添加：script.async = false;<br>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。这种可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;gibberish.js&quot;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-5-XMHTL中的变化\"><a href=\"#2-1-5-XMHTL中的变化\" class=\"headerlink\" title=\"2.1.5 XMHTL中的变化\"></a>2.1.5 XMHTL中的变化</h2><p>XHTML：可扩展超文本标记语言，是将HTML作为XML的应用重新包装的结果。在XHTML中使用JS必须制定type属性且值为text/javascript。<br>XHTML比较少见。</p>\n<h2 id=\"2-1-6-废弃的语法\"><a href=\"#2-1-6-废弃的语法\" class=\"headerlink\" title=\"2.1.6 废弃的语法\"></a>2.1.6 废弃的语法</h2><p>个别废弃的语法，可不看。</p>\n<h1 id=\"2-2-行内代码与外部文件\"><a href=\"#2-2-行内代码与外部文件\" class=\"headerlink\" title=\"2.2 行内代码与外部文件\"></a>2.2 行内代码与外部文件</h1><p>最佳实践是尽可能将JS代码放在外部文件中。推荐原因如下：<br>可维护性：JS代码分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。<br>缓存：浏览器会根据特定的设置缓存所有外部链接的JS文件，这意味着若干两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。<br>适应未来：通过把JS放到外部文件中，就不比考虑用XHTML的或注释黑科技。包含外部JS文件的语法在HTML和XHTML是一样的。<br>在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JS组件形式向客户端送达脚本更具优势。<br>在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从同一个地方取得一批文件，并将他们逐个放到浏览器缓存中。从浏览器角度看，通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JS文件的 延迟差不多。<br>在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。</p>\n<h1 id=\"2-3-文档模式\"><a href=\"#2-3-文档模式\" class=\"headerlink\" title=\"2.3 文档模式\"></a>2.3 文档模式</h1><p>最初有两种模式：混杂模式，标准模式。<br>第三种模式：准标准模式。</p>\n<h1 id=\"2-4-noscript元素\"><a href=\"#2-4-noscript元素\" class=\"headerlink\" title=\"2.4 noscript元素\"></a>2.4 noscript元素</h1><p>针对不支持JS的浏览器而出的元素。以下两种情况，浏览器将显示包含在noscript中的内容：<br>浏览器不支持脚本；<br>浏览器对脚本的支持被关闭；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;noscript&gt; </span><br><span class=\"line\">&lt;p&gt;This page requires a JavaScript-enabled browser.&lt;&#x2F;p&gt; </span><br><span class=\"line\">&lt;&#x2F;noscript&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-5-小结\"><a href=\"#2-5-小结\" class=\"headerlink\" title=\"2.5 小结\"></a>2.5 小结</h1><p>JS通过script元素插入到HTML页面中。这个元素可以用于把JS代码嵌入到HTML页面汇总，跟其他标记混合在一起，也可以用与引入保存在外部文件中的JS。本章的重点如下：<br>1.要包含外部JS文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。<br>2.所有script元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在script元素中的代码必须严格按次序解释。<br>3.对不推迟执行的脚本，浏览器必须解释完位于script元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常把script元素放到页面末尾，介于主内容之后及body标签之前。<br>4.可以使用defer推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。<br>5.可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。<br>6.通过使用noscript元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则noscript元素中的任何内容都不会被渲染。</p>\n<h1 id=\"3-1-语法\"><a href=\"#3-1-语法\" class=\"headerlink\" title=\"3.1 语法\"></a>3.1 语法</h1><h2 id=\"3-1-1-区别大小写\"><a href=\"#3-1-1-区别大小写\" class=\"headerlink\" title=\"3.1.1 区别大小写\"></a>3.1.1 区别大小写</h2><p>ECMA中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。<br>typeof不能作为函数名，因为它是一个关键字。但Typeof可以用。</p>\n<h2 id=\"3-1-2-标识符\"><a href=\"#3-1-2-标识符\" class=\"headerlink\" title=\"3.1.2 标识符\"></a>3.1.2 标识符</h2><p>变量、函数、属性或函数参数的名称。可以由一个或多个下列字符组成：<br>第一个字符必须是一个字母、下划线（_）或美元符号（$）;<br>剩下的其他字符可以是字母、下划线、美元符号或数字。<br>一般使用驼峰大小写形式。</p>\n<h2 id=\"3-1-3-注释\"><a href=\"#3-1-3-注释\" class=\"headerlink\" title=\"3.1.3 注释\"></a>3.1.3 注释</h2><h2 id=\"3-1-4-严格模式\"><a href=\"#3-1-4-严格模式\" class=\"headerlink\" title=\"3.1.4 严格模式\"></a>3.1.4 严格模式</h2><p>“use strict” //脚本开头加上这一行<br>也可以在指定函数内加上开头。所有现代浏览器都支持严格模式。</p>\n<h2 id=\"3-1-5-语句\"><a href=\"#3-1-5-语句\" class=\"headerlink\" title=\"3.1.5 语句\"></a>3.1.5 语句</h2><p>结尾建议加分号，建议语句块加{}</p>\n<h2 id=\"3-2-关键字与保留字\"><a href=\"#3-2-关键字与保留字\" class=\"headerlink\" title=\"3.2 关键字与保留字\"></a>3.2 关键字与保留字</h2><p>ES6的关键字有：<br>break     do     in     typeof<br>case     else     instanceof     var<br>catch     export     new     void<br>class     extends     return     while<br>const     finally     super     with<br>continue   for     switch     yield<br>debugger function    this<br>default     if     throw<br>delete     import     try<br>ES6将来保留词汇：<br>始终保留：<br>enum<br>严格模式下保留：<br>implements     package     public<br>interface     protected     static<br>let     private<br>模块代码中保留：<br>await<br>这些词汇不能作标识符，但可以坐对象的属性名，推荐不用作属性名。</p>\n<h1 id=\"3-3-变量\"><a href=\"#3-3-变量\" class=\"headerlink\" title=\"3.3 变量\"></a>3.3 变量</h1><p>ECMA变量是松散类型的，变量可以用于保存任何类型的数据。每个变量不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var,const,let<br>var:声明完后可以赋值，但未标识类型。//声明提升<br>//var message = “hi”;<br>//message = 100; // 合法，但不推荐。<br>//作用域在声明的环境下的函数作用域，例在函数内定义，调用完函数随即被销毁。<br>//在函数内定义时省略var操作符，可以创建一个全局变量。不推荐这么做。<br>let:块作用域，同一个块内不能重复声明。变量在作用域中无声明提升。<br>//有暂时性死区。<br>//无法全局声明，声明的变量不会成为window对象的属性。<br>//ES6不能依赖条件声明模式<br>const:与let基本相同，区别是声明变量时必须同时初始化变量，且无法修改const声明的变量。</p>\n<h2 id=\"3-3-4-声明风格及最佳实践\"><a href=\"#3-3-4-声明风格及最佳实践\" class=\"headerlink\" title=\"3.3.4 声明风格及最佳实践\"></a>3.3.4 声明风格及最佳实践</h2><p>1.不使用var<br>2.const优先，let次之</p>\n<h1 id=\"3-4-数据类型\"><a href=\"#3-4-数据类型\" class=\"headerlink\" title=\"3.4 数据类型\"></a>3.4 数据类型</h1><p>ES6有6种简单的数据类型（原始类型）：undefined,null,boolean,number,String,Symbol。Symbol是ES6新增的。还有一种复杂的数据类型叫Object（对象）。Object是一种无序名值对的集合。</p>\n<h2 id=\"3-4-1-typeof操作符\"><a href=\"#3-4-1-typeof操作符\" class=\"headerlink\" title=\"3.4.1 typeof操作符\"></a>3.4.1 typeof操作符</h2><p>不需要参数（但可以使用参数），严格来说，函数也是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。可以用typeof区分。</p>\n<h2 id=\"3-4-2-Undefined类型\"><a href=\"#3-4-2-Undefined类型\" class=\"headerlink\" title=\"3.4.2 Undefined类型\"></a>3.4.2 Undefined类型</h2><p>变量未初始化即是Undefined，相当于给变量赋值了Undefined。<br>建议在声明时初始化，出现undefined可以更好辨别。</p>\n<h2 id=\"3-4-4-Null类型\"><a href=\"#3-4-4-Null类型\" class=\"headerlink\" title=\"3.4.4 Null类型\"></a>3.4.4 Null类型</h2><p>Null类型同样只有一个值，即特殊值null。null值表示一个空对象指针，typeof null返回Object。<br>在定义将来要保存对象值的变量时，建议初始化为null。</p>\n<h2 id=\"3-4-4-Boolean类型\"><a href=\"#3-4-4-Boolean类型\" class=\"headerlink\" title=\"3.4.4 Boolean类型\"></a>3.4.4 Boolean类型</h2><p>有两个字面值：true，false。<br>True和False是有效的标识符，不是布尔值。//区分大小写<br>使用Boolean()来转换类型</p>\n<h2 id=\"3-4-5-Number类型\"><a href=\"#3-4-5-Number类型\" class=\"headerlink\" title=\"3.4.5 Number类型\"></a>3.4.5 Number类型</h2><p>1.浮点值<br>//小数点后面必须带数字，不然当整数处理。<br>2.值的范围<br>//Number.MIN_VALUE:5e-324<br>Number.MAX_VALUE:1.7976931348623157e+308<br>超出以上范围会表示为Infinity或-Infinity,该值无法用于计算。<br>可使用isFinite()函数进行判断<br>3.NaN<br>NaN表示”不是数值”,用于表示本来要返回数值的操作失败了（不是抛出错误）。<br>例：0除任意数值<br>console.log(0/0) // NaN<br>console.log(5/0) //Infinity<br>console.log(5/-0)//-Infinity<br>任何涉及NaN的操作始终返回NaN，NaN不等于任何值。//(NaN == NaN)–&gt;false<br>可用isNaN()函数判断是否不是数值<br>isNaN(NaN)//true<br>isNaN(10)//false<br>isNaN(“10”)//false,可转换为数值10<br>isNaN(“blue”)//true,无法转换为数值<br>isNaN(true)//false,可以转换为1<br>4.数值转换<br>有3个函数可以将非数值转换为数值：<br>Number(),parseInt(),parseFloat()<br>Number()是转型函数，可用于任何数据类型。后两个主要用于将字符串转为数值。<br>Number()有如下规则：<br>(true)-&gt;1,(false)-&gt;0,(null)-&gt;0,(undefined)-&gt;NaN,数值直接返回<br>如果字符串包含数值字符，包括数值字符前面带加号、减号的情况，则转换为一个十进制数值。<br>如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值（同样，忽略前面的0）。<br>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。<br>如果是空字符串（不包含字符），则返回0。<br>如果字符串包含上述情况之外的其他字符，则返回NaN。<br>通常使用parseInt（）</p>\n<h2 id=\"3-4-6-String类型\"><a href=\"#3-4-6-String类型\" class=\"headerlink\" title=\"3.4.6 String类型\"></a>3.4.6 String类型</h2><p>字符串使用：双引号，单引号，反引号都合法，引号类型前后必须一致。<br>1.字面量：<br>\\n  换行<br>\\t   制表<br>\\b  退格<br>\\r   回车<br>\\f   换页等<br>2.特点<br>不可变，一旦创建，值不能变。要修改某个变量的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。<br>3.转换为字符串<br>toString()//函数<br>还可以传入参数输出不同进制<br>let num = 10;<br>num.toString() // “10”<br>num.toString(2) // “1010”<br>num.toString(8) // “12”<br>4.模板字面量<br>可以使用换行字符，可以跨行定义字符串。<br>使用反引号会保持引号内部的空格，字面量，length会增加。<br>5.字符串插值<br>可以在定义中插入一个或多个值。<br>通过反引号中使用 ${}插入，插入的值都会通过toString转换为字符串<br>插值表达式中可以调用函数和方法：<br>foo = {toString:() =&gt; ‘Wrold’};<code>hello,${foo}</code> // hello world<br>capitalize(word) =&gt;return <code>${word[0].toUpperCase()}</code>   // <code>${capitalize(&#39;hello&#39;)}</code>//-&gt;Hello<br>6.模板字面量标签函数<br>支持定义标签函数，通过标签函数可以自定义插值行为。<br>7.原始字符串<br>Unicode字符<br>使用String.raw获取原始字符串<br>‘\\u00A9’ // 版权符号<br>String.raw<code>\\u00A9</code>// \\u00A9</p>\n<h2 id=\"3-4-7-Symbol类型\"><a href=\"#3-4-7-Symbol类型\" class=\"headerlink\" title=\"3.4.7 Symbol类型\"></a>3.4.7 Symbol类型</h2><p>Symbol是ES6新增的，且实例是唯一，不可变的。用于创建唯一记号，进而用作非字符串形式的对象属性。<br>1.基本用法<br>let sym = Symbol(); type of sym//symbol<br>也可以传入字符串参数作为对symbol的描述，可通过这个字符串来调试代码。但这个字符串参数与符号定义或标识无关。<br>符号无法与new关键字一起作为构造函数使用。<br>可以使用符号包装对象，借用Object函数()函数：<br>let mySymbol = Symbol();<br>let myWrappedSymbol = Object (mySymbol);<br>console.log(typeof myWrappedSymbol); // “object”<br>2.使用全局符号注册表<br>如果运行时的不同部分需要共享和 重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br>需要使用Symbol.for()方法。</p>\n<h2 id=\"3-4-8-Object类型\"><a href=\"#3-4-8-Object类型\" class=\"headerlink\" title=\"3.4.8 Object类型\"></a>3.4.8 Object类型</h2><p>对象其实就是一组数据和功能的集合。可以通过new来创建实例对象。<br>每个对象都有如下属性和方法：<br>constructor：用于创建当前对象的函数，构造函数。<br>hasOwnProperty(propertyName)：用于判断当前对象实例上是否存在给定的属性。<br>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。<br>propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用。<br>toLacaleString():返回对象的字符串表示,反映对象所在本地化执行环境。<br>toString():返回对象的字符串表示。<br>valueOf():返回对象对应的字符串、数值或布尔值表示。</p>\n<h1 id=\"3-5-操作符\"><a href=\"#3-5-操作符\" class=\"headerlink\" title=\"3.5 操作符\"></a>3.5 操作符</h1><h2 id=\"3-5-1-一元操作符\"><a href=\"#3-5-1-一元操作符\" class=\"headerlink\" title=\"3.5.1 一元操作符\"></a>3.5.1 一元操作符</h2><p>只操作一个值的操作符叫一元操作符。<br>++,–;  //操作中会自行转换类型,(递增和递减)<br>+,-//一元加减符，可以用于运算和转换</p>\n<h2 id=\"3-5-2-位操作符\"><a href=\"#3-5-2-位操作符\" class=\"headerlink\" title=\"3.5.2 位操作符\"></a>3.5.2 位操作符</h2><p>…</p>\n<h2 id=\"3-5-3-布尔操作符\"><a href=\"#3-5-3-布尔操作符\" class=\"headerlink\" title=\"3.5.3 布尔操作符\"></a>3.5.3 布尔操作符</h2><p>逻辑非，逻辑与逻辑或<br>1.逻辑非 ：！（感叹号）<br>!false // true<br>!”blue” //false<br>!0 //true<br>!NaN //true<br>!”” //true<br>!12345 //false<br>也可以用两个感叹号:!!,相当于调用了转型函数Boolean()。第一个返回布尔值，第二个对该布尔值取反。<br>相当于如上例子，布尔值取反。<br>2.逻辑与<br>由&amp;&amp;表示 // true &amp;&amp; true为true  其余都为false<br>3.逻辑或<br>由||表示 //有一个是true为true，false || false为false</p>\n<h2 id=\"3-5-4-乘性操作符\"><a href=\"#3-5-4-乘性操作符\" class=\"headerlink\" title=\"3.5.4 乘性操作符\"></a>3.5.4 乘性操作符</h2><p>乘法(<em>)，除法(/)，取模(%)。<br>乘法(</em>):都为数值则计算，有一项为NaN则返回NaN，如果是Infinity<em>0=NaN,Infinity</em>(-/+)num=(-)Infinity，Infinity*Infinity=Infinity,如果不是数值会转换后再近些操作。<br>除法(/):<br>0 / 0 = NaN,Infinity / Infinity = NaN,-(number)/0 = (-)Infinity,Infinity / (-)Number = (-)Infinity<br>取模(%):类似除</p>\n<h2 id=\"3-5-5-指数操作符\"><a href=\"#3-5-5-指数操作符\" class=\"headerlink\" title=\"3.5.5 指数操作符\"></a>3.5.5 指数操作符</h2><p>ES7新增的操作符 (*<em>)//Math.pow(3,2) == 3 *</em> 2 == 9<br>squared ** = 2 //9</p>\n<h2 id=\"3-5-6-加性操作符\"><a href=\"#3-5-6-加性操作符\" class=\"headerlink\" title=\"3.5.6 加性操作符\"></a>3.5.6 加性操作符</h2><p>（+），（-）</p>\n<h2 id=\"3-5-7-关系操作符\"><a href=\"#3-5-7-关系操作符\" class=\"headerlink\" title=\"3.5.7 关系操作符\"></a>3.5.7 关系操作符</h2><p>（&lt;）,（&gt;）,（&lt;=），（&gt;=）</p>\n<h2 id=\"3-5-8-相等操作符\"><a href=\"#3-5-8-相等操作符\" class=\"headerlink\" title=\"3.5.8 相等操作符\"></a>3.5.8 相等操作符</h2><p>（==），（!=），（===）,（!==）</p>\n<h2 id=\"3-5-9-条件操作符\"><a href=\"#3-5-9-条件操作符\" class=\"headerlink\" title=\"3.5.9 条件操作符\"></a>3.5.9 条件操作符</h2><p>（?）// let max = （num1 &gt; num2）? num1 : num2</p>\n<h2 id=\"3-5-10-赋值操作符\"><a href=\"#3-5-10-赋值操作符\" class=\"headerlink\" title=\"3.5.10 赋值操作符\"></a>3.5.10 赋值操作符</h2><p>（=），（*=），（/=），（%=），（+=）,（-=）,（&lt;&lt;=）,（&gt;&gt;=）,（&gt;&gt;&gt;=）</p>\n<h1 id=\"3-6-语句\"><a href=\"#3-6-语句\" class=\"headerlink\" title=\"3.6 语句\"></a>3.6 语句</h1><h2 id=\"3-6-1-if语句\"><a href=\"#3-6-1-if语句\" class=\"headerlink\" title=\"3.6.1 if语句\"></a>3.6.1 if语句</h2><p>…</p>\n<h2 id=\"3-6-2-do-while语句\"><a href=\"#3-6-2-do-while语句\" class=\"headerlink\" title=\"3.6.2 do-while语句\"></a>3.6.2 do-while语句</h2><p>do {***} while(expression);</p>\n<h2 id=\"3-6-3-while语句\"><a href=\"#3-6-3-while语句\" class=\"headerlink\" title=\"3.6.3 while语句\"></a>3.6.3 while语句</h2><p>let i = 0;<br>while(i &lt; 10) { i += 2};</p>\n<h2 id=\"3-6-4-for语句\"><a href=\"#3-6-4-for语句\" class=\"headerlink\" title=\"3.6.4 for语句\"></a>3.6.4 for语句</h2><p>for(initialization;expression;post-loop-expression) statement</p>\n<h2 id=\"3-6-5-for-in语句\"><a href=\"#3-6-5-for-in语句\" class=\"headerlink\" title=\"3.6.5 for-in语句\"></a>3.6.5 for-in语句</h2><p>for(property in expression) statement<br>for(const propName in window) {document.write(propName)}//例子</p>\n<h2 id=\"3-6-6-for-of语句\"><a href=\"#3-6-6-for-of语句\" class=\"headerlink\" title=\"3.6.6 for-of语句\"></a>3.6.6 for-of语句</h2><p>for(property of expression) statement<br>for(const el of [2,4,6,8]){document.write(el)}//例子</p>\n<h2 id=\"3-6-7-标签语句\"><a href=\"#3-6-7-标签语句\" class=\"headerlink\" title=\"3.6.7 标签语句\"></a>3.6.7 标签语句</h2><p>label:statement<br>start: for(let i = 0;i &lt; count;i++){console.log(i)}//start是一个标签，可在后面通过break，continue语句引用。</p>\n<h2 id=\"3-6-8-break和continue语句\"><a href=\"#3-6-8-break和continue语句\" class=\"headerlink\" title=\"3.6.8 break和continue语句\"></a>3.6.8 break和continue语句</h2><p>break用于立即退出循环,强行执行循环后的下一条语句。<br>continue语句用于立即退出循环，但会从循环顶部开始执行。</p>\n<h2 id=\"3-6-9-with语句\"><a href=\"#3-6-9-with语句\" class=\"headerlink\" title=\"3.6.9 with语句\"></a>3.6.9 with语句</h2><p>with(expression) statement;<br>let qs = location.search.substring(1);<br>let hostName = location.hostname;<br>let url = location.href;<br>with(location){<br>let qs = search.substring(1);<br>let hostName = hostname;<br>let url = href;<br>}<br>严格模式不允许使用</p>\n<h2 id=\"3-6-10-switch语句\"><a href=\"#3-6-10-switch语句\" class=\"headerlink\" title=\"3.6.10 switch语句\"></a>3.6.10 switch语句</h2><p>switch(expression){<br>  case value1:<br>    statament<br>    break;<br>  case value2:<br>    statement<br>    break;<br>  …<br>  default:<br>    statement<br>}<br>//switch不会强制转换数据类型</p>\n<h2 id=\"3-7-函数\"><a href=\"#3-7-函数\" class=\"headerlink\" title=\"3.7 函数\"></a>3.7 函数</h2><p>function Name(arg0,arg1){ statements}<br>遇到return语句函数就会立即停止执行并退出。<br>函数不能以eval，arguments作为名称；<br>函数的参数不能叫eval，arguments；<br>两个命名参数不能拥有同一个名称。</p>\n<h2 id=\"3-8-小结\"><a href=\"#3-8-小结\" class=\"headerlink\" title=\"3.8 小结\"></a>3.8 小结</h2><p>ES中基本数据类型包括：undefined,Null,Boolean,Number,String,Symbol<br>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。//声明方式<br>不指定返回值的函数实际上会返回特殊值undefined。</p>\n<h1 id=\"4-变量、作用域与内存\"><a href=\"#4-变量、作用域与内存\" class=\"headerlink\" title=\"4 变量、作用域与内存\"></a>4 变量、作用域与内存</h1><h2 id=\"4-1-原始值与引用值\"><a href=\"#4-1-原始值与引用值\" class=\"headerlink\" title=\"4.1 原始值与引用值\"></a>4.1 原始值与引用值</h2><p>变量有两种不同的类型：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。<br>原始值的变量是按值访问的，引用值是保存在内存中的对象，操作对象时，操作的是对该对象的引用而非实际的对象本身。</p>\n<h3 id=\"4-1-1-动态属性\"><a href=\"#4-1-1-动态属性\" class=\"headerlink\" title=\"4.1.1 动态属性\"></a>4.1.1 动态属性</h3><p>引用值可以随时添加、修改和删除其属性和方法。<br>只有引用值可以动态添加后面可以使用的属性。<br>原始类型的初始化可以只使用原始字面量形式。如果使用new则创建Object类型的实例。<br>let name1 = “wxc”;//typeof name1 == string<br>let name2 = new String(“Matt”);//typeof name2 == object</p>\n<h3 id=\"4-1-2-复制值\"><a href=\"#4-1-2-复制值\" class=\"headerlink\" title=\"4.1.2 复制值\"></a>4.1.2 复制值</h3><p>原始值的变量复制会创建新变量。//let name1 = “wxc”;let name2 = name1;<br>引用值的变量复制的是一个指针，两个变量指向同一个对象，一改则都改。</p>\n<h3 id=\"4-1-3-传递参数\"><a href=\"#4-1-3-传递参数\" class=\"headerlink\" title=\"4.1.3 传递参数\"></a>4.1.3 传递参数</h3><p>函数的参数都是按值传递的，传递时，值会被复制到一个局部变量。<br>按引用传递参数时，值在内存中的位置会被保存在一个局部变量，对本地变量的修改会反映到函数外部。ES中函数的参数就是局部变量。</p>\n<h3 id=\"4-1-4确定类型\"><a href=\"#4-1-4确定类型\" class=\"headerlink\" title=\"4.1.4确定类型\"></a>4.1.4确定类型</h3><p>typeof对于原始值有用，但对引用值不大。<br>引用值判断可以用instanceof<br>person instanceof Object<br>colors instanceof Array<br>pattern instanceof RegExp<br>instanceof对于原始值始终返回false，原始值不是对象。</p>\n<h2 id=\"4-2-执行上下文与作用域\"><a href=\"#4-2-执行上下文与作用域\" class=\"headerlink\" title=\"4.2 执行上下文与作用域\"></a>4.2 执行上下文与作用域</h2><p>每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。<br>浏览器中，全局上下文为window对象。var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。<br>每个函数也有自己的上下文，执行函数时，函数上下文被推倒一个上下文栈上，执行完后弹出。ES的执行流通过该上下文栈进行控制。<br>上下文中的代码在执行时，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链的下一个变量对象来自上级包含上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象。<br>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>\n<h3 id=\"4-2-1-作用域链增强\"><a href=\"#4-2-1-作用域链增强\" class=\"headerlink\" title=\"4.2.1 作用域链增强\"></a>4.2.1 作用域链增强</h3><p>代码执行到try/catch语句的catch块与with语句时，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>\n<h3 id=\"4-2-2-变量声明\"><a href=\"#4-2-2-变量声明\" class=\"headerlink\" title=\"4.2.2 变量声明\"></a>4.2.2 变量声明</h3><p>1.使用var声明变量，变量会被自动添加到最接近的上下文，最接近的上下文大多是函数的局部上下文，如果未声明就被初始化了，就被添加到全局上下文。如果在函数内声明变量添加到全局上下文，函数退出后依然可以访问。<br>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。变量提升。<br>2.使用let声明的块级作用域声明<br>块级作用域由最近的{}界定。<br>3.使用const的常量声明<br>const声明的同时必须初始化为某个值。声明后不能重新赋新值。<br>作用域与let声明一样。<br>建议多使用const，除非需要一个会重新赋值的变量。可以防止重新赋值的BUG。<br>4.标识符查找<br>特定上下文读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。//其实就是调用变量</p>\n<h2 id=\"4-3-垃圾回收\"><a href=\"#4-3-垃圾回收\" class=\"headerlink\" title=\"4.3 垃圾回收\"></a>4.3 垃圾回收</h2><p>JS使用垃圾回收，程序每隔一段就会自动运行。确定不会再使用的变量，释放内存。</p>\n<h3 id=\"4-3-1-标记清理\"><a href=\"#4-3-1-标记清理\" class=\"headerlink\" title=\"4.3.1 标记清理\"></a>4.3.1 标记清理</h3><p>常用策略是标记清理。程序运行时，标记内存中存储的所有变量，将所有上下文中的变量，以及被在上下文中的变量引用的标记去掉。再加上标记代表待删除，随后做一次内存清理，销毁带标记的所有值并回收内存。<br>IE，Firefox，Opera，Chrome，Safari都在JS实习标记清理，频率有所差异。</p>\n<h3 id=\"4-3-2-引用计数\"><a href=\"#4-3-2-引用计数\" class=\"headerlink\" title=\"4.3.2 引用计数\"></a>4.3.2 引用计数</h3><p>对每个值记录引用次数。声明变量并赋一个引用值时，这个值的引用数为1。 如果保存对该值引用的变量被其他值给覆盖了，引用数-1。引用数为0时回收内存。</p>\n<h3 id=\"4-3-3-性能\"><a href=\"#4-3-3-性能\" class=\"headerlink\" title=\"4.3.3 性能\"></a>4.3.3 性能</h3><p>垃圾回收的时间调度很重要，变量太多会造成性能损失。JS引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果回收的内存不到已分配的15%，这些阈值会翻倍。如果一次回收的内存达到已分配的85%，则阈值重置为默认值。</p>\n<h3 id=\"4-3-4-内存管理\"><a href=\"#4-3-4-内存管理\" class=\"headerlink\" title=\"4.3.4 内存管理\"></a>4.3.4 内存管理</h3><p>保证在执行代码时只保存必要的数据。不在必要则设置为null，从而释放其引用。这也可以叫作解除引用。局部变量在超出作用域会自动解除引用，所以该建议更适合全局变量和全局对象。<br>1.通过const和let声明提升性能<br>块作用域，能更早让垃圾回收程序介入。<br>2.隐藏类和删除操作<br>对象与隐藏类会被关联起来，用于跟踪他们的属性特征。共享相同隐藏类的对象性能会更好。<br>function Article(){this.title = ‘go go go’}<br>let a1 = new Article();//隐藏类title<br>let a2 = new Article();//隐藏类title<br>a1.author = ‘Jake’//对应多出author隐藏类，可能对性能产生明显影响。<br>function Article(author){this.title=’go’,this.author=author}<br>let a2 = new Article(‘wxc’)//a2与a1相同，共享一个隐藏类。<br>delete a1.author//使用delete关键字会导致生成同样的隐藏类片段<br>a1.author = null; //保持共享，并达到垃圾回收的效果<br>3.内存泄漏<br>JS的内存泄漏大部分是不合理的引用导致的。<br>function(){name = ‘Jake’}意外声明全局变量是最常见也最容易修复的内存泄漏问题。无关键字声明。<br>定时器也会导致内存泄漏，定时器的回调通过闭包引用了外部变量。<br>使用闭包容易造成内存泄漏，如下：<br>let outer = function() {let name = ‘Jake’;return function() {return name};};<br>调用outer()会导致内存泄漏。只要返回的函数存在就不能清理name，因为闭包一直在引用，加入name的内容很大，就是个大问题。<br>4.静态分配与对象池<br>不要动态创建矢量对象<br>在初始化的时候，创建一个对象池，管理一组可回收的对象。使用完后回归对象池。</p>\n<h2 id=\"4-4-小结\"><a href=\"#4-4-小结\" class=\"headerlink\" title=\"4.4 小结\"></a>4.4 小结</h2><p>原始值大小固定，因此保存在栈内存上。<br>引用值是对象，存储在堆内存上。<br>任何变量都存在于某个作用域（上下文）中，这个作用域决定了变量的声明周期，以及它们可以访问代码的哪些部分。<br>全局上下文：window，浏览器。<br>函数上下文：声明函数的{}内<br>块级上下文：最近的{}内<br>JS有垃圾回收，垃圾回收的方法有：引用计数，标记清理。主流为标记清理。<br>接触变量引用一般直接给变量赋值为null。</p>\n<h1 id=\"5-基本引用类型\"><a href=\"#5-基本引用类型\" class=\"headerlink\" title=\"5.基本引用类型\"></a>5.基本引用类型</h1><p>引用值是某个特定引用类型的实例。<br>对象被认为是某个特定引用类型的实例。新对象通过使用new操作符跟一个构造函数来创建。<br>函数也是一种引用类型。</p>\n<h2 id=\"5-1-Date\"><a href=\"#5-1-Date\" class=\"headerlink\" title=\"5.1 Date\"></a>5.1 Date</h2><p>日期对象//let now = new Date();<br>可用Date.parse()转换成日期对象//let someDate = new Date(Date.parse(“May 23,2019”));如果字符串不表示日期，会返回NaN。<br>let allFives = new Date(Date.UTC(2005,4,5,17,55,55));//GMT时间——Date.UTC方法<br>ES提供了Date.now()方法，返回表示方法执行时日期。<br>let start = Date.now();//当前时间</p>\n<h3 id=\"5-1-1-继承的方法\"><a href=\"#5-1-1-继承的方法\" class=\"headerlink\" title=\"5.1.1 继承的方法\"></a>5.1.1 继承的方法</h3><p>let date = new Date(2021,1,20);<br>toLocaleString()//–&gt;2021/2/20 上午12:00:00<br>toString()//–&gt;Sat Feb 20 2021 00:00:00 GMT+0800<br>valueOf()//–&gt;1613750400000</p>\n<h3 id=\"5-1-2-日期格式化方法\"><a href=\"#5-1-2-日期格式化方法\" class=\"headerlink\" title=\"5.1.2 日期格式化方法\"></a>5.1.2 日期格式化方法</h3><p>Date格式化日期的方法：<br>toDateString()//显示日期中的周几，月，日，年<br>toTimeString()//显示日期中的时分秒和时区<br>toLocaleDateString()//显示日期中的周几 月 日 年<br>toLocaleTimeString()//显示日期中的时 分 秒<br>toUTCString()//显示完整的UTC日期</p>\n<h3 id=\"5-1-3-日期-时间组件方法\"><a href=\"#5-1-3-日期-时间组件方法\" class=\"headerlink\" title=\"5.1.3 日期/时间组件方法\"></a>5.1.3 日期/时间组件方法</h3><p>主要应用：<br>getTime()//返回日期的毫秒表示，与valueOf相同<br>setTime(milliseconds)//设置日期的毫秒表示，从而修改整个日期<br>getFullYear()//返回四位年数<br>getMonth()//返回日期的月<br>getDate()//返回日期的日<br>getDay()//返回日期中表示周几的数值<br>getHours()//返回日期中的时<br>getMinutes()//返回日期中的分<br>getSeconds()//返回日期中的秒</p>\n<h2 id=\"5-2-RegExp\"><a href=\"#5-2-RegExp\" class=\"headerlink\" title=\"5.2 RegExp\"></a>5.2 RegExp</h2><p>ES通过RegExp类型支持正则表达式。<br>let expression = /pattern/flags;<br>匹配模式的标记：<br>1.g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。<br>2.i:不区分大小写，表示查找匹配时忽略pattern和字符串的大小写。<br>3.m:多行模式，表示查找到一行文本末尾时会继续查找。<br>4.y:粘附模式，表示只查找从lastIndex开始及之后的字符串。<br>5.u:Unicode模式，启用Unicode匹配。<br>6.s：dotAll模式，表示元字符匹配任何字符。(包括\\n或\\r)。<br>使用不同模式和标记可以创建出各种正则表达式，比如：<br>//匹配字符串中的所有”at”<br>let pattern1 = /at/g;<br>//匹配第一个”bat”或”cat” 忽略大小写<br>let pattern2 = /[bc]at/i<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi<br>元字符在模式中必须转义：<br>( ，[， {，\\，^，$，|，)，]，}，？，*，+，- //这些符号前面需要\\来转义<br>//匹配第一个”bat”或”cat”，忽略大小写<br>let pattern1 = /[bc]at/i;<br>//匹配第一个”[bc]at”，忽略大小写<br>let pattern2 = /[bc]at/i;<br>//匹配所有以”at”结尾的三字符组合，忽略大小写<br>let pattern3 = /.at/gi;<br>//匹配所有”.at”，忽略大小写<br>let pattern4 = /.at/gi;<br>也可使用RegExp构造函数来创建：<br>let pattern1 = /[bc]at/i   ==   new RegExp(“[bc]at”,”i”);<br>也可以使用实例，选择性修改标记<br>const re1 = /cat/g;<br>const re2 = new RegExp(re1);<br>const re3 = new RegExp(re1,”i”);</p>\n<h3 id=\"5-2-1-RegExp实例属性\"><a href=\"#5-2-1-RegExp实例属性\" class=\"headerlink\" title=\"5.2.1 RegExp实例属性\"></a>5.2.1 RegExp实例属性</h3><p>global:布尔值，表示是否设置了g标记。<br>ignoreCase:布尔值，表示是否设置了i标记。<br>unicode:布尔值，表示是否设置了u标记。<br>sticky:布尔值，表示是否设置了y标记。<br>lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。<br>multiline:布尔值，表示是否设置了m标记。<br>dotAll:布尔值，表示是否设置了s标记。<br>source:正则表达式的字面量字符串，没有开头和结尾的斜杠。<br>flags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回。</p>\n<h3 id=\"5-2-2-RegExp实例方法\"><a href=\"#5-2-2-RegExp实例方法\" class=\"headerlink\" title=\"5.2.2 RegExp实例方法\"></a>5.2.2 RegExp实例方法</h3><p>exec()函数：<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);<br>  console.log(matchs);//cat<br>//设置了全局标记(g)，每次调用返回一个匹配的信息，如果没有设置全局标记，只会返回第一个匹配的信息。<br>//设置了g标记，每次调用exec()都会在字符中向前搜索下一个匹配项<br>let text = ‘cat, bat, sat, fat’;<br>  let pattern = /.at/gi;<br>  let matchs = pattern.exec(text);//cat<br>  let matchs = pattern.exec(text);//bat<br>  let matchs = pattern.exec(text);//sat<br>  console.log(matchs);<br>//设置了y标记，每次调用会在lastIndex的位置上寻找匹配项。y标记覆盖g标记。<br>test()函数：//用于判断是否存在实际内容中，常在if判断语句中<br>let text = “000-00-00 00”;<br>let pattern = /\\d{3}-\\d{2}-\\d(4)/;<br>if(pattern.test(text)) {console.log(“The pattern was matched.”)};<br>继承的方法toLocaleString()和toString()都返回字面量表示。<br>let pattern = new RegExp(“\\[bc\\]at”,”gt”);<br>console.log(pattern.toString());//  /[bc]at/gi<br>console.log(pattern.toLocaleString());//  /[bc]at/gi</p>\n<h3 id=\"5-2-3-RegExp构造函数属性\"><a href=\"#5-2-3-RegExp构造函数属性\" class=\"headerlink\" title=\"5.2.3 RegExp构造函数属性\"></a>5.2.3 RegExp构造函数属性</h3><p>input：$_   //最后搜索的字符串<br>lastMatch：$&amp;   //最后匹配的文本<br>lastParen：$+   //最后匹配的捕获组<br>leftContext：$`   //input字符串中出现在lastMatch前面的文本<br>rightContext：$’   //input字符串中出现在lastMatch后面的文本<br>let text = “this has been a short summer”;<br>let pattern = /(.)hort/g; //()–&gt;捕获组<br>if(pattern.test(text)) {<br>   console.log(RegExp.input); //this has been a short summer<br>   console.log(RegExp.leftContext); //this has been a<br>   console.log(RegExp.rightContext); //summer<br>   console.log(RegExp.lastMatch); //short<br>   console.log(RegExp.input); //s<br>}</p>\n<p>if(pattern.test(text)) {<br>   console.log(RegExp.$_); //this has been a short summer<br>   console.log(RegExp[“$`”]); //this has been a<br>   console.log(RegExp[“$’”]); //summer<br>   console.log(RegExp[“$&amp;”]); //short<br>   console.log(RegExp[“$+”]); //s<br>}<br>let pattern = /(..)or(.)/g;</p>\n<p>if(pattern.test(text)) {<br>   console.log(RegExp.$1); // sh<br>   console.log(RegExp.$2);// t<br>}</p>\n<h3 id=\"5-2-4-模式局限\"><a href=\"#5-2-4-模式局限\" class=\"headerlink\" title=\"5.2.4 模式局限\"></a>5.2.4 模式局限</h3><p>ES对正则表达式的支持还缺少一些高级特性。</p>\n<h2 id=\"5-3-原始值包装类型\"><a href=\"#5-3-原始值包装类型\" class=\"headerlink\" title=\"5.3 原始值包装类型\"></a>5.3 原始值包装类型</h2><p>ES提供了3种特殊类型的引用类型：Boolean,Number,String。<br>以读模式访问字符串时，后台执行：<br>（1）创建一个String类型的实例；// let s1 = “some text”<br>（2）调用实例上的特点方法；// let s2 = s1.substring(2);<br>（3）销毁实例；// s1 = null;<br>let value = “25”;<br>let number = Number(value);   //转型函数<br>console.log(typeof number);   //“number”<br>let obj = new Number(value); // 构造函数<br>console.log(typeof obj); //“object”<br>变量obj保存一个Number实例。</p>\n<h3 id=\"5-3-1-Boolean\"><a href=\"#5-3-1-Boolean\" class=\"headerlink\" title=\"5.3.1 Boolean\"></a>5.3.1 Boolean</h3><p>let falseObject = new Boolean(false);// typeof == object<br>let result = falseObject &amp;&amp; true;<br>console.log(result); //true<br>let falseValue = false;//typeof == boolean 强烈建议永远不要使用<br>result = falseValue &amp;&amp; true;<br>console.log(result); //false</p>\n<h3 id=\"5-3-2-Number\"><a href=\"#5-3-2-Number\" class=\"headerlink\" title=\"5.3.2 Number\"></a>5.3.2 Number</h3><p>方法：toFix()//let num = 10;num.toFixed(2);// “10.00”<br>方法：toExponential()//let num = 10;num.toExponential(1);//“1.0e+1”<br>方法：toPrecision()//let num = 99;<br>num.toPrecision(1)//“1e+2”<br>num.toPrecision(2)//“99”<br>num.toPrecision(3)//“99.0”<br>方法：isInterger()//辨别一个数值是否保存为整数。<br>Number.isInterger(1);// true<br>Number.isInterger(1.00)//true<br>Number.isInterger(1.01)//false<br>方法：isSafeInterger()判断数值范围</p>\n<h3 id=\"5-3-3-String\"><a href=\"#5-3-3-String\" class=\"headerlink\" title=\"5.3.3 String\"></a>5.3.3 String</h3><p>每个字符用16位表示，基于16位码元完成操作。//基本多语言平面。<br>normalize()方法：用于判断规范性。<br>concat()：拼接//用加法运算符也可<br>Value = “hello world”;<br>slice()：<br>Value.slice(3)//“lo world”;<br>Value.slice(3,7)//“lo w”;<br>Value.slice(-3)//“rld” 等同于slice(8);(11-3)<br>Value.slice(3,-4)//“lo w” 等同于slice(3,7);(3+4)<br>substr()：<br>Value.substr(3)//“lo world”;<br>Value.substr(3,7)//“lo worl”;<br>Value.substr(-3)//“rld” 等同于substr(8);<br>Value.substr(3,-4)//“”等同于substr(3,0);<br>substring()：<br>Value.substring(3)//“lo world”;<br>Value.substring(3,7)//“lo w”;<br>Value.substring(-3)//“hello world” 等同于substring(0)<br>Value.substring(3,-4)//“hel”等同于substring(0,3)<br>indexOf():<br>Value.indexOf(“o”);// 4<br>Value.indexOf(“t”)// -1<br>Value.indexOf(“o”,6)//7<br>lastIndexOf():<br>Value.lastIndexOf(“o”)//7<br>Value.lastIndexOf(“t”)//-1<br>Value.lastIndexOf(“o”,6)//4<br>message = “foobarbaz”;<br>startWith():<br>message.startWith(“foo”);//true<br>message.startWith(“bar”);//false<br>endWith():<br>message.endWith(“baz”);//true<br>message.endWith(“bar”);//false<br>includes():<br>message.includes(“bar”);//true<br>message.includes(“qux”);//false<br>trim()://不影响原字符串，trimLeft(),trimRight()<br>let string = “   hello  world   “;<br>string.trim()//“hello  world”<br>repeat():<br>string = “abc”;<br>string.repeat(2)//“abcabc”;<br>padStart(),padEnd():<br>string = “foo”<br>string.padStart(6)//“   foo”;len=6<br>string.padStart(9,”.”)//“……foo”;len=9<br>string.padStart(8,”bar”)//“barbafoo”len=8<br>string.padEnd(6)//“foo   “;<br>string.padEnd(9,”.”)//“foo……”;<br>string.padEnd(8,”bar”)//“foobarba”;<br>迭代与解构<br>let message = “abc”;<br>Iterator = message<a href>Symbol.iterator</a>;<br>Iterator.next()//{value:”a”,done:false}<br>Iterator.next()//{value:”b”,done:false}<br>Iterator.next()//{value:”c”,done:false}<br>Iterator.next()//{value:”undefined”,done:true}<br>大小写转换<br>toLowerCase()//小写<br>toLocalLowerCase()//特定地区方法使用<br>toUpperCase()//大写<br>toLocalUpperCase()//特定地区方法使用<br>字符串模式匹配方法<br>match():与exec()方法一致<br>search():<br>let text = “cat, bat, sat, fat”;<br>let pos = text.search(/at/);//1第一个位置为1<br>replace():<br>let res = text.replace(“at”,”ond”);//“cond, bat, sat, fat”<br>let res = text.replace(/at/g,”ond”)//“cond, bond, sond, fond”<br>localeCompare():按字母表顺序比较返回值</p>\n<h2 id=\"5-4-单例内置对象\"><a href=\"#5-4-单例内置对象\" class=\"headerlink\" title=\"5.4 单例内置对象\"></a>5.4 单例内置对象</h2><p>包括Global,Math</p>\n<h3 id=\"5-4-1-Global\"><a href=\"#5-4-1-Global\" class=\"headerlink\" title=\"5.4.1 Global\"></a>5.4.1 Global</h3><p>全局作用域中定义的变量和函数都会成为Global对象的属性。<br>encodeURI(),encodeURIComponent()//编码统一资源标识符。<br>eval():<br>eval(“console.log(‘hi’)”);///console.log(“hi”);<br>eval(“function sayHi(){console.log(‘hi’);}”);///sayHi();<br>容易被XSS攻击。<br>对象属性：<br>undefined//特殊值<br>NaN//特殊值<br>Infinity//特殊值<br>Object//构造函数<br>Array//构造函数<br>Function//构造函数<br>….<br>window对象<br>window为Global对象的代理,全局变量和函数即为window的属性。</p>\n<h3 id=\"5-4-2-Math\"><a href=\"#5-4-2-Math\" class=\"headerlink\" title=\"5.4.2 Math\"></a>5.4.2 Math</h3><p>Math对象属性：<br>E //自然对数的基数e的值<br>LN10 //10为底的自然对数<br>LN2 //2为底的自然对数<br>LOG2E //以2为底e的对数<br>LOG10E //以10为底e的对数<br>PI //π的值<br>SQRT1_2 //1/2的平方根<br>SQRT2 //2的平方根<br>Math方法：<br>min():取最小值//配合数组可以使用扩展操作符<br>max():取最大值//max = Math.max(…array);<br>ceil():向上取<br>Math.ceil(25.9);//26<br>Math.ceil(25.5);//26<br>Math.ceil(25.1);//26<br>round():四舍五入<br>console.log(Math.round(25.9)); // 26<br>console.log(Math.round(25.5)); // 26<br>console.log(Math.round(25.1)); // 25<br>fround():取单精度浮点值<br>console.log(Math.fround(0.4)); // 0.4000000059604645<br>console.log(Math.fround(0.5)); // 0.5<br>console.log(Math.fround(25.9)); // 25.899999618530273<br>floor():向下取<br>console.log(Math.floor(25.9)); // 25<br>console.log(Math.floor(25.5)); // 25<br>console.log(Math.floor(25.1)); // 25<br>random()://返回小数0~1内<br>加密提高不确定性：建议使用window.crypto.getRandomValues()。<br>abs()//绝对值<br>exp()//次幂<br>log()//自然对数<br>….</p>\n<h2 id=\"5-5-小结\"><a href=\"#5-5-小结\" class=\"headerlink\" title=\"5.5 小结\"></a>5.5 小结</h2><p>对象为引用值，内置的引用类型可用于创建特定类型的对象。<br>RegExp是ES支持正则表达式的接口。<br>函数实际上是Function类型的实例，是对象。</p>\n<h1 id=\"6-集合引用类型\"><a href=\"#6-集合引用类型\" class=\"headerlink\" title=\"6 集合引用类型\"></a>6 集合引用类型</h1><h2 id=\"6-1-Object\"><a href=\"#6-1-Object\" class=\"headerlink\" title=\"6.1 Object\"></a>6.1 Object</h2><p>let person = new Object();//构造函数<br>person.name = ‘micheal’;<br>let person = {name:’micheal’};//{}字面量表达式<br>person[“name”]//micheal<br>person.name//micheal</p>\n<h2 id=\"6-2-Array\"><a href=\"#6-2-Array\" class=\"headerlink\" title=\"6.2 Array\"></a>6.2 Array</h2><h3 id=\"6-2-1-创建数组\"><a href=\"#6-2-1-创建数组\" class=\"headerlink\" title=\"6.2.1 创建数组\"></a>6.2.1 创建数组</h3><p>let colors = new Array();//可以传值创建初始length的数组，也可以传数组值<br>let colors = [“red”,”blue”]//字面量表达式<br>from():<br>Array.from(“Matt”)//[“M”,”a”,”t”,”t”]<br>适用于Map,Set,Array,iterator,arguments<br>of()://使用Array.prototype.slice.call(arguments)<br>Array.of(1,2,3,4)//[1,2,3,4]<br>Array.of(undefined)//[undefined]</p>\n<h3 id=\"6-2-2-数组空位\"><a href=\"#6-2-2-数组空位\" class=\"headerlink\" title=\"6.2.2 数组空位\"></a>6.2.2 数组空位</h3><p>使用(,)创建数组空位<br>const options = [,,,,,]<br>options.length = 5<br>options //[,,,,,]<br>空值为undefined<br>options = [1,,,5];<br>options.map(()=&gt;6)//[6,,,6]<br>options.join(‘-‘)//“1—–5”</p>\n<h3 id=\"6-2-3-数组索引\"><a href=\"#6-2-3-数组索引\" class=\"headerlink\" title=\"6.2.3 数组索引\"></a>6.2.3 数组索引</h3><p>colors[0]–&gt;第一个元素<br>给数组设置length会改变数组大小</p>\n<h3 id=\"6-2-4-检测数组\"><a href=\"#6-2-4-检测数组\" class=\"headerlink\" title=\"6.2.4 检测数组\"></a>6.2.4 检测数组</h3><p>判断是否数组，使用instanceof<br>也可使用isArray()方法</p>\n<h3 id=\"6-2-5-迭代器方法\"><a href=\"#6-2-5-迭代器方法\" class=\"headerlink\" title=\"6.2.5 迭代器方法\"></a>6.2.5 迭代器方法</h3><p>const a = [“a”,”b”,”c”,”d”];<br>keys()://返回数组索引的迭代器<br>const akeys = Array.from(a.keys()); // [0,1,2,3]<br>values()://返回数组元素的迭代器<br>const aValues = Array.from(a.Values());//[“a”,”b”,”c”,”d”]<br>entries()://返回索引/值对的迭代器<br>const aEntries = Array.from(a.entries());//[[0,”a”],[1,”b”],[2,”c”],[3,”d”]]<br>for(const [idx,element] of a.entries()){<br>alert(idx);<br>alert(element);<br>}<br>//0<br>//a<br>//1<br>//b<br>//2<br>//c<br>//3<br>//d</p>\n<h3 id=\"6-2-6-复制和填充方法\"><a href=\"#6-2-6-复制和填充方法\" class=\"headerlink\" title=\"6.2.6 复制和填充方法\"></a>6.2.6 复制和填充方法</h3><p>copyWithin()//批量复制<br>fill()://填充<br>const a = [0,0,0,0,0];<br>zeros.fill(5)//[5,5,5,5,5];<br>zeros.fill(6,3)//[0,0,0,6,6]<br>zeros.fill(7,1,3)//[0,7,7,0,0]<br>索引过低，过高，反向都会被忽略<br>部门可用的索引，填充可用部分。<br>ints = [0,1,2,3,4,5,6,7,8,9];<br>ints.copyWithin(5) // [0,1,2,3,4,0,1,2,3,4];<br>ints.copyWithin(0,5)//[5,6,7,8,9,5,6,7,8,9];<br>ints.copyWithin(4,0,3)//[0,1,2,3,0,1,2,7,8,9];<br>ints.copyWithin(2,0,6)//[0,1,0,1,2,3,4,5,8,9];</p>\n<h3 id=\"6-2-7-转换方法\"><a href=\"#6-2-7-转换方法\" class=\"headerlink\" title=\"6.2.7 转换方法\"></a>6.2.7 转换方法</h3><p>数组调用toString(),valueOf()方法相当于每个元素调用一次这个方法。</p>\n<h3 id=\"6-2-8-栈方法\"><a href=\"#6-2-8-栈方法\" class=\"headerlink\" title=\"6.2.8 栈方法\"></a>6.2.8 栈方法</h3><p>push()//从最后推入数据<br>pop()//弹出最后一项并返回</p>\n<h3 id=\"6-2-9-队列方法\"><a href=\"#6-2-9-队列方法\" class=\"headerlink\" title=\"6.2.9 队列方法\"></a>6.2.9 队列方法</h3><p>shift()://删除数组第一项并返回<br>push()://从最后推入数据<br>unshift()://从开头推入</p>\n<h3 id=\"6-2-10-排序方法\"><a href=\"#6-2-10-排序方法\" class=\"headerlink\" title=\"6.2.10 排序方法\"></a>6.2.10 排序方法</h3><p>reverse()://反向排序<br>sort()://将元素转换成字符串比较</p>\n<h3 id=\"6-1-11-操作方法\"><a href=\"#6-1-11-操作方法\" class=\"headerlink\" title=\"6.1.11 操作方法\"></a>6.1.11 操作方法</h3><p>concat():添加//直接使用会打平数组<br>slice():取值<br>splice()://可实现删除(两个参数)，插入(三个参数)，替换(三个参数)</p>\n<h3 id=\"6-2-12-搜索和位置方法\"><a href=\"#6-2-12-搜索和位置方法\" class=\"headerlink\" title=\"6.2.12 搜索和位置方法\"></a>6.2.12 搜索和位置方法</h3><p>indexOf()//查找元素位置，返回<br>lastIndexOf()//查找元素位置，返回<br>includes()//返回布尔值，是否包含元素<br>find()//返回第一个匹配的元素<br>findIndex()//返回索引</p>\n<h3 id=\"6-2-13-迭代方法\"><a href=\"#6-2-13-迭代方法\" class=\"headerlink\" title=\"6.2.13 迭代方法\"></a>6.2.13 迭代方法</h3><p>every():元素都匹配才会返回true<br>filter():返回true的元素组成数组返回<br>forEach():运行函数，无返回值<br>map():调用结果构成数组返回<br>some():如果有一项返回true，则返回true</p>\n<h3 id=\"6-2-14-归并方法\"><a href=\"#6-2-14-归并方法\" class=\"headerlink\" title=\"6.2.14 归并方法\"></a>6.2.14 归并方法</h3><p>reduce():从头遍历,构建一个返回值<br>reduceRight():从尾遍历,构建一个返回值</p>\n<h2 id=\"6-3-定型数组\"><a href=\"#6-3-定型数组\" class=\"headerlink\" title=\"6.3 定型数组\"></a>6.3 定型数组</h2><h3 id=\"6-3-1-历史\"><a href=\"#6-3-1-历史\" class=\"headerlink\" title=\"6.3.1 历史\"></a>6.3.1 历史</h3><p>WebGL用到，3D技术。<br>定型数组</p>\n<h3 id=\"6-3-2-ArrayBuffer\"><a href=\"#6-3-2-ArrayBuffer\" class=\"headerlink\" title=\"6.3.2 ArrayBuffer\"></a>6.3.2 ArrayBuffer</h3><p>构造函数，用于内存中分配特定数量的字节空间。</p>\n<h3 id=\"6-3-3-DataView\"><a href=\"#6-3-3-DataView\" class=\"headerlink\" title=\"6.3.3 DataView\"></a>6.3.3 DataView</h3><h3 id=\"6-3-4-定型数组\"><a href=\"#6-3-4-定型数组\" class=\"headerlink\" title=\"6.3.4 定型数组\"></a>6.3.4 定型数组</h3><h2 id=\"6-4-Map\"><a href=\"#6-4-Map\" class=\"headerlink\" title=\"6.4 Map\"></a>6.4 Map</h2><p>一种实现键值存储机制的集合类型。</p>\n<h3 id=\"6-4-1-基本API\"><a href=\"#6-4-1-基本API\" class=\"headerlink\" title=\"6.4.1 基本API\"></a>6.4.1 基本API</h3><p>const m2 = new Map([[“key1”,”val1”][“key2”,”val2”][“key3”,”val3”]])<br>m1.size = 3<br>可使用has(),get()进行查询，delete(),clear()删除值。</p>\n<h3 id=\"6-4-2-顺序与迭代\"><a href=\"#6-4-2-顺序与迭代\" class=\"headerlink\" title=\"6.4.2 顺序与迭代\"></a>6.4.2 顺序与迭代</h3><p>提供迭代器(Iterator),通过entries()获取<br>可以通过遍历获取。</p>\n<h3 id=\"6-4-3-选择Object还是Map\"><a href=\"#6-4-3-选择Object还是Map\" class=\"headerlink\" title=\"6.4.3 选择Object还是Map\"></a>6.4.3 选择Object还是Map</h3><p>1.内存占用<br>Map占用更小<br>2.插入性能<br>Map插入性能更好<br>3.查找速度<br>Object优于Map<br>4.删除性能<br>Map更快，涉及大量删除 Map最佳。</p>\n<h2 id=\"6-5-WeakMap\"><a href=\"#6-5-WeakMap\" class=\"headerlink\" title=\"6.5 WeakMap\"></a>6.5 WeakMap</h2><p>类似于Map，只能用对象作为键。<br>API与Map相同。<br>键不存在时，值会被垃圾回收。<br>无法迭代。</p>\n<h2 id=\"6-6-Set\"><a href=\"#6-6-Set\" class=\"headerlink\" title=\"6.6 Set\"></a>6.6 Set</h2><h3 id=\"6-6-1-基本API\"><a href=\"#6-6-1-基本API\" class=\"headerlink\" title=\"6.6.1 基本API\"></a>6.6.1 基本API</h3><p>与Map相似，size长度，has()查询，delete()和clear()删除元素。<br>add()添加元素。</p>\n<h3 id=\"6-6-2-顺序与迭代\"><a href=\"#6-6-2-顺序与迭代\" class=\"headerlink\" title=\"6.6.2 顺序与迭代\"></a>6.6.2 顺序与迭代</h3><p>可通过values()与keys()获取迭代器<br>可以使用遍历方法迭代。</p>\n<h2 id=\"6-7-WeakSet\"><a href=\"#6-7-WeakSet\" class=\"headerlink\" title=\"6.7 WeakSet\"></a>6.7 WeakSet</h2><p>与WeakMap类型</p>\n<h2 id=\"6-8-迭代与扩展操作\"><a href=\"#6-8-迭代与扩展操作\" class=\"headerlink\" title=\"6.8 迭代与扩展操作\"></a>6.8 迭代与扩展操作</h2><p>支持for-of循环<br>支持浅拷贝<br>let arr1 = […arr2];</p>\n<h2 id=\"6-9-小结\"><a href=\"#6-9-小结\" class=\"headerlink\" title=\"6.9 小结\"></a>6.9 小结</h2><p>JS的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。<br>Object类型是一个基础类型，所有引用类型都继承了它的基本行为。<br>Array是一组有序的值，并提供了操作和转换值的能力。<br>定型数组包含一套不同的引用类型。<br>Date，日期类型。RegExp，正则表达式的接口。<br>ES6新增Map，WeakMap,Set,WeakSet。</p>\n<h1 id=\"7-迭代器与生成器\"><a href=\"#7-迭代器与生成器\" class=\"headerlink\" title=\"7 迭代器与生成器\"></a>7 迭代器与生成器</h1><p>迭代即“重复”，“再来”。</p>\n<h2 id=\"7-1-理解迭代\"><a href=\"#7-1-理解迭代\" class=\"headerlink\" title=\"7.1 理解迭代\"></a>7.1 理解迭代</h2><p>JS中，计数循环就是一种最简单的迭代：for（）<br>可以指定顺序，次数，在一个有序集合上进行。<br>需知道如何使用数据结构，遍历顺序不是数据结构固有的。</p>\n<h2 id=\"7-2-迭代器模式\"><a href=\"#7-2-迭代器模式\" class=\"headerlink\" title=\"7.2 迭代器模式\"></a>7.2 迭代器模式</h2><p>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。<br>迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。</p>\n<h3 id=\"7-2-1-可迭代协议\"><a href=\"#7-2-1-可迭代协议\" class=\"headerlink\" title=\"7.2.1 可迭代协议\"></a>7.2.1 可迭代协议</h3><p>实现了Iterable接口的内置类型：<br>1.字符串<br>2.数组<br>3.映射<br>4.集合<br>5.arguments对象<br>6.NodeList等DOM集合类型<br>接受可迭代对象的语言特性包括：<br>let arr = [“foo”,”bar”,”baz”];<br>1.for-of //for(let el of arr){el};<br>2.数组解构 //let [a,b,c] = arr;<br>3.扩展操作符 // let arr2 = […arr];<br>4.Array.from() //let arr3 = Array.from(arr);<br>5.创建集合 //let set = new Set(arr);<br>6.创建映射 //let pairs = arr.map((x,i)=&gt;[x,i]);<br>7.promise.all()<br>8.promise.race()<br>9.yield*操作符</p>\n<h3 id=\"7-2-2-迭代器协议\"><a href=\"#7-2-2-迭代器协议\" class=\"headerlink\" title=\"7.2.2 迭代器协议\"></a>7.2.2 迭代器协议</h3><p>let arr = [“a”,”b”];<br>console.log(arr[Symbol.iterator]); //f values(){[native code]};<br>let iter = arr<a href>Symbol.iterator</a>;<br>console.log(iter);// ArrayIterator()<br>iter.next();//{done:false,value:”a”};</p>\n<h3 id=\"7-2-3-自定义迭代器\"><a href=\"#7-2-3-自定义迭代器\" class=\"headerlink\" title=\"7.2.3 自定义迭代器\"></a>7.2.3 自定义迭代器</h3><p>自定义迭代方法</p>\n<h3 id=\"7-2-4-提前终止迭代器\"><a href=\"#7-2-4-提前终止迭代器\" class=\"headerlink\" title=\"7.2.4 提前终止迭代器\"></a>7.2.4 提前终止迭代器</h3><p>return {done:true};<br>或break</p>\n<h2 id=\"7-3-生成器\"><a href=\"#7-3-生成器\" class=\"headerlink\" title=\"7.3 生成器\"></a>7.3 生成器</h2><h3 id=\"7-3-1-生成器基础\"><a href=\"#7-3-1-生成器基础\" class=\"headerlink\" title=\"7.3.1 生成器基础\"></a>7.3.1 生成器基础</h3><h3 id=\"7-3-2-通过yield中断执行\"><a href=\"#7-3-2-通过yield中断执行\" class=\"headerlink\" title=\"7.3.2 通过yield中断执行\"></a>7.3.2 通过yield中断执行</h3><h3 id=\"7-3-3-生成器作为默认迭代器\"><a href=\"#7-3-3-生成器作为默认迭代器\" class=\"headerlink\" title=\"7.3.3 生成器作为默认迭代器\"></a>7.3.3 生成器作为默认迭代器</h3><h3 id=\"7-3-4-提前终止生成器\"><a href=\"#7-3-4-提前终止生成器\" class=\"headerlink\" title=\"7.3.4 提前终止生成器\"></a>7.3.4 提前终止生成器</h3><h2 id=\"7-4-小结\"><a href=\"#7-4-小结\" class=\"headerlink\" title=\"7.4 小结\"></a>7.4 小结</h2><p>由任意对象实现的接口，支持连续获取对象产出的每一个值。使用symbol.iterator获取，并且通过一些方法调用，例next(),for-of。</p>\n<h1 id=\"8-对象、类与面向对象编程\"><a href=\"#8-对象、类与面向对象编程\" class=\"headerlink\" title=\"8 对象、类与面向对象编程\"></a>8 对象、类与面向对象编程</h1><p>无特定顺序的值。每个属性或方法都用名称标识。</p>\n<h2 id=\"8-1-理解对象\"><a href=\"#8-1-理解对象\" class=\"headerlink\" title=\"8.1 理解对象\"></a>8.1 理解对象</h2><h3 id=\"8-1-1-属性的类型\"><a href=\"#8-1-1-属性的类型\" class=\"headerlink\" title=\"8.1.1 属性的类型\"></a>8.1.1 属性的类型</h3><p>数据属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Writable]]:表示属性的值是否可以被修改。<br>[[Value]]:表示属性的值。<br>访问器属性：<br>[[Configurable]]:表示属性是否可以通过delete删除并重定义，是否可修改特性，是否可以把它改为访问器属性。<br>[[Enumerable]]:表示属性是否可以通过for-in循环返回。<br>[[Get]]:获取函数，读取属性调用。<br>[[Set]]:设置函数，写入属性时调用。</p>\n<h3 id=\"8-1-2-定义多个属性\"><a href=\"#8-1-2-定义多个属性\" class=\"headerlink\" title=\"8.1.2 定义多个属性\"></a>8.1.2 定义多个属性</h3><p>let book = {};<br>Object.defineProperties(book,{year:{value:2017},edition:{value:1},year:{get(){return this.year;}}});</p>\n<h3 id=\"8-1-3-读取属性的特性\"><a href=\"#8-1-3-读取属性的特性\" class=\"headerlink\" title=\"8.1.3 读取属性的特性\"></a>8.1.3 读取属性的特性</h3><p>Object.getOwnPropertyDescriptor(object,’name’);<br>descriptor = Object.getOwnPropertyDescriptor(book,”year”);<br>Object.getOwnPropertyDescriptors(object);//获取所有</p>\n<h3 id=\"8-1-4-合并对象\"><a href=\"#8-1-4-合并对象\" class=\"headerlink\" title=\"8.1.4 合并对象\"></a>8.1.4 合并对象</h3><p>Object.assgin();//浅拷贝,会覆盖重复的属性<br>result = Object.assign(object1,object2);<br>object === result<br>result = Object.assign(object1,object2,object3);</p>\n<h3 id=\"8-1-5-对象标识及相等判定\"><a href=\"#8-1-5-对象标识及相等判定\" class=\"headerlink\" title=\"8.1.5 对象标识及相等判定\"></a>8.1.5 对象标识及相等判定</h3><p>Object.is()//需要两个参数<br>Object.is(+0,-0)//false</p>\n<h3 id=\"8-1-6-增强的对象语法\"><a href=\"#8-1-6-增强的对象语法\" class=\"headerlink\" title=\"8.1.6 增强的对象语法\"></a>8.1.6 增强的对象语法</h3><p>let person = {name:name};  === let person = {name};//不建议<br>namekey = “name”;let person = {[namekey]:’Matt’};//[]内可以使用表达式，属性可计算<br>let person = {<a href=\"name\">nameKey</a>{console.log(‘name’)}};//方法名兼容计算属性</p>\n<h3 id=\"8-1-7-对象解构\"><a href=\"#8-1-7-对象解构\" class=\"headerlink\" title=\"8.1.7 对象解构\"></a>8.1.7 对象解构</h3><p>let person = {name:’matt’,age:27}//不解构<br>let personName = person.name,personAge = person.age;//解构<br>let {name:personName,age:personAge} = person;<br>null和undefined不支持解构</p>\n<p>let person = {job:{title:’Software engineer’}};//嵌套解构<br>let personCopy={};<br>let({job:personCopy.job}=person);</p>\n<p>前面的解构出错，后面的解构会失败。</p>\n<p>let person = {name:’matt’,age:27}; function printPerson(foo,{name,age},bar)//参数解构，调用时传入对象</p>\n<h2 id=\"8-2-创建对象\"><a href=\"#8-2-创建对象\" class=\"headerlink\" title=\"8.2 创建对象\"></a>8.2 创建对象</h2><h3 id=\"8-2-1-概述\"><a href=\"#8-2-1-概述\" class=\"headerlink\" title=\"8.2.1 概述\"></a>8.2.1 概述</h3><p>与类不同，对象的巧妙运行可以实现与类相同的行为。</p>\n<h3 id=\"8-2-2-工厂模式\"><a href=\"#8-2-2-工厂模式\" class=\"headerlink\" title=\"8.2.2 工厂模式\"></a>8.2.2 工厂模式</h3><p>设计模式之一<br>function createPerson(name,age,job){<br>   let o = new Object();<br>   o.name = name;<br>   o.age = age;<br>   o.job = job;<br>   o.sayName = function(){<br>       console.log(this.name);<br>   };<br>   return o;<br>}<br>解决创建多个类似对象的问题，但无解决对象标识问题（对象类型）。</p>\n<h3 id=\"8-2-3-构造函数模式\"><a href=\"#8-2-3-构造函数模式\" class=\"headerlink\" title=\"8.2.3 构造函数模式\"></a>8.2.3 构造函数模式</h3><p>function Person(name,age,job){<br>   this.name = name;<br>   this.age = age;<br>   this.job = job;<br>   this.sayName = function(){<br>      console.log(this.name);<br>   }<br>}<br>与工厂模式类似,无return，无显式创建对象。<br>构造函数不一定写成函数声明的形式。赋值给变量的函数表达式也可。<br>let person = function(){};<br>let person1 = new person(…);<br>let person2 = new person(…);<br>person1 instanceof Object//true<br>person1 instanceof person//true<br>person2一样<br>构造函数也可以直接调用<br>person(…);window.sayName();//添加到了window<br>let o = new Object();<br>Person.call(o,”wxc”,25);o.sayName()//wxc 在另一个对象的作用域中调用<br>在构造函数内定义的函数实例化后相同名称确不相等，是两个不同的函数。<br>可以在外部定义函数，在内部赋值解决这个问题。</p>\n<h3 id=\"8-2-4-原型模式\"><a href=\"#8-2-4-原型模式\" class=\"headerlink\" title=\"8.2.4 原型模式\"></a>8.2.4 原型模式</h3><p>prototype,这个属性为一个对象。包含由特定引用类型的实例共享的属性和方法。实际上是构造函数创建的原型。<br>在原型上定义的值可以共享。<br>Chrome暴露了<em>proto_属性，可通过这个属性访问对象的原型。prototype属性为对象。<br>原型链会终止与Object的原型链。<br>person.prototype._proto</em>.<em>proto</em> === null//true<br>构造函数、原型对象和实例，三个完全不同的对象。<br>实例通过_proto_链接到原型对象，实际指向[[Prototype]]<br>构造函数通过prototype属性链接到原型对象。<br>同一个构造函数创建的两个实例，共享一个原型对象。<br>isPrototypeOf()//用于判断实例原型对象与构造函数的原型相同否<br>getPrototypeOf()//用于获取[[prototype]]原型对象<br>setPrototypeOf()//用于给[[prototype]]对象写入新值,该方法调用可能会严重导致性能下降。<br>create()//用于创建新对象指定原型<br>访问对象属性时，如果未在对象实例本身找到则会沿着指针进入原型对象，在原型对象上查找。无法通过实例重写这些值，如果创建于原型对象中同名的属性，会在实例上创建这个属性，遮蔽原型对象上的属性，只有delete后才能继续搜索原型对象的该属性。<br>hasOwnProperty()//用于判断属性在实例或原型上<br>可以通过for-in判断通过对象能否访问到一个属性//“name” in person(true)<br>getOwnPropertyNames()//…按顺序进行枚举</p>\n<h3 id=\"8-2-5-对象迭代\"><a href=\"#8-2-5-对象迭代\" class=\"headerlink\" title=\"8.2.5 对象迭代\"></a>8.2.5 对象迭代</h3><p>Object.values()//以数组的形式输出值<br>Object.entries()//以数组的形式输出键值和值<br>非字符串的属性会被转换为字符串输出，符号属性会被忽略。<br>重写了prototype的函数原型不默认指向constructor<br>ES语法需要使用defineProperty()来恢复constructor属性。<br>实例只有指向原型的指针，没有指向构造函数的指针。</p>\n<h2 id=\"8-3-继承\"><a href=\"#8-3-继承\" class=\"headerlink\" title=\"8.3 继承\"></a>8.3 继承</h2><p>ES中只支持实现继承。</p>\n<h3 id=\"8-3-1-原型链\"><a href=\"#8-3-1-原型链\" class=\"headerlink\" title=\"8.3.1 原型链\"></a>8.3.1 原型链</h3><p>通过原型继承多个引用类型的属性和方法。原型链为ES主要继承方式。<br>将A函数原型赋值为B函数的实例，A函数的实例可以通过原型访问到B函数实例的属性和方法。实际A函数可以通过原型与B函数的原型挂钩。在搜索属性时，会通过原型链访问到原型的原型，直到末端。<br>所有引用类型都继承自Object，任何函数的默认原型都是一个Object的实例，也是为什么自定义类型能够继承toString(),valueOf()方法的原因。调用toString()时，实际在调用Object.prototype上的方法。<br>通过instanceof返回原型与构造函数的原型关系。<br>通过isPrototypeOf返回原型链中是否含有这个原型。<br>添加属性或覆盖属性时需要在原型赋值后添加到原型上。<br>通过prototype字面量直接修改原型，会破坏之前的原型链。<br>原型链的问题：<br>1.使用原型实现继承后，函数原型对象的所有属性都会被函数实例共享。<br>2.子类型在实例化时不能给父类型的构造函数传参。</p>\n<h3 id=\"8-3-2-盗用构造函数\"><a href=\"#8-3-2-盗用构造函数\" class=\"headerlink\" title=\"8.3.2 盗用构造函数\"></a>8.3.2 盗用构造函数</h3><p>通过call，apply来调用执行函数的构造函数，从而得到构造函数的属性和方法。<br>可以通过apply,call来向父类构造函数传值。<br>缺点：必须在构造函数中定义方法，函数无法重用。且子类无法访问父类原型的方法。（原型不是父类的实例对象）</p>\n<h3 id=\"8-3-3-组合继承\"><a href=\"#8-3-3-组合继承\" class=\"headerlink\" title=\"8.3.3 组合继承\"></a>8.3.3 组合继承</h3><p>综合原型链和盗用构造函数，集中了优点。<br>利用call实现传值改变继承的值，并且属性不共用。</p>\n<h3 id=\"8-3-4-原型式继承\"><a href=\"#8-3-4-原型式继承\" class=\"headerlink\" title=\"8.3.4 原型式继承\"></a>8.3.4 原型式继承</h3><p>实例一个对象作原型，使用Object.create()。</p>\n<h3 id=\"8-3-5-寄生式继承\"><a href=\"#8-3-5-寄生式继承\" class=\"headerlink\" title=\"8.3.5 寄生式继承\"></a>8.3.5 寄生式继承</h3><p>创建一个对象，给对象添加属性和值，返回这个对象。</p>\n<h3 id=\"8-3-6-寄生式组合继承\"><a href=\"#8-3-6-寄生式组合继承\" class=\"headerlink\" title=\"8.3.6 寄生式组合继承\"></a>8.3.6 寄生式组合继承</h3><p>会调用两次构造函数。</p>\n<h2 id=\"8-4-类\"><a href=\"#8-4-类\" class=\"headerlink\" title=\"8.4 类\"></a>8.4 类</h2><h3 id=\"8-4-1-类定义\"><a href=\"#8-4-1-类定义\" class=\"headerlink\" title=\"8.4.1 类定义\"></a>8.4.1 类定义</h3><p>class Person{} // 类声明<br>class Animal = class {} // 类表达式<br>类定义无法声明提升，类受块作用域限制。<br>class Foo{<br>constructor(){} //构造函数<br>get myBaz(){} //有获取函数<br>static myQue(){} // 有静态方法<br>}<br>外部无法访问类名(标识符)</p>\n<h3 id=\"8-4-2-类构造函数\"><a href=\"#8-4-2-类构造函数\" class=\"headerlink\" title=\"8.4.2 类构造函数\"></a>8.4.2 类构造函数</h3><p>P250</p>\n"},{"title":"MyWorkingDiary","date":"2020-07-08T05:44:49.000Z","_content":"\n### 2020/7->2020年7月开始记录\n\n2020/7/7\n工作：暂无工作任务。\n难点：JS基础还需巩固扎实，需要实际提交。\n学习：开一个新的github项目，适用github上传个人项目，学习Vue源码。\n\n2020/7/8 \n工作：设计APP原型，主要适用于数据输入，5,5寸手持机。\n难点：github的使用需要注意，一些代码提交问题。解决了提交未显示contribution问题，需要在.git文件下添加user信息，邮箱符合即可。\n学习：累计产品设计经验（会抄才是关键）。\n\n2020/7/9\n工作：设计APP原型。\n难点：需求分析，功能确定，流程清晰。\n学习：累计项目经验，完善独自完成项目的能力。\n反思：在需求评审会议中，需要专心听。\n\n2020/7/10\n工作：设计APP原型，完善功能。\n难点：分析需求\n学习：同7/9\n反思：同7/9\n\n2020/7/13\n工作：设计APP原型，完善功能。\n难点：分析需求\n学习：同7/9\n反思：同7/9，早睡，保持良好工作精神。\n\n2020/7/14\n工作：设计APP原型，一期收尾。\n难点：分析需求\n学习：同7/9\n反思：同7/9，早睡，保持良好工作精神。\n\n2020/7/15\n工作：完善原型一期\n难点：分析需求\n学习：学习Vue3.0，有机会分析源码\n\n2020/7/16\n工作：原型修改\n难点：分析文档\n学习：阅读能力\n\n2020/7/17\n工作：原型改动，思考，看admin项目系统。\n难点：掌握项目结构\n学习：新知识，开拓新思想\n反思：呵，社会人~\n\n2020/7/20\n工作：上午开会，下午任务计划具体看安排\n难点：暂无\n学习：提升需求理解能力\n反思：暂无\n\n2020/7/21\n工作：完善原型，解析admin\n难点：系统架构\n学习：审美提高\n反思：多参考其他原型，提升普适性\n\n2020/7/22\n工作：完善原型最后一天\n难点：系统架构，产品设计\n学习：审美提高，产品思维提升\n反思：同7/21\n\n2020/7/23\n工作：驳回，继续完善原型\n难点：满足需求，工作经验不足，UI设计\n学习：讨论，结合需求办公，思考功能逻辑\n反思：恶心\n\n2020/7/24\n工作：研究开源项目\n难点：项目原理，路由\n学习：逻辑\n反思：在同事间信息交流注意方式学习\n\n2020/7/27\n工作：待会议功能分配，Vue3.0持续深入\n难点：同上\n学习：同上\n反思：多看书，提高认知\n\n2020/7/28\n工作：研究开源项目，APP素材整理\n难点：项目原理，路由\n学习：逻辑\n反思：开始拓展思维\n\n2020/7/29\n工作：研究开源项目，开发相关代码\n难顶：项目原理，路由\n学习：逻辑，搞懂ES6，WebPack\n反思：看书学习知识\n\n2020/7/30\n工作：研究开源项目\n难点：项目原理，持续研究权限登录和路由，研究页面样式和布局\n学习：逻辑，知识积累\n反思：深入研究，集中\n\n2020/7/31\n工作：研究开源项目，吃透知识点\n难点：知识点细化，掌握\n学习：同上\n反思：同上\n\n2020/8/3\n工作：开了一下午会，白天开发仓储系统相关页面\n难点：Ajax，promise对象\n学习：异步操作，同步方式\n反思：知识点积累\n\n2020/8/4\n工作：完善原型，开发仓储系统\n难点：Ajax异步请求\n学习：Ajax异步请求，await async使用\n反思：知识点积累\n\n2020/8/5\n工作：开发仓储系统（详情页面）\n难点：暂无\n学习：暂无\n反思：组件化复用\n\n2020/8/6\n工作：维护并开发仓储系统\n难点：\n学习：Scss使用\n反思：Fehelper插件的使用\n\n2020/8/7\n工作：研究开源项目\n难点：优化，性能问题\n学习：scss文件引入问题，菜单子项V-for显示，mixins使用\n反思：组件复用化，函数复用，混入函数的使用\n\n2020/8/10\n工作：思考仓储可视化图实现方式\n难点：canvas图示绘制\n学习：canvas\n反思：暂无\n\n2020/8/11\n工作：续昨日\n难点：思考其余解决方案\n学习：检索数据和判断条件\n反思：\n\n2020/8/12\n工作：实现仓储可视化\n难点：图形实现，暂用<ul><li>+css样式实现粗略\n学习：图形绘制\n反思：\n\n2020/8/12\n工作：仓储可视化完善，思考更优解决方案\n难点：图形\n学习：\n反思：\n\n2020/8/13\n工作：修改原型，可视化研究，开源项目开发，布局思路，思考开发架构\n难点：原理\n学习：个别布局方式和样式设置\n反思：学习！自学！\n\n2020/8/14\n工作：开源项目持续研究开发，架构思考，原型完善\n难点：\n学习：\n反思：\n\n2020/8/17\n工作：底层技术（基础）学习，开会后续通知，下午因个人事务，请假3小时\n难点：调试货架，css样式\n学习：\n反思：\n\n2020/8/18\n工作：修改原型，学习基础\n难点：\n学习：\n反思：\n\n2020/8/19\n今日因台风停工\n\n2020/8/20\n工作：同8/14任务，开发出入库操作\n难点：\n学习：熟练代码编写\n反思：\n\n2020/8/21\n工作：开发出入库操作，学习基础\n难点：\n学习：\n反思：\n\n2020/8/24\n工作：学习任务\n难点：\n学习：\n反思：\n\n2020/8/25\n工作：部署nginx服务器\n难点：原理不清楚，alias和root配置原理\n学习：\n反思：\n\n2020/8/26\n工作：学习相关前端知识，自行寻找需求开发\n难点：\n学习：\n反思：\n\n2020/8/27\n工作：学习相关前端知识，打基础\n难点：\n学习：\n反思:\n\n2020/8/28\n工作：去甲方出差\n难点：\n学习：对甲方态度要好\n反思：\n\n2020/8/31\n工作：开会，部署项目\n难点：\n学习：\n反思：\n\n2020/9/1\n工作：开发仓储系统\n难点：\n学习：\n反思：\n\n2020/9/2\n工作：可视化修改，自适应大小\n难点：\n学习：\n反思：\n\n2020/9/3\n工作：扎实基础,部署项目\n难点：\n学习：\n反思：\n\n2020/9/4\n工作：扎实基础\n难点：\n学习：\n反思：\n\n2020/9/7\n工作：仓储系统出入库界面进度\n难点：\n学习：\n反思：\n\n2020/9/8\n工作：学习，扎实基础\n难点：\n学习：\n反思：\n\n2020/9/9\n工作：扎实基础\n难点：\n学习：\n反思：\n\n2020/9/10\n工作：开发入库展示\n难点：\n学习：\n反思：\n\n2020/9/11\n工作：仓储系统完善，责任分工明细\n难点：\n学习：\n反思：\n\n2020/9/14\n工作：对接门闸操作接口地址\n难点：\n学习：封装request\n反思：\n\n2020/9/15\n工作：开发仓储系统不足部分，考虑产品\n难点：\n学习：\n反思：\n\n2020/9/16\n工作：开发仓储，出入库\n难点：接口调试，功能逻辑\n学习：\n反思：\n\n2020/9/17\n工作：开发仓储，单元格\n难点：考虑功能逻辑，全局计时器调用\n学习：\n反思：\n\n2020/9/18\n工作：开发仓储，单元格\n难点：逻辑实现，store挂载timer\n学习：\n反思：\n\n2020/9/21\n工作：开发仓储，修改接口改动的请求，设计货架功能和实现\n难点：设计事项，业务能力，个别技术问题\n学习：\n反思：\n\n2020/9/22\n工作：开发仓储\n难点：解决数据流问题，监听路由变化，在切换页面缓存的情况下，更新数据\n学习：\n反思：\n\n2020/10/13\n工作：仓储系统自测\n难点：产品思维，寻找不足\n学习：\n反思：\n\n2020/10/14\n工作：开发仓储首页展示\n难点：设计，数据流向\n学习：样式继承\n反思：\n\n2020/10/15\n工作：完善首页，系统功能\n难点：功能点满足预测\n学习：\n反思：\n\n2020/10/16\n工作：完善货架业务，github使用，移动端项目开发参与\n难点：github\n学习：\n反思：github深入学习","source":"_posts/MyWorkingDiary.md","raw":"---\ntitle: MyWorkingDiary\ndate: 2020-07-08 13:44:49\ntags:\n - diary\n - 日记\ncategories: 想法\n---\n\n### 2020/7->2020年7月开始记录\n\n2020/7/7\n工作：暂无工作任务。\n难点：JS基础还需巩固扎实，需要实际提交。\n学习：开一个新的github项目，适用github上传个人项目，学习Vue源码。\n\n2020/7/8 \n工作：设计APP原型，主要适用于数据输入，5,5寸手持机。\n难点：github的使用需要注意，一些代码提交问题。解决了提交未显示contribution问题，需要在.git文件下添加user信息，邮箱符合即可。\n学习：累计产品设计经验（会抄才是关键）。\n\n2020/7/9\n工作：设计APP原型。\n难点：需求分析，功能确定，流程清晰。\n学习：累计项目经验，完善独自完成项目的能力。\n反思：在需求评审会议中，需要专心听。\n\n2020/7/10\n工作：设计APP原型，完善功能。\n难点：分析需求\n学习：同7/9\n反思：同7/9\n\n2020/7/13\n工作：设计APP原型，完善功能。\n难点：分析需求\n学习：同7/9\n反思：同7/9，早睡，保持良好工作精神。\n\n2020/7/14\n工作：设计APP原型，一期收尾。\n难点：分析需求\n学习：同7/9\n反思：同7/9，早睡，保持良好工作精神。\n\n2020/7/15\n工作：完善原型一期\n难点：分析需求\n学习：学习Vue3.0，有机会分析源码\n\n2020/7/16\n工作：原型修改\n难点：分析文档\n学习：阅读能力\n\n2020/7/17\n工作：原型改动，思考，看admin项目系统。\n难点：掌握项目结构\n学习：新知识，开拓新思想\n反思：呵，社会人~\n\n2020/7/20\n工作：上午开会，下午任务计划具体看安排\n难点：暂无\n学习：提升需求理解能力\n反思：暂无\n\n2020/7/21\n工作：完善原型，解析admin\n难点：系统架构\n学习：审美提高\n反思：多参考其他原型，提升普适性\n\n2020/7/22\n工作：完善原型最后一天\n难点：系统架构，产品设计\n学习：审美提高，产品思维提升\n反思：同7/21\n\n2020/7/23\n工作：驳回，继续完善原型\n难点：满足需求，工作经验不足，UI设计\n学习：讨论，结合需求办公，思考功能逻辑\n反思：恶心\n\n2020/7/24\n工作：研究开源项目\n难点：项目原理，路由\n学习：逻辑\n反思：在同事间信息交流注意方式学习\n\n2020/7/27\n工作：待会议功能分配，Vue3.0持续深入\n难点：同上\n学习：同上\n反思：多看书，提高认知\n\n2020/7/28\n工作：研究开源项目，APP素材整理\n难点：项目原理，路由\n学习：逻辑\n反思：开始拓展思维\n\n2020/7/29\n工作：研究开源项目，开发相关代码\n难顶：项目原理，路由\n学习：逻辑，搞懂ES6，WebPack\n反思：看书学习知识\n\n2020/7/30\n工作：研究开源项目\n难点：项目原理，持续研究权限登录和路由，研究页面样式和布局\n学习：逻辑，知识积累\n反思：深入研究，集中\n\n2020/7/31\n工作：研究开源项目，吃透知识点\n难点：知识点细化，掌握\n学习：同上\n反思：同上\n\n2020/8/3\n工作：开了一下午会，白天开发仓储系统相关页面\n难点：Ajax，promise对象\n学习：异步操作，同步方式\n反思：知识点积累\n\n2020/8/4\n工作：完善原型，开发仓储系统\n难点：Ajax异步请求\n学习：Ajax异步请求，await async使用\n反思：知识点积累\n\n2020/8/5\n工作：开发仓储系统（详情页面）\n难点：暂无\n学习：暂无\n反思：组件化复用\n\n2020/8/6\n工作：维护并开发仓储系统\n难点：\n学习：Scss使用\n反思：Fehelper插件的使用\n\n2020/8/7\n工作：研究开源项目\n难点：优化，性能问题\n学习：scss文件引入问题，菜单子项V-for显示，mixins使用\n反思：组件复用化，函数复用，混入函数的使用\n\n2020/8/10\n工作：思考仓储可视化图实现方式\n难点：canvas图示绘制\n学习：canvas\n反思：暂无\n\n2020/8/11\n工作：续昨日\n难点：思考其余解决方案\n学习：检索数据和判断条件\n反思：\n\n2020/8/12\n工作：实现仓储可视化\n难点：图形实现，暂用<ul><li>+css样式实现粗略\n学习：图形绘制\n反思：\n\n2020/8/12\n工作：仓储可视化完善，思考更优解决方案\n难点：图形\n学习：\n反思：\n\n2020/8/13\n工作：修改原型，可视化研究，开源项目开发，布局思路，思考开发架构\n难点：原理\n学习：个别布局方式和样式设置\n反思：学习！自学！\n\n2020/8/14\n工作：开源项目持续研究开发，架构思考，原型完善\n难点：\n学习：\n反思：\n\n2020/8/17\n工作：底层技术（基础）学习，开会后续通知，下午因个人事务，请假3小时\n难点：调试货架，css样式\n学习：\n反思：\n\n2020/8/18\n工作：修改原型，学习基础\n难点：\n学习：\n反思：\n\n2020/8/19\n今日因台风停工\n\n2020/8/20\n工作：同8/14任务，开发出入库操作\n难点：\n学习：熟练代码编写\n反思：\n\n2020/8/21\n工作：开发出入库操作，学习基础\n难点：\n学习：\n反思：\n\n2020/8/24\n工作：学习任务\n难点：\n学习：\n反思：\n\n2020/8/25\n工作：部署nginx服务器\n难点：原理不清楚，alias和root配置原理\n学习：\n反思：\n\n2020/8/26\n工作：学习相关前端知识，自行寻找需求开发\n难点：\n学习：\n反思：\n\n2020/8/27\n工作：学习相关前端知识，打基础\n难点：\n学习：\n反思:\n\n2020/8/28\n工作：去甲方出差\n难点：\n学习：对甲方态度要好\n反思：\n\n2020/8/31\n工作：开会，部署项目\n难点：\n学习：\n反思：\n\n2020/9/1\n工作：开发仓储系统\n难点：\n学习：\n反思：\n\n2020/9/2\n工作：可视化修改，自适应大小\n难点：\n学习：\n反思：\n\n2020/9/3\n工作：扎实基础,部署项目\n难点：\n学习：\n反思：\n\n2020/9/4\n工作：扎实基础\n难点：\n学习：\n反思：\n\n2020/9/7\n工作：仓储系统出入库界面进度\n难点：\n学习：\n反思：\n\n2020/9/8\n工作：学习，扎实基础\n难点：\n学习：\n反思：\n\n2020/9/9\n工作：扎实基础\n难点：\n学习：\n反思：\n\n2020/9/10\n工作：开发入库展示\n难点：\n学习：\n反思：\n\n2020/9/11\n工作：仓储系统完善，责任分工明细\n难点：\n学习：\n反思：\n\n2020/9/14\n工作：对接门闸操作接口地址\n难点：\n学习：封装request\n反思：\n\n2020/9/15\n工作：开发仓储系统不足部分，考虑产品\n难点：\n学习：\n反思：\n\n2020/9/16\n工作：开发仓储，出入库\n难点：接口调试，功能逻辑\n学习：\n反思：\n\n2020/9/17\n工作：开发仓储，单元格\n难点：考虑功能逻辑，全局计时器调用\n学习：\n反思：\n\n2020/9/18\n工作：开发仓储，单元格\n难点：逻辑实现，store挂载timer\n学习：\n反思：\n\n2020/9/21\n工作：开发仓储，修改接口改动的请求，设计货架功能和实现\n难点：设计事项，业务能力，个别技术问题\n学习：\n反思：\n\n2020/9/22\n工作：开发仓储\n难点：解决数据流问题，监听路由变化，在切换页面缓存的情况下，更新数据\n学习：\n反思：\n\n2020/10/13\n工作：仓储系统自测\n难点：产品思维，寻找不足\n学习：\n反思：\n\n2020/10/14\n工作：开发仓储首页展示\n难点：设计，数据流向\n学习：样式继承\n反思：\n\n2020/10/15\n工作：完善首页，系统功能\n难点：功能点满足预测\n学习：\n反思：\n\n2020/10/16\n工作：完善货架业务，github使用，移动端项目开发参与\n难点：github\n学习：\n反思：github深入学习","slug":"MyWorkingDiary","published":1,"updated":"2020-10-16T02:56:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow3700014pcva8bn3e7fa","content":"<h3 id=\"2020-7-gt-2020年7月开始记录\"><a href=\"#2020-7-gt-2020年7月开始记录\" class=\"headerlink\" title=\"2020/7-&gt;2020年7月开始记录\"></a>2020/7-&gt;2020年7月开始记录</h3><p>2020/7/7<br>工作：暂无工作任务。<br>难点：JS基础还需巩固扎实，需要实际提交。<br>学习：开一个新的github项目，适用github上传个人项目，学习Vue源码。</p>\n<p>2020/7/8<br>工作：设计APP原型，主要适用于数据输入，5,5寸手持机。<br>难点：github的使用需要注意，一些代码提交问题。解决了提交未显示contribution问题，需要在.git文件下添加user信息，邮箱符合即可。<br>学习：累计产品设计经验（会抄才是关键）。</p>\n<p>2020/7/9<br>工作：设计APP原型。<br>难点：需求分析，功能确定，流程清晰。<br>学习：累计项目经验，完善独自完成项目的能力。<br>反思：在需求评审会议中，需要专心听。</p>\n<p>2020/7/10<br>工作：设计APP原型，完善功能。<br>难点：分析需求<br>学习：同7/9<br>反思：同7/9</p>\n<p>2020/7/13<br>工作：设计APP原型，完善功能。<br>难点：分析需求<br>学习：同7/9<br>反思：同7/9，早睡，保持良好工作精神。</p>\n<p>2020/7/14<br>工作：设计APP原型，一期收尾。<br>难点：分析需求<br>学习：同7/9<br>反思：同7/9，早睡，保持良好工作精神。</p>\n<p>2020/7/15<br>工作：完善原型一期<br>难点：分析需求<br>学习：学习Vue3.0，有机会分析源码</p>\n<p>2020/7/16<br>工作：原型修改<br>难点：分析文档<br>学习：阅读能力</p>\n<p>2020/7/17<br>工作：原型改动，思考，看admin项目系统。<br>难点：掌握项目结构<br>学习：新知识，开拓新思想<br>反思：呵，社会人~</p>\n<p>2020/7/20<br>工作：上午开会，下午任务计划具体看安排<br>难点：暂无<br>学习：提升需求理解能力<br>反思：暂无</p>\n<p>2020/7/21<br>工作：完善原型，解析admin<br>难点：系统架构<br>学习：审美提高<br>反思：多参考其他原型，提升普适性</p>\n<p>2020/7/22<br>工作：完善原型最后一天<br>难点：系统架构，产品设计<br>学习：审美提高，产品思维提升<br>反思：同7/21</p>\n<p>2020/7/23<br>工作：驳回，继续完善原型<br>难点：满足需求，工作经验不足，UI设计<br>学习：讨论，结合需求办公，思考功能逻辑<br>反思：恶心</p>\n<p>2020/7/24<br>工作：研究开源项目<br>难点：项目原理，路由<br>学习：逻辑<br>反思：在同事间信息交流注意方式学习</p>\n<p>2020/7/27<br>工作：待会议功能分配，Vue3.0持续深入<br>难点：同上<br>学习：同上<br>反思：多看书，提高认知</p>\n<p>2020/7/28<br>工作：研究开源项目，APP素材整理<br>难点：项目原理，路由<br>学习：逻辑<br>反思：开始拓展思维</p>\n<p>2020/7/29<br>工作：研究开源项目，开发相关代码<br>难顶：项目原理，路由<br>学习：逻辑，搞懂ES6，WebPack<br>反思：看书学习知识</p>\n<p>2020/7/30<br>工作：研究开源项目<br>难点：项目原理，持续研究权限登录和路由，研究页面样式和布局<br>学习：逻辑，知识积累<br>反思：深入研究，集中</p>\n<p>2020/7/31<br>工作：研究开源项目，吃透知识点<br>难点：知识点细化，掌握<br>学习：同上<br>反思：同上</p>\n<p>2020/8/3<br>工作：开了一下午会，白天开发仓储系统相关页面<br>难点：Ajax，promise对象<br>学习：异步操作，同步方式<br>反思：知识点积累</p>\n<p>2020/8/4<br>工作：完善原型，开发仓储系统<br>难点：Ajax异步请求<br>学习：Ajax异步请求，await async使用<br>反思：知识点积累</p>\n<p>2020/8/5<br>工作：开发仓储系统（详情页面）<br>难点：暂无<br>学习：暂无<br>反思：组件化复用</p>\n<p>2020/8/6<br>工作：维护并开发仓储系统<br>难点：<br>学习：Scss使用<br>反思：Fehelper插件的使用</p>\n<p>2020/8/7<br>工作：研究开源项目<br>难点：优化，性能问题<br>学习：scss文件引入问题，菜单子项V-for显示，mixins使用<br>反思：组件复用化，函数复用，混入函数的使用</p>\n<p>2020/8/10<br>工作：思考仓储可视化图实现方式<br>难点：canvas图示绘制<br>学习：canvas<br>反思：暂无</p>\n<p>2020/8/11<br>工作：续昨日<br>难点：思考其余解决方案<br>学习：检索数据和判断条件<br>反思：</p>\n<p>2020/8/12<br>工作：实现仓储可视化<br>难点：图形实现，暂用<ul><li>+css样式实现粗略<br>学习：图形绘制<br>反思：</li></ul></p>\n<p>2020/8/12<br>工作：仓储可视化完善，思考更优解决方案<br>难点：图形<br>学习：<br>反思：</p>\n<p>2020/8/13<br>工作：修改原型，可视化研究，开源项目开发，布局思路，思考开发架构<br>难点：原理<br>学习：个别布局方式和样式设置<br>反思：学习！自学！</p>\n<p>2020/8/14<br>工作：开源项目持续研究开发，架构思考，原型完善<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/17<br>工作：底层技术（基础）学习，开会后续通知，下午因个人事务，请假3小时<br>难点：调试货架，css样式<br>学习：<br>反思：</p>\n<p>2020/8/18<br>工作：修改原型，学习基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/19<br>今日因台风停工</p>\n<p>2020/8/20<br>工作：同8/14任务，开发出入库操作<br>难点：<br>学习：熟练代码编写<br>反思：</p>\n<p>2020/8/21<br>工作：开发出入库操作，学习基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/24<br>工作：学习任务<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/25<br>工作：部署nginx服务器<br>难点：原理不清楚，alias和root配置原理<br>学习：<br>反思：</p>\n<p>2020/8/26<br>工作：学习相关前端知识，自行寻找需求开发<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/27<br>工作：学习相关前端知识，打基础<br>难点：<br>学习：<br>反思:</p>\n<p>2020/8/28<br>工作：去甲方出差<br>难点：<br>学习：对甲方态度要好<br>反思：</p>\n<p>2020/8/31<br>工作：开会，部署项目<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/1<br>工作：开发仓储系统<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/2<br>工作：可视化修改，自适应大小<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/3<br>工作：扎实基础,部署项目<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/4<br>工作：扎实基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/7<br>工作：仓储系统出入库界面进度<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/8<br>工作：学习，扎实基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/9<br>工作：扎实基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/10<br>工作：开发入库展示<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/11<br>工作：仓储系统完善，责任分工明细<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/14<br>工作：对接门闸操作接口地址<br>难点：<br>学习：封装request<br>反思：</p>\n<p>2020/9/15<br>工作：开发仓储系统不足部分，考虑产品<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/16<br>工作：开发仓储，出入库<br>难点：接口调试，功能逻辑<br>学习：<br>反思：</p>\n<p>2020/9/17<br>工作：开发仓储，单元格<br>难点：考虑功能逻辑，全局计时器调用<br>学习：<br>反思：</p>\n<p>2020/9/18<br>工作：开发仓储，单元格<br>难点：逻辑实现，store挂载timer<br>学习：<br>反思：</p>\n<p>2020/9/21<br>工作：开发仓储，修改接口改动的请求，设计货架功能和实现<br>难点：设计事项，业务能力，个别技术问题<br>学习：<br>反思：</p>\n<p>2020/9/22<br>工作：开发仓储<br>难点：解决数据流问题，监听路由变化，在切换页面缓存的情况下，更新数据<br>学习：<br>反思：</p>\n<p>2020/10/13<br>工作：仓储系统自测<br>难点：产品思维，寻找不足<br>学习：<br>反思：</p>\n<p>2020/10/14<br>工作：开发仓储首页展示<br>难点：设计，数据流向<br>学习：样式继承<br>反思：</p>\n<p>2020/10/15<br>工作：完善首页，系统功能<br>难点：功能点满足预测<br>学习：<br>反思：</p>\n<p>2020/10/16<br>工作：完善货架业务，github使用，移动端项目开发参与<br>难点：github<br>学习：<br>反思：github深入学习</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"2020-7-gt-2020年7月开始记录\"><a href=\"#2020-7-gt-2020年7月开始记录\" class=\"headerlink\" title=\"2020/7-&gt;2020年7月开始记录\"></a>2020/7-&gt;2020年7月开始记录</h3><p>2020/7/7<br>工作：暂无工作任务。<br>难点：JS基础还需巩固扎实，需要实际提交。<br>学习：开一个新的github项目，适用github上传个人项目，学习Vue源码。</p>\n<p>2020/7/8<br>工作：设计APP原型，主要适用于数据输入，5,5寸手持机。<br>难点：github的使用需要注意，一些代码提交问题。解决了提交未显示contribution问题，需要在.git文件下添加user信息，邮箱符合即可。<br>学习：累计产品设计经验（会抄才是关键）。</p>\n<p>2020/7/9<br>工作：设计APP原型。<br>难点：需求分析，功能确定，流程清晰。<br>学习：累计项目经验，完善独自完成项目的能力。<br>反思：在需求评审会议中，需要专心听。</p>\n<p>2020/7/10<br>工作：设计APP原型，完善功能。<br>难点：分析需求<br>学习：同7/9<br>反思：同7/9</p>\n<p>2020/7/13<br>工作：设计APP原型，完善功能。<br>难点：分析需求<br>学习：同7/9<br>反思：同7/9，早睡，保持良好工作精神。</p>\n<p>2020/7/14<br>工作：设计APP原型，一期收尾。<br>难点：分析需求<br>学习：同7/9<br>反思：同7/9，早睡，保持良好工作精神。</p>\n<p>2020/7/15<br>工作：完善原型一期<br>难点：分析需求<br>学习：学习Vue3.0，有机会分析源码</p>\n<p>2020/7/16<br>工作：原型修改<br>难点：分析文档<br>学习：阅读能力</p>\n<p>2020/7/17<br>工作：原型改动，思考，看admin项目系统。<br>难点：掌握项目结构<br>学习：新知识，开拓新思想<br>反思：呵，社会人~</p>\n<p>2020/7/20<br>工作：上午开会，下午任务计划具体看安排<br>难点：暂无<br>学习：提升需求理解能力<br>反思：暂无</p>\n<p>2020/7/21<br>工作：完善原型，解析admin<br>难点：系统架构<br>学习：审美提高<br>反思：多参考其他原型，提升普适性</p>\n<p>2020/7/22<br>工作：完善原型最后一天<br>难点：系统架构，产品设计<br>学习：审美提高，产品思维提升<br>反思：同7/21</p>\n<p>2020/7/23<br>工作：驳回，继续完善原型<br>难点：满足需求，工作经验不足，UI设计<br>学习：讨论，结合需求办公，思考功能逻辑<br>反思：恶心</p>\n<p>2020/7/24<br>工作：研究开源项目<br>难点：项目原理，路由<br>学习：逻辑<br>反思：在同事间信息交流注意方式学习</p>\n<p>2020/7/27<br>工作：待会议功能分配，Vue3.0持续深入<br>难点：同上<br>学习：同上<br>反思：多看书，提高认知</p>\n<p>2020/7/28<br>工作：研究开源项目，APP素材整理<br>难点：项目原理，路由<br>学习：逻辑<br>反思：开始拓展思维</p>\n<p>2020/7/29<br>工作：研究开源项目，开发相关代码<br>难顶：项目原理，路由<br>学习：逻辑，搞懂ES6，WebPack<br>反思：看书学习知识</p>\n<p>2020/7/30<br>工作：研究开源项目<br>难点：项目原理，持续研究权限登录和路由，研究页面样式和布局<br>学习：逻辑，知识积累<br>反思：深入研究，集中</p>\n<p>2020/7/31<br>工作：研究开源项目，吃透知识点<br>难点：知识点细化，掌握<br>学习：同上<br>反思：同上</p>\n<p>2020/8/3<br>工作：开了一下午会，白天开发仓储系统相关页面<br>难点：Ajax，promise对象<br>学习：异步操作，同步方式<br>反思：知识点积累</p>\n<p>2020/8/4<br>工作：完善原型，开发仓储系统<br>难点：Ajax异步请求<br>学习：Ajax异步请求，await async使用<br>反思：知识点积累</p>\n<p>2020/8/5<br>工作：开发仓储系统（详情页面）<br>难点：暂无<br>学习：暂无<br>反思：组件化复用</p>\n<p>2020/8/6<br>工作：维护并开发仓储系统<br>难点：<br>学习：Scss使用<br>反思：Fehelper插件的使用</p>\n<p>2020/8/7<br>工作：研究开源项目<br>难点：优化，性能问题<br>学习：scss文件引入问题，菜单子项V-for显示，mixins使用<br>反思：组件复用化，函数复用，混入函数的使用</p>\n<p>2020/8/10<br>工作：思考仓储可视化图实现方式<br>难点：canvas图示绘制<br>学习：canvas<br>反思：暂无</p>\n<p>2020/8/11<br>工作：续昨日<br>难点：思考其余解决方案<br>学习：检索数据和判断条件<br>反思：</p>\n<p>2020/8/12<br>工作：实现仓储可视化<br>难点：图形实现，暂用<ul><li>+css样式实现粗略<br>学习：图形绘制<br>反思：</li></ul></p>\n<p>2020/8/12<br>工作：仓储可视化完善，思考更优解决方案<br>难点：图形<br>学习：<br>反思：</p>\n<p>2020/8/13<br>工作：修改原型，可视化研究，开源项目开发，布局思路，思考开发架构<br>难点：原理<br>学习：个别布局方式和样式设置<br>反思：学习！自学！</p>\n<p>2020/8/14<br>工作：开源项目持续研究开发，架构思考，原型完善<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/17<br>工作：底层技术（基础）学习，开会后续通知，下午因个人事务，请假3小时<br>难点：调试货架，css样式<br>学习：<br>反思：</p>\n<p>2020/8/18<br>工作：修改原型，学习基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/19<br>今日因台风停工</p>\n<p>2020/8/20<br>工作：同8/14任务，开发出入库操作<br>难点：<br>学习：熟练代码编写<br>反思：</p>\n<p>2020/8/21<br>工作：开发出入库操作，学习基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/24<br>工作：学习任务<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/25<br>工作：部署nginx服务器<br>难点：原理不清楚，alias和root配置原理<br>学习：<br>反思：</p>\n<p>2020/8/26<br>工作：学习相关前端知识，自行寻找需求开发<br>难点：<br>学习：<br>反思：</p>\n<p>2020/8/27<br>工作：学习相关前端知识，打基础<br>难点：<br>学习：<br>反思:</p>\n<p>2020/8/28<br>工作：去甲方出差<br>难点：<br>学习：对甲方态度要好<br>反思：</p>\n<p>2020/8/31<br>工作：开会，部署项目<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/1<br>工作：开发仓储系统<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/2<br>工作：可视化修改，自适应大小<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/3<br>工作：扎实基础,部署项目<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/4<br>工作：扎实基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/7<br>工作：仓储系统出入库界面进度<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/8<br>工作：学习，扎实基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/9<br>工作：扎实基础<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/10<br>工作：开发入库展示<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/11<br>工作：仓储系统完善，责任分工明细<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/14<br>工作：对接门闸操作接口地址<br>难点：<br>学习：封装request<br>反思：</p>\n<p>2020/9/15<br>工作：开发仓储系统不足部分，考虑产品<br>难点：<br>学习：<br>反思：</p>\n<p>2020/9/16<br>工作：开发仓储，出入库<br>难点：接口调试，功能逻辑<br>学习：<br>反思：</p>\n<p>2020/9/17<br>工作：开发仓储，单元格<br>难点：考虑功能逻辑，全局计时器调用<br>学习：<br>反思：</p>\n<p>2020/9/18<br>工作：开发仓储，单元格<br>难点：逻辑实现，store挂载timer<br>学习：<br>反思：</p>\n<p>2020/9/21<br>工作：开发仓储，修改接口改动的请求，设计货架功能和实现<br>难点：设计事项，业务能力，个别技术问题<br>学习：<br>反思：</p>\n<p>2020/9/22<br>工作：开发仓储<br>难点：解决数据流问题，监听路由变化，在切换页面缓存的情况下，更新数据<br>学习：<br>反思：</p>\n<p>2020/10/13<br>工作：仓储系统自测<br>难点：产品思维，寻找不足<br>学习：<br>反思：</p>\n<p>2020/10/14<br>工作：开发仓储首页展示<br>难点：设计，数据流向<br>学习：样式继承<br>反思：</p>\n<p>2020/10/15<br>工作：完善首页，系统功能<br>难点：功能点满足预测<br>学习：<br>反思：</p>\n<p>2020/10/16<br>工作：完善货架业务，github使用，移动端项目开发参与<br>难点：github<br>学习：<br>反思：github深入学习</p>\n"},{"title":"Nginx服务器的部署","date":"2020-08-25T08:05:41.000Z","_content":"### Nginx服务器对Vue项目的部署\n\n## 1.在本地下载Nginx\n直接百度nginx，进入官网，选择Stable（稳定版），windows（版本）下载\n\n## 2.解压下载的压缩包\n解压压缩包在磁盘（合理规划磁盘）\n\n## 3.配置nginx文件\n在解压出的文件夹中有conf文件，进入，选择nginx.conf文件进行配置\n```bash\n server {\n        listen       8100; //此为端口,如果端口有被占用请更改\n        server_name  localhost;//服务器名\n\n        location ^~ /wms { // 配置，用到正则表达式\n            alias   E:/nginx-1.18.0/html/dist//如使用alias，则不会进行路径拼接，会进行替换，直接在该绝对路径中寻找index下的文件\n            root   E:/nginx-1.18.0/html/dist;//根目录，root代表路径，会跟上面的/wms进行拼接，为绝对路径\n            index  index.html index.htm;//从上面得到的绝对路径中寻找index.html文件，如查找不到则报403 forbidden错误，即为文件不存在\n        }\n        location /dev-api/{ //webpack不会打包代理请求路径，需自己配置\n            proxy_pass http://192.168.1.58:8888/; // 在nginx上部署的项目请求服务器地址代理\n        }\n```\n## history模式下的问题\n在router使用history模式下，部署nginx的项目刷新会出现404，找不到页面的情况\n这时候需要进行重定位\n```bash\nlocation / {\n　　root  /；\n　　index index.html;\n　　try_files $uri $uri/ /index.html //根目录的情况下\n}\nlocation /xx/xx/ {\n　　root  /；\n　　index index.html;\n　　try_files $uri $uri/ /xx/xx/index.html //特定目录情况下\n}\nlocation /payfor/ {\n       root /home/web;\n       index index.html;\n       try_files $uri $uri/ /payfor/index.html; //例子\n}\n```\n[参考链接：匹配规则](https://www.cnblogs.com/jpfss/p/10418150.html)\n---\n\n重点：路径配置规则需了解","source":"_posts/Nginx服务器的部署.md","raw":"---\ntitle: Nginx服务器的部署\ndate: 2020-08-25 16:05:41\ntags:\n - 前端开发\ncategories: 经验\n---\n### Nginx服务器对Vue项目的部署\n\n## 1.在本地下载Nginx\n直接百度nginx，进入官网，选择Stable（稳定版），windows（版本）下载\n\n## 2.解压下载的压缩包\n解压压缩包在磁盘（合理规划磁盘）\n\n## 3.配置nginx文件\n在解压出的文件夹中有conf文件，进入，选择nginx.conf文件进行配置\n```bash\n server {\n        listen       8100; //此为端口,如果端口有被占用请更改\n        server_name  localhost;//服务器名\n\n        location ^~ /wms { // 配置，用到正则表达式\n            alias   E:/nginx-1.18.0/html/dist//如使用alias，则不会进行路径拼接，会进行替换，直接在该绝对路径中寻找index下的文件\n            root   E:/nginx-1.18.0/html/dist;//根目录，root代表路径，会跟上面的/wms进行拼接，为绝对路径\n            index  index.html index.htm;//从上面得到的绝对路径中寻找index.html文件，如查找不到则报403 forbidden错误，即为文件不存在\n        }\n        location /dev-api/{ //webpack不会打包代理请求路径，需自己配置\n            proxy_pass http://192.168.1.58:8888/; // 在nginx上部署的项目请求服务器地址代理\n        }\n```\n## history模式下的问题\n在router使用history模式下，部署nginx的项目刷新会出现404，找不到页面的情况\n这时候需要进行重定位\n```bash\nlocation / {\n　　root  /；\n　　index index.html;\n　　try_files $uri $uri/ /index.html //根目录的情况下\n}\nlocation /xx/xx/ {\n　　root  /；\n　　index index.html;\n　　try_files $uri $uri/ /xx/xx/index.html //特定目录情况下\n}\nlocation /payfor/ {\n       root /home/web;\n       index index.html;\n       try_files $uri $uri/ /payfor/index.html; //例子\n}\n```\n[参考链接：匹配规则](https://www.cnblogs.com/jpfss/p/10418150.html)\n---\n\n重点：路径配置规则需了解","slug":"Nginx服务器的部署","published":1,"updated":"2020-09-03T05:48:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow3720016pcva4u69bu4x","content":"<h3 id=\"Nginx服务器对Vue项目的部署\"><a href=\"#Nginx服务器对Vue项目的部署\" class=\"headerlink\" title=\"Nginx服务器对Vue项目的部署\"></a>Nginx服务器对Vue项目的部署</h3><h2 id=\"1-在本地下载Nginx\"><a href=\"#1-在本地下载Nginx\" class=\"headerlink\" title=\"1.在本地下载Nginx\"></a>1.在本地下载Nginx</h2><p>直接百度nginx，进入官网，选择Stable（稳定版），windows（版本）下载</p>\n<h2 id=\"2-解压下载的压缩包\"><a href=\"#2-解压下载的压缩包\" class=\"headerlink\" title=\"2.解压下载的压缩包\"></a>2.解压下载的压缩包</h2><p>解压压缩包在磁盘（合理规划磁盘）</p>\n<h2 id=\"3-配置nginx文件\"><a href=\"#3-配置nginx文件\" class=\"headerlink\" title=\"3.配置nginx文件\"></a>3.配置nginx文件</h2><p>在解压出的文件夹中有conf文件，进入，选择nginx.conf文件进行配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">       listen       8100; //此为端口,如果端口有被占用请更改</span><br><span class=\"line\">       server_name  localhost;//服务器名</span><br><span class=\"line\"></span><br><span class=\"line\">       location ^~ /wms &#123; // 配置，用到正则表达式</span><br><span class=\"line\">           <span class=\"built_in\">alias</span>   E:/nginx-1.18.0/html/dist//如使用<span class=\"built_in\">alias</span>，则不会进行路径拼接，会进行替换，直接在该绝对路径中寻找index下的文件</span><br><span class=\"line\">           root   E:/nginx-1.18.0/html/dist;//根目录，root代表路径，会跟上面的/wms进行拼接，为绝对路径</span><br><span class=\"line\">           index  index.html index.htm;//从上面得到的绝对路径中寻找index.html文件，如查找不到则报403 forbidden错误，即为文件不存在</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       location /dev-api/&#123; //webpack不会打包代理请求路径，需自己配置</span><br><span class=\"line\">           proxy_pass http://192.168.1.58:8888/; // 在nginx上部署的项目请求服务器地址代理</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"history模式下的问题\"><a href=\"#history模式下的问题\" class=\"headerlink\" title=\"history模式下的问题\"></a>history模式下的问题</h2><p>在router使用history模式下，部署nginx的项目刷新会出现404，找不到页面的情况<br>这时候需要进行重定位</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">　　root  /；</span><br><span class=\"line\">　　index index.html;</span><br><span class=\"line\">　　try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html //根目录的情况下</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location /xx/xx/ &#123;</span><br><span class=\"line\">　　root  /；</span><br><span class=\"line\">　　index index.html;</span><br><span class=\"line\">　　try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /xx/xx/index.html //特定目录情况下</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location /payfor/ &#123;</span><br><span class=\"line\">       root /home/web;</span><br><span class=\"line\">       index index.html;</span><br><span class=\"line\">       try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /payfor/index.html; //例子</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接：匹配规则\"><a href=\"#参考链接：匹配规则\" class=\"headerlink\" title=\"参考链接：匹配规则\"></a><a href=\"https://www.cnblogs.com/jpfss/p/10418150.html\" target=\"_blank\" rel=\"noopener\">参考链接：匹配规则</a></h2><p>重点：路径配置规则需了解</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Nginx服务器对Vue项目的部署\"><a href=\"#Nginx服务器对Vue项目的部署\" class=\"headerlink\" title=\"Nginx服务器对Vue项目的部署\"></a>Nginx服务器对Vue项目的部署</h3><h2 id=\"1-在本地下载Nginx\"><a href=\"#1-在本地下载Nginx\" class=\"headerlink\" title=\"1.在本地下载Nginx\"></a>1.在本地下载Nginx</h2><p>直接百度nginx，进入官网，选择Stable（稳定版），windows（版本）下载</p>\n<h2 id=\"2-解压下载的压缩包\"><a href=\"#2-解压下载的压缩包\" class=\"headerlink\" title=\"2.解压下载的压缩包\"></a>2.解压下载的压缩包</h2><p>解压压缩包在磁盘（合理规划磁盘）</p>\n<h2 id=\"3-配置nginx文件\"><a href=\"#3-配置nginx文件\" class=\"headerlink\" title=\"3.配置nginx文件\"></a>3.配置nginx文件</h2><p>在解压出的文件夹中有conf文件，进入，选择nginx.conf文件进行配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">       listen       8100; //此为端口,如果端口有被占用请更改</span><br><span class=\"line\">       server_name  localhost;//服务器名</span><br><span class=\"line\"></span><br><span class=\"line\">       location ^~ /wms &#123; // 配置，用到正则表达式</span><br><span class=\"line\">           <span class=\"built_in\">alias</span>   E:/nginx-1.18.0/html/dist//如使用<span class=\"built_in\">alias</span>，则不会进行路径拼接，会进行替换，直接在该绝对路径中寻找index下的文件</span><br><span class=\"line\">           root   E:/nginx-1.18.0/html/dist;//根目录，root代表路径，会跟上面的/wms进行拼接，为绝对路径</span><br><span class=\"line\">           index  index.html index.htm;//从上面得到的绝对路径中寻找index.html文件，如查找不到则报403 forbidden错误，即为文件不存在</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       location /dev-api/&#123; //webpack不会打包代理请求路径，需自己配置</span><br><span class=\"line\">           proxy_pass http://192.168.1.58:8888/; // 在nginx上部署的项目请求服务器地址代理</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"history模式下的问题\"><a href=\"#history模式下的问题\" class=\"headerlink\" title=\"history模式下的问题\"></a>history模式下的问题</h2><p>在router使用history模式下，部署nginx的项目刷新会出现404，找不到页面的情况<br>这时候需要进行重定位</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">　　root  /；</span><br><span class=\"line\">　　index index.html;</span><br><span class=\"line\">　　try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html //根目录的情况下</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location /xx/xx/ &#123;</span><br><span class=\"line\">　　root  /；</span><br><span class=\"line\">　　index index.html;</span><br><span class=\"line\">　　try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /xx/xx/index.html //特定目录情况下</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location /payfor/ &#123;</span><br><span class=\"line\">       root /home/web;</span><br><span class=\"line\">       index index.html;</span><br><span class=\"line\">       try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /payfor/index.html; //例子</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考链接：匹配规则\"><a href=\"#参考链接：匹配规则\" class=\"headerlink\" title=\"参考链接：匹配规则\"></a><a href=\"https://www.cnblogs.com/jpfss/p/10418150.html\" target=\"_blank\" rel=\"noopener\">参考链接：匹配规则</a></h2><p>重点：路径配置规则需了解</p>\n"},{"title":"PS技术研究","date":"2020-06-15T01:49:45.000Z","_content":"\n## 下载CS6版本PS，找PDF图和视频观看学习。\n\n```bash\n基本操作：\n选框：各种不同格式选框工具，选择后可以复制图层进行编辑。\n注意！（各种图片都是由许多图层构成）后期图片细节再做研究。\n快捷键：Ctrl+Z返回 \nCtrl+J复制当前图层 \nCtrl+光标 移动当前选定图层\nCtrl+T 自由变换快捷键\nCtrl+M调整曲线\n熊猫表情类似制作方法：使用索套工具将面部标签截取并复制图层，后图像->调整->黑白 确定后，调整->曝光度，调整到适应的表情样式，后用橡皮擦把一些无关线条划去。\n抠图方法之一：使用魔法棒将相同颜色区域选择并删除（适用于背景色单调的图片）\n图片拼接：使用图层蒙版，然后使用画笔在图层蒙版上划去重叠不一致的样式。\n换脸：使用索套工具将脸部选择并复制到另一图层，设置颜色，使用橡皮，将流量调低至30左右，擦去不适应的地方，可以调不透明度，微调曲线，选择蓝色通道\nGIF图制作：需要选择窗口->时间轴  新建帧 每个帧对应的图层不同，调整帧变动的时间，组成GIF。\n通过图像，画布大小，可以调整背景画布的大小。\n```","source":"_posts/PS技术研究.md","raw":"---\ntitle: PS技术研究\ndate: 2020-06-15 09:49:45\ntags:\n - 图片编辑\ncategories: 产品\n---\n\n## 下载CS6版本PS，找PDF图和视频观看学习。\n\n```bash\n基本操作：\n选框：各种不同格式选框工具，选择后可以复制图层进行编辑。\n注意！（各种图片都是由许多图层构成）后期图片细节再做研究。\n快捷键：Ctrl+Z返回 \nCtrl+J复制当前图层 \nCtrl+光标 移动当前选定图层\nCtrl+T 自由变换快捷键\nCtrl+M调整曲线\n熊猫表情类似制作方法：使用索套工具将面部标签截取并复制图层，后图像->调整->黑白 确定后，调整->曝光度，调整到适应的表情样式，后用橡皮擦把一些无关线条划去。\n抠图方法之一：使用魔法棒将相同颜色区域选择并删除（适用于背景色单调的图片）\n图片拼接：使用图层蒙版，然后使用画笔在图层蒙版上划去重叠不一致的样式。\n换脸：使用索套工具将脸部选择并复制到另一图层，设置颜色，使用橡皮，将流量调低至30左右，擦去不适应的地方，可以调不透明度，微调曲线，选择蓝色通道\nGIF图制作：需要选择窗口->时间轴  新建帧 每个帧对应的图层不同，调整帧变动的时间，组成GIF。\n通过图像，画布大小，可以调整背景画布的大小。\n```","slug":"PS技术研究","published":1,"updated":"2020-08-13T06:42:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow374001apcva15kh67px","content":"<h2 id=\"下载CS6版本PS，找PDF图和视频观看学习。\"><a href=\"#下载CS6版本PS，找PDF图和视频观看学习。\" class=\"headerlink\" title=\"下载CS6版本PS，找PDF图和视频观看学习。\"></a>下载CS6版本PS，找PDF图和视频观看学习。</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本操作：</span><br><span class=\"line\">选框：各种不同格式选框工具，选择后可以复制图层进行编辑。</span><br><span class=\"line\">注意！（各种图片都是由许多图层构成）后期图片细节再做研究。</span><br><span class=\"line\">快捷键：Ctrl+Z返回 </span><br><span class=\"line\">Ctrl+J复制当前图层 </span><br><span class=\"line\">Ctrl+光标 移动当前选定图层</span><br><span class=\"line\">Ctrl+T 自由变换快捷键</span><br><span class=\"line\">Ctrl+M调整曲线</span><br><span class=\"line\">熊猫表情类似制作方法：使用索套工具将面部标签截取并复制图层，后图像-&gt;调整-&gt;黑白 确定后，调整-&gt;曝光度，调整到适应的表情样式，后用橡皮擦把一些无关线条划去。</span><br><span class=\"line\">抠图方法之一：使用魔法棒将相同颜色区域选择并删除（适用于背景色单调的图片）</span><br><span class=\"line\">图片拼接：使用图层蒙版，然后使用画笔在图层蒙版上划去重叠不一致的样式。</span><br><span class=\"line\">换脸：使用索套工具将脸部选择并复制到另一图层，设置颜色，使用橡皮，将流量调低至30左右，擦去不适应的地方，可以调不透明度，微调曲线，选择蓝色通道</span><br><span class=\"line\">GIF图制作：需要选择窗口-&gt;时间轴  新建帧 每个帧对应的图层不同，调整帧变动的时间，组成GIF。</span><br><span class=\"line\">通过图像，画布大小，可以调整背景画布的大小。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载CS6版本PS，找PDF图和视频观看学习。\"><a href=\"#下载CS6版本PS，找PDF图和视频观看学习。\" class=\"headerlink\" title=\"下载CS6版本PS，找PDF图和视频观看学习。\"></a>下载CS6版本PS，找PDF图和视频观看学习。</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本操作：</span><br><span class=\"line\">选框：各种不同格式选框工具，选择后可以复制图层进行编辑。</span><br><span class=\"line\">注意！（各种图片都是由许多图层构成）后期图片细节再做研究。</span><br><span class=\"line\">快捷键：Ctrl+Z返回 </span><br><span class=\"line\">Ctrl+J复制当前图层 </span><br><span class=\"line\">Ctrl+光标 移动当前选定图层</span><br><span class=\"line\">Ctrl+T 自由变换快捷键</span><br><span class=\"line\">Ctrl+M调整曲线</span><br><span class=\"line\">熊猫表情类似制作方法：使用索套工具将面部标签截取并复制图层，后图像-&gt;调整-&gt;黑白 确定后，调整-&gt;曝光度，调整到适应的表情样式，后用橡皮擦把一些无关线条划去。</span><br><span class=\"line\">抠图方法之一：使用魔法棒将相同颜色区域选择并删除（适用于背景色单调的图片）</span><br><span class=\"line\">图片拼接：使用图层蒙版，然后使用画笔在图层蒙版上划去重叠不一致的样式。</span><br><span class=\"line\">换脸：使用索套工具将脸部选择并复制到另一图层，设置颜色，使用橡皮，将流量调低至30左右，擦去不适应的地方，可以调不透明度，微调曲线，选择蓝色通道</span><br><span class=\"line\">GIF图制作：需要选择窗口-&gt;时间轴  新建帧 每个帧对应的图层不同，调整帧变动的时间，组成GIF。</span><br><span class=\"line\">通过图像，画布大小，可以调整背景画布的大小。</span><br></pre></td></tr></table></figure>"},{"title":"SVN工具在编辑器上的使用","date":"2020-05-12T05:39:52.000Z","_content":"方便SVNcommit和update\n---\n\n## 2020/5/13 10:53 Write\n\n关键词：SVN\n\n在WebStorm上配置SVN，方便操作\n\n## 1.\n![SVN操作1](SVN-1.png)\n---\n## 2.\n![SVN操作2](SVN-2.png)\n---\n## 3.\n![SVN操作3](SVN-3.png)\n\n参考链接：https://blog.csdn.net/yaomengzhi/article/details/80723925","source":"_posts/SVN工具在编辑器上的使用.md","raw":"---\ntitle: SVN工具在编辑器上的使用\ndate: 2020-05-12 13:39:52\ntags:\n - 代码管理\ncategories: 开发工具\n---\n方便SVNcommit和update\n---\n\n## 2020/5/13 10:53 Write\n\n关键词：SVN\n\n在WebStorm上配置SVN，方便操作\n\n## 1.\n![SVN操作1](SVN-1.png)\n---\n## 2.\n![SVN操作2](SVN-2.png)\n---\n## 3.\n![SVN操作3](SVN-3.png)\n\n参考链接：https://blog.csdn.net/yaomengzhi/article/details/80723925","slug":"SVN工具在编辑器上的使用","published":1,"updated":"2020-05-14T02:40:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow376001bpcvahsf4f30n","content":"<h2 id=\"方便SVNcommit和update\"><a href=\"#方便SVNcommit和update\" class=\"headerlink\" title=\"方便SVNcommit和update\"></a>方便SVNcommit和update</h2><h2 id=\"2020-5-13-10-53-Write\"><a href=\"#2020-5-13-10-53-Write\" class=\"headerlink\" title=\"2020/5/13 10:53 Write\"></a>2020/5/13 10:53 Write</h2><p>关键词：SVN</p>\n<p>在WebStorm上配置SVN，方便操作</p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h2><h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2020/05/12/SVN%E5%B7%A5%E5%85%B7%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/SVN-1.png\" alt=\"SVN操作1\"></h2><h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h2><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title></a><img src=\"/2020/05/12/SVN%E5%B7%A5%E5%85%B7%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/SVN-2.png\" alt=\"SVN操作2\"></h2><h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h2><p><img src=\"/2020/05/12/SVN%E5%B7%A5%E5%85%B7%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/SVN-3.png\" alt=\"SVN操作3\"></p>\n<p>参考链接：<a href=\"https://blog.csdn.net/yaomengzhi/article/details/80723925\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yaomengzhi/article/details/80723925</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"方便SVNcommit和update\"><a href=\"#方便SVNcommit和update\" class=\"headerlink\" title=\"方便SVNcommit和update\"></a>方便SVNcommit和update</h2><h2 id=\"2020-5-13-10-53-Write\"><a href=\"#2020-5-13-10-53-Write\" class=\"headerlink\" title=\"2020/5/13 10:53 Write\"></a>2020/5/13 10:53 Write</h2><p>关键词：SVN</p>\n<p>在WebStorm上配置SVN，方便操作</p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h2><h2 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2020/05/12/SVN%E5%B7%A5%E5%85%B7%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/SVN-1.png\" alt=\"SVN操作1\"></h2><h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h2><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title></a><img src=\"/2020/05/12/SVN%E5%B7%A5%E5%85%B7%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/SVN-2.png\" alt=\"SVN操作2\"></h2><h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h2><p><img src=\"/2020/05/12/SVN%E5%B7%A5%E5%85%B7%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/SVN-3.png\" alt=\"SVN操作3\"></p>\n<p>参考链接：<a href=\"https://blog.csdn.net/yaomengzhi/article/details/80723925\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yaomengzhi/article/details/80723925</a></p>\n"},{"title":"Vue开发","date":"2020-05-26T06:50:00.000Z","_content":"This is my vue develop exprience~\n---\n## 2020/5/7 16:02 Write\n\n过往项目经验总结\n\n关键词：Vue，CSS，SVN，WebPack，IconFont，Flex，Jeecg，Iview，ElementUI\n\n```bash\n使用Vue开发页面，环境配置，导入包，Package，使用IView组件进行页面开发。\n（使用开源组件一定需要查看开发文档！！！！！！）\nCSS排版布局，flex学习并使用，各种定位的深入了解。\nrouter路由在Vue当中的使用，熟练使用组件进行开发。\n熟练使用SVN进行提交和更新代码，提交需要带钩子，如果本地有更改过的文件，在更新时需要将有改动的文件删除再更新，否则会出现乱码\n父子组件间的传值通信，Props的使用，对话框的熟练使用。\n分析需求并设计页面，使用Axure进行页面的设计，使用开源的移动端组件和阿里的IconFont，必要时可以自行设计组件。\n熟悉WebPack框架和Cli脚手架。\n```\n---\n\n```bash\n使用ant-design-jeecg-vue进行开发，代码自动生成。文档链接：[jeecg开发文档](\"http://doc.jeecg.com/1273969\")\n该框架生成的代码由ElementUI组件组成。\n考虑页面的逻辑和合理性。\n弹框嵌套，需要注意层级。\n```\n\n---\n\n\n## 2020/5/7 10:33 Write\n\n使用Vue进行对应页面开发\n\n```bash\n使用elementUI进行页面的开发，使用Upload上传文件，自带判断文件后缀。\n使用POST方法，带FormData参数，使用Append添加序列，需要New一个FormData对象，然后进行传参。\n使用Dialog组件，显示设备详情，点击跳出，准备参析路由。\nGET方法带的参数只有Params对象。跟在URL后面。\nPOST和GET不同：//都为TCP链接，并无差别。\n参数格式不同以外，参数的大小也不同。因为服务器的处理方式不同，不一定能接受到数据（request body的数据）。\n由于HTTP的规定和浏览器/服务器的限制，应用过程体型出不同。\nGET产生一个TCP数据包，POST产生两个TCP数据包。\nGET，header和data一起发过去，响应200。（返回数据）\nPOST，先发送header，服务器响应continue，再发送data，响应200。（ 返回数据）\n```\n\n---\n\n## 2020/5/7 15:53 Write\n\n使用Element组件遇到的问题~\n\n```bash\n使用elementUI的UpLoad组件上传xls文件，需要注意文件格式和文件获取\n组件自带上传，可以设置header和数据的name，需要注意Token或者Cookie\n组件获取文件的方式   this.$refs.{upload}（这是关联upload组件的ref名称）.$data.uploadFiles\n注意dialog组件的visible显示值设置\n详细查看开发文档！！！！！必要时进行测试获取信息！！\n```\n\n---\n\n## 2020/5/8 9:38 Write\n\n使用SVN合并代码，并开发模式遇到问题\n\n```bash\n将文件checkout在其他文件夹里，然后修改原代码文件。\n多注意NetWork中请求的格式，请求的参数格式！！！！\n其中GET方式的URL会随参数改变，POST方式不会。\n使用POSTMan测试。\n接口文档管理有使用到SWAGGER和小幺鸡~\n```\n\n---\n\n## 2020/5/9 9:53 Write\n\n总结工作经验，编写简历\n\n---\n\n```bash\nVue的两种路由模式：Hash和History模式\nhash：默认模式\n常用NewURL和OldURL来改变链接，动态页面数据。hash值发生变化的时候，会触发hashchange这个时间，通过该事件监听hashchange来实现更新页面部分内容。\nHistory模式：\n切换历史状态，back，forward，go三个方法，刷新页面会请求服务器。History模式需要避免刷新。刷新时如果没有相应的响应或者资源，会刷新出404。\n```\n---\n\n```bash\n同事开发地图，使用蜂鸟地图插件。经过询问得知，正在研究。\n```\n---\n```bash\n回温Vue文档。查看生命周期。\nbeforeCreate()->created()->beforeMount()->mounted()->beforeUpdate()->updated()->beforeDestroy()->destoryed()//函数调用顺序，中间各有过程\n周期如下图\n```\n![vue](vue.png)\n```bash\n在使用ElementUI的Upload上传文件时，action的动态响应是在上传后执行的，所以需要给上传方法设置延时器，并且用到this上下文的时候，需要将this传到该函数内使用，否则会报错。\n上传可以设置header的值，在初始化的时候获取token：this.header = {token:`${this.$cookie.get('token')}`}\n设置的header是一个对象，给header的token属性赋值，要求上传成功后自动关闭对话框，然后清除选择文件数据：this.$refs.upload.clearFiles();\n需要考虑功能全面，合理\n```\n---\n```bash\nvue中数据异步渲染，数据响应式为Vue 的重要核心，在数据变更后，可能DOM还未更新，所以可以调用nextTick（callback）函数，这样回调函数将在DOM更新完后被调用。并且this会绑定到当前的vue实例上。\n同域：域名、端口、协议均相同，缺一不可。\n跨域：浏览器从一个域名的网页去请求另一个域名的资源时，不同域，就是跨域。//可能会被另一个域保存Cookie或session用来对同域网站发起非法操作，为CSRF攻击，盗用身份。\n解决方法：JSONP，CORS。//https://www.jianshu.com/p/f880878c1398(参考)\n使用FileZilla Client进行网页部署，连接到服务器，将右边框内dist文件删除，从左边框内选择本体文件，然后右键上传。\n```\n---\n\nVue加载本地图片失败，无法使用相对路径。\n//使用绝对路径 :src=\"'https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg'\"\n//使用require :src=\"require('@/assets/images/icon/file/jpg.png')\"\n//使用import   import jpg from '@/assets/images/icon/file/jpg.png'\nVue使用vue-awesome\n//执行指令 npm install vue-awesome\n//在main.js文件下 import 'vue-awesome' || import Icon from 'vue-awesome/components/Icon'\n//Vue.component('icon',Icon)  然后正常使用  <icon name=”beer”></icon>\nVue使用Iconfont\n//选择Icon加入购物车，并且下载源码\n//执行命令npm install css-loader -D(否则会报错）\n//在main.js文件中引入 import '@/assets/Iconfont/iconfont.css'!!!!!注意这里使用@，绝对路径\n//直接使用<i class=\"iconfont icon-MV\" style=\"color: white\"></i>  在iconfont.json文件中查看各个icon的fontclass\nVue行内写hover样式\n//onmouseover=\"this.style.color='#57EDED'\"!!由于无法实现hover，使用js事件实现，并且在参数边要加引号''\n//改变光标形状为小手:cursor='pointer'\nVue点击跳转链接\n//如果不写协议，会自动在链接前加上localhost:8080(相当于一个相对路径)\nCSS3 animaiton 实现图片旋转\n//animation: 15s linear 0s normal none infinite rotate;\n//animation-play-state: running;\nVue导入本地音频文件\n//文件放入static文件里，无需改变任何Webpack配置，直接引入\n//引入写法：mp3Url:\"static/attack音D.mp3\"\nVue js将小数转为整数值\n//toFixed(2) 后面的数值代表保留两位小数\nVue 将字符串转化为数值\n//parseInt(str) 如果是浮点数，将Int改成float即可\nVue 实现进度条\n// element UI 放置 el-progress   :percentage=\"mp3width\" 设置percentage为数值变量\n// 实现函数LoadProgress 通过setInterval改变mp3width的值（浮点数）\n//使用el-slide,可以实现点击和拖拽\n//需要注意函数运行速度，存在未取到值而后直接进行计算\nVue注意事项\n//开发到后发现，需要通过数据关联来通过子组件控制父组件。\n//还有一些加载速度，值得优化和注意。\nVue遇到组件通信问题\n//尽量减少组件层数，如果在同一层父组件时，子组件可以一起和父组件通信，获得数据共享。\n\n---\n\n深入响应式原理，vue的核心。\n当一个对象在实例化中的data选项，Vue将遍历此对象所有的property，转为getter和setter。\n每个组件实例都对应有一个watcher实例，在渲染过程中把数据property记录为依赖，之后当setter触发时，会通知watcher，使关联的组件重新渲染。\n注意：当数据在data选项外时，为非响应式！！！\n数组的长度和直接利用索引直接设置的数据都不是响应性的，这时可以使用set方法，使用index和数组的子项更新数据。\nvue提前声明所有的响应式property。\nVue在更新DOM时是异步执行的，侦听到数据变化时，将开启一个队列，缓冲在同一事件循环中发生的所有数据变更。\n使用原生html，js，css开发文书模板。\nbody{padding:0px;margin:0px} //适应浏览器，无白边\n使用占位符，空格（&nbsp），后用正则表达式替换。\ntext-align:justify;// 文字两端对齐\nmargin:0 auto;// 左右对齐\nwhite-space:normal// 文字换行,元素空白处理\ndiv的使用和flex的合理使用\n---\n\n使用远程桌面连接部署，Windows+r运行 mstsc\n输入用户名和密码，连接\n然后将本地的文件复制并粘贴部署到连接的服务器上\n\n---\n\n## 开源项目Vue-element-admin\n权限验证：根据用户登录的role去判断角色请求路由表，动态生成可访问页面。路由挂载。\n指令权限：通过封装方法，判断角色权限，类似于V-if，不同角色能看到的操作不同。\nspa(single page web application 单页面开发)//科普\n路由：分动态和静态路由，主要需要注意引入和使用到的地方，需要快速定位代码中使用路由的位置，研究动态路由的实现。\n在文件夹中选择find in path 在所有文件中查询使用的地方\n将router的path改为“/”为默认跳转的第一页面\nvue有三类路由钩子\n1.全局钩子  调用router.beforeEach和.afterEach函数 其中next，to中如果带参数，会导致回调，要避免死循环。\n2.某个路由的钩子\n3.组件内钩子\nVuex使用和了解\n```bash\n//State\ncomputed: {\n    count () {\n      return this.$store.state.count//一般如此调用store的数据\n    }，\n...mapState({ //或者通过mapState函数，批量获取\n      sidebar: state => state.app.sidebar,\n      device: state => state.app.device,\n      showSettings: state => state.settings.showSettings,\n      needTagsView: state => state.settings.tagsView,\n      fixedHeader: state => state.settings.fixedHeader\n    }),\n  }\n//Getter\n getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)//返回处理过的数据\n       return this.$store.getters.doneTodosCount//直接返回函数运行后返回的对象\n    }\n  sidebar: state => state.app.sidebar,\n  size: state => state.app.size,\n  device: state => state.app.device\n}\ncomputed: { //依旧在computed辅助函数里调用，mapGetters函数\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n//mutation 相当于函数，用于改变state的值\nstore.commit('increment')//调用mutation handler方式\n// ...\nmutations: {//mutation函数，限制函数同步执行\n  increment (state, n) {//可以传值\n    state.count += n\n  }\n}\nstore.commit('increment', 10)//传入值10\nmutations: {\n  increment (state, payload) { //一般是传入一个对象\n    state.count += payload.amount\n  }\n}\nconst mutations = {\n  SET_TOKEN: (state, token) => { //使用常量来定义函数名\n    state.token = token\n  },\n  SET_INTRODUCTION: (state, introduction) => {//同上\n    state.introduction = introduction\n  }\n}\ncommit('SET_ROLES', roles)//调用时\ncommit('SET_NAME', name)\n//action 类似于mutation，可以在其中调用mutation，可以内部执行异步操作\nactions: { //action函数接受一个与store实例具有相同方法和属性的context对象，可以通过该对象获取state和gettersstore.dispatch('increment')\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\nstore.dispatch('increment')//action函数通过dispatch方法触发\n//在action中有设计到登录操作，调用异步API和分发多重mutation\n也可使用mapAction\n//Module 用于将store分割成模块，每个模块拥有自己的state，mutation，action，getter，从上到下分割\n在状态数较大时可以使用，避免臃肿。\n设置Namespaced：true，使其成为带命名空间的模块，避免冲命名污染。\n在全局命名空间内分发action或提交mutation，将root：true作为第三参数传给dispatch或commit，直接访问到root下的函数（数据）。\n```\n---\n可以在assets文件中放置css文件，或者一些静态文件。在main.js引入，全局调用。\n路由在跳转的时候可以传递参数，有三种方式：\n方案1\n```bash\nthis.$router.push({//使用方法\n    path: `/describe/${id}`,\n)}\n{//对应配置的路由\n  path:'/describe/:id',\n  name: 'Describe',\n  component: Describe\n}\nthis.$route.params.id//调用方法\n```\n方案二\n```bash\nthis.$router.push({//使用方法\n    name: 'Describe',\n    params: {\n      id: id\n   }\n})\n//路由正常配置\n$route.params.id//调用方法\n```\n方案三\n```bash\nthis.$router.push({//使用方法\n  path: '/describe',\n  query: {\n    id: id\n  }\n})\n$route.query.id//调用方法\n```\n---\n项目菜单栏：通过多个组件组成，使用el-scrollbar组件（在element文档没有标注）\n包裹el-menu，自定义sidebar-item组件使用v-for动态生成多个子项，通过v-if来判断子项显示模式，使用render函数返回item组件作为menuitem，使用link组件（通过：is来判断标签类型，v-bind绑定跳转链接）包裹item来作为跳转链接。\nmixins混入的使用，其中有函数，数据，并且在每个组件混入的数据都是独立的。（主要作用：代码复用，减少冗余），其中在mixins里的函数命名必须带$_避免引入组件中函数名重复。\nscss文件引入其他scss文件，可以调用类型，但无法调用里面的属性和mixins，在main.js引入就可以全局调用，包括引入文件中已经引入的文件。\nItem组件使用render函数返回的原因（性能问题）\ncss3的使用，美化页面。\n---\nv-for的使用，需要一个参数（item,i）in（数组或对象）,可以生成多个。\n布局注意，P标签自占高度，使用a标签，display：block，块级元素，就可以调整高度了。canvas的使用需要研究，图形实现的好方法。\n安装prettier自动代码格式化。\n通过ps打开图片获取颜色和像素。\n---\nVue项目不同环境打包指令和配置\n1.env.js文件中各自有\n```bash\n'use strict'\nmodule.exports = {\n NODE_ENV: '\"production（生产）\"',//testing（测试）,development（开发）\n EVN_CONFIG:'\"prod\"',//test,dev\n API_ROOT:'\"/apis/v1\"'//api代理地址\n}\n```\n2.还需修改package.json文件\n```bash\n\"scripts\": {\n  \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n  \"start\": \"npm run dev\",\n  \"build\": \"node build/build.js\",\n  \"build:test\": \"cross-env NODE_ENV=production env_config=test node build/build.js\",\n  \"build:pre\": \"cross-env NODE_ENV=production env_config=pre node build/build.js\",\n  \"build:prod\": \"cross-env NODE_ENV=production env_config=prod node build/build.js\"\n }\n```\n3.修改config/index.js\n```bash\nbuild:{\n  // Template for index.html\n  // 添加test pre prod 三处环境的配制\n  prodEnv: require('./prod.env'),\n  preEnv: require('./pre.env'),\n  testEnv: require('./test.env')\n}\n```\n4.在webpackage.pro.conf.js中使用构建环境参数\n```bash\n// 个性env常量的定义\n// const env = require('../config/prod.env')\nconst env = config.build[process.env.env_config+'Env']\n```\n5.build.js文件修改\n```bash\n'use strict'\nrequire('./check-versions')()\n// 注释掉的代码\n// process.env.NODE_ENV = 'production'\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n// 修改spinner的定义\n// const spinner = ora('building for production...')\nvar spinner = ora('building for ' + process.env.NODE_ENV + ' of ' + process.env.env_config+ ' mode...' )\nspinner.start()\n//更多的其它内容，不需要做任何调整的内容 ...\n```\n6.打包指令\nnpm run build:test//测试环境\nnpm run build:prod//生产环境\n以此类推\n---\n异步加载：async,defer,动态创建script标签\n异步任务：promise，async\n---\n8中数据类型分别是：\nNumber，String，Boolean，Null，undefined，object（data，function，array），symbol，bigInt\nNull只有一个值，是null，不存在的对象。\nUndefined只有一个值，是undefined，没有初始化，undefined是从null中派生出来的。\nUndefined是没有定义的，null定义了但是为空。\n基本类型的变量是存放在栈内存（stack）里的\n基本类型的值是按值访问的\n基本类型的值是不可变的\n基本类型的比较是它们的值的比较\n类型方法\n运算符优先级[参考链接表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n---\n柯里化：接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下参数并且返回结果的新函数。\n```bash\n// 普通的add函数\nfunction add(x, y) {\n    return x + y\n}\n\n// Currying后\nfunction curryingAdd(x) {\n    return function (y) {\n        return x + y\n    }\n}\n```\n---\n数组常用方法（array）：\n1.concat（arrA，arrB，...）//合并数组\n2. arr.join（separator）//数组转字符串\n3.arr.toString //无参数，转字符串\n4.arr.toLocaleString//以逗号隔开输出\n5.arr.slice（start，end）//截取数组\n6.arr.splice（index，many，【item1】）//数组删除/添加\n7.arr.unshift（x,y）//头部增加\n8.arr.shitf（）//头部删除\n9.arr.push(x,y)//尾部增加\n10.arr.pop()//尾部删除\n11.arr.sort(sortby) //按字符编码进行排序\n12.arr.reverse（）//数组颠倒\n13.arr.filter()//数组过滤\n字符串常用方法（string）：\n1.str.charAt(index)//返回指定位置的（字符）！！\n2.str.indexOf(value,[index])//从index找，返回value第一次出现的下标\n3.str.match（value）//存放匹配结果的数组\n4.str.split(separator,[many])//数组在separator指定的边界处分割字符串\n5.str.search(str)//第一个与str匹配的子串起始位置\n6.str.slice(start,end)//按下标截取字符串\n7.str.substr(start,[length])//返回从start开始的len个字符\n8.str.substring（start,[stop]）//提取start到stop的字符串\n9.str.concat(x,y,z)//连接字符串\n10.str.replace(substr,replacement)//替换字符串中的部分\n11.str.toLowerCase()//变小写\n12.str.toUpperCase()//变大写\n数组循环方法：\nforEach(),for-of\n---\n引用类型：\nObject，Array，RegExp，Date，Function\n引用类型的值是保存在堆内存（heap）中的对象（object）\n引用类型的值是按引用访问的\n引用类型的值是可变的\n引用类型的比较是引用的比较\n---\n深浅拷贝\n浅拷贝为引用，深拷贝为创建一个相同的新对象。\n---\n异步和同步\n1.同步任务在主线程上形成一个执行栈\n2.主线程外还有一个任务队列\n3.一旦“执行栈”里的任务执行完毕，系统会读取任务队列里的任务执行\n4.主线程重复以上三个步骤\nheap（堆）stack（栈）\n任务队列中可以放置定时事件（setTimeout，setInterval）\n定时器将事件插入任务队列，等执行栈执行完才能去执行指定的回调函数\n---\n使用setInterval()循环，在mounted函数中使用。\n```bash\ndata:{timer:''}\nthis.timer = setInterval(()=>{此处写函数},3000)//1000为1s\nbeforeDestroy(){\n  clearInterval(this.timer)//在页面销毁前关闭计时器\n}\n```\n---\n### 使用store\n创建新文件timer.js用来设置计时器\n在index.js主store中引入\n```bash\nimport timer from './modules/timer'\nconst store = new Vuex.Store({\n     modules:{\n        timer\n     }\n})\nexport default store //暴露，可以外部引入\n```\n在js文件中，需要引入store ///import store from './store'\n直接调用store即可// store.state.clock//store.commit('set_clock',1)\n在组件当中调用//this.$store.dispatch对应action（异步）\n//this.$store.state对应对象\n//this.$store.commit对应mutation（同步）!!只有mutation可以改变状态\n//this.$store.getters对应getter //挂载数据计算功能（里面可有数据计算函数）\n---\n路由监听：\npermission文件当中使用的this.$router.beforeEach(to,from,next)=>{}是全局监听路由的方法\nvue页面中有三种监听路由的方法：\n```bash\n1.watch:{\n   $route:{\n      handler(val,oldval){\n        console.log(val);//新路由信息\n        console.log(oldval);//老路由信息\n      }\n      deep:true//深度观察监听\n   }\n}\n2.watch:{\n  $route(to,from){\n    console.log(from.path)//从哪来\n    console.log(to.path)//到哪去\n  }\n}\n3.methods:{\n  getpath(){\n    console.log(111)\n  }\n}\nwatch:{\n   '$route':'getPath'\n}\n```\njs数组对象为指针，修改需要深拷贝，否则会修改原数据\n防抖：防止按钮多次点击\n封装防抖函数：debounce.js\nlet timeout = null\nfunction bounce(fn,wait) {\n  if(timeout !== null) clearTimeout(timeout)\n  timeout = setTimeout(fn,wait)\n}\n引入(import)并使用\nbounce(()=>{function},1000)\n数组深拷贝：\n1.concat():\nlet copyArray = [].concat(array)\n2.slice(idx1,idx2)\nlet copyArray = [].slice()//无参为拷贝数组\n---\n逻辑梳理，设计模式，需求合理，可维护性\n在写api请求的时候，可以使用promise与async await同步操作\n并且可以后续抓错处理\n\njs中Set类型的使用：\nSet类型带有的函数\nlet num = new Set() //初始化  typeof num为object\nnum.add()// 添加元素的函数\nnum.size //set类型的长度\nset类型无法添加重复的元素 //利用这点可以数组去重\nlet array = [...num] || num = new Set(array)//数组与set的转换\nnum.has() //Set类型用来判断一个值是否在set中\nnum.delete() //Set类型用来删除在set中的值\nnum.clear()//Set类型清空所有的值\nSet类型的遍历方式\nnum.forEach(function(value){}) // forEach\nfor(val of num){} // for...of\njs中的遍历函数：\nArray.map(value,index,array){} //map函数，有元素值，元素下标，数组三个参数，针对每个元素处理，原数组不变，最后返回一个新数组\nArray.forEach(value,index,array){}//forEach函数，参数如上，无返回值，原数组不变\nArray.filter(value,index,array){}//filter函数,参数如上,针对每个元素，判断条件返回元素，返回新数组，原数组不变\nArray.some(),Array.every()//对所有数组成员依次执行函数，返回布尔值,用作数组满足条件判断\nArray.some(function callback(value,index,arr){})//调用filter的数组\nArray.some()如果一个成员满足条件则返回true，Array.every()需要全部成员满足条件才返回true,原数组都不变\nArray.reduce() //使用函数依次处理每个成员，最终返回一个值\nreduce(callback(previousValue,currentValue,currentIndex,array){函数},initialValue)// previousValue:上一次遍历后提供的值，最开始为初始值:initialValue\n遍历函数的区别与总结：\nmap()： 在处理函数中将返回值组成一个新的数组返回，原数组(arr)保持不变。\nforEach()： 没有返回值，即使处理函数中设置了return也无效，原数组(arr)保持不变。\nfilter()： 判断处理函数中的返回值是否为true，将返回为true的数组元素(该元素为最原始的数组元素)组成一个新的数组返回，原数组(arr)保持不变。\nsome()与every()： 判断处理函数中的返回值是否为true，如果有一个成员返回值为true，则some()返回true；如果所有成员返回值都为true，则every()返回true，原数组(arr)保持不变。\nreduce()： 返回值会被记住，并且在遍历下一个元素中可以被调用，最后返回单个结果值，原数组(arr)保持不变\n设计模式对代码设计有着非常大的作用，尽快学习。\n循环机制->同步异步->函数运行机制->执行栈宏任务(Macro)微任务(Micro)\n宏任务：script(整体代码)，setTimeout,setInterval,I/O,UI交互事件，setImmediate(Node.js)\n微任务：Promise,MutaionObserver,process.nextTick(Node.js)\n---\n父子组件传值\n父向子传值：单向绑定，父传过来的值无法在子组件中更改。\n1.v-bind props\n{\nfooA:Number //只接受数值类型的参数\nfooB:[String,Number] //可以接受字符串和数值类型的参数\nfooC:{type:String,required:true} //可以接受字符串的类型，参数必须传入\nfooD:{type:Number,default:100} //接受数值类型的参数，默认值为100\nfooE:{type:Object,default:()=>{return{message:''}};//当为对象类型时设置默认值必须使用函数返回\nfooF:{validator:function(value){return value >= 0 && value <= 100;}}//使用一个自定义的验证器\nfooG:{type:Array,default:function(){return[]}}// 当为数值类型设置默认值时必须使用数组返回\n}\n---\n利用$refs\nref=\"home\" //调用子组件函数获值\nthis.$refs.home.setMsg(this.mgs)//父\nsetMsg(val){this.msg = val}//子\n---\n子向父传值： v-on $emit\nthis.$emit(\"receive\",\"value\")//子组件\n@receive=\"receive\"\nmethods:{receive(val){}}\n---\n利用$parent\nsetMsg(){this.$parent.toValue(this.msg)} //子\ntoValue(val){this.msg = val} //父\n---\n爷传孙:props\n:mgs=\"msg\"//爷\nv-bind=\"$attrs\"//父\nprops:{mgs:String}//子\n---\n孙传爷\nthis.$emit(\"setVal\",this.msg)//孙\nv-on=\"$listeners\"//父\n@setVal=\"setVal\" setVal(val){this.msg = val}\n---\n祖组件传后代组件:要求值必须为对象!!!\nprovide(){return {data:this.dataObj}}//与data同级,祖组件\ninject:['data'],computed:{()=>{return'${this.data.msg}&{this.data.num}'}}\n---\n兄弟组件传值(store)\nEventBus可用，调用完必须销毁，否则出bug。\n---\napply:传入两个参数，一个参数数组，一个运行环境，默认Window。\ncall:传入多个参数，一个 运行环境，其他为参数。\nbind:使用多加（），绑定上下文。\n三个函数皆为改变上下文this的函数\n多熟悉组件间通信，路由间通信。\n### 持续进行编写和开发，经验保存\n后续将CSDN博客中的经验总结并转移，并学习更多HEXO使用方式和编写方式","source":"_posts/Vue开发.md","raw":"---\ntitle: Vue开发\ndate: 2020-05-26 14:50\ntags:\n - 前端框架\ncategories: Web前端\n---\nThis is my vue develop exprience~\n---\n## 2020/5/7 16:02 Write\n\n过往项目经验总结\n\n关键词：Vue，CSS，SVN，WebPack，IconFont，Flex，Jeecg，Iview，ElementUI\n\n```bash\n使用Vue开发页面，环境配置，导入包，Package，使用IView组件进行页面开发。\n（使用开源组件一定需要查看开发文档！！！！！！）\nCSS排版布局，flex学习并使用，各种定位的深入了解。\nrouter路由在Vue当中的使用，熟练使用组件进行开发。\n熟练使用SVN进行提交和更新代码，提交需要带钩子，如果本地有更改过的文件，在更新时需要将有改动的文件删除再更新，否则会出现乱码\n父子组件间的传值通信，Props的使用，对话框的熟练使用。\n分析需求并设计页面，使用Axure进行页面的设计，使用开源的移动端组件和阿里的IconFont，必要时可以自行设计组件。\n熟悉WebPack框架和Cli脚手架。\n```\n---\n\n```bash\n使用ant-design-jeecg-vue进行开发，代码自动生成。文档链接：[jeecg开发文档](\"http://doc.jeecg.com/1273969\")\n该框架生成的代码由ElementUI组件组成。\n考虑页面的逻辑和合理性。\n弹框嵌套，需要注意层级。\n```\n\n---\n\n\n## 2020/5/7 10:33 Write\n\n使用Vue进行对应页面开发\n\n```bash\n使用elementUI进行页面的开发，使用Upload上传文件，自带判断文件后缀。\n使用POST方法，带FormData参数，使用Append添加序列，需要New一个FormData对象，然后进行传参。\n使用Dialog组件，显示设备详情，点击跳出，准备参析路由。\nGET方法带的参数只有Params对象。跟在URL后面。\nPOST和GET不同：//都为TCP链接，并无差别。\n参数格式不同以外，参数的大小也不同。因为服务器的处理方式不同，不一定能接受到数据（request body的数据）。\n由于HTTP的规定和浏览器/服务器的限制，应用过程体型出不同。\nGET产生一个TCP数据包，POST产生两个TCP数据包。\nGET，header和data一起发过去，响应200。（返回数据）\nPOST，先发送header，服务器响应continue，再发送data，响应200。（ 返回数据）\n```\n\n---\n\n## 2020/5/7 15:53 Write\n\n使用Element组件遇到的问题~\n\n```bash\n使用elementUI的UpLoad组件上传xls文件，需要注意文件格式和文件获取\n组件自带上传，可以设置header和数据的name，需要注意Token或者Cookie\n组件获取文件的方式   this.$refs.{upload}（这是关联upload组件的ref名称）.$data.uploadFiles\n注意dialog组件的visible显示值设置\n详细查看开发文档！！！！！必要时进行测试获取信息！！\n```\n\n---\n\n## 2020/5/8 9:38 Write\n\n使用SVN合并代码，并开发模式遇到问题\n\n```bash\n将文件checkout在其他文件夹里，然后修改原代码文件。\n多注意NetWork中请求的格式，请求的参数格式！！！！\n其中GET方式的URL会随参数改变，POST方式不会。\n使用POSTMan测试。\n接口文档管理有使用到SWAGGER和小幺鸡~\n```\n\n---\n\n## 2020/5/9 9:53 Write\n\n总结工作经验，编写简历\n\n---\n\n```bash\nVue的两种路由模式：Hash和History模式\nhash：默认模式\n常用NewURL和OldURL来改变链接，动态页面数据。hash值发生变化的时候，会触发hashchange这个时间，通过该事件监听hashchange来实现更新页面部分内容。\nHistory模式：\n切换历史状态，back，forward，go三个方法，刷新页面会请求服务器。History模式需要避免刷新。刷新时如果没有相应的响应或者资源，会刷新出404。\n```\n---\n\n```bash\n同事开发地图，使用蜂鸟地图插件。经过询问得知，正在研究。\n```\n---\n```bash\n回温Vue文档。查看生命周期。\nbeforeCreate()->created()->beforeMount()->mounted()->beforeUpdate()->updated()->beforeDestroy()->destoryed()//函数调用顺序，中间各有过程\n周期如下图\n```\n![vue](vue.png)\n```bash\n在使用ElementUI的Upload上传文件时，action的动态响应是在上传后执行的，所以需要给上传方法设置延时器，并且用到this上下文的时候，需要将this传到该函数内使用，否则会报错。\n上传可以设置header的值，在初始化的时候获取token：this.header = {token:`${this.$cookie.get('token')}`}\n设置的header是一个对象，给header的token属性赋值，要求上传成功后自动关闭对话框，然后清除选择文件数据：this.$refs.upload.clearFiles();\n需要考虑功能全面，合理\n```\n---\n```bash\nvue中数据异步渲染，数据响应式为Vue 的重要核心，在数据变更后，可能DOM还未更新，所以可以调用nextTick（callback）函数，这样回调函数将在DOM更新完后被调用。并且this会绑定到当前的vue实例上。\n同域：域名、端口、协议均相同，缺一不可。\n跨域：浏览器从一个域名的网页去请求另一个域名的资源时，不同域，就是跨域。//可能会被另一个域保存Cookie或session用来对同域网站发起非法操作，为CSRF攻击，盗用身份。\n解决方法：JSONP，CORS。//https://www.jianshu.com/p/f880878c1398(参考)\n使用FileZilla Client进行网页部署，连接到服务器，将右边框内dist文件删除，从左边框内选择本体文件，然后右键上传。\n```\n---\n\nVue加载本地图片失败，无法使用相对路径。\n//使用绝对路径 :src=\"'https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg'\"\n//使用require :src=\"require('@/assets/images/icon/file/jpg.png')\"\n//使用import   import jpg from '@/assets/images/icon/file/jpg.png'\nVue使用vue-awesome\n//执行指令 npm install vue-awesome\n//在main.js文件下 import 'vue-awesome' || import Icon from 'vue-awesome/components/Icon'\n//Vue.component('icon',Icon)  然后正常使用  <icon name=”beer”></icon>\nVue使用Iconfont\n//选择Icon加入购物车，并且下载源码\n//执行命令npm install css-loader -D(否则会报错）\n//在main.js文件中引入 import '@/assets/Iconfont/iconfont.css'!!!!!注意这里使用@，绝对路径\n//直接使用<i class=\"iconfont icon-MV\" style=\"color: white\"></i>  在iconfont.json文件中查看各个icon的fontclass\nVue行内写hover样式\n//onmouseover=\"this.style.color='#57EDED'\"!!由于无法实现hover，使用js事件实现，并且在参数边要加引号''\n//改变光标形状为小手:cursor='pointer'\nVue点击跳转链接\n//如果不写协议，会自动在链接前加上localhost:8080(相当于一个相对路径)\nCSS3 animaiton 实现图片旋转\n//animation: 15s linear 0s normal none infinite rotate;\n//animation-play-state: running;\nVue导入本地音频文件\n//文件放入static文件里，无需改变任何Webpack配置，直接引入\n//引入写法：mp3Url:\"static/attack音D.mp3\"\nVue js将小数转为整数值\n//toFixed(2) 后面的数值代表保留两位小数\nVue 将字符串转化为数值\n//parseInt(str) 如果是浮点数，将Int改成float即可\nVue 实现进度条\n// element UI 放置 el-progress   :percentage=\"mp3width\" 设置percentage为数值变量\n// 实现函数LoadProgress 通过setInterval改变mp3width的值（浮点数）\n//使用el-slide,可以实现点击和拖拽\n//需要注意函数运行速度，存在未取到值而后直接进行计算\nVue注意事项\n//开发到后发现，需要通过数据关联来通过子组件控制父组件。\n//还有一些加载速度，值得优化和注意。\nVue遇到组件通信问题\n//尽量减少组件层数，如果在同一层父组件时，子组件可以一起和父组件通信，获得数据共享。\n\n---\n\n深入响应式原理，vue的核心。\n当一个对象在实例化中的data选项，Vue将遍历此对象所有的property，转为getter和setter。\n每个组件实例都对应有一个watcher实例，在渲染过程中把数据property记录为依赖，之后当setter触发时，会通知watcher，使关联的组件重新渲染。\n注意：当数据在data选项外时，为非响应式！！！\n数组的长度和直接利用索引直接设置的数据都不是响应性的，这时可以使用set方法，使用index和数组的子项更新数据。\nvue提前声明所有的响应式property。\nVue在更新DOM时是异步执行的，侦听到数据变化时，将开启一个队列，缓冲在同一事件循环中发生的所有数据变更。\n使用原生html，js，css开发文书模板。\nbody{padding:0px;margin:0px} //适应浏览器，无白边\n使用占位符，空格（&nbsp），后用正则表达式替换。\ntext-align:justify;// 文字两端对齐\nmargin:0 auto;// 左右对齐\nwhite-space:normal// 文字换行,元素空白处理\ndiv的使用和flex的合理使用\n---\n\n使用远程桌面连接部署，Windows+r运行 mstsc\n输入用户名和密码，连接\n然后将本地的文件复制并粘贴部署到连接的服务器上\n\n---\n\n## 开源项目Vue-element-admin\n权限验证：根据用户登录的role去判断角色请求路由表，动态生成可访问页面。路由挂载。\n指令权限：通过封装方法，判断角色权限，类似于V-if，不同角色能看到的操作不同。\nspa(single page web application 单页面开发)//科普\n路由：分动态和静态路由，主要需要注意引入和使用到的地方，需要快速定位代码中使用路由的位置，研究动态路由的实现。\n在文件夹中选择find in path 在所有文件中查询使用的地方\n将router的path改为“/”为默认跳转的第一页面\nvue有三类路由钩子\n1.全局钩子  调用router.beforeEach和.afterEach函数 其中next，to中如果带参数，会导致回调，要避免死循环。\n2.某个路由的钩子\n3.组件内钩子\nVuex使用和了解\n```bash\n//State\ncomputed: {\n    count () {\n      return this.$store.state.count//一般如此调用store的数据\n    }，\n...mapState({ //或者通过mapState函数，批量获取\n      sidebar: state => state.app.sidebar,\n      device: state => state.app.device,\n      showSettings: state => state.settings.showSettings,\n      needTagsView: state => state.settings.tagsView,\n      fixedHeader: state => state.settings.fixedHeader\n    }),\n  }\n//Getter\n getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)//返回处理过的数据\n       return this.$store.getters.doneTodosCount//直接返回函数运行后返回的对象\n    }\n  sidebar: state => state.app.sidebar,\n  size: state => state.app.size,\n  device: state => state.app.device\n}\ncomputed: { //依旧在computed辅助函数里调用，mapGetters函数\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n//mutation 相当于函数，用于改变state的值\nstore.commit('increment')//调用mutation handler方式\n// ...\nmutations: {//mutation函数，限制函数同步执行\n  increment (state, n) {//可以传值\n    state.count += n\n  }\n}\nstore.commit('increment', 10)//传入值10\nmutations: {\n  increment (state, payload) { //一般是传入一个对象\n    state.count += payload.amount\n  }\n}\nconst mutations = {\n  SET_TOKEN: (state, token) => { //使用常量来定义函数名\n    state.token = token\n  },\n  SET_INTRODUCTION: (state, introduction) => {//同上\n    state.introduction = introduction\n  }\n}\ncommit('SET_ROLES', roles)//调用时\ncommit('SET_NAME', name)\n//action 类似于mutation，可以在其中调用mutation，可以内部执行异步操作\nactions: { //action函数接受一个与store实例具有相同方法和属性的context对象，可以通过该对象获取state和gettersstore.dispatch('increment')\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\nstore.dispatch('increment')//action函数通过dispatch方法触发\n//在action中有设计到登录操作，调用异步API和分发多重mutation\n也可使用mapAction\n//Module 用于将store分割成模块，每个模块拥有自己的state，mutation，action，getter，从上到下分割\n在状态数较大时可以使用，避免臃肿。\n设置Namespaced：true，使其成为带命名空间的模块，避免冲命名污染。\n在全局命名空间内分发action或提交mutation，将root：true作为第三参数传给dispatch或commit，直接访问到root下的函数（数据）。\n```\n---\n可以在assets文件中放置css文件，或者一些静态文件。在main.js引入，全局调用。\n路由在跳转的时候可以传递参数，有三种方式：\n方案1\n```bash\nthis.$router.push({//使用方法\n    path: `/describe/${id}`,\n)}\n{//对应配置的路由\n  path:'/describe/:id',\n  name: 'Describe',\n  component: Describe\n}\nthis.$route.params.id//调用方法\n```\n方案二\n```bash\nthis.$router.push({//使用方法\n    name: 'Describe',\n    params: {\n      id: id\n   }\n})\n//路由正常配置\n$route.params.id//调用方法\n```\n方案三\n```bash\nthis.$router.push({//使用方法\n  path: '/describe',\n  query: {\n    id: id\n  }\n})\n$route.query.id//调用方法\n```\n---\n项目菜单栏：通过多个组件组成，使用el-scrollbar组件（在element文档没有标注）\n包裹el-menu，自定义sidebar-item组件使用v-for动态生成多个子项，通过v-if来判断子项显示模式，使用render函数返回item组件作为menuitem，使用link组件（通过：is来判断标签类型，v-bind绑定跳转链接）包裹item来作为跳转链接。\nmixins混入的使用，其中有函数，数据，并且在每个组件混入的数据都是独立的。（主要作用：代码复用，减少冗余），其中在mixins里的函数命名必须带$_避免引入组件中函数名重复。\nscss文件引入其他scss文件，可以调用类型，但无法调用里面的属性和mixins，在main.js引入就可以全局调用，包括引入文件中已经引入的文件。\nItem组件使用render函数返回的原因（性能问题）\ncss3的使用，美化页面。\n---\nv-for的使用，需要一个参数（item,i）in（数组或对象）,可以生成多个。\n布局注意，P标签自占高度，使用a标签，display：block，块级元素，就可以调整高度了。canvas的使用需要研究，图形实现的好方法。\n安装prettier自动代码格式化。\n通过ps打开图片获取颜色和像素。\n---\nVue项目不同环境打包指令和配置\n1.env.js文件中各自有\n```bash\n'use strict'\nmodule.exports = {\n NODE_ENV: '\"production（生产）\"',//testing（测试）,development（开发）\n EVN_CONFIG:'\"prod\"',//test,dev\n API_ROOT:'\"/apis/v1\"'//api代理地址\n}\n```\n2.还需修改package.json文件\n```bash\n\"scripts\": {\n  \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n  \"start\": \"npm run dev\",\n  \"build\": \"node build/build.js\",\n  \"build:test\": \"cross-env NODE_ENV=production env_config=test node build/build.js\",\n  \"build:pre\": \"cross-env NODE_ENV=production env_config=pre node build/build.js\",\n  \"build:prod\": \"cross-env NODE_ENV=production env_config=prod node build/build.js\"\n }\n```\n3.修改config/index.js\n```bash\nbuild:{\n  // Template for index.html\n  // 添加test pre prod 三处环境的配制\n  prodEnv: require('./prod.env'),\n  preEnv: require('./pre.env'),\n  testEnv: require('./test.env')\n}\n```\n4.在webpackage.pro.conf.js中使用构建环境参数\n```bash\n// 个性env常量的定义\n// const env = require('../config/prod.env')\nconst env = config.build[process.env.env_config+'Env']\n```\n5.build.js文件修改\n```bash\n'use strict'\nrequire('./check-versions')()\n// 注释掉的代码\n// process.env.NODE_ENV = 'production'\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n// 修改spinner的定义\n// const spinner = ora('building for production...')\nvar spinner = ora('building for ' + process.env.NODE_ENV + ' of ' + process.env.env_config+ ' mode...' )\nspinner.start()\n//更多的其它内容，不需要做任何调整的内容 ...\n```\n6.打包指令\nnpm run build:test//测试环境\nnpm run build:prod//生产环境\n以此类推\n---\n异步加载：async,defer,动态创建script标签\n异步任务：promise，async\n---\n8中数据类型分别是：\nNumber，String，Boolean，Null，undefined，object（data，function，array），symbol，bigInt\nNull只有一个值，是null，不存在的对象。\nUndefined只有一个值，是undefined，没有初始化，undefined是从null中派生出来的。\nUndefined是没有定义的，null定义了但是为空。\n基本类型的变量是存放在栈内存（stack）里的\n基本类型的值是按值访问的\n基本类型的值是不可变的\n基本类型的比较是它们的值的比较\n类型方法\n运算符优先级[参考链接表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n---\n柯里化：接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下参数并且返回结果的新函数。\n```bash\n// 普通的add函数\nfunction add(x, y) {\n    return x + y\n}\n\n// Currying后\nfunction curryingAdd(x) {\n    return function (y) {\n        return x + y\n    }\n}\n```\n---\n数组常用方法（array）：\n1.concat（arrA，arrB，...）//合并数组\n2. arr.join（separator）//数组转字符串\n3.arr.toString //无参数，转字符串\n4.arr.toLocaleString//以逗号隔开输出\n5.arr.slice（start，end）//截取数组\n6.arr.splice（index，many，【item1】）//数组删除/添加\n7.arr.unshift（x,y）//头部增加\n8.arr.shitf（）//头部删除\n9.arr.push(x,y)//尾部增加\n10.arr.pop()//尾部删除\n11.arr.sort(sortby) //按字符编码进行排序\n12.arr.reverse（）//数组颠倒\n13.arr.filter()//数组过滤\n字符串常用方法（string）：\n1.str.charAt(index)//返回指定位置的（字符）！！\n2.str.indexOf(value,[index])//从index找，返回value第一次出现的下标\n3.str.match（value）//存放匹配结果的数组\n4.str.split(separator,[many])//数组在separator指定的边界处分割字符串\n5.str.search(str)//第一个与str匹配的子串起始位置\n6.str.slice(start,end)//按下标截取字符串\n7.str.substr(start,[length])//返回从start开始的len个字符\n8.str.substring（start,[stop]）//提取start到stop的字符串\n9.str.concat(x,y,z)//连接字符串\n10.str.replace(substr,replacement)//替换字符串中的部分\n11.str.toLowerCase()//变小写\n12.str.toUpperCase()//变大写\n数组循环方法：\nforEach(),for-of\n---\n引用类型：\nObject，Array，RegExp，Date，Function\n引用类型的值是保存在堆内存（heap）中的对象（object）\n引用类型的值是按引用访问的\n引用类型的值是可变的\n引用类型的比较是引用的比较\n---\n深浅拷贝\n浅拷贝为引用，深拷贝为创建一个相同的新对象。\n---\n异步和同步\n1.同步任务在主线程上形成一个执行栈\n2.主线程外还有一个任务队列\n3.一旦“执行栈”里的任务执行完毕，系统会读取任务队列里的任务执行\n4.主线程重复以上三个步骤\nheap（堆）stack（栈）\n任务队列中可以放置定时事件（setTimeout，setInterval）\n定时器将事件插入任务队列，等执行栈执行完才能去执行指定的回调函数\n---\n使用setInterval()循环，在mounted函数中使用。\n```bash\ndata:{timer:''}\nthis.timer = setInterval(()=>{此处写函数},3000)//1000为1s\nbeforeDestroy(){\n  clearInterval(this.timer)//在页面销毁前关闭计时器\n}\n```\n---\n### 使用store\n创建新文件timer.js用来设置计时器\n在index.js主store中引入\n```bash\nimport timer from './modules/timer'\nconst store = new Vuex.Store({\n     modules:{\n        timer\n     }\n})\nexport default store //暴露，可以外部引入\n```\n在js文件中，需要引入store ///import store from './store'\n直接调用store即可// store.state.clock//store.commit('set_clock',1)\n在组件当中调用//this.$store.dispatch对应action（异步）\n//this.$store.state对应对象\n//this.$store.commit对应mutation（同步）!!只有mutation可以改变状态\n//this.$store.getters对应getter //挂载数据计算功能（里面可有数据计算函数）\n---\n路由监听：\npermission文件当中使用的this.$router.beforeEach(to,from,next)=>{}是全局监听路由的方法\nvue页面中有三种监听路由的方法：\n```bash\n1.watch:{\n   $route:{\n      handler(val,oldval){\n        console.log(val);//新路由信息\n        console.log(oldval);//老路由信息\n      }\n      deep:true//深度观察监听\n   }\n}\n2.watch:{\n  $route(to,from){\n    console.log(from.path)//从哪来\n    console.log(to.path)//到哪去\n  }\n}\n3.methods:{\n  getpath(){\n    console.log(111)\n  }\n}\nwatch:{\n   '$route':'getPath'\n}\n```\njs数组对象为指针，修改需要深拷贝，否则会修改原数据\n防抖：防止按钮多次点击\n封装防抖函数：debounce.js\nlet timeout = null\nfunction bounce(fn,wait) {\n  if(timeout !== null) clearTimeout(timeout)\n  timeout = setTimeout(fn,wait)\n}\n引入(import)并使用\nbounce(()=>{function},1000)\n数组深拷贝：\n1.concat():\nlet copyArray = [].concat(array)\n2.slice(idx1,idx2)\nlet copyArray = [].slice()//无参为拷贝数组\n---\n逻辑梳理，设计模式，需求合理，可维护性\n在写api请求的时候，可以使用promise与async await同步操作\n并且可以后续抓错处理\n\njs中Set类型的使用：\nSet类型带有的函数\nlet num = new Set() //初始化  typeof num为object\nnum.add()// 添加元素的函数\nnum.size //set类型的长度\nset类型无法添加重复的元素 //利用这点可以数组去重\nlet array = [...num] || num = new Set(array)//数组与set的转换\nnum.has() //Set类型用来判断一个值是否在set中\nnum.delete() //Set类型用来删除在set中的值\nnum.clear()//Set类型清空所有的值\nSet类型的遍历方式\nnum.forEach(function(value){}) // forEach\nfor(val of num){} // for...of\njs中的遍历函数：\nArray.map(value,index,array){} //map函数，有元素值，元素下标，数组三个参数，针对每个元素处理，原数组不变，最后返回一个新数组\nArray.forEach(value,index,array){}//forEach函数，参数如上，无返回值，原数组不变\nArray.filter(value,index,array){}//filter函数,参数如上,针对每个元素，判断条件返回元素，返回新数组，原数组不变\nArray.some(),Array.every()//对所有数组成员依次执行函数，返回布尔值,用作数组满足条件判断\nArray.some(function callback(value,index,arr){})//调用filter的数组\nArray.some()如果一个成员满足条件则返回true，Array.every()需要全部成员满足条件才返回true,原数组都不变\nArray.reduce() //使用函数依次处理每个成员，最终返回一个值\nreduce(callback(previousValue,currentValue,currentIndex,array){函数},initialValue)// previousValue:上一次遍历后提供的值，最开始为初始值:initialValue\n遍历函数的区别与总结：\nmap()： 在处理函数中将返回值组成一个新的数组返回，原数组(arr)保持不变。\nforEach()： 没有返回值，即使处理函数中设置了return也无效，原数组(arr)保持不变。\nfilter()： 判断处理函数中的返回值是否为true，将返回为true的数组元素(该元素为最原始的数组元素)组成一个新的数组返回，原数组(arr)保持不变。\nsome()与every()： 判断处理函数中的返回值是否为true，如果有一个成员返回值为true，则some()返回true；如果所有成员返回值都为true，则every()返回true，原数组(arr)保持不变。\nreduce()： 返回值会被记住，并且在遍历下一个元素中可以被调用，最后返回单个结果值，原数组(arr)保持不变\n设计模式对代码设计有着非常大的作用，尽快学习。\n循环机制->同步异步->函数运行机制->执行栈宏任务(Macro)微任务(Micro)\n宏任务：script(整体代码)，setTimeout,setInterval,I/O,UI交互事件，setImmediate(Node.js)\n微任务：Promise,MutaionObserver,process.nextTick(Node.js)\n---\n父子组件传值\n父向子传值：单向绑定，父传过来的值无法在子组件中更改。\n1.v-bind props\n{\nfooA:Number //只接受数值类型的参数\nfooB:[String,Number] //可以接受字符串和数值类型的参数\nfooC:{type:String,required:true} //可以接受字符串的类型，参数必须传入\nfooD:{type:Number,default:100} //接受数值类型的参数，默认值为100\nfooE:{type:Object,default:()=>{return{message:''}};//当为对象类型时设置默认值必须使用函数返回\nfooF:{validator:function(value){return value >= 0 && value <= 100;}}//使用一个自定义的验证器\nfooG:{type:Array,default:function(){return[]}}// 当为数值类型设置默认值时必须使用数组返回\n}\n---\n利用$refs\nref=\"home\" //调用子组件函数获值\nthis.$refs.home.setMsg(this.mgs)//父\nsetMsg(val){this.msg = val}//子\n---\n子向父传值： v-on $emit\nthis.$emit(\"receive\",\"value\")//子组件\n@receive=\"receive\"\nmethods:{receive(val){}}\n---\n利用$parent\nsetMsg(){this.$parent.toValue(this.msg)} //子\ntoValue(val){this.msg = val} //父\n---\n爷传孙:props\n:mgs=\"msg\"//爷\nv-bind=\"$attrs\"//父\nprops:{mgs:String}//子\n---\n孙传爷\nthis.$emit(\"setVal\",this.msg)//孙\nv-on=\"$listeners\"//父\n@setVal=\"setVal\" setVal(val){this.msg = val}\n---\n祖组件传后代组件:要求值必须为对象!!!\nprovide(){return {data:this.dataObj}}//与data同级,祖组件\ninject:['data'],computed:{()=>{return'${this.data.msg}&{this.data.num}'}}\n---\n兄弟组件传值(store)\nEventBus可用，调用完必须销毁，否则出bug。\n---\napply:传入两个参数，一个参数数组，一个运行环境，默认Window。\ncall:传入多个参数，一个 运行环境，其他为参数。\nbind:使用多加（），绑定上下文。\n三个函数皆为改变上下文this的函数\n多熟悉组件间通信，路由间通信。\n### 持续进行编写和开发，经验保存\n后续将CSDN博客中的经验总结并转移，并学习更多HEXO使用方式和编写方式","slug":"Vue开发","published":1,"updated":"2020-12-09T06:14:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow377001cpcvaaqxacdou","content":"<h2 id=\"This-is-my-vue-develop-exprience\"><a href=\"#This-is-my-vue-develop-exprience\" class=\"headerlink\" title=\"This is my vue develop exprience~\"></a>This is my vue develop exprience~</h2><h2 id=\"2020-5-7-16-02-Write\"><a href=\"#2020-5-7-16-02-Write\" class=\"headerlink\" title=\"2020/5/7 16:02 Write\"></a>2020/5/7 16:02 Write</h2><p>过往项目经验总结</p>\n<p>关键词：Vue，CSS，SVN，WebPack，IconFont，Flex，Jeecg，Iview，ElementUI</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用Vue开发页面，环境配置，导入包，Package，使用IView组件进行页面开发。</span><br><span class=\"line\">（使用开源组件一定需要查看开发文档！！！！！！）</span><br><span class=\"line\">CSS排版布局，flex学习并使用，各种定位的深入了解。</span><br><span class=\"line\">router路由在Vue当中的使用，熟练使用组件进行开发。</span><br><span class=\"line\">熟练使用SVN进行提交和更新代码，提交需要带钩子，如果本地有更改过的文件，在更新时需要将有改动的文件删除再更新，否则会出现乱码</span><br><span class=\"line\">父子组件间的传值通信，Props的使用，对话框的熟练使用。</span><br><span class=\"line\">分析需求并设计页面，使用Axure进行页面的设计，使用开源的移动端组件和阿里的IconFont，必要时可以自行设计组件。</span><br><span class=\"line\">熟悉WebPack框架和Cli脚手架。</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ant-design-jeecg-vue进行开发，代码自动生成。文档链接：[jeecg开发文档](<span class=\"string\">\"http://doc.jeecg.com/1273969\"</span>)</span><br><span class=\"line\">该框架生成的代码由ElementUI组件组成。</span><br><span class=\"line\">考虑页面的逻辑和合理性。</span><br><span class=\"line\">弹框嵌套，需要注意层级。</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-7-10-33-Write\"><a href=\"#2020-5-7-10-33-Write\" class=\"headerlink\" title=\"2020/5/7 10:33 Write\"></a>2020/5/7 10:33 Write</h2><p>使用Vue进行对应页面开发</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用elementUI进行页面的开发，使用Upload上传文件，自带判断文件后缀。</span><br><span class=\"line\">使用POST方法，带FormData参数，使用Append添加序列，需要New一个FormData对象，然后进行传参。</span><br><span class=\"line\">使用Dialog组件，显示设备详情，点击跳出，准备参析路由。</span><br><span class=\"line\">GET方法带的参数只有Params对象。跟在URL后面。</span><br><span class=\"line\">POST和GET不同：//都为TCP链接，并无差别。</span><br><span class=\"line\">参数格式不同以外，参数的大小也不同。因为服务器的处理方式不同，不一定能接受到数据（request body的数据）。</span><br><span class=\"line\">由于HTTP的规定和浏览器/服务器的限制，应用过程体型出不同。</span><br><span class=\"line\">GET产生一个TCP数据包，POST产生两个TCP数据包。</span><br><span class=\"line\">GET，header和data一起发过去，响应200。（返回数据）</span><br><span class=\"line\">POST，先发送header，服务器响应<span class=\"built_in\">continue</span>，再发送data，响应200。（ 返回数据）</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-7-15-53-Write\"><a href=\"#2020-5-7-15-53-Write\" class=\"headerlink\" title=\"2020/5/7 15:53 Write\"></a>2020/5/7 15:53 Write</h2><p>使用Element组件遇到的问题~</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用elementUI的UpLoad组件上传xls文件，需要注意文件格式和文件获取</span><br><span class=\"line\">组件自带上传，可以设置header和数据的name，需要注意Token或者Cookie</span><br><span class=\"line\">组件获取文件的方式   this.<span class=\"variable\">$refs</span>.&#123;upload&#125;（这是关联upload组件的ref名称）.<span class=\"variable\">$data</span>.uploadFiles</span><br><span class=\"line\">注意dialog组件的visible显示值设置</span><br><span class=\"line\">详细查看开发文档！！！！！必要时进行测试获取信息！！</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-8-9-38-Write\"><a href=\"#2020-5-8-9-38-Write\" class=\"headerlink\" title=\"2020/5/8 9:38 Write\"></a>2020/5/8 9:38 Write</h2><p>使用SVN合并代码，并开发模式遇到问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将文件checkout在其他文件夹里，然后修改原代码文件。</span><br><span class=\"line\">多注意NetWork中请求的格式，请求的参数格式！！！！</span><br><span class=\"line\">其中GET方式的URL会随参数改变，POST方式不会。</span><br><span class=\"line\">使用POSTMan测试。</span><br><span class=\"line\">接口文档管理有使用到SWAGGER和小幺鸡~</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-9-9-53-Write\"><a href=\"#2020-5-9-9-53-Write\" class=\"headerlink\" title=\"2020/5/9 9:53 Write\"></a>2020/5/9 9:53 Write</h2><p>总结工作经验，编写简历</p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue的两种路由模式：Hash和History模式</span><br><span class=\"line\"><span class=\"built_in\">hash</span>：默认模式</span><br><span class=\"line\">常用NewURL和OldURL来改变链接，动态页面数据。<span class=\"built_in\">hash</span>值发生变化的时候，会触发hashchange这个时间，通过该事件监听hashchange来实现更新页面部分内容。</span><br><span class=\"line\">History模式：</span><br><span class=\"line\">切换历史状态，back，forward，go三个方法，刷新页面会请求服务器。History模式需要避免刷新。刷新时如果没有相应的响应或者资源，会刷新出404。</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同事开发地图，使用蜂鸟地图插件。经过询问得知，正在研究。</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回温Vue文档。查看生命周期。</span><br><span class=\"line\">beforeCreate()-&gt;created()-&gt;beforeMount()-&gt;mounted()-&gt;beforeUpdate()-&gt;updated()-&gt;beforeDestroy()-&gt;destoryed()//函数调用顺序，中间各有过程</span><br><span class=\"line\">周期如下图</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/05/26/Vue%E5%BC%80%E5%8F%91/vue.png\" alt=\"vue\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在使用ElementUI的Upload上传文件时，action的动态响应是在上传后执行的，所以需要给上传方法设置延时器，并且用到this上下文的时候，需要将this传到该函数内使用，否则会报错。</span><br><span class=\"line\">上传可以设置header的值，在初始化的时候获取token：this.header = &#123;token:`<span class=\"variable\">$&#123;this.$cookie.get('token')&#125;</span>`&#125;</span><br><span class=\"line\">设置的header是一个对象，给header的token属性赋值，要求上传成功后自动关闭对话框，然后清除选择文件数据：this.<span class=\"variable\">$refs</span>.upload.clearFiles();</span><br><span class=\"line\">需要考虑功能全面，合理</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue中数据异步渲染，数据响应式为Vue 的重要核心，在数据变更后，可能DOM还未更新，所以可以调用nextTick（callback）函数，这样回调函数将在DOM更新完后被调用。并且this会绑定到当前的vue实例上。</span><br><span class=\"line\">同域：域名、端口、协议均相同，缺一不可。</span><br><span class=\"line\">跨域：浏览器从一个域名的网页去请求另一个域名的资源时，不同域，就是跨域。//可能会被另一个域保存Cookie或session用来对同域网站发起非法操作，为CSRF攻击，盗用身份。</span><br><span class=\"line\">解决方法：JSONP，CORS。//https://www.jianshu.com/p/f880878c1398(参考)</span><br><span class=\"line\">使用FileZilla Client进行网页部署，连接到服务器，将右边框内dist文件删除，从左边框内选择本体文件，然后右键上传。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>Vue加载本地图片失败，无法使用相对路径。<br>//使用绝对路径 :src=”‘<a href=\"https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&#39;&quot;\" target=\"_blank\" rel=\"noopener\">https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&#39;&quot;</a><br>//使用require :src=”require(‘@/assets/images/icon/file/jpg.png’)”<br>//使用import   import jpg from ‘@/assets/images/icon/file/jpg.png’<br>Vue使用vue-awesome<br>//执行指令 npm install vue-awesome<br>//在main.js文件下 import ‘vue-awesome’ || import Icon from ‘vue-awesome/components/Icon’<br>//Vue.component(‘icon’,Icon)  然后正常使用  <icon name=\"”beer”\"></icon><br>Vue使用Iconfont<br>//选择Icon加入购物车，并且下载源码<br>//执行命令npm install css-loader -D(否则会报错）<br>//在main.js文件中引入 import ‘@/assets/Iconfont/iconfont.css’!!!!!注意这里使用@，绝对路径<br>//直接使用<i class=\"iconfont icon-MV\" style=\"color: white\"></i>  在iconfont.json文件中查看各个icon的fontclass<br>Vue行内写hover样式<br>//onmouseover=”this.style.color=’#57EDED’”!!由于无法实现hover，使用js事件实现，并且在参数边要加引号’’<br>//改变光标形状为小手:cursor=’pointer’<br>Vue点击跳转链接<br>//如果不写协议，会自动在链接前加上localhost:8080(相当于一个相对路径)<br>CSS3 animaiton 实现图片旋转<br>//animation: 15s linear 0s normal none infinite rotate;<br>//animation-play-state: running;<br>Vue导入本地音频文件<br>//文件放入static文件里，无需改变任何Webpack配置，直接引入<br>//引入写法：mp3Url:”static/attack音D.mp3”<br>Vue js将小数转为整数值<br>//toFixed(2) 后面的数值代表保留两位小数<br>Vue 将字符串转化为数值<br>//parseInt(str) 如果是浮点数，将Int改成float即可<br>Vue 实现进度条<br>// element UI 放置 el-progress   :percentage=”mp3width” 设置percentage为数值变量<br>// 实现函数LoadProgress 通过setInterval改变mp3width的值（浮点数）<br>//使用el-slide,可以实现点击和拖拽<br>//需要注意函数运行速度，存在未取到值而后直接进行计算<br>Vue注意事项<br>//开发到后发现，需要通过数据关联来通过子组件控制父组件。<br>//还有一些加载速度，值得优化和注意。<br>Vue遇到组件通信问题<br>//尽量减少组件层数，如果在同一层父组件时，子组件可以一起和父组件通信，获得数据共享。</p>\n<hr>\n<p>深入响应式原理，vue的核心。<br>当一个对象在实例化中的data选项，Vue将遍历此对象所有的property，转为getter和setter。<br>每个组件实例都对应有一个watcher实例，在渲染过程中把数据property记录为依赖，之后当setter触发时，会通知watcher，使关联的组件重新渲染。<br>注意：当数据在data选项外时，为非响应式！！！<br>数组的长度和直接利用索引直接设置的数据都不是响应性的，这时可以使用set方法，使用index和数组的子项更新数据。<br>vue提前声明所有的响应式property。<br>Vue在更新DOM时是异步执行的，侦听到数据变化时，将开启一个队列，缓冲在同一事件循环中发生的所有数据变更。<br>使用原生html，js，css开发文书模板。<br>body{padding:0px;margin:0px} //适应浏览器，无白边<br>使用占位符，空格（&amp;nbsp），后用正则表达式替换。<br>text-align:justify;// 文字两端对齐<br>margin:0 auto;// 左右对齐<br>white-space:normal// 文字换行,元素空白处理<br>div的使用和flex的合理使用</p>\n<hr>\n<p>使用远程桌面连接部署，Windows+r运行 mstsc<br>输入用户名和密码，连接<br>然后将本地的文件复制并粘贴部署到连接的服务器上</p>\n<hr>\n<h2 id=\"开源项目Vue-element-admin\"><a href=\"#开源项目Vue-element-admin\" class=\"headerlink\" title=\"开源项目Vue-element-admin\"></a>开源项目Vue-element-admin</h2><p>权限验证：根据用户登录的role去判断角色请求路由表，动态生成可访问页面。路由挂载。<br>指令权限：通过封装方法，判断角色权限，类似于V-if，不同角色能看到的操作不同。<br>spa(single page web application 单页面开发)//科普<br>路由：分动态和静态路由，主要需要注意引入和使用到的地方，需要快速定位代码中使用路由的位置，研究动态路由的实现。<br>在文件夹中选择find in path 在所有文件中查询使用的地方<br>将router的path改为“/”为默认跳转的第一页面<br>vue有三类路由钩子<br>1.全局钩子  调用router.beforeEach和.afterEach函数 其中next，to中如果带参数，会导致回调，要避免死循环。<br>2.某个路由的钩子<br>3.组件内钩子<br>Vuex使用和了解</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//State</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">count</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> this.<span class=\"variable\">$store</span>.state.count//一般如此调用store的数据</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">...mapState(&#123; //或者通过mapState函数，批量获取</span><br><span class=\"line\">      sidebar: state =&gt; state.app.sidebar,</span><br><span class=\"line\">      device: state =&gt; state.app.device,</span><br><span class=\"line\">      showSettings: state =&gt; state.settings.showSettings,</span><br><span class=\"line\">      needTagsView: state =&gt; state.settings.tagsView,</span><br><span class=\"line\">      fixedHeader: state =&gt; state.settings.fixedHeader</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">//Getter</span><br><span class=\"line\"> getters: &#123;</span><br><span class=\"line\">    doneTodos: state =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> state.todos.filter(todo =&gt; todo.done)//返回处理过的数据</span><br><span class=\"line\">       <span class=\"built_in\">return</span> this.<span class=\"variable\">$store</span>.getters.doneTodosCount//直接返回函数运行后返回的对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  sidebar: state =&gt; state.app.sidebar,</span><br><span class=\"line\">  size: state =&gt; state.app.size,</span><br><span class=\"line\">  device: state =&gt; state.app.device</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">computed: &#123; //依旧在computed辅助函数里调用，mapGetters函数</span><br><span class=\"line\">  // 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\">      <span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">//mutation 相当于函数，用于改变state的值</span><br><span class=\"line\">store.commit(<span class=\"string\">'increment'</span>)//调用mutation handler方式</span><br><span class=\"line\">// ...</span><br><span class=\"line\">mutations: &#123;//mutation函数，限制函数同步执行</span><br><span class=\"line\">  increment (state, n) &#123;//可以传值</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.commit(<span class=\"string\">'increment'</span>, 10)//传入值10</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, payload) &#123; //一般是传入一个对象</span><br><span class=\"line\">    state.count += payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const mutations = &#123;</span><br><span class=\"line\">  SET_TOKEN: (state, token) =&gt; &#123; //使用常量来定义函数名</span><br><span class=\"line\">    state.token = token</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  SET_INTRODUCTION: (state, introduction) =&gt; &#123;//同上</span><br><span class=\"line\">    state.introduction = introduction</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">commit(<span class=\"string\">'SET_ROLES'</span>, roles)//调用时</span><br><span class=\"line\">commit(<span class=\"string\">'SET_NAME'</span>, name)</span><br><span class=\"line\">//action 类似于mutation，可以在其中调用mutation，可以内部执行异步操作</span><br><span class=\"line\">actions: &#123; //action函数接受一个与store实例具有相同方法和属性的context对象，可以通过该对象获取state和gettersstore.dispatch(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">  increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.dispatch(<span class=\"string\">'increment'</span>)//action函数通过dispatch方法触发</span><br><span class=\"line\">//在action中有设计到登录操作，调用异步API和分发多重mutation</span><br><span class=\"line\">也可使用mapAction</span><br><span class=\"line\">//Module 用于将store分割成模块，每个模块拥有自己的state，mutation，action，getter，从上到下分割</span><br><span class=\"line\">在状态数较大时可以使用，避免臃肿。</span><br><span class=\"line\">设置Namespaced：<span class=\"literal\">true</span>，使其成为带命名空间的模块，避免冲命名污染。</span><br><span class=\"line\">在全局命名空间内分发action或提交mutation，将root：<span class=\"literal\">true</span>作为第三参数传给dispatch或commit，直接访问到root下的函数（数据）。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>可以在assets文件中放置css文件，或者一些静态文件。在main.js引入，全局调用。<br>路由在跳转的时候可以传递参数，有三种方式：<br>方案1</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$router</span>.push(&#123;//使用方法</span><br><span class=\"line\">    path: `/describe/<span class=\"variable\">$&#123;id&#125;</span>`,</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">&#123;//对应配置的路由</span><br><span class=\"line\">  path:<span class=\"string\">'/describe/:id'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'Describe'</span>,</span><br><span class=\"line\">  component: Describe</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">this.<span class=\"variable\">$route</span>.params.id//调用方法</span><br></pre></td></tr></table></figure>\n<p>方案二</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$router</span>.push(&#123;//使用方法</span><br><span class=\"line\">    name: <span class=\"string\">'Describe'</span>,</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      id: id</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//路由正常配置</span><br><span class=\"line\"><span class=\"variable\">$route</span>.params.id//调用方法</span><br></pre></td></tr></table></figure>\n<p>方案三</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$router</span>.push(&#123;//使用方法</span><br><span class=\"line\">  path: <span class=\"string\">'/describe'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    id: id</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable\">$route</span>.query.id//调用方法</span><br></pre></td></tr></table></figure>\n<hr>\n<p>项目菜单栏：通过多个组件组成，使用el-scrollbar组件（在element文档没有标注）<br>包裹el-menu，自定义sidebar-item组件使用v-for动态生成多个子项，通过v-if来判断子项显示模式，使用render函数返回item组件作为menuitem，使用link组件（通过：is来判断标签类型，v-bind绑定跳转链接）包裹item来作为跳转链接。<br>mixins混入的使用，其中有函数，数据，并且在每个组件混入的数据都是独立的。（主要作用：代码复用，减少冗余），其中在mixins里的函数命名必须带$_避免引入组件中函数名重复。<br>scss文件引入其他scss文件，可以调用类型，但无法调用里面的属性和mixins，在main.js引入就可以全局调用，包括引入文件中已经引入的文件。<br>Item组件使用render函数返回的原因（性能问题）<br>css3的使用，美化页面。</p>\n<hr>\n<p>v-for的使用，需要一个参数（item,i）in（数组或对象）,可以生成多个。<br>布局注意，P标签自占高度，使用a标签，display：block，块级元素，就可以调整高度了。canvas的使用需要研究，图形实现的好方法。<br>安装prettier自动代码格式化。<br>通过ps打开图片获取颜色和像素。</p>\n<hr>\n<p>Vue项目不同环境打包指令和配置<br>1.env.js文件中各自有</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"> NODE_ENV: <span class=\"string\">'\"production（生产）\"'</span>,//testing（测试）,development（开发）</span><br><span class=\"line\"> EVN_CONFIG:<span class=\"string\">'\"prod\"'</span>,//<span class=\"built_in\">test</span>,dev</span><br><span class=\"line\"> API_ROOT:<span class=\"string\">'\"/apis/v1\"'</span>//api代理地址</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.还需修改package.json文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npm run dev\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"node build/build.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build:test\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production env_config=test node build/build.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build:pre\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production env_config=pre node build/build.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build:prod\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production env_config=prod node build/build.js\"</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>3.修改config/index.js</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build:&#123;</span><br><span class=\"line\">  // Template <span class=\"keyword\">for</span> index.html</span><br><span class=\"line\">  // 添加<span class=\"built_in\">test</span> pre prod 三处环境的配制</span><br><span class=\"line\">  prodEnv: require(<span class=\"string\">'./prod.env'</span>),</span><br><span class=\"line\">  preEnv: require(<span class=\"string\">'./pre.env'</span>),</span><br><span class=\"line\">  testEnv: require(<span class=\"string\">'./test.env'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.在webpackage.pro.conf.js中使用构建环境参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 个性env常量的定义</span><br><span class=\"line\">// const env = require(<span class=\"string\">'../config/prod.env'</span>)</span><br><span class=\"line\">const env = config.build[process.env.env_config+<span class=\"string\">'Env'</span>]</span><br></pre></td></tr></table></figure>\n<p>5.build.js文件修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span></span><br><span class=\"line\">require(<span class=\"string\">'./check-versions'</span>)()</span><br><span class=\"line\">// 注释掉的代码</span><br><span class=\"line\">// process.env.NODE_ENV = <span class=\"string\">'production'</span></span><br><span class=\"line\">const ora = require(<span class=\"string\">'ora'</span>)</span><br><span class=\"line\">const rm = require(<span class=\"string\">'rimraf'</span>)</span><br><span class=\"line\">const path = require(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">const chalk = require(<span class=\"string\">'chalk'</span>)</span><br><span class=\"line\">const webpack = require(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\">const config = require(<span class=\"string\">'../config'</span>)</span><br><span class=\"line\">const webpackConfig = require(<span class=\"string\">'./webpack.prod.conf'</span>)</span><br><span class=\"line\">// 修改spinner的定义</span><br><span class=\"line\">// const spinner = ora(<span class=\"string\">'building for production...'</span>)</span><br><span class=\"line\">var spinner = ora(<span class=\"string\">'building for '</span> + process.env.NODE_ENV + <span class=\"string\">' of '</span> + process.env.env_config+ <span class=\"string\">' mode...'</span> )</span><br><span class=\"line\">spinner.start()</span><br><span class=\"line\">//更多的其它内容，不需要做任何调整的内容 ...</span><br></pre></td></tr></table></figure>\n<p>6.打包指令<br>npm run build:test//测试环境<br>npm run build:prod//生产环境<br>以此类推</p>\n<hr>\n<p>异步加载：async,defer,动态创建script标签<br>异步任务：promise，async</p>\n<hr>\n<p>8中数据类型分别是：<br>Number，String，Boolean，Null，undefined，object（data，function，array），symbol，bigInt<br>Null只有一个值，是null，不存在的对象。<br>Undefined只有一个值，是undefined，没有初始化，undefined是从null中派生出来的。<br>Undefined是没有定义的，null定义了但是为空。<br>基本类型的变量是存放在栈内存（stack）里的<br>基本类型的值是按值访问的<br>基本类型的值是不可变的<br>基本类型的比较是它们的值的比较<br>类型方法<br>运算符优先级<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" target=\"_blank\" rel=\"noopener\">参考链接表</a></p>\n<hr>\n<p>柯里化：接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下参数并且返回结果的新函数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通的add函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> add(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Currying后</span><br><span class=\"line\"><span class=\"keyword\">function</span> curryingAdd(x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"keyword\">function</span> (y) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> x + y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>数组常用方法（array）：<br>1.concat（arrA，arrB，…）//合并数组<br>2. arr.join（separator）//数组转字符串<br>3.arr.toString //无参数，转字符串<br>4.arr.toLocaleString//以逗号隔开输出<br>5.arr.slice（start，end）//截取数组<br>6.arr.splice（index，many，【item1】）//数组删除/添加<br>7.arr.unshift（x,y）//头部增加<br>8.arr.shitf（）//头部删除<br>9.arr.push(x,y)//尾部增加<br>10.arr.pop()//尾部删除<br>11.arr.sort(sortby) //按字符编码进行排序<br>12.arr.reverse（）//数组颠倒<br>13.arr.filter()//数组过滤<br>字符串常用方法（string）：<br>1.str.charAt(index)//返回指定位置的（字符）！！<br>2.str.indexOf(value,[index])//从index找，返回value第一次出现的下标<br>3.str.match（value）//存放匹配结果的数组<br>4.str.split(separator,[many])//数组在separator指定的边界处分割字符串<br>5.str.search(str)//第一个与str匹配的子串起始位置<br>6.str.slice(start,end)//按下标截取字符串<br>7.str.substr(start,[length])//返回从start开始的len个字符<br>8.str.substring（start,[stop]）//提取start到stop的字符串<br>9.str.concat(x,y,z)//连接字符串<br>10.str.replace(substr,replacement)//替换字符串中的部分<br>11.str.toLowerCase()//变小写<br>12.str.toUpperCase()//变大写<br>数组循环方法：<br>forEach(),for-of</p>\n<hr>\n<p>引用类型：<br>Object，Array，RegExp，Date，Function<br>引用类型的值是保存在堆内存（heap）中的对象（object）<br>引用类型的值是按引用访问的<br>引用类型的值是可变的<br>引用类型的比较是引用的比较</p>\n<hr>\n<p>深浅拷贝<br>浅拷贝为引用，深拷贝为创建一个相同的新对象。</p>\n<hr>\n<p>异步和同步<br>1.同步任务在主线程上形成一个执行栈<br>2.主线程外还有一个任务队列<br>3.一旦“执行栈”里的任务执行完毕，系统会读取任务队列里的任务执行<br>4.主线程重复以上三个步骤<br>heap（堆）stack（栈）<br>任务队列中可以放置定时事件（setTimeout，setInterval）<br>定时器将事件插入任务队列，等执行栈执行完才能去执行指定的回调函数</p>\n<hr>\n<p>使用setInterval()循环，在mounted函数中使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:&#123;timer:<span class=\"string\">''</span>&#125;</span><br><span class=\"line\">this.timer = setInterval(()=&gt;&#123;此处写函数&#125;,3000)//1000为1s</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">beforeDestroy</span></span>()&#123;</span><br><span class=\"line\">  clearInterval(this.timer)//在页面销毁前关闭计时器</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"使用store\"><a href=\"#使用store\" class=\"headerlink\" title=\"使用store\"></a>使用store</h3><p>创建新文件timer.js用来设置计时器<br>在index.js主store中引入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import timer from <span class=\"string\">'./modules/timer'</span></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">     modules:&#123;</span><br><span class=\"line\">        timer</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">export</span> default store //暴露，可以外部引入</span><br></pre></td></tr></table></figure>\n<p>在js文件中，需要引入store ///import store from ‘./store’<br>直接调用store即可// store.state.clock//store.commit(‘set_clock’,1)<br>在组件当中调用//this.$store.dispatch对应action（异步）<br>//this.$store.state对应对象<br>//this.$store.commit对应mutation（同步）!!只有mutation可以改变状态<br>//this.$store.getters对应getter //挂载数据计算功能（里面可有数据计算函数）</p>\n<hr>\n<p>路由监听：<br>permission文件当中使用的this.$router.beforeEach(to,from,next)=&gt;{}是全局监听路由的方法<br>vue页面中有三种监听路由的方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.watch:&#123;</span><br><span class=\"line\">   <span class=\"variable\">$route</span>:&#123;</span><br><span class=\"line\">      handler(val,oldval)&#123;</span><br><span class=\"line\">        console.log(val);//新路由信息</span><br><span class=\"line\">        console.log(oldval);//老路由信息</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      deep:<span class=\"literal\">true</span>//深度观察监听</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2.watch:&#123;</span><br><span class=\"line\">  <span class=\"variable\">$route</span>(to,from)&#123;</span><br><span class=\"line\">    console.log(from.path)//从哪来</span><br><span class=\"line\">    console.log(to.path)//到哪去</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3.methods:&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getpath</span></span>()&#123;</span><br><span class=\"line\">    console.log(111)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">watch:&#123;</span><br><span class=\"line\">   <span class=\"string\">'$route'</span>:<span class=\"string\">'getPath'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>js数组对象为指针，修改需要深拷贝，否则会修改原数据<br>防抖：防止按钮多次点击<br>封装防抖函数：debounce.js<br>let timeout = null<br>function bounce(fn,wait) {<br>  if(timeout !== null) clearTimeout(timeout)<br>  timeout = setTimeout(fn,wait)<br>}<br>引入(import)并使用<br>bounce(()=&gt;{function},1000)<br>数组深拷贝：<br>1.concat():<br>let copyArray = [].concat(array)<br>2.slice(idx1,idx2)<br>let copyArray = [].slice()//无参为拷贝数组</p>\n<hr>\n<p>逻辑梳理，设计模式，需求合理，可维护性<br>在写api请求的时候，可以使用promise与async await同步操作<br>并且可以后续抓错处理</p>\n<p>js中Set类型的使用：<br>Set类型带有的函数<br>let num = new Set() //初始化  typeof num为object<br>num.add()// 添加元素的函数<br>num.size //set类型的长度<br>set类型无法添加重复的元素 //利用这点可以数组去重<br>let array = […num] || num = new Set(array)//数组与set的转换<br>num.has() //Set类型用来判断一个值是否在set中<br>num.delete() //Set类型用来删除在set中的值<br>num.clear()//Set类型清空所有的值<br>Set类型的遍历方式<br>num.forEach(function(value){}) // forEach<br>for(val of num){} // for…of<br>js中的遍历函数：<br>Array.map(value,index,array){} //map函数，有元素值，元素下标，数组三个参数，针对每个元素处理，原数组不变，最后返回一个新数组<br>Array.forEach(value,index,array){}//forEach函数，参数如上，无返回值，原数组不变<br>Array.filter(value,index,array){}//filter函数,参数如上,针对每个元素，判断条件返回元素，返回新数组，原数组不变<br>Array.some(),Array.every()//对所有数组成员依次执行函数，返回布尔值,用作数组满足条件判断<br>Array.some(function callback(value,index,arr){})//调用filter的数组<br>Array.some()如果一个成员满足条件则返回true，Array.every()需要全部成员满足条件才返回true,原数组都不变<br>Array.reduce() //使用函数依次处理每个成员，最终返回一个值<br>reduce(callback(previousValue,currentValue,currentIndex,array){函数},initialValue)// previousValue:上一次遍历后提供的值，最开始为初始值:initialValue<br>遍历函数的区别与总结：<br>map()： 在处理函数中将返回值组成一个新的数组返回，原数组(arr)保持不变。<br>forEach()： 没有返回值，即使处理函数中设置了return也无效，原数组(arr)保持不变。<br>filter()： 判断处理函数中的返回值是否为true，将返回为true的数组元素(该元素为最原始的数组元素)组成一个新的数组返回，原数组(arr)保持不变。<br>some()与every()： 判断处理函数中的返回值是否为true，如果有一个成员返回值为true，则some()返回true；如果所有成员返回值都为true，则every()返回true，原数组(arr)保持不变。<br>reduce()： 返回值会被记住，并且在遍历下一个元素中可以被调用，最后返回单个结果值，原数组(arr)保持不变<br>设计模式对代码设计有着非常大的作用，尽快学习。<br>循环机制-&gt;同步异步-&gt;函数运行机制-&gt;执行栈宏任务(Macro)微任务(Micro)<br>宏任务：script(整体代码)，setTimeout,setInterval,I/O,UI交互事件，setImmediate(Node.js)<br>微任务：Promise,MutaionObserver,process.nextTick(Node.js)</p>\n<hr>\n<p>父子组件传值<br>父向子传值：单向绑定，父传过来的值无法在子组件中更改。<br>1.v-bind props<br>{<br>fooA:Number //只接受数值类型的参数<br>fooB:[String,Number] //可以接受字符串和数值类型的参数<br>fooC:{type:String,required:true} //可以接受字符串的类型，参数必须传入<br>fooD:{type:Number,default:100} //接受数值类型的参数，默认值为100<br>fooE:{type:Object,default:()=&gt;{return{message:’’}};//当为对象类型时设置默认值必须使用函数返回<br>fooF:{validator:function(value){return value &gt;= 0 &amp;&amp; value &lt;= 100;}}//使用一个自定义的验证器<br>fooG:{type:Array,default:function(){return[]}}// 当为数值类型设置默认值时必须使用数组返回<br>}</p>\n<hr>\n<p>利用$refs<br>ref=”home” //调用子组件函数获值<br>this.$refs.home.setMsg(this.mgs)//父<br>setMsg(val){this.msg = val}//子</p>\n<hr>\n<p>子向父传值： v-on $emit<br>this.$emit(“receive”,”value”)//子组件<br>@receive=”receive”<br>methods:{receive(val){}}</p>\n<hr>\n<p>利用$parent<br>setMsg(){this.$parent.toValue(this.msg)} //子<br>toValue(val){this.msg = val} //父</p>\n<hr>\n<p>爷传孙:props<br>:mgs=”msg”//爷<br>v-bind=”$attrs”//父<br>props:{mgs:String}//子</p>\n<hr>\n<p>孙传爷<br>this.$emit(“setVal”,this.msg)//孙<br>v-on=”$listeners”//父<br>@setVal=”setVal” setVal(val){this.msg = val}</p>\n<hr>\n<p>祖组件传后代组件:要求值必须为对象!!!<br>provide(){return {data:this.dataObj}}//与data同级,祖组件<br>inject:[‘data’],computed:{()=&gt;{return’${this.data.msg}&amp;{this.data.num}’}}</p>\n<hr>\n<p>兄弟组件传值(store)<br>EventBus可用，调用完必须销毁，否则出bug。</p>\n<hr>\n<p>apply:传入两个参数，一个参数数组，一个运行环境，默认Window。<br>call:传入多个参数，一个 运行环境，其他为参数。<br>bind:使用多加（），绑定上下文。<br>三个函数皆为改变上下文this的函数<br>多熟悉组件间通信，路由间通信。</p>\n<h3 id=\"持续进行编写和开发，经验保存\"><a href=\"#持续进行编写和开发，经验保存\" class=\"headerlink\" title=\"持续进行编写和开发，经验保存\"></a>持续进行编写和开发，经验保存</h3><p>后续将CSDN博客中的经验总结并转移，并学习更多HEXO使用方式和编写方式</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"This-is-my-vue-develop-exprience\"><a href=\"#This-is-my-vue-develop-exprience\" class=\"headerlink\" title=\"This is my vue develop exprience~\"></a>This is my vue develop exprience~</h2><h2 id=\"2020-5-7-16-02-Write\"><a href=\"#2020-5-7-16-02-Write\" class=\"headerlink\" title=\"2020/5/7 16:02 Write\"></a>2020/5/7 16:02 Write</h2><p>过往项目经验总结</p>\n<p>关键词：Vue，CSS，SVN，WebPack，IconFont，Flex，Jeecg，Iview，ElementUI</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用Vue开发页面，环境配置，导入包，Package，使用IView组件进行页面开发。</span><br><span class=\"line\">（使用开源组件一定需要查看开发文档！！！！！！）</span><br><span class=\"line\">CSS排版布局，flex学习并使用，各种定位的深入了解。</span><br><span class=\"line\">router路由在Vue当中的使用，熟练使用组件进行开发。</span><br><span class=\"line\">熟练使用SVN进行提交和更新代码，提交需要带钩子，如果本地有更改过的文件，在更新时需要将有改动的文件删除再更新，否则会出现乱码</span><br><span class=\"line\">父子组件间的传值通信，Props的使用，对话框的熟练使用。</span><br><span class=\"line\">分析需求并设计页面，使用Axure进行页面的设计，使用开源的移动端组件和阿里的IconFont，必要时可以自行设计组件。</span><br><span class=\"line\">熟悉WebPack框架和Cli脚手架。</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ant-design-jeecg-vue进行开发，代码自动生成。文档链接：[jeecg开发文档](<span class=\"string\">\"http://doc.jeecg.com/1273969\"</span>)</span><br><span class=\"line\">该框架生成的代码由ElementUI组件组成。</span><br><span class=\"line\">考虑页面的逻辑和合理性。</span><br><span class=\"line\">弹框嵌套，需要注意层级。</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-7-10-33-Write\"><a href=\"#2020-5-7-10-33-Write\" class=\"headerlink\" title=\"2020/5/7 10:33 Write\"></a>2020/5/7 10:33 Write</h2><p>使用Vue进行对应页面开发</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用elementUI进行页面的开发，使用Upload上传文件，自带判断文件后缀。</span><br><span class=\"line\">使用POST方法，带FormData参数，使用Append添加序列，需要New一个FormData对象，然后进行传参。</span><br><span class=\"line\">使用Dialog组件，显示设备详情，点击跳出，准备参析路由。</span><br><span class=\"line\">GET方法带的参数只有Params对象。跟在URL后面。</span><br><span class=\"line\">POST和GET不同：//都为TCP链接，并无差别。</span><br><span class=\"line\">参数格式不同以外，参数的大小也不同。因为服务器的处理方式不同，不一定能接受到数据（request body的数据）。</span><br><span class=\"line\">由于HTTP的规定和浏览器/服务器的限制，应用过程体型出不同。</span><br><span class=\"line\">GET产生一个TCP数据包，POST产生两个TCP数据包。</span><br><span class=\"line\">GET，header和data一起发过去，响应200。（返回数据）</span><br><span class=\"line\">POST，先发送header，服务器响应<span class=\"built_in\">continue</span>，再发送data，响应200。（ 返回数据）</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-7-15-53-Write\"><a href=\"#2020-5-7-15-53-Write\" class=\"headerlink\" title=\"2020/5/7 15:53 Write\"></a>2020/5/7 15:53 Write</h2><p>使用Element组件遇到的问题~</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用elementUI的UpLoad组件上传xls文件，需要注意文件格式和文件获取</span><br><span class=\"line\">组件自带上传，可以设置header和数据的name，需要注意Token或者Cookie</span><br><span class=\"line\">组件获取文件的方式   this.<span class=\"variable\">$refs</span>.&#123;upload&#125;（这是关联upload组件的ref名称）.<span class=\"variable\">$data</span>.uploadFiles</span><br><span class=\"line\">注意dialog组件的visible显示值设置</span><br><span class=\"line\">详细查看开发文档！！！！！必要时进行测试获取信息！！</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-8-9-38-Write\"><a href=\"#2020-5-8-9-38-Write\" class=\"headerlink\" title=\"2020/5/8 9:38 Write\"></a>2020/5/8 9:38 Write</h2><p>使用SVN合并代码，并开发模式遇到问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将文件checkout在其他文件夹里，然后修改原代码文件。</span><br><span class=\"line\">多注意NetWork中请求的格式，请求的参数格式！！！！</span><br><span class=\"line\">其中GET方式的URL会随参数改变，POST方式不会。</span><br><span class=\"line\">使用POSTMan测试。</span><br><span class=\"line\">接口文档管理有使用到SWAGGER和小幺鸡~</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2020-5-9-9-53-Write\"><a href=\"#2020-5-9-9-53-Write\" class=\"headerlink\" title=\"2020/5/9 9:53 Write\"></a>2020/5/9 9:53 Write</h2><p>总结工作经验，编写简历</p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue的两种路由模式：Hash和History模式</span><br><span class=\"line\"><span class=\"built_in\">hash</span>：默认模式</span><br><span class=\"line\">常用NewURL和OldURL来改变链接，动态页面数据。<span class=\"built_in\">hash</span>值发生变化的时候，会触发hashchange这个时间，通过该事件监听hashchange来实现更新页面部分内容。</span><br><span class=\"line\">History模式：</span><br><span class=\"line\">切换历史状态，back，forward，go三个方法，刷新页面会请求服务器。History模式需要避免刷新。刷新时如果没有相应的响应或者资源，会刷新出404。</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同事开发地图，使用蜂鸟地图插件。经过询问得知，正在研究。</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回温Vue文档。查看生命周期。</span><br><span class=\"line\">beforeCreate()-&gt;created()-&gt;beforeMount()-&gt;mounted()-&gt;beforeUpdate()-&gt;updated()-&gt;beforeDestroy()-&gt;destoryed()//函数调用顺序，中间各有过程</span><br><span class=\"line\">周期如下图</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/05/26/Vue%E5%BC%80%E5%8F%91/vue.png\" alt=\"vue\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在使用ElementUI的Upload上传文件时，action的动态响应是在上传后执行的，所以需要给上传方法设置延时器，并且用到this上下文的时候，需要将this传到该函数内使用，否则会报错。</span><br><span class=\"line\">上传可以设置header的值，在初始化的时候获取token：this.header = &#123;token:`<span class=\"variable\">$&#123;this.$cookie.get('token')&#125;</span>`&#125;</span><br><span class=\"line\">设置的header是一个对象，给header的token属性赋值，要求上传成功后自动关闭对话框，然后清除选择文件数据：this.<span class=\"variable\">$refs</span>.upload.clearFiles();</span><br><span class=\"line\">需要考虑功能全面，合理</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue中数据异步渲染，数据响应式为Vue 的重要核心，在数据变更后，可能DOM还未更新，所以可以调用nextTick（callback）函数，这样回调函数将在DOM更新完后被调用。并且this会绑定到当前的vue实例上。</span><br><span class=\"line\">同域：域名、端口、协议均相同，缺一不可。</span><br><span class=\"line\">跨域：浏览器从一个域名的网页去请求另一个域名的资源时，不同域，就是跨域。//可能会被另一个域保存Cookie或session用来对同域网站发起非法操作，为CSRF攻击，盗用身份。</span><br><span class=\"line\">解决方法：JSONP，CORS。//https://www.jianshu.com/p/f880878c1398(参考)</span><br><span class=\"line\">使用FileZilla Client进行网页部署，连接到服务器，将右边框内dist文件删除，从左边框内选择本体文件，然后右键上传。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>Vue加载本地图片失败，无法使用相对路径。<br>//使用绝对路径 :src=”‘<a href=\"https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&#39;&quot;\" target=\"_blank\" rel=\"noopener\">https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&#39;&quot;</a><br>//使用require :src=”require(‘@/assets/images/icon/file/jpg.png’)”<br>//使用import   import jpg from ‘@/assets/images/icon/file/jpg.png’<br>Vue使用vue-awesome<br>//执行指令 npm install vue-awesome<br>//在main.js文件下 import ‘vue-awesome’ || import Icon from ‘vue-awesome/components/Icon’<br>//Vue.component(‘icon’,Icon)  然后正常使用  <icon name=\"”beer”\"></icon><br>Vue使用Iconfont<br>//选择Icon加入购物车，并且下载源码<br>//执行命令npm install css-loader -D(否则会报错）<br>//在main.js文件中引入 import ‘@/assets/Iconfont/iconfont.css’!!!!!注意这里使用@，绝对路径<br>//直接使用<i class=\"iconfont icon-MV\" style=\"color: white\"></i>  在iconfont.json文件中查看各个icon的fontclass<br>Vue行内写hover样式<br>//onmouseover=”this.style.color=’#57EDED’”!!由于无法实现hover，使用js事件实现，并且在参数边要加引号’’<br>//改变光标形状为小手:cursor=’pointer’<br>Vue点击跳转链接<br>//如果不写协议，会自动在链接前加上localhost:8080(相当于一个相对路径)<br>CSS3 animaiton 实现图片旋转<br>//animation: 15s linear 0s normal none infinite rotate;<br>//animation-play-state: running;<br>Vue导入本地音频文件<br>//文件放入static文件里，无需改变任何Webpack配置，直接引入<br>//引入写法：mp3Url:”static/attack音D.mp3”<br>Vue js将小数转为整数值<br>//toFixed(2) 后面的数值代表保留两位小数<br>Vue 将字符串转化为数值<br>//parseInt(str) 如果是浮点数，将Int改成float即可<br>Vue 实现进度条<br>// element UI 放置 el-progress   :percentage=”mp3width” 设置percentage为数值变量<br>// 实现函数LoadProgress 通过setInterval改变mp3width的值（浮点数）<br>//使用el-slide,可以实现点击和拖拽<br>//需要注意函数运行速度，存在未取到值而后直接进行计算<br>Vue注意事项<br>//开发到后发现，需要通过数据关联来通过子组件控制父组件。<br>//还有一些加载速度，值得优化和注意。<br>Vue遇到组件通信问题<br>//尽量减少组件层数，如果在同一层父组件时，子组件可以一起和父组件通信，获得数据共享。</p>\n<hr>\n<p>深入响应式原理，vue的核心。<br>当一个对象在实例化中的data选项，Vue将遍历此对象所有的property，转为getter和setter。<br>每个组件实例都对应有一个watcher实例，在渲染过程中把数据property记录为依赖，之后当setter触发时，会通知watcher，使关联的组件重新渲染。<br>注意：当数据在data选项外时，为非响应式！！！<br>数组的长度和直接利用索引直接设置的数据都不是响应性的，这时可以使用set方法，使用index和数组的子项更新数据。<br>vue提前声明所有的响应式property。<br>Vue在更新DOM时是异步执行的，侦听到数据变化时，将开启一个队列，缓冲在同一事件循环中发生的所有数据变更。<br>使用原生html，js，css开发文书模板。<br>body{padding:0px;margin:0px} //适应浏览器，无白边<br>使用占位符，空格（&amp;nbsp），后用正则表达式替换。<br>text-align:justify;// 文字两端对齐<br>margin:0 auto;// 左右对齐<br>white-space:normal// 文字换行,元素空白处理<br>div的使用和flex的合理使用</p>\n<hr>\n<p>使用远程桌面连接部署，Windows+r运行 mstsc<br>输入用户名和密码，连接<br>然后将本地的文件复制并粘贴部署到连接的服务器上</p>\n<hr>\n<h2 id=\"开源项目Vue-element-admin\"><a href=\"#开源项目Vue-element-admin\" class=\"headerlink\" title=\"开源项目Vue-element-admin\"></a>开源项目Vue-element-admin</h2><p>权限验证：根据用户登录的role去判断角色请求路由表，动态生成可访问页面。路由挂载。<br>指令权限：通过封装方法，判断角色权限，类似于V-if，不同角色能看到的操作不同。<br>spa(single page web application 单页面开发)//科普<br>路由：分动态和静态路由，主要需要注意引入和使用到的地方，需要快速定位代码中使用路由的位置，研究动态路由的实现。<br>在文件夹中选择find in path 在所有文件中查询使用的地方<br>将router的path改为“/”为默认跳转的第一页面<br>vue有三类路由钩子<br>1.全局钩子  调用router.beforeEach和.afterEach函数 其中next，to中如果带参数，会导致回调，要避免死循环。<br>2.某个路由的钩子<br>3.组件内钩子<br>Vuex使用和了解</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//State</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">count</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> this.<span class=\"variable\">$store</span>.state.count//一般如此调用store的数据</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">...mapState(&#123; //或者通过mapState函数，批量获取</span><br><span class=\"line\">      sidebar: state =&gt; state.app.sidebar,</span><br><span class=\"line\">      device: state =&gt; state.app.device,</span><br><span class=\"line\">      showSettings: state =&gt; state.settings.showSettings,</span><br><span class=\"line\">      needTagsView: state =&gt; state.settings.tagsView,</span><br><span class=\"line\">      fixedHeader: state =&gt; state.settings.fixedHeader</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">//Getter</span><br><span class=\"line\"> getters: &#123;</span><br><span class=\"line\">    doneTodos: state =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> state.todos.filter(todo =&gt; todo.done)//返回处理过的数据</span><br><span class=\"line\">       <span class=\"built_in\">return</span> this.<span class=\"variable\">$store</span>.getters.doneTodosCount//直接返回函数运行后返回的对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  sidebar: state =&gt; state.app.sidebar,</span><br><span class=\"line\">  size: state =&gt; state.app.size,</span><br><span class=\"line\">  device: state =&gt; state.app.device</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">computed: &#123; //依旧在computed辅助函数里调用，mapGetters函数</span><br><span class=\"line\">  // 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\">      <span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">//mutation 相当于函数，用于改变state的值</span><br><span class=\"line\">store.commit(<span class=\"string\">'increment'</span>)//调用mutation handler方式</span><br><span class=\"line\">// ...</span><br><span class=\"line\">mutations: &#123;//mutation函数，限制函数同步执行</span><br><span class=\"line\">  increment (state, n) &#123;//可以传值</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.commit(<span class=\"string\">'increment'</span>, 10)//传入值10</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, payload) &#123; //一般是传入一个对象</span><br><span class=\"line\">    state.count += payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const mutations = &#123;</span><br><span class=\"line\">  SET_TOKEN: (state, token) =&gt; &#123; //使用常量来定义函数名</span><br><span class=\"line\">    state.token = token</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  SET_INTRODUCTION: (state, introduction) =&gt; &#123;//同上</span><br><span class=\"line\">    state.introduction = introduction</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">commit(<span class=\"string\">'SET_ROLES'</span>, roles)//调用时</span><br><span class=\"line\">commit(<span class=\"string\">'SET_NAME'</span>, name)</span><br><span class=\"line\">//action 类似于mutation，可以在其中调用mutation，可以内部执行异步操作</span><br><span class=\"line\">actions: &#123; //action函数接受一个与store实例具有相同方法和属性的context对象，可以通过该对象获取state和gettersstore.dispatch(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">  increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.dispatch(<span class=\"string\">'increment'</span>)//action函数通过dispatch方法触发</span><br><span class=\"line\">//在action中有设计到登录操作，调用异步API和分发多重mutation</span><br><span class=\"line\">也可使用mapAction</span><br><span class=\"line\">//Module 用于将store分割成模块，每个模块拥有自己的state，mutation，action，getter，从上到下分割</span><br><span class=\"line\">在状态数较大时可以使用，避免臃肿。</span><br><span class=\"line\">设置Namespaced：<span class=\"literal\">true</span>，使其成为带命名空间的模块，避免冲命名污染。</span><br><span class=\"line\">在全局命名空间内分发action或提交mutation，将root：<span class=\"literal\">true</span>作为第三参数传给dispatch或commit，直接访问到root下的函数（数据）。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>可以在assets文件中放置css文件，或者一些静态文件。在main.js引入，全局调用。<br>路由在跳转的时候可以传递参数，有三种方式：<br>方案1</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$router</span>.push(&#123;//使用方法</span><br><span class=\"line\">    path: `/describe/<span class=\"variable\">$&#123;id&#125;</span>`,</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">&#123;//对应配置的路由</span><br><span class=\"line\">  path:<span class=\"string\">'/describe/:id'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'Describe'</span>,</span><br><span class=\"line\">  component: Describe</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">this.<span class=\"variable\">$route</span>.params.id//调用方法</span><br></pre></td></tr></table></figure>\n<p>方案二</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$router</span>.push(&#123;//使用方法</span><br><span class=\"line\">    name: <span class=\"string\">'Describe'</span>,</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      id: id</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//路由正常配置</span><br><span class=\"line\"><span class=\"variable\">$route</span>.params.id//调用方法</span><br></pre></td></tr></table></figure>\n<p>方案三</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.<span class=\"variable\">$router</span>.push(&#123;//使用方法</span><br><span class=\"line\">  path: <span class=\"string\">'/describe'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    id: id</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable\">$route</span>.query.id//调用方法</span><br></pre></td></tr></table></figure>\n<hr>\n<p>项目菜单栏：通过多个组件组成，使用el-scrollbar组件（在element文档没有标注）<br>包裹el-menu，自定义sidebar-item组件使用v-for动态生成多个子项，通过v-if来判断子项显示模式，使用render函数返回item组件作为menuitem，使用link组件（通过：is来判断标签类型，v-bind绑定跳转链接）包裹item来作为跳转链接。<br>mixins混入的使用，其中有函数，数据，并且在每个组件混入的数据都是独立的。（主要作用：代码复用，减少冗余），其中在mixins里的函数命名必须带$_避免引入组件中函数名重复。<br>scss文件引入其他scss文件，可以调用类型，但无法调用里面的属性和mixins，在main.js引入就可以全局调用，包括引入文件中已经引入的文件。<br>Item组件使用render函数返回的原因（性能问题）<br>css3的使用，美化页面。</p>\n<hr>\n<p>v-for的使用，需要一个参数（item,i）in（数组或对象）,可以生成多个。<br>布局注意，P标签自占高度，使用a标签，display：block，块级元素，就可以调整高度了。canvas的使用需要研究，图形实现的好方法。<br>安装prettier自动代码格式化。<br>通过ps打开图片获取颜色和像素。</p>\n<hr>\n<p>Vue项目不同环境打包指令和配置<br>1.env.js文件中各自有</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"> NODE_ENV: <span class=\"string\">'\"production（生产）\"'</span>,//testing（测试）,development（开发）</span><br><span class=\"line\"> EVN_CONFIG:<span class=\"string\">'\"prod\"'</span>,//<span class=\"built_in\">test</span>,dev</span><br><span class=\"line\"> API_ROOT:<span class=\"string\">'\"/apis/v1\"'</span>//api代理地址</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.还需修改package.json文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npm run dev\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"node build/build.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build:test\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production env_config=test node build/build.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build:pre\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production env_config=pre node build/build.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build:prod\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production env_config=prod node build/build.js\"</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>3.修改config/index.js</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build:&#123;</span><br><span class=\"line\">  // Template <span class=\"keyword\">for</span> index.html</span><br><span class=\"line\">  // 添加<span class=\"built_in\">test</span> pre prod 三处环境的配制</span><br><span class=\"line\">  prodEnv: require(<span class=\"string\">'./prod.env'</span>),</span><br><span class=\"line\">  preEnv: require(<span class=\"string\">'./pre.env'</span>),</span><br><span class=\"line\">  testEnv: require(<span class=\"string\">'./test.env'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.在webpackage.pro.conf.js中使用构建环境参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 个性env常量的定义</span><br><span class=\"line\">// const env = require(<span class=\"string\">'../config/prod.env'</span>)</span><br><span class=\"line\">const env = config.build[process.env.env_config+<span class=\"string\">'Env'</span>]</span><br></pre></td></tr></table></figure>\n<p>5.build.js文件修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'use strict'</span></span><br><span class=\"line\">require(<span class=\"string\">'./check-versions'</span>)()</span><br><span class=\"line\">// 注释掉的代码</span><br><span class=\"line\">// process.env.NODE_ENV = <span class=\"string\">'production'</span></span><br><span class=\"line\">const ora = require(<span class=\"string\">'ora'</span>)</span><br><span class=\"line\">const rm = require(<span class=\"string\">'rimraf'</span>)</span><br><span class=\"line\">const path = require(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">const chalk = require(<span class=\"string\">'chalk'</span>)</span><br><span class=\"line\">const webpack = require(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\">const config = require(<span class=\"string\">'../config'</span>)</span><br><span class=\"line\">const webpackConfig = require(<span class=\"string\">'./webpack.prod.conf'</span>)</span><br><span class=\"line\">// 修改spinner的定义</span><br><span class=\"line\">// const spinner = ora(<span class=\"string\">'building for production...'</span>)</span><br><span class=\"line\">var spinner = ora(<span class=\"string\">'building for '</span> + process.env.NODE_ENV + <span class=\"string\">' of '</span> + process.env.env_config+ <span class=\"string\">' mode...'</span> )</span><br><span class=\"line\">spinner.start()</span><br><span class=\"line\">//更多的其它内容，不需要做任何调整的内容 ...</span><br></pre></td></tr></table></figure>\n<p>6.打包指令<br>npm run build:test//测试环境<br>npm run build:prod//生产环境<br>以此类推</p>\n<hr>\n<p>异步加载：async,defer,动态创建script标签<br>异步任务：promise，async</p>\n<hr>\n<p>8中数据类型分别是：<br>Number，String，Boolean，Null，undefined，object（data，function，array），symbol，bigInt<br>Null只有一个值，是null，不存在的对象。<br>Undefined只有一个值，是undefined，没有初始化，undefined是从null中派生出来的。<br>Undefined是没有定义的，null定义了但是为空。<br>基本类型的变量是存放在栈内存（stack）里的<br>基本类型的值是按值访问的<br>基本类型的值是不可变的<br>基本类型的比较是它们的值的比较<br>类型方法<br>运算符优先级<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" target=\"_blank\" rel=\"noopener\">参考链接表</a></p>\n<hr>\n<p>柯里化：接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下参数并且返回结果的新函数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通的add函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> add(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Currying后</span><br><span class=\"line\"><span class=\"keyword\">function</span> curryingAdd(x) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"keyword\">function</span> (y) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> x + y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>数组常用方法（array）：<br>1.concat（arrA，arrB，…）//合并数组<br>2. arr.join（separator）//数组转字符串<br>3.arr.toString //无参数，转字符串<br>4.arr.toLocaleString//以逗号隔开输出<br>5.arr.slice（start，end）//截取数组<br>6.arr.splice（index，many，【item1】）//数组删除/添加<br>7.arr.unshift（x,y）//头部增加<br>8.arr.shitf（）//头部删除<br>9.arr.push(x,y)//尾部增加<br>10.arr.pop()//尾部删除<br>11.arr.sort(sortby) //按字符编码进行排序<br>12.arr.reverse（）//数组颠倒<br>13.arr.filter()//数组过滤<br>字符串常用方法（string）：<br>1.str.charAt(index)//返回指定位置的（字符）！！<br>2.str.indexOf(value,[index])//从index找，返回value第一次出现的下标<br>3.str.match（value）//存放匹配结果的数组<br>4.str.split(separator,[many])//数组在separator指定的边界处分割字符串<br>5.str.search(str)//第一个与str匹配的子串起始位置<br>6.str.slice(start,end)//按下标截取字符串<br>7.str.substr(start,[length])//返回从start开始的len个字符<br>8.str.substring（start,[stop]）//提取start到stop的字符串<br>9.str.concat(x,y,z)//连接字符串<br>10.str.replace(substr,replacement)//替换字符串中的部分<br>11.str.toLowerCase()//变小写<br>12.str.toUpperCase()//变大写<br>数组循环方法：<br>forEach(),for-of</p>\n<hr>\n<p>引用类型：<br>Object，Array，RegExp，Date，Function<br>引用类型的值是保存在堆内存（heap）中的对象（object）<br>引用类型的值是按引用访问的<br>引用类型的值是可变的<br>引用类型的比较是引用的比较</p>\n<hr>\n<p>深浅拷贝<br>浅拷贝为引用，深拷贝为创建一个相同的新对象。</p>\n<hr>\n<p>异步和同步<br>1.同步任务在主线程上形成一个执行栈<br>2.主线程外还有一个任务队列<br>3.一旦“执行栈”里的任务执行完毕，系统会读取任务队列里的任务执行<br>4.主线程重复以上三个步骤<br>heap（堆）stack（栈）<br>任务队列中可以放置定时事件（setTimeout，setInterval）<br>定时器将事件插入任务队列，等执行栈执行完才能去执行指定的回调函数</p>\n<hr>\n<p>使用setInterval()循环，在mounted函数中使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:&#123;timer:<span class=\"string\">''</span>&#125;</span><br><span class=\"line\">this.timer = setInterval(()=&gt;&#123;此处写函数&#125;,3000)//1000为1s</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">beforeDestroy</span></span>()&#123;</span><br><span class=\"line\">  clearInterval(this.timer)//在页面销毁前关闭计时器</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"使用store\"><a href=\"#使用store\" class=\"headerlink\" title=\"使用store\"></a>使用store</h3><p>创建新文件timer.js用来设置计时器<br>在index.js主store中引入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import timer from <span class=\"string\">'./modules/timer'</span></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">     modules:&#123;</span><br><span class=\"line\">        timer</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">export</span> default store //暴露，可以外部引入</span><br></pre></td></tr></table></figure>\n<p>在js文件中，需要引入store ///import store from ‘./store’<br>直接调用store即可// store.state.clock//store.commit(‘set_clock’,1)<br>在组件当中调用//this.$store.dispatch对应action（异步）<br>//this.$store.state对应对象<br>//this.$store.commit对应mutation（同步）!!只有mutation可以改变状态<br>//this.$store.getters对应getter //挂载数据计算功能（里面可有数据计算函数）</p>\n<hr>\n<p>路由监听：<br>permission文件当中使用的this.$router.beforeEach(to,from,next)=&gt;{}是全局监听路由的方法<br>vue页面中有三种监听路由的方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.watch:&#123;</span><br><span class=\"line\">   <span class=\"variable\">$route</span>:&#123;</span><br><span class=\"line\">      handler(val,oldval)&#123;</span><br><span class=\"line\">        console.log(val);//新路由信息</span><br><span class=\"line\">        console.log(oldval);//老路由信息</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      deep:<span class=\"literal\">true</span>//深度观察监听</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2.watch:&#123;</span><br><span class=\"line\">  <span class=\"variable\">$route</span>(to,from)&#123;</span><br><span class=\"line\">    console.log(from.path)//从哪来</span><br><span class=\"line\">    console.log(to.path)//到哪去</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3.methods:&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getpath</span></span>()&#123;</span><br><span class=\"line\">    console.log(111)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">watch:&#123;</span><br><span class=\"line\">   <span class=\"string\">'$route'</span>:<span class=\"string\">'getPath'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>js数组对象为指针，修改需要深拷贝，否则会修改原数据<br>防抖：防止按钮多次点击<br>封装防抖函数：debounce.js<br>let timeout = null<br>function bounce(fn,wait) {<br>  if(timeout !== null) clearTimeout(timeout)<br>  timeout = setTimeout(fn,wait)<br>}<br>引入(import)并使用<br>bounce(()=&gt;{function},1000)<br>数组深拷贝：<br>1.concat():<br>let copyArray = [].concat(array)<br>2.slice(idx1,idx2)<br>let copyArray = [].slice()//无参为拷贝数组</p>\n<hr>\n<p>逻辑梳理，设计模式，需求合理，可维护性<br>在写api请求的时候，可以使用promise与async await同步操作<br>并且可以后续抓错处理</p>\n<p>js中Set类型的使用：<br>Set类型带有的函数<br>let num = new Set() //初始化  typeof num为object<br>num.add()// 添加元素的函数<br>num.size //set类型的长度<br>set类型无法添加重复的元素 //利用这点可以数组去重<br>let array = […num] || num = new Set(array)//数组与set的转换<br>num.has() //Set类型用来判断一个值是否在set中<br>num.delete() //Set类型用来删除在set中的值<br>num.clear()//Set类型清空所有的值<br>Set类型的遍历方式<br>num.forEach(function(value){}) // forEach<br>for(val of num){} // for…of<br>js中的遍历函数：<br>Array.map(value,index,array){} //map函数，有元素值，元素下标，数组三个参数，针对每个元素处理，原数组不变，最后返回一个新数组<br>Array.forEach(value,index,array){}//forEach函数，参数如上，无返回值，原数组不变<br>Array.filter(value,index,array){}//filter函数,参数如上,针对每个元素，判断条件返回元素，返回新数组，原数组不变<br>Array.some(),Array.every()//对所有数组成员依次执行函数，返回布尔值,用作数组满足条件判断<br>Array.some(function callback(value,index,arr){})//调用filter的数组<br>Array.some()如果一个成员满足条件则返回true，Array.every()需要全部成员满足条件才返回true,原数组都不变<br>Array.reduce() //使用函数依次处理每个成员，最终返回一个值<br>reduce(callback(previousValue,currentValue,currentIndex,array){函数},initialValue)// previousValue:上一次遍历后提供的值，最开始为初始值:initialValue<br>遍历函数的区别与总结：<br>map()： 在处理函数中将返回值组成一个新的数组返回，原数组(arr)保持不变。<br>forEach()： 没有返回值，即使处理函数中设置了return也无效，原数组(arr)保持不变。<br>filter()： 判断处理函数中的返回值是否为true，将返回为true的数组元素(该元素为最原始的数组元素)组成一个新的数组返回，原数组(arr)保持不变。<br>some()与every()： 判断处理函数中的返回值是否为true，如果有一个成员返回值为true，则some()返回true；如果所有成员返回值都为true，则every()返回true，原数组(arr)保持不变。<br>reduce()： 返回值会被记住，并且在遍历下一个元素中可以被调用，最后返回单个结果值，原数组(arr)保持不变<br>设计模式对代码设计有着非常大的作用，尽快学习。<br>循环机制-&gt;同步异步-&gt;函数运行机制-&gt;执行栈宏任务(Macro)微任务(Micro)<br>宏任务：script(整体代码)，setTimeout,setInterval,I/O,UI交互事件，setImmediate(Node.js)<br>微任务：Promise,MutaionObserver,process.nextTick(Node.js)</p>\n<hr>\n<p>父子组件传值<br>父向子传值：单向绑定，父传过来的值无法在子组件中更改。<br>1.v-bind props<br>{<br>fooA:Number //只接受数值类型的参数<br>fooB:[String,Number] //可以接受字符串和数值类型的参数<br>fooC:{type:String,required:true} //可以接受字符串的类型，参数必须传入<br>fooD:{type:Number,default:100} //接受数值类型的参数，默认值为100<br>fooE:{type:Object,default:()=&gt;{return{message:’’}};//当为对象类型时设置默认值必须使用函数返回<br>fooF:{validator:function(value){return value &gt;= 0 &amp;&amp; value &lt;= 100;}}//使用一个自定义的验证器<br>fooG:{type:Array,default:function(){return[]}}// 当为数值类型设置默认值时必须使用数组返回<br>}</p>\n<hr>\n<p>利用$refs<br>ref=”home” //调用子组件函数获值<br>this.$refs.home.setMsg(this.mgs)//父<br>setMsg(val){this.msg = val}//子</p>\n<hr>\n<p>子向父传值： v-on $emit<br>this.$emit(“receive”,”value”)//子组件<br>@receive=”receive”<br>methods:{receive(val){}}</p>\n<hr>\n<p>利用$parent<br>setMsg(){this.$parent.toValue(this.msg)} //子<br>toValue(val){this.msg = val} //父</p>\n<hr>\n<p>爷传孙:props<br>:mgs=”msg”//爷<br>v-bind=”$attrs”//父<br>props:{mgs:String}//子</p>\n<hr>\n<p>孙传爷<br>this.$emit(“setVal”,this.msg)//孙<br>v-on=”$listeners”//父<br>@setVal=”setVal” setVal(val){this.msg = val}</p>\n<hr>\n<p>祖组件传后代组件:要求值必须为对象!!!<br>provide(){return {data:this.dataObj}}//与data同级,祖组件<br>inject:[‘data’],computed:{()=&gt;{return’${this.data.msg}&amp;{this.data.num}’}}</p>\n<hr>\n<p>兄弟组件传值(store)<br>EventBus可用，调用完必须销毁，否则出bug。</p>\n<hr>\n<p>apply:传入两个参数，一个参数数组，一个运行环境，默认Window。<br>call:传入多个参数，一个 运行环境，其他为参数。<br>bind:使用多加（），绑定上下文。<br>三个函数皆为改变上下文this的函数<br>多熟悉组件间通信，路由间通信。</p>\n<h3 id=\"持续进行编写和开发，经验保存\"><a href=\"#持续进行编写和开发，经验保存\" class=\"headerlink\" title=\"持续进行编写和开发，经验保存\"></a>持续进行编写和开发，经验保存</h3><p>后续将CSDN博客中的经验总结并转移，并学习更多HEXO使用方式和编写方式</p>\n"},{"title":"Vue3.0经验","date":"2020-07-10T09:12:58.000Z","_content":"## 先安装cli脚手架，命令如下：\n```bash\nnpm install -g @vue/cli\n$vue -V //使用命令查看cli版本\n@vue/cli 4.3.1 //当前cli版本\n```\n## 初始化Vue项目，命令如下：\n```bash\nvue create \"项目名称\" //创建项目\n>Manully select features //手动选择\nBabel,Router,Vuex,CSS Pre-processors,Linter / Formatter //选择这些模块\n```\n剩下的直接回车\n\n## 升级项目，命令如下：\n```bash\ncd \"项目\"\nvue add vue-next //安装\n```\n该命令会完成：\n·安装Vue3.0依赖\n·更新Vue3.0 webpack loader配置，使其能够支持 .vue文件构建（重要）\n·创建Vue3.0 的模板代码\n·自动升级Vue Router\n·自动生成Vue Router和Vuex模板代码\n\n## 启动项目\n基于ReadMe.md，其中的命令启动项目。\n\n## 项目过程问题\n使用composition API的provide和inject实现组件间传值\n注意！！provide和inject只能在setup（）函数中使用\n```bash\nimport {provide} from 'vue' //引入provide\nprovide(\"data\",\"send\") //父组件传值\nlet send = inject(\"data\") //子组件接收\nreturn {\n  send //返回使用\n}\n```\n\n### Vue3.0新特性\nVue3.0的设计目标是更快，更小，并更好的支持TypeScript\n新特性包括\n```bash\ncomposition\nMultiple root elements\nSuspense\nMultiple V-models\nReactivity\nTeleport\nTransition\nRemove Filter\nApp configuration\n```\n\n## 1、Composition API\nVue3.0中模板带有setup（）函数，用于处理数据，需要使用ref函数声明数据（也可以直接声明函数），return返回在模板中使用。\n```bash\nimport {ref} from 'vue'\nexport default{\n   setup() {\n      const count = ref(0)\n      const inc = () =>{\n          count.value++\n      }\n      return { \n          count,\n          inc\n      }\n   }\n}\n```\ncomposition主要有两大好处：\n1.清晰的代码结构2.消除重复逻辑\n小结：composition API主要针对闭包的应用，通过其他函数中声明值，并使用watch函数监视，在需要的组件引入，达到代码复用。\n\n## 2、Multiple root elements\nVue2.0中template的根元素只能取一个，要用div包含。\nVue3.0中取消了这一限制：\n在template中使用任意数量的标签\n\n## 3、Suspense\nSuspense使用与前后端数据交互时，提供默认内容加载，当数据返回时配合使用v-if来控制数据显示。\nSuspense简化了这个过程：它提供了default和fallback状态：\n```bash\n<Suspense>\n    <template #default>\n      <div v-for=\"item in articleList\" :key=\"item.id\">\n        <article>\n          <h2>{{ item.title }}</h2>\n          <p>{{ item.body }}</p>\n        </article>\n      </div>\n    </template>\n    <template #fallback>\n      Articles loading...\n    </template>\n</Suspense>\n```\n## 4、Multiple v-models\n一个表单可以绑定多个V-model\n```bash\n<Form>\n    v-model:name=\"name\"\n    v-model:age = \"age\"\n</Form>\n```\n## 5、Reactivity\n3.0响应式系统全部用Typescript重构，利用代理（Proxy）和反射（Reflect）来替换Vue2.0的Object.defineProperty\n耦合度降低，分类清晰。\n支出通过修改数组下标的时候进行响应。\n## 6、Portals\n","source":"_posts/Vue3-0经验.md","raw":"---\ntitle: Vue3.0经验\ndate: 2020-07-10 17:12:58\ntags:\n - 前端框架\ncategories: Web前端\n---\n## 先安装cli脚手架，命令如下：\n```bash\nnpm install -g @vue/cli\n$vue -V //使用命令查看cli版本\n@vue/cli 4.3.1 //当前cli版本\n```\n## 初始化Vue项目，命令如下：\n```bash\nvue create \"项目名称\" //创建项目\n>Manully select features //手动选择\nBabel,Router,Vuex,CSS Pre-processors,Linter / Formatter //选择这些模块\n```\n剩下的直接回车\n\n## 升级项目，命令如下：\n```bash\ncd \"项目\"\nvue add vue-next //安装\n```\n该命令会完成：\n·安装Vue3.0依赖\n·更新Vue3.0 webpack loader配置，使其能够支持 .vue文件构建（重要）\n·创建Vue3.0 的模板代码\n·自动升级Vue Router\n·自动生成Vue Router和Vuex模板代码\n\n## 启动项目\n基于ReadMe.md，其中的命令启动项目。\n\n## 项目过程问题\n使用composition API的provide和inject实现组件间传值\n注意！！provide和inject只能在setup（）函数中使用\n```bash\nimport {provide} from 'vue' //引入provide\nprovide(\"data\",\"send\") //父组件传值\nlet send = inject(\"data\") //子组件接收\nreturn {\n  send //返回使用\n}\n```\n\n### Vue3.0新特性\nVue3.0的设计目标是更快，更小，并更好的支持TypeScript\n新特性包括\n```bash\ncomposition\nMultiple root elements\nSuspense\nMultiple V-models\nReactivity\nTeleport\nTransition\nRemove Filter\nApp configuration\n```\n\n## 1、Composition API\nVue3.0中模板带有setup（）函数，用于处理数据，需要使用ref函数声明数据（也可以直接声明函数），return返回在模板中使用。\n```bash\nimport {ref} from 'vue'\nexport default{\n   setup() {\n      const count = ref(0)\n      const inc = () =>{\n          count.value++\n      }\n      return { \n          count,\n          inc\n      }\n   }\n}\n```\ncomposition主要有两大好处：\n1.清晰的代码结构2.消除重复逻辑\n小结：composition API主要针对闭包的应用，通过其他函数中声明值，并使用watch函数监视，在需要的组件引入，达到代码复用。\n\n## 2、Multiple root elements\nVue2.0中template的根元素只能取一个，要用div包含。\nVue3.0中取消了这一限制：\n在template中使用任意数量的标签\n\n## 3、Suspense\nSuspense使用与前后端数据交互时，提供默认内容加载，当数据返回时配合使用v-if来控制数据显示。\nSuspense简化了这个过程：它提供了default和fallback状态：\n```bash\n<Suspense>\n    <template #default>\n      <div v-for=\"item in articleList\" :key=\"item.id\">\n        <article>\n          <h2>{{ item.title }}</h2>\n          <p>{{ item.body }}</p>\n        </article>\n      </div>\n    </template>\n    <template #fallback>\n      Articles loading...\n    </template>\n</Suspense>\n```\n## 4、Multiple v-models\n一个表单可以绑定多个V-model\n```bash\n<Form>\n    v-model:name=\"name\"\n    v-model:age = \"age\"\n</Form>\n```\n## 5、Reactivity\n3.0响应式系统全部用Typescript重构，利用代理（Proxy）和反射（Reflect）来替换Vue2.0的Object.defineProperty\n耦合度降低，分类清晰。\n支出通过修改数组下标的时候进行响应。\n## 6、Portals\n","slug":"Vue3-0经验","published":1,"updated":"2020-07-15T01:28:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow378001fpcva1sls5pbx","content":"<h2 id=\"先安装cli脚手架，命令如下：\"><a href=\"#先安装cli脚手架，命令如下：\" class=\"headerlink\" title=\"先安装cli脚手架，命令如下：\"></a>先安装cli脚手架，命令如下：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @vue/cli</span><br><span class=\"line\"><span class=\"variable\">$vue</span> -V //使用命令查看cli版本</span><br><span class=\"line\">@vue/cli 4.3.1 //当前cli版本</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化Vue项目，命令如下：\"><a href=\"#初始化Vue项目，命令如下：\" class=\"headerlink\" title=\"初始化Vue项目，命令如下：\"></a>初始化Vue项目，命令如下：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create <span class=\"string\">\"项目名称\"</span> //创建项目</span><br><span class=\"line\">&gt;Manully select features //手动选择</span><br><span class=\"line\">Babel,Router,Vuex,CSS Pre-processors,Linter / Formatter //选择这些模块</span><br></pre></td></tr></table></figure>\n<p>剩下的直接回车</p>\n<h2 id=\"升级项目，命令如下：\"><a href=\"#升级项目，命令如下：\" class=\"headerlink\" title=\"升级项目，命令如下：\"></a>升级项目，命令如下：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"string\">\"项目\"</span></span><br><span class=\"line\">vue add vue-next //安装</span><br></pre></td></tr></table></figure>\n<p>该命令会完成：<br>·安装Vue3.0依赖<br>·更新Vue3.0 webpack loader配置，使其能够支持 .vue文件构建（重要）<br>·创建Vue3.0 的模板代码<br>·自动升级Vue Router<br>·自动生成Vue Router和Vuex模板代码</p>\n<h2 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h2><p>基于ReadMe.md，其中的命令启动项目。</p>\n<h2 id=\"项目过程问题\"><a href=\"#项目过程问题\" class=\"headerlink\" title=\"项目过程问题\"></a>项目过程问题</h2><p>使用composition API的provide和inject实现组件间传值<br>注意！！provide和inject只能在setup（）函数中使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;provide&#125; from <span class=\"string\">'vue'</span> //引入provide</span><br><span class=\"line\">provide(<span class=\"string\">\"data\"</span>,<span class=\"string\">\"send\"</span>) //父组件传值</span><br><span class=\"line\"><span class=\"built_in\">let</span> send = inject(<span class=\"string\">\"data\"</span>) //子组件接收</span><br><span class=\"line\"><span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">  send //返回使用</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vue3-0新特性\"><a href=\"#Vue3-0新特性\" class=\"headerlink\" title=\"Vue3.0新特性\"></a>Vue3.0新特性</h3><p>Vue3.0的设计目标是更快，更小，并更好的支持TypeScript<br>新特性包括</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composition</span><br><span class=\"line\">Multiple root elements</span><br><span class=\"line\">Suspense</span><br><span class=\"line\">Multiple V-models</span><br><span class=\"line\">Reactivity</span><br><span class=\"line\">Teleport</span><br><span class=\"line\">Transition</span><br><span class=\"line\">Remove Filter</span><br><span class=\"line\">App configuration</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1、Composition-API\"><a href=\"#1、Composition-API\" class=\"headerlink\" title=\"1、Composition API\"></a>1、Composition API</h2><p>Vue3.0中模板带有setup（）函数，用于处理数据，需要使用ref函数声明数据（也可以直接声明函数），return返回在模板中使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;ref&#125; from <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> default&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"title\">setup</span></span>() &#123;</span><br><span class=\"line\">      const count = ref(0)</span><br><span class=\"line\">      const inc = () =&gt;&#123;</span><br><span class=\"line\">          count.value++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> &#123; </span><br><span class=\"line\">          count,</span><br><span class=\"line\">          inc</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>composition主要有两大好处：<br>1.清晰的代码结构2.消除重复逻辑<br>小结：composition API主要针对闭包的应用，通过其他函数中声明值，并使用watch函数监视，在需要的组件引入，达到代码复用。</p>\n<h2 id=\"2、Multiple-root-elements\"><a href=\"#2、Multiple-root-elements\" class=\"headerlink\" title=\"2、Multiple root elements\"></a>2、Multiple root elements</h2><p>Vue2.0中template的根元素只能取一个，要用div包含。<br>Vue3.0中取消了这一限制：<br>在template中使用任意数量的标签</p>\n<h2 id=\"3、Suspense\"><a href=\"#3、Suspense\" class=\"headerlink\" title=\"3、Suspense\"></a>3、Suspense</h2><p>Suspense使用与前后端数据交互时，提供默认内容加载，当数据返回时配合使用v-if来控制数据显示。<br>Suspense简化了这个过程：它提供了default和fallback状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Suspense&gt;</span><br><span class=\"line\">    &lt;template <span class=\"comment\">#default&gt;</span></span><br><span class=\"line\">      &lt;div v-for=<span class=\"string\">\"item in articleList\"</span> :key=<span class=\"string\">\"item.id\"</span>&gt;</span><br><span class=\"line\">        &lt;article&gt;</span><br><span class=\"line\">          &lt;h2&gt;&#123;&#123; item.title &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">          &lt;p&gt;&#123;&#123; item.body &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;/article&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template <span class=\"comment\">#fallback&gt;</span></span><br><span class=\"line\">      Articles loading...</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、Multiple-v-models\"><a href=\"#4、Multiple-v-models\" class=\"headerlink\" title=\"4、Multiple v-models\"></a>4、Multiple v-models</h2><p>一个表单可以绑定多个V-model</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Form&gt;</span><br><span class=\"line\">    v-model:name=<span class=\"string\">\"name\"</span></span><br><span class=\"line\">    v-model:age = <span class=\"string\">\"age\"</span></span><br><span class=\"line\">&lt;/Form&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、Reactivity\"><a href=\"#5、Reactivity\" class=\"headerlink\" title=\"5、Reactivity\"></a>5、Reactivity</h2><p>3.0响应式系统全部用Typescript重构，利用代理（Proxy）和反射（Reflect）来替换Vue2.0的Object.defineProperty<br>耦合度降低，分类清晰。<br>支出通过修改数组下标的时候进行响应。</p>\n<h2 id=\"6、Portals\"><a href=\"#6、Portals\" class=\"headerlink\" title=\"6、Portals\"></a>6、Portals</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"先安装cli脚手架，命令如下：\"><a href=\"#先安装cli脚手架，命令如下：\" class=\"headerlink\" title=\"先安装cli脚手架，命令如下：\"></a>先安装cli脚手架，命令如下：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @vue/cli</span><br><span class=\"line\"><span class=\"variable\">$vue</span> -V //使用命令查看cli版本</span><br><span class=\"line\">@vue/cli 4.3.1 //当前cli版本</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化Vue项目，命令如下：\"><a href=\"#初始化Vue项目，命令如下：\" class=\"headerlink\" title=\"初始化Vue项目，命令如下：\"></a>初始化Vue项目，命令如下：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create <span class=\"string\">\"项目名称\"</span> //创建项目</span><br><span class=\"line\">&gt;Manully select features //手动选择</span><br><span class=\"line\">Babel,Router,Vuex,CSS Pre-processors,Linter / Formatter //选择这些模块</span><br></pre></td></tr></table></figure>\n<p>剩下的直接回车</p>\n<h2 id=\"升级项目，命令如下：\"><a href=\"#升级项目，命令如下：\" class=\"headerlink\" title=\"升级项目，命令如下：\"></a>升级项目，命令如下：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"string\">\"项目\"</span></span><br><span class=\"line\">vue add vue-next //安装</span><br></pre></td></tr></table></figure>\n<p>该命令会完成：<br>·安装Vue3.0依赖<br>·更新Vue3.0 webpack loader配置，使其能够支持 .vue文件构建（重要）<br>·创建Vue3.0 的模板代码<br>·自动升级Vue Router<br>·自动生成Vue Router和Vuex模板代码</p>\n<h2 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h2><p>基于ReadMe.md，其中的命令启动项目。</p>\n<h2 id=\"项目过程问题\"><a href=\"#项目过程问题\" class=\"headerlink\" title=\"项目过程问题\"></a>项目过程问题</h2><p>使用composition API的provide和inject实现组件间传值<br>注意！！provide和inject只能在setup（）函数中使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;provide&#125; from <span class=\"string\">'vue'</span> //引入provide</span><br><span class=\"line\">provide(<span class=\"string\">\"data\"</span>,<span class=\"string\">\"send\"</span>) //父组件传值</span><br><span class=\"line\"><span class=\"built_in\">let</span> send = inject(<span class=\"string\">\"data\"</span>) //子组件接收</span><br><span class=\"line\"><span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">  send //返回使用</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vue3-0新特性\"><a href=\"#Vue3-0新特性\" class=\"headerlink\" title=\"Vue3.0新特性\"></a>Vue3.0新特性</h3><p>Vue3.0的设计目标是更快，更小，并更好的支持TypeScript<br>新特性包括</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composition</span><br><span class=\"line\">Multiple root elements</span><br><span class=\"line\">Suspense</span><br><span class=\"line\">Multiple V-models</span><br><span class=\"line\">Reactivity</span><br><span class=\"line\">Teleport</span><br><span class=\"line\">Transition</span><br><span class=\"line\">Remove Filter</span><br><span class=\"line\">App configuration</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1、Composition-API\"><a href=\"#1、Composition-API\" class=\"headerlink\" title=\"1、Composition API\"></a>1、Composition API</h2><p>Vue3.0中模板带有setup（）函数，用于处理数据，需要使用ref函数声明数据（也可以直接声明函数），return返回在模板中使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;ref&#125; from <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> default&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"title\">setup</span></span>() &#123;</span><br><span class=\"line\">      const count = ref(0)</span><br><span class=\"line\">      const inc = () =&gt;&#123;</span><br><span class=\"line\">          count.value++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> &#123; </span><br><span class=\"line\">          count,</span><br><span class=\"line\">          inc</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>composition主要有两大好处：<br>1.清晰的代码结构2.消除重复逻辑<br>小结：composition API主要针对闭包的应用，通过其他函数中声明值，并使用watch函数监视，在需要的组件引入，达到代码复用。</p>\n<h2 id=\"2、Multiple-root-elements\"><a href=\"#2、Multiple-root-elements\" class=\"headerlink\" title=\"2、Multiple root elements\"></a>2、Multiple root elements</h2><p>Vue2.0中template的根元素只能取一个，要用div包含。<br>Vue3.0中取消了这一限制：<br>在template中使用任意数量的标签</p>\n<h2 id=\"3、Suspense\"><a href=\"#3、Suspense\" class=\"headerlink\" title=\"3、Suspense\"></a>3、Suspense</h2><p>Suspense使用与前后端数据交互时，提供默认内容加载，当数据返回时配合使用v-if来控制数据显示。<br>Suspense简化了这个过程：它提供了default和fallback状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Suspense&gt;</span><br><span class=\"line\">    &lt;template <span class=\"comment\">#default&gt;</span></span><br><span class=\"line\">      &lt;div v-for=<span class=\"string\">\"item in articleList\"</span> :key=<span class=\"string\">\"item.id\"</span>&gt;</span><br><span class=\"line\">        &lt;article&gt;</span><br><span class=\"line\">          &lt;h2&gt;&#123;&#123; item.title &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">          &lt;p&gt;&#123;&#123; item.body &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">        &lt;/article&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">    &lt;template <span class=\"comment\">#fallback&gt;</span></span><br><span class=\"line\">      Articles loading...</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、Multiple-v-models\"><a href=\"#4、Multiple-v-models\" class=\"headerlink\" title=\"4、Multiple v-models\"></a>4、Multiple v-models</h2><p>一个表单可以绑定多个V-model</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Form&gt;</span><br><span class=\"line\">    v-model:name=<span class=\"string\">\"name\"</span></span><br><span class=\"line\">    v-model:age = <span class=\"string\">\"age\"</span></span><br><span class=\"line\">&lt;/Form&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、Reactivity\"><a href=\"#5、Reactivity\" class=\"headerlink\" title=\"5、Reactivity\"></a>5、Reactivity</h2><p>3.0响应式系统全部用Typescript重构，利用代理（Proxy）和反射（Reflect）来替换Vue2.0的Object.defineProperty<br>耦合度降低，分类清晰。<br>支出通过修改数组下标的时候进行响应。</p>\n<h2 id=\"6、Portals\"><a href=\"#6、Portals\" class=\"headerlink\" title=\"6、Portals\"></a>6、Portals</h2>"},{"title":"Vue源码学习","date":"2020-07-06T06:10:53.000Z","_content":"### 1.0 如何监听一个对象的变化\n\n1.Object.defineProperty方法//ES5中新增->可以自定义getter和setter函数，从而在\n获取对象属性和设置对象属性的时候能够执行自定义的回调函数。\n2.对象是个层次的结构，对象的某个属性可能仍是一个对象。\n```bash\nlet data = {\n    user: {\n        name: \"liangshaofeng\",\n        age: \"24\"\n    },\n    address: {\n        city: \"beijing\"\n    }\n};\n```\n解决方案：如果对象的属性仍然是一个对象，那么使用递归算法，walk函数，继续new一个Observer\n直到到达最底层的属性位置。\n实现代码：\n```bash\n// 观察者构造函数\nfunction Observer(data) {\n    this.data = data;\n    this.walk(data)\n}\n\nlet p = Observer.prototype;\n\n// 此函数用于深层次遍历对象的各个属性\n// 采用的是递归的思路\n// 因为我们要为对象的每一个属性绑定getter和setter\np.walk = function (obj) {\n    let val;\n    for (let key in obj) {\n        // 这里为什么要用hasOwnProperty进行过滤呢？\n        // 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来\n        // 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。\n        if (obj.hasOwnProperty(key)) {\n            val = obj[key];\n\n            // 这里进行判断，如果还没有遍历到最底层，继续new Observer\n            if (typeof val === 'object') {\n                new Observer(val);\n            }\n\n            this.convert(key, val);\n        }\n    }\n};\n\np.convert = function (key, val) {\n    Object.defineProperty(this.data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            console.log('你访问了' + key);\n            return val\n        },\n        set: function (newVal) {\n            console.log('你设置了' + key);\n            console.log('新的' + key + ' = ' + newVal)\n            if (newVal === val) return;\n            val = newVal\n        }\n    })\n};\n\nlet data = {\n    user: {\n        name: \"liangshaofeng\",\n        age: \"24\"\n    },\n    address: {\n        city: \"beijing\"\n    }\n};\n\nlet app = new Observer(data);\n```\n1.上面的代码只监听了对象的变化，没有处理数组的变化。\n2.当你重新set的属性是对象的话，那么新set的对象里面的属性不能调用getter和setter。\n3.①实现observer②消息-订阅器③实现一个watcher④实现一个vue\n4.①↑通过递归，给每个属性（包括子属性）加上get/set，有赋值触发set方法，发出通知，触发回调。\n5.②↑watcher为订阅者，一旦触发notify函数，遍历watcher，调用update方法。\n6.③↑实现watcher，内置构造函数，update函数（调用更新数据的函数），根据判断object.defineProperty的get是否有值来调用。\n7.④↑实现一个vue，引入observer，引入watcher，observer自己的data，访问data的属性，watcher属性。\n实现vue的代码如下：\n```bash\nimport Watcher from '../watcher'\nimport {observe} from \"../observer\"\n\nexport default class Vue {\n  constructor (options={}) {\n    //这里简化了。。其实要merge\n    this.$options=options\n    //这里简化了。。其实要区分的\n    let data = this._data=this.$options.data\n    Object.keys(data).forEach(key=>this._proxy(key))\n    observe(data,this)\n  }\n\n\n  $watch(expOrFn, cb, options){\n    new Watcher(this, expOrFn, cb)\n  }\n\n  _proxy(key) {\n    var self = this\n    Object.defineProperty(self, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return self._data[key]\n      },\n      set: function proxySetter (val) {\n        self._data[key] = val\n      }\n    })\n  }\n}\n```\n---\n\n### 2.0 如何监听一个数组的变化\nVue.js包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：\n```bash\n.push()\n.pop()\n.shift()\n.unshift()\n.splice()\n.sort()\n.reverse()\n```\nVue.js不能检测到下面数组变化：\n```bash\n.直接用索引设置元素，如vm.items[0] = {};\n.修改数据的长度，如vm.items.length = 0。\n```\n修改push()函数的实现：\n```bash\nfunction FakeArray() {\n    Array.call(this,arguments);\n}\n\nFakeArray.prototype = [];\nFakeArray.prototype.constructor = FakeArray;\n\nFakeArray.prototype.push = function () {\n    console.log('我被改变啦');\n    return Array.prototype.push.call(this,arguments);\n};\n\nlet list = ['a','b','c'];\n\nlet fakeList = new FakeArray(list);\n```\n这里是类似一种继承，在继承了push函数的情况下多增一些方法。\n构造函数默认返回的是this对象，而非数组，Array.call(this.arguments)这个返回的是数组。\n如果直接return一个原生的Array出来，push函数就没达到重写了。\n\n---\n\n### 3.0如何实现一个watcher库\n[实现watcher库请看这](https://github.com/melanke/Watch.JS)\n\n### 4.0如何实现动态数据绑定\n\n```bash\n// html\n<div id=\"app\">\n    <p>姓名:{{user.name}}</p>\n    <p>年龄:{{user.age}}</p>\n</div>\n```\n```bash\n// js\nconst app = new Bue({\n    el: '#app',\n    data: {\n        user: {\n            name: 'youngwind',\n            age: 24\n        }\n    }\n});\n```\n直接遍历DOM模板把数据改成实际值替换，存在问题\n①修改非DOM相关数据也会触发DOM的重新渲染。\n②修改DOM相关属性会渲染更新整个DOM。\n\n指令Directive\n只更新数据变动相关的DOM，必须有个对象将DOM节点和对应的数据一一映射起来。\n```bash\n/**\n * 指令构造函数\n * @param name {string} 值为\"text\", 代表是文本节点\n * @param el {Element} 对应的DOM元素\n * @param vm {Bue} bue实例\n * @param expression {String} 指令表达式，例如 \"name\"\n*  @param attr {String} 值为'nodeValue', 代表数据值对应的书节点的值\n * @constructor\n */\nfunction Directive(name, el, vm, expression) {\n    this.name = name;  // 指令的名称， 对于普通的文本节点来说，值为\"text\"\n    this.el = el;              // 指令对应的DOM元素\n    this.vm = vm;          // 指令所属bue实例\n    this.expression = expression;       // 指令表达式，例如 \"name\"\n    this.attr = 'nodeValue';        \n    this.update();\n}\n\n// 这是指令的更新方法。当对应的数据发生改变了，就会执行这个方法\n// 可以看出来，这个方法就是用来更新nodeValue的\nDirective.prototype.update = function () {\n    this.el[this.attr] = this.vm.$data[this.expression];\n    console.log(`更新了DOM-${this.expression}`);\n};\n```\n实现思路：遍历DOM节点时，会匹配出表达式，新建空的textNode，插入到这个节点前面，\n然后remove掉这个文本节点。\n\n存在问题：每次数据发生改变的时候，都需要循环directive，匹配表达式值才能找到指令，\n效率很低。且根据$watch对应的回调函数与DOM无关，不会有el和attr。\n\n解决思路：引入binding和watcher这两个类。\n每个属性上都有一个数组，这个数组是订阅的意思，里面存放着一系列watcher，当watcher\n代表数据发生改变时，会遍历数组，执行update更新。\nWatcher是一个观察容器，可以装载Directive。\n根据Binding（解决键值索引）、watcher（解决$watch）、Directive(更新DOM中属性值)三者实现双向数据绑定。\n\n### 5.0批处理更新DOM\n频繁操作DOM是低效率的，实现多次数据更新只更新一次DOM。\n\n官方注：每观察到数据变化，Vue会开始一个队列，将同一事件循环内所有的数据变化\n缓存起来，一个watcher多次被触发，只会推入一次到队列中。下次循环，清空队列，进行\n必要的DOM更新。\n解决原理：Batcher，批处理类。\n```bash\n/**\n * 批处理构造函数\n * @constructor\n */\nfunction Batcher() {\n    this.reset();\n}\n\n/**\n * 批处理重置\n */\nBatcher.prototype.reset = function () {\n    this.has = {};\n    this.queue = [];\n    this.waiting = false;\n};\n\n/**\n * 将事件添加到队列中\n * @param job {Watcher} watcher事件\n */\nBatcher.prototype.push = function (job) {\n    if (!this.has[job.id]) {\n        this.queue.push(job);\n        this.has[job.id] = job;\n        if (!this.waiting) { // wating用于保护\n            this.waiting = true;\n            setTimeout(() => {\n                this.flush();// 更新执行的函数\n            });\n        }\n    }\n};\n\n/**\n * 执行并清空事件队列\n */\nBatcher.prototype.flush = function () {\n    this.queue.forEach((job) => {\n        job.cb.call(job.ctx);\n    });\n    this.reset();//重置队列，保证下次能更新数据\n};\n```\n","source":"_posts/Vue源码学习.md","raw":"---\ntitle: Vue源码学习\ndate: 2020-07-06 14:10:53\ntags:\n - 前端框架\ncategories: Web前端\n---\n### 1.0 如何监听一个对象的变化\n\n1.Object.defineProperty方法//ES5中新增->可以自定义getter和setter函数，从而在\n获取对象属性和设置对象属性的时候能够执行自定义的回调函数。\n2.对象是个层次的结构，对象的某个属性可能仍是一个对象。\n```bash\nlet data = {\n    user: {\n        name: \"liangshaofeng\",\n        age: \"24\"\n    },\n    address: {\n        city: \"beijing\"\n    }\n};\n```\n解决方案：如果对象的属性仍然是一个对象，那么使用递归算法，walk函数，继续new一个Observer\n直到到达最底层的属性位置。\n实现代码：\n```bash\n// 观察者构造函数\nfunction Observer(data) {\n    this.data = data;\n    this.walk(data)\n}\n\nlet p = Observer.prototype;\n\n// 此函数用于深层次遍历对象的各个属性\n// 采用的是递归的思路\n// 因为我们要为对象的每一个属性绑定getter和setter\np.walk = function (obj) {\n    let val;\n    for (let key in obj) {\n        // 这里为什么要用hasOwnProperty进行过滤呢？\n        // 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来\n        // 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。\n        if (obj.hasOwnProperty(key)) {\n            val = obj[key];\n\n            // 这里进行判断，如果还没有遍历到最底层，继续new Observer\n            if (typeof val === 'object') {\n                new Observer(val);\n            }\n\n            this.convert(key, val);\n        }\n    }\n};\n\np.convert = function (key, val) {\n    Object.defineProperty(this.data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            console.log('你访问了' + key);\n            return val\n        },\n        set: function (newVal) {\n            console.log('你设置了' + key);\n            console.log('新的' + key + ' = ' + newVal)\n            if (newVal === val) return;\n            val = newVal\n        }\n    })\n};\n\nlet data = {\n    user: {\n        name: \"liangshaofeng\",\n        age: \"24\"\n    },\n    address: {\n        city: \"beijing\"\n    }\n};\n\nlet app = new Observer(data);\n```\n1.上面的代码只监听了对象的变化，没有处理数组的变化。\n2.当你重新set的属性是对象的话，那么新set的对象里面的属性不能调用getter和setter。\n3.①实现observer②消息-订阅器③实现一个watcher④实现一个vue\n4.①↑通过递归，给每个属性（包括子属性）加上get/set，有赋值触发set方法，发出通知，触发回调。\n5.②↑watcher为订阅者，一旦触发notify函数，遍历watcher，调用update方法。\n6.③↑实现watcher，内置构造函数，update函数（调用更新数据的函数），根据判断object.defineProperty的get是否有值来调用。\n7.④↑实现一个vue，引入observer，引入watcher，observer自己的data，访问data的属性，watcher属性。\n实现vue的代码如下：\n```bash\nimport Watcher from '../watcher'\nimport {observe} from \"../observer\"\n\nexport default class Vue {\n  constructor (options={}) {\n    //这里简化了。。其实要merge\n    this.$options=options\n    //这里简化了。。其实要区分的\n    let data = this._data=this.$options.data\n    Object.keys(data).forEach(key=>this._proxy(key))\n    observe(data,this)\n  }\n\n\n  $watch(expOrFn, cb, options){\n    new Watcher(this, expOrFn, cb)\n  }\n\n  _proxy(key) {\n    var self = this\n    Object.defineProperty(self, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return self._data[key]\n      },\n      set: function proxySetter (val) {\n        self._data[key] = val\n      }\n    })\n  }\n}\n```\n---\n\n### 2.0 如何监听一个数组的变化\nVue.js包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：\n```bash\n.push()\n.pop()\n.shift()\n.unshift()\n.splice()\n.sort()\n.reverse()\n```\nVue.js不能检测到下面数组变化：\n```bash\n.直接用索引设置元素，如vm.items[0] = {};\n.修改数据的长度，如vm.items.length = 0。\n```\n修改push()函数的实现：\n```bash\nfunction FakeArray() {\n    Array.call(this,arguments);\n}\n\nFakeArray.prototype = [];\nFakeArray.prototype.constructor = FakeArray;\n\nFakeArray.prototype.push = function () {\n    console.log('我被改变啦');\n    return Array.prototype.push.call(this,arguments);\n};\n\nlet list = ['a','b','c'];\n\nlet fakeList = new FakeArray(list);\n```\n这里是类似一种继承，在继承了push函数的情况下多增一些方法。\n构造函数默认返回的是this对象，而非数组，Array.call(this.arguments)这个返回的是数组。\n如果直接return一个原生的Array出来，push函数就没达到重写了。\n\n---\n\n### 3.0如何实现一个watcher库\n[实现watcher库请看这](https://github.com/melanke/Watch.JS)\n\n### 4.0如何实现动态数据绑定\n\n```bash\n// html\n<div id=\"app\">\n    <p>姓名:{{user.name}}</p>\n    <p>年龄:{{user.age}}</p>\n</div>\n```\n```bash\n// js\nconst app = new Bue({\n    el: '#app',\n    data: {\n        user: {\n            name: 'youngwind',\n            age: 24\n        }\n    }\n});\n```\n直接遍历DOM模板把数据改成实际值替换，存在问题\n①修改非DOM相关数据也会触发DOM的重新渲染。\n②修改DOM相关属性会渲染更新整个DOM。\n\n指令Directive\n只更新数据变动相关的DOM，必须有个对象将DOM节点和对应的数据一一映射起来。\n```bash\n/**\n * 指令构造函数\n * @param name {string} 值为\"text\", 代表是文本节点\n * @param el {Element} 对应的DOM元素\n * @param vm {Bue} bue实例\n * @param expression {String} 指令表达式，例如 \"name\"\n*  @param attr {String} 值为'nodeValue', 代表数据值对应的书节点的值\n * @constructor\n */\nfunction Directive(name, el, vm, expression) {\n    this.name = name;  // 指令的名称， 对于普通的文本节点来说，值为\"text\"\n    this.el = el;              // 指令对应的DOM元素\n    this.vm = vm;          // 指令所属bue实例\n    this.expression = expression;       // 指令表达式，例如 \"name\"\n    this.attr = 'nodeValue';        \n    this.update();\n}\n\n// 这是指令的更新方法。当对应的数据发生改变了，就会执行这个方法\n// 可以看出来，这个方法就是用来更新nodeValue的\nDirective.prototype.update = function () {\n    this.el[this.attr] = this.vm.$data[this.expression];\n    console.log(`更新了DOM-${this.expression}`);\n};\n```\n实现思路：遍历DOM节点时，会匹配出表达式，新建空的textNode，插入到这个节点前面，\n然后remove掉这个文本节点。\n\n存在问题：每次数据发生改变的时候，都需要循环directive，匹配表达式值才能找到指令，\n效率很低。且根据$watch对应的回调函数与DOM无关，不会有el和attr。\n\n解决思路：引入binding和watcher这两个类。\n每个属性上都有一个数组，这个数组是订阅的意思，里面存放着一系列watcher，当watcher\n代表数据发生改变时，会遍历数组，执行update更新。\nWatcher是一个观察容器，可以装载Directive。\n根据Binding（解决键值索引）、watcher（解决$watch）、Directive(更新DOM中属性值)三者实现双向数据绑定。\n\n### 5.0批处理更新DOM\n频繁操作DOM是低效率的，实现多次数据更新只更新一次DOM。\n\n官方注：每观察到数据变化，Vue会开始一个队列，将同一事件循环内所有的数据变化\n缓存起来，一个watcher多次被触发，只会推入一次到队列中。下次循环，清空队列，进行\n必要的DOM更新。\n解决原理：Batcher，批处理类。\n```bash\n/**\n * 批处理构造函数\n * @constructor\n */\nfunction Batcher() {\n    this.reset();\n}\n\n/**\n * 批处理重置\n */\nBatcher.prototype.reset = function () {\n    this.has = {};\n    this.queue = [];\n    this.waiting = false;\n};\n\n/**\n * 将事件添加到队列中\n * @param job {Watcher} watcher事件\n */\nBatcher.prototype.push = function (job) {\n    if (!this.has[job.id]) {\n        this.queue.push(job);\n        this.has[job.id] = job;\n        if (!this.waiting) { // wating用于保护\n            this.waiting = true;\n            setTimeout(() => {\n                this.flush();// 更新执行的函数\n            });\n        }\n    }\n};\n\n/**\n * 执行并清空事件队列\n */\nBatcher.prototype.flush = function () {\n    this.queue.forEach((job) => {\n        job.cb.call(job.ctx);\n    });\n    this.reset();//重置队列，保证下次能更新数据\n};\n```\n","slug":"Vue源码学习","published":1,"updated":"2020-07-06T07:43:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow379001hpcva4qe08lr5","content":"<h3 id=\"1-0-如何监听一个对象的变化\"><a href=\"#1-0-如何监听一个对象的变化\" class=\"headerlink\" title=\"1.0 如何监听一个对象的变化\"></a>1.0 如何监听一个对象的变化</h3><p>1.Object.defineProperty方法//ES5中新增-&gt;可以自定义getter和setter函数，从而在<br>获取对象属性和设置对象属性的时候能够执行自定义的回调函数。<br>2.对象是个层次的结构，对象的某个属性可能仍是一个对象。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> data = &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">\"liangshaofeng\"</span>,</span><br><span class=\"line\">        age: <span class=\"string\">\"24\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    address: &#123;</span><br><span class=\"line\">        city: <span class=\"string\">\"beijing\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解决方案：如果对象的属性仍然是一个对象，那么使用递归算法，walk函数，继续new一个Observer<br>直到到达最底层的属性位置。<br>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 观察者构造函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> Observer(data) &#123;</span><br><span class=\"line\">    this.data = data;</span><br><span class=\"line\">    this.walk(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> p = Observer.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">// 此函数用于深层次遍历对象的各个属性</span><br><span class=\"line\">// 采用的是递归的思路</span><br><span class=\"line\">// 因为我们要为对象的每一个属性绑定getter和setter</span><br><span class=\"line\">p.walk = <span class=\"keyword\">function</span> (obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> val;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        // 这里为什么要用hasOwnProperty进行过滤呢？</span><br><span class=\"line\">        // 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来</span><br><span class=\"line\">        // 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">            val = obj[key];</span><br><span class=\"line\"></span><br><span class=\"line\">            // 这里进行判断，如果还没有遍历到最底层，继续new Observer</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeof val === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">                new Observer(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            this.convert(key, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p.convert = <span class=\"keyword\">function</span> (key, val) &#123;</span><br><span class=\"line\">    Object.defineProperty(this.data, key, &#123;</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            console.log(<span class=\"string\">'你访问了'</span> + key);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> val</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"built_in\">set</span>: <span class=\"keyword\">function</span> (newVal) &#123;</span><br><span class=\"line\">            console.log(<span class=\"string\">'你设置了'</span> + key);</span><br><span class=\"line\">            console.log(<span class=\"string\">'新的'</span> + key + <span class=\"string\">' = '</span> + newVal)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newVal === val) <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            val = newVal</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> data = &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">\"liangshaofeng\"</span>,</span><br><span class=\"line\">        age: <span class=\"string\">\"24\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    address: &#123;</span><br><span class=\"line\">        city: <span class=\"string\">\"beijing\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> app = new Observer(data);</span><br></pre></td></tr></table></figure>\n<p>1.上面的代码只监听了对象的变化，没有处理数组的变化。<br>2.当你重新set的属性是对象的话，那么新set的对象里面的属性不能调用getter和setter。<br>3.①实现observer②消息-订阅器③实现一个watcher④实现一个vue<br>4.①↑通过递归，给每个属性（包括子属性）加上get/set，有赋值触发set方法，发出通知，触发回调。<br>5.②↑watcher为订阅者，一旦触发notify函数，遍历watcher，调用update方法。<br>6.③↑实现watcher，内置构造函数，update函数（调用更新数据的函数），根据判断object.defineProperty的get是否有值来调用。<br>7.④↑实现一个vue，引入observer，引入watcher，observer自己的data，访问data的属性，watcher属性。<br>实现vue的代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Watcher from <span class=\"string\">'../watcher'</span></span><br><span class=\"line\">import &#123;observe&#125; from <span class=\"string\">\"../observer\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default class Vue &#123;</span><br><span class=\"line\">  constructor (options=&#123;&#125;) &#123;</span><br><span class=\"line\">    //这里简化了。。其实要merge</span><br><span class=\"line\">    this.<span class=\"variable\">$options</span>=options</span><br><span class=\"line\">    //这里简化了。。其实要区分的</span><br><span class=\"line\">    <span class=\"built_in\">let</span> data = this._data=this.<span class=\"variable\">$options</span>.data</span><br><span class=\"line\">    Object.keys(data).forEach(key=&gt;this._proxy(key))</span><br><span class=\"line\">    observe(data,this)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable\">$watch</span>(expOrFn, cb, options)&#123;</span><br><span class=\"line\">    new Watcher(this, expOrFn, cb)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _proxy(key) &#123;</span><br><span class=\"line\">    var self = this</span><br><span class=\"line\">    Object.defineProperty(self, key, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      get: <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">proxyGetter</span></span> () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> self._data[key]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"built_in\">set</span>: <span class=\"keyword\">function</span> proxySetter (val) &#123;</span><br><span class=\"line\">        self._data[key] = val</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-0-如何监听一个数组的变化\"><a href=\"#2-0-如何监听一个数组的变化\" class=\"headerlink\" title=\"2.0 如何监听一个数组的变化\"></a>2.0 如何监听一个数组的变化</h3><p>Vue.js包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.push()</span><br><span class=\"line\">.pop()</span><br><span class=\"line\">.<span class=\"built_in\">shift</span>()</span><br><span class=\"line\">.unshift()</span><br><span class=\"line\">.splice()</span><br><span class=\"line\">.sort()</span><br><span class=\"line\">.reverse()</span><br></pre></td></tr></table></figure>\n<p>Vue.js不能检测到下面数组变化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.直接用索引设置元素，如vm.items[0] = &#123;&#125;;</span><br><span class=\"line\">.修改数据的长度，如vm.items.length = 0。</span><br></pre></td></tr></table></figure>\n<p>修改push()函数的实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">FakeArray</span></span>() &#123;</span><br><span class=\"line\">    Array.call(this,arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FakeArray.prototype = [];</span><br><span class=\"line\">FakeArray.prototype.constructor = FakeArray;</span><br><span class=\"line\"></span><br><span class=\"line\">FakeArray.prototype.push = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'我被改变啦'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Array.prototype.push.call(this,arguments);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> list = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> fakeList = new FakeArray(list);</span><br></pre></td></tr></table></figure>\n<p>这里是类似一种继承，在继承了push函数的情况下多增一些方法。<br>构造函数默认返回的是this对象，而非数组，Array.call(this.arguments)这个返回的是数组。<br>如果直接return一个原生的Array出来，push函数就没达到重写了。</p>\n<hr>\n<h3 id=\"3-0如何实现一个watcher库\"><a href=\"#3-0如何实现一个watcher库\" class=\"headerlink\" title=\"3.0如何实现一个watcher库\"></a>3.0如何实现一个watcher库</h3><p><a href=\"https://github.com/melanke/Watch.JS\" target=\"_blank\" rel=\"noopener\">实现watcher库请看这</a></p>\n<h3 id=\"4-0如何实现动态数据绑定\"><a href=\"#4-0如何实现动态数据绑定\" class=\"headerlink\" title=\"4.0如何实现动态数据绑定\"></a>4.0如何实现动态数据绑定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// html</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;年龄:&#123;&#123;user.age&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// js</span><br><span class=\"line\">const app = new Bue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        user: &#123;</span><br><span class=\"line\">            name: <span class=\"string\">'youngwind'</span>,</span><br><span class=\"line\">            age: 24</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>直接遍历DOM模板把数据改成实际值替换，存在问题<br>①修改非DOM相关数据也会触发DOM的重新渲染。<br>②修改DOM相关属性会渲染更新整个DOM。</p>\n<p>指令Directive<br>只更新数据变动相关的DOM，必须有个对象将DOM节点和对应的数据一一映射起来。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 指令构造函数</span><br><span class=\"line\"> * @param name &#123;string&#125; 值为<span class=\"string\">\"text\"</span>, 代表是文本节点</span><br><span class=\"line\"> * @param el &#123;Element&#125; 对应的DOM元素</span><br><span class=\"line\"> * @param vm &#123;Bue&#125; bue实例</span><br><span class=\"line\"> * @param expression &#123;String&#125; 指令表达式，例如 <span class=\"string\">\"name\"</span></span><br><span class=\"line\">*  @param attr &#123;String&#125; 值为<span class=\"string\">'nodeValue'</span>, 代表数据值对应的书节点的值</span><br><span class=\"line\"> * @constructor</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> Directive(name, el, vm, expression) &#123;</span><br><span class=\"line\">    this.name = name;  // 指令的名称， 对于普通的文本节点来说，值为<span class=\"string\">\"text\"</span></span><br><span class=\"line\">    this.el = el;              // 指令对应的DOM元素</span><br><span class=\"line\">    this.vm = vm;          // 指令所属bue实例</span><br><span class=\"line\">    this.expression = expression;       // 指令表达式，例如 <span class=\"string\">\"name\"</span></span><br><span class=\"line\">    this.attr = <span class=\"string\">'nodeValue'</span>;        </span><br><span class=\"line\">    this.update();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这是指令的更新方法。当对应的数据发生改变了，就会执行这个方法</span><br><span class=\"line\">// 可以看出来，这个方法就是用来更新nodeValue的</span><br><span class=\"line\">Directive.prototype.update = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.el[this.attr] = this.vm.<span class=\"variable\">$data</span>[this.expression];</span><br><span class=\"line\">    console.log(`更新了DOM-<span class=\"variable\">$&#123;this.expression&#125;</span>`);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>实现思路：遍历DOM节点时，会匹配出表达式，新建空的textNode，插入到这个节点前面，<br>然后remove掉这个文本节点。</p>\n<p>存在问题：每次数据发生改变的时候，都需要循环directive，匹配表达式值才能找到指令，<br>效率很低。且根据$watch对应的回调函数与DOM无关，不会有el和attr。</p>\n<p>解决思路：引入binding和watcher这两个类。<br>每个属性上都有一个数组，这个数组是订阅的意思，里面存放着一系列watcher，当watcher<br>代表数据发生改变时，会遍历数组，执行update更新。<br>Watcher是一个观察容器，可以装载Directive。<br>根据Binding（解决键值索引）、watcher（解决$watch）、Directive(更新DOM中属性值)三者实现双向数据绑定。</p>\n<h3 id=\"5-0批处理更新DOM\"><a href=\"#5-0批处理更新DOM\" class=\"headerlink\" title=\"5.0批处理更新DOM\"></a>5.0批处理更新DOM</h3><p>频繁操作DOM是低效率的，实现多次数据更新只更新一次DOM。</p>\n<p>官方注：每观察到数据变化，Vue会开始一个队列，将同一事件循环内所有的数据变化<br>缓存起来，一个watcher多次被触发，只会推入一次到队列中。下次循环，清空队列，进行<br>必要的DOM更新。<br>解决原理：Batcher，批处理类。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 批处理构造函数</span><br><span class=\"line\"> * @constructor</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Batcher</span></span>() &#123;</span><br><span class=\"line\">    this.reset();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 批处理重置</span><br><span class=\"line\"> */</span><br><span class=\"line\">Batcher.prototype.reset = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.has = &#123;&#125;;</span><br><span class=\"line\">    this.queue = [];</span><br><span class=\"line\">    this.waiting = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 将事件添加到队列中</span><br><span class=\"line\"> * @param job &#123;Watcher&#125; watcher事件</span><br><span class=\"line\"> */</span><br><span class=\"line\">Batcher.prototype.push = <span class=\"keyword\">function</span> (job) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!this.has[job.id]) &#123;</span><br><span class=\"line\">        this.queue.push(job);</span><br><span class=\"line\">        this.has[job.id] = job;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!this.waiting) &#123; // wating用于保护</span><br><span class=\"line\">            this.waiting = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                this.flush();// 更新执行的函数</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 执行并清空事件队列</span><br><span class=\"line\"> */</span><br><span class=\"line\">Batcher.prototype.flush = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.queue.forEach((job) =&gt; &#123;</span><br><span class=\"line\">        job.cb.call(job.ctx);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    this.reset();//重置队列，保证下次能更新数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-0-如何监听一个对象的变化\"><a href=\"#1-0-如何监听一个对象的变化\" class=\"headerlink\" title=\"1.0 如何监听一个对象的变化\"></a>1.0 如何监听一个对象的变化</h3><p>1.Object.defineProperty方法//ES5中新增-&gt;可以自定义getter和setter函数，从而在<br>获取对象属性和设置对象属性的时候能够执行自定义的回调函数。<br>2.对象是个层次的结构，对象的某个属性可能仍是一个对象。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> data = &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">\"liangshaofeng\"</span>,</span><br><span class=\"line\">        age: <span class=\"string\">\"24\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    address: &#123;</span><br><span class=\"line\">        city: <span class=\"string\">\"beijing\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解决方案：如果对象的属性仍然是一个对象，那么使用递归算法，walk函数，继续new一个Observer<br>直到到达最底层的属性位置。<br>实现代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 观察者构造函数</span><br><span class=\"line\"><span class=\"keyword\">function</span> Observer(data) &#123;</span><br><span class=\"line\">    this.data = data;</span><br><span class=\"line\">    this.walk(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> p = Observer.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">// 此函数用于深层次遍历对象的各个属性</span><br><span class=\"line\">// 采用的是递归的思路</span><br><span class=\"line\">// 因为我们要为对象的每一个属性绑定getter和setter</span><br><span class=\"line\">p.walk = <span class=\"keyword\">function</span> (obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> val;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        // 这里为什么要用hasOwnProperty进行过滤呢？</span><br><span class=\"line\">        // 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来</span><br><span class=\"line\">        // 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">            val = obj[key];</span><br><span class=\"line\"></span><br><span class=\"line\">            // 这里进行判断，如果还没有遍历到最底层，继续new Observer</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeof val === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">                new Observer(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            this.convert(key, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p.convert = <span class=\"keyword\">function</span> (key, val) &#123;</span><br><span class=\"line\">    Object.defineProperty(this.data, key, &#123;</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            console.log(<span class=\"string\">'你访问了'</span> + key);</span><br><span class=\"line\">            <span class=\"built_in\">return</span> val</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"built_in\">set</span>: <span class=\"keyword\">function</span> (newVal) &#123;</span><br><span class=\"line\">            console.log(<span class=\"string\">'你设置了'</span> + key);</span><br><span class=\"line\">            console.log(<span class=\"string\">'新的'</span> + key + <span class=\"string\">' = '</span> + newVal)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newVal === val) <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            val = newVal</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> data = &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">        name: <span class=\"string\">\"liangshaofeng\"</span>,</span><br><span class=\"line\">        age: <span class=\"string\">\"24\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    address: &#123;</span><br><span class=\"line\">        city: <span class=\"string\">\"beijing\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> app = new Observer(data);</span><br></pre></td></tr></table></figure>\n<p>1.上面的代码只监听了对象的变化，没有处理数组的变化。<br>2.当你重新set的属性是对象的话，那么新set的对象里面的属性不能调用getter和setter。<br>3.①实现observer②消息-订阅器③实现一个watcher④实现一个vue<br>4.①↑通过递归，给每个属性（包括子属性）加上get/set，有赋值触发set方法，发出通知，触发回调。<br>5.②↑watcher为订阅者，一旦触发notify函数，遍历watcher，调用update方法。<br>6.③↑实现watcher，内置构造函数，update函数（调用更新数据的函数），根据判断object.defineProperty的get是否有值来调用。<br>7.④↑实现一个vue，引入observer，引入watcher，observer自己的data，访问data的属性，watcher属性。<br>实现vue的代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Watcher from <span class=\"string\">'../watcher'</span></span><br><span class=\"line\">import &#123;observe&#125; from <span class=\"string\">\"../observer\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default class Vue &#123;</span><br><span class=\"line\">  constructor (options=&#123;&#125;) &#123;</span><br><span class=\"line\">    //这里简化了。。其实要merge</span><br><span class=\"line\">    this.<span class=\"variable\">$options</span>=options</span><br><span class=\"line\">    //这里简化了。。其实要区分的</span><br><span class=\"line\">    <span class=\"built_in\">let</span> data = this._data=this.<span class=\"variable\">$options</span>.data</span><br><span class=\"line\">    Object.keys(data).forEach(key=&gt;this._proxy(key))</span><br><span class=\"line\">    observe(data,this)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable\">$watch</span>(expOrFn, cb, options)&#123;</span><br><span class=\"line\">    new Watcher(this, expOrFn, cb)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _proxy(key) &#123;</span><br><span class=\"line\">    var self = this</span><br><span class=\"line\">    Object.defineProperty(self, key, &#123;</span><br><span class=\"line\">      configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      get: <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">proxyGetter</span></span> () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> self._data[key]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"built_in\">set</span>: <span class=\"keyword\">function</span> proxySetter (val) &#123;</span><br><span class=\"line\">        self._data[key] = val</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-0-如何监听一个数组的变化\"><a href=\"#2-0-如何监听一个数组的变化\" class=\"headerlink\" title=\"2.0 如何监听一个数组的变化\"></a>2.0 如何监听一个数组的变化</h3><p>Vue.js包装了被观察数组的变异方法，故它们能触发视图更新。被包装的方法有：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.push()</span><br><span class=\"line\">.pop()</span><br><span class=\"line\">.<span class=\"built_in\">shift</span>()</span><br><span class=\"line\">.unshift()</span><br><span class=\"line\">.splice()</span><br><span class=\"line\">.sort()</span><br><span class=\"line\">.reverse()</span><br></pre></td></tr></table></figure>\n<p>Vue.js不能检测到下面数组变化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.直接用索引设置元素，如vm.items[0] = &#123;&#125;;</span><br><span class=\"line\">.修改数据的长度，如vm.items.length = 0。</span><br></pre></td></tr></table></figure>\n<p>修改push()函数的实现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">FakeArray</span></span>() &#123;</span><br><span class=\"line\">    Array.call(this,arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FakeArray.prototype = [];</span><br><span class=\"line\">FakeArray.prototype.constructor = FakeArray;</span><br><span class=\"line\"></span><br><span class=\"line\">FakeArray.prototype.push = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'我被改变啦'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> Array.prototype.push.call(this,arguments);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> list = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">let</span> fakeList = new FakeArray(list);</span><br></pre></td></tr></table></figure>\n<p>这里是类似一种继承，在继承了push函数的情况下多增一些方法。<br>构造函数默认返回的是this对象，而非数组，Array.call(this.arguments)这个返回的是数组。<br>如果直接return一个原生的Array出来，push函数就没达到重写了。</p>\n<hr>\n<h3 id=\"3-0如何实现一个watcher库\"><a href=\"#3-0如何实现一个watcher库\" class=\"headerlink\" title=\"3.0如何实现一个watcher库\"></a>3.0如何实现一个watcher库</h3><p><a href=\"https://github.com/melanke/Watch.JS\" target=\"_blank\" rel=\"noopener\">实现watcher库请看这</a></p>\n<h3 id=\"4-0如何实现动态数据绑定\"><a href=\"#4-0如何实现动态数据绑定\" class=\"headerlink\" title=\"4.0如何实现动态数据绑定\"></a>4.0如何实现动态数据绑定</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// html</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;年龄:&#123;&#123;user.age&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// js</span><br><span class=\"line\">const app = new Bue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        user: &#123;</span><br><span class=\"line\">            name: <span class=\"string\">'youngwind'</span>,</span><br><span class=\"line\">            age: 24</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>直接遍历DOM模板把数据改成实际值替换，存在问题<br>①修改非DOM相关数据也会触发DOM的重新渲染。<br>②修改DOM相关属性会渲染更新整个DOM。</p>\n<p>指令Directive<br>只更新数据变动相关的DOM，必须有个对象将DOM节点和对应的数据一一映射起来。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 指令构造函数</span><br><span class=\"line\"> * @param name &#123;string&#125; 值为<span class=\"string\">\"text\"</span>, 代表是文本节点</span><br><span class=\"line\"> * @param el &#123;Element&#125; 对应的DOM元素</span><br><span class=\"line\"> * @param vm &#123;Bue&#125; bue实例</span><br><span class=\"line\"> * @param expression &#123;String&#125; 指令表达式，例如 <span class=\"string\">\"name\"</span></span><br><span class=\"line\">*  @param attr &#123;String&#125; 值为<span class=\"string\">'nodeValue'</span>, 代表数据值对应的书节点的值</span><br><span class=\"line\"> * @constructor</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> Directive(name, el, vm, expression) &#123;</span><br><span class=\"line\">    this.name = name;  // 指令的名称， 对于普通的文本节点来说，值为<span class=\"string\">\"text\"</span></span><br><span class=\"line\">    this.el = el;              // 指令对应的DOM元素</span><br><span class=\"line\">    this.vm = vm;          // 指令所属bue实例</span><br><span class=\"line\">    this.expression = expression;       // 指令表达式，例如 <span class=\"string\">\"name\"</span></span><br><span class=\"line\">    this.attr = <span class=\"string\">'nodeValue'</span>;        </span><br><span class=\"line\">    this.update();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这是指令的更新方法。当对应的数据发生改变了，就会执行这个方法</span><br><span class=\"line\">// 可以看出来，这个方法就是用来更新nodeValue的</span><br><span class=\"line\">Directive.prototype.update = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.el[this.attr] = this.vm.<span class=\"variable\">$data</span>[this.expression];</span><br><span class=\"line\">    console.log(`更新了DOM-<span class=\"variable\">$&#123;this.expression&#125;</span>`);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>实现思路：遍历DOM节点时，会匹配出表达式，新建空的textNode，插入到这个节点前面，<br>然后remove掉这个文本节点。</p>\n<p>存在问题：每次数据发生改变的时候，都需要循环directive，匹配表达式值才能找到指令，<br>效率很低。且根据$watch对应的回调函数与DOM无关，不会有el和attr。</p>\n<p>解决思路：引入binding和watcher这两个类。<br>每个属性上都有一个数组，这个数组是订阅的意思，里面存放着一系列watcher，当watcher<br>代表数据发生改变时，会遍历数组，执行update更新。<br>Watcher是一个观察容器，可以装载Directive。<br>根据Binding（解决键值索引）、watcher（解决$watch）、Directive(更新DOM中属性值)三者实现双向数据绑定。</p>\n<h3 id=\"5-0批处理更新DOM\"><a href=\"#5-0批处理更新DOM\" class=\"headerlink\" title=\"5.0批处理更新DOM\"></a>5.0批处理更新DOM</h3><p>频繁操作DOM是低效率的，实现多次数据更新只更新一次DOM。</p>\n<p>官方注：每观察到数据变化，Vue会开始一个队列，将同一事件循环内所有的数据变化<br>缓存起来，一个watcher多次被触发，只会推入一次到队列中。下次循环，清空队列，进行<br>必要的DOM更新。<br>解决原理：Batcher，批处理类。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 批处理构造函数</span><br><span class=\"line\"> * @constructor</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Batcher</span></span>() &#123;</span><br><span class=\"line\">    this.reset();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 批处理重置</span><br><span class=\"line\"> */</span><br><span class=\"line\">Batcher.prototype.reset = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.has = &#123;&#125;;</span><br><span class=\"line\">    this.queue = [];</span><br><span class=\"line\">    this.waiting = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 将事件添加到队列中</span><br><span class=\"line\"> * @param job &#123;Watcher&#125; watcher事件</span><br><span class=\"line\"> */</span><br><span class=\"line\">Batcher.prototype.push = <span class=\"keyword\">function</span> (job) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!this.has[job.id]) &#123;</span><br><span class=\"line\">        this.queue.push(job);</span><br><span class=\"line\">        this.has[job.id] = job;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!this.waiting) &#123; // wating用于保护</span><br><span class=\"line\">            this.waiting = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                this.flush();// 更新执行的函数</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 执行并清空事件队列</span><br><span class=\"line\"> */</span><br><span class=\"line\">Batcher.prototype.flush = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.queue.forEach((job) =&gt; &#123;</span><br><span class=\"line\">        job.cb.call(job.ctx);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    this.reset();//重置队列，保证下次能更新数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"javaScript设计模式","date":"2020-11-18T09:40:57.000Z","_content":"开放封闭原则:\n对稳定的东西进行封装，将可能会变动的东西分离出来，增加功能或者改动的时候增加代码即可，无需改动代码。\n1.放置挂钩\nhook（待研究）\n2.使用回调函数\n把回调函数当做参数传入一个稳定和封闭的函数中，当回调函数被执行的时候，程序会因为回调函数的内部逻辑不同，而产生不同的结果。\najax异步请求是不变的，获取数据后的下一步可能变化。","source":"_posts/javaScript设计模式.md","raw":"---\ntitle: javaScript设计模式\ndate: 2020-11-18 17:40:57\ntags:\n - javaScript\ncategories: javaScript设计模式\n---\n开放封闭原则:\n对稳定的东西进行封装，将可能会变动的东西分离出来，增加功能或者改动的时候增加代码即可，无需改动代码。\n1.放置挂钩\nhook（待研究）\n2.使用回调函数\n把回调函数当做参数传入一个稳定和封闭的函数中，当回调函数被执行的时候，程序会因为回调函数的内部逻辑不同，而产生不同的结果。\najax异步请求是不变的，获取数据后的下一步可能变化。","slug":"javaScript设计模式","published":1,"updated":"2020-11-18T09:46:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37a001lpcva34lmfs6d","content":"<p>开放封闭原则:<br>对稳定的东西进行封装，将可能会变动的东西分离出来，增加功能或者改动的时候增加代码即可，无需改动代码。<br>1.放置挂钩<br>hook（待研究）<br>2.使用回调函数<br>把回调函数当做参数传入一个稳定和封闭的函数中，当回调函数被执行的时候，程序会因为回调函数的内部逻辑不同，而产生不同的结果。<br>ajax异步请求是不变的，获取数据后的下一步可能变化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>开放封闭原则:<br>对稳定的东西进行封装，将可能会变动的东西分离出来，增加功能或者改动的时候增加代码即可，无需改动代码。<br>1.放置挂钩<br>hook（待研究）<br>2.使用回调函数<br>把回调函数当做参数传入一个稳定和封闭的函数中，当回调函数被执行的时候，程序会因为回调函数的内部逻辑不同，而产生不同的结果。<br>ajax异步请求是不变的，获取数据后的下一步可能变化。</p>\n"},{"title":"Web前端性能优化-页面加载","date":"2020-05-20T08:38:42.000Z","_content":"\n## Web前端性能优化的方式\n\n### 1.减少HTTP请求\n```bash\n一个页面80%~90%的时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。\n```\n### 2.将样式表放在头部\n```bash\n将样式表放在头部对于实际页面加载的时间影响不大，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，放置“白屏”。\n将样式表放在文档底部会阻止浏览器中的内容逐步出现，为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为，如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前无需绘制任何东西。\n```\n### 3.将脚本放在底部\n```bash\n跟样式表相同，脚本放在底部对于实际页面加载的数据影响不大。\nJS的下载和执行会阻塞DOM树的构建，所以script放在首屏范围内的HTML代码段里会截断首屏的内容。\n下载脚本时并下载是禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。\n```\n### 4.使用外部的JavaScript和CSS\n```bash\n内联脚本或者样式可以减少HTTP请求，按理说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存他们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。\n影响原因：\n用户产生的浏览量越少，内联脚本和样式的论据越强势。\n如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。\n```\n\n### 5.对文件进行压缩\n```bash\n在服务器端对文件进行压缩，在浏览器端对文件解压，可以有效减少通信传输的数据量。\n外部脚本和样式进行合并，多个合为一个，文本文件的压缩率可达80%以上。\n但是服务器资源不足的情况下要权衡考虑。\n```\n\n### 6.合并CSS图片\n```bash\n使用CSS Sprites，减少请求数。\n```\n\n### 7.JS代码的优化\n```bash\n慎用with：在with代码块中访问非局部变量都是先从obj上开始查找，如果没有再一次按作用域链向上查找，使用with相当于增加了作用域链长度。查找需要消耗时间，过长的作用域链会导致性能下降。\n避免使用eval和Function：每次使用，需要将源代码转换成可执行的代码，很消耗资源。使用该函数也不利于JavaScript压缩工具执行压缩。\n减少作用域链查找：应该减少闭包的使用。\n数据访问：对对象属性和任何数组成员的访问次数减少，尽可能减少对对象以及数组深度查找。\n字符串拼接：在JavaScript使用“+”来拼接效率比较低，使用join函数更为高效（当拼接的字符串比较多的时候考虑使用此方法）。\n```","source":"_posts/Web前端性能优化-页面加载.md","raw":"---\ntitle: Web前端性能优化-页面加载\ndate: 2020-05-20 16:38:42\ntags:\n - Web性能\ncategories: 优化\n---\n\n## Web前端性能优化的方式\n\n### 1.减少HTTP请求\n```bash\n一个页面80%~90%的时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。\n```\n### 2.将样式表放在头部\n```bash\n将样式表放在头部对于实际页面加载的时间影响不大，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，放置“白屏”。\n将样式表放在文档底部会阻止浏览器中的内容逐步出现，为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为，如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前无需绘制任何东西。\n```\n### 3.将脚本放在底部\n```bash\n跟样式表相同，脚本放在底部对于实际页面加载的数据影响不大。\nJS的下载和执行会阻塞DOM树的构建，所以script放在首屏范围内的HTML代码段里会截断首屏的内容。\n下载脚本时并下载是禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。\n```\n### 4.使用外部的JavaScript和CSS\n```bash\n内联脚本或者样式可以减少HTTP请求，按理说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存他们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。\n影响原因：\n用户产生的浏览量越少，内联脚本和样式的论据越强势。\n如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。\n```\n\n### 5.对文件进行压缩\n```bash\n在服务器端对文件进行压缩，在浏览器端对文件解压，可以有效减少通信传输的数据量。\n外部脚本和样式进行合并，多个合为一个，文本文件的压缩率可达80%以上。\n但是服务器资源不足的情况下要权衡考虑。\n```\n\n### 6.合并CSS图片\n```bash\n使用CSS Sprites，减少请求数。\n```\n\n### 7.JS代码的优化\n```bash\n慎用with：在with代码块中访问非局部变量都是先从obj上开始查找，如果没有再一次按作用域链向上查找，使用with相当于增加了作用域链长度。查找需要消耗时间，过长的作用域链会导致性能下降。\n避免使用eval和Function：每次使用，需要将源代码转换成可执行的代码，很消耗资源。使用该函数也不利于JavaScript压缩工具执行压缩。\n减少作用域链查找：应该减少闭包的使用。\n数据访问：对对象属性和任何数组成员的访问次数减少，尽可能减少对对象以及数组深度查找。\n字符串拼接：在JavaScript使用“+”来拼接效率比较低，使用join函数更为高效（当拼接的字符串比较多的时候考虑使用此方法）。\n```","slug":"Web前端性能优化-页面加载","published":1,"updated":"2020-05-20T09:02:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37d001opcva8juc0eqs","content":"<h2 id=\"Web前端性能优化的方式\"><a href=\"#Web前端性能优化的方式\" class=\"headerlink\" title=\"Web前端性能优化的方式\"></a>Web前端性能优化的方式</h2><h3 id=\"1-减少HTTP请求\"><a href=\"#1-减少HTTP请求\" class=\"headerlink\" title=\"1.减少HTTP请求\"></a>1.减少HTTP请求</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个页面80%~90%的时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-将样式表放在头部\"><a href=\"#2-将样式表放在头部\" class=\"headerlink\" title=\"2.将样式表放在头部\"></a>2.将样式表放在头部</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将样式表放在头部对于实际页面加载的时间影响不大，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，放置“白屏”。</span><br><span class=\"line\">将样式表放在文档底部会阻止浏览器中的内容逐步出现，为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为，如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前无需绘制任何东西。</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-将脚本放在底部\"><a href=\"#3-将脚本放在底部\" class=\"headerlink\" title=\"3.将脚本放在底部\"></a>3.将脚本放在底部</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">跟样式表相同，脚本放在底部对于实际页面加载的数据影响不大。</span><br><span class=\"line\">JS的下载和执行会阻塞DOM树的构建，所以script放在首屏范围内的HTML代码段里会截断首屏的内容。</span><br><span class=\"line\">下载脚本时并下载是禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-使用外部的JavaScript和CSS\"><a href=\"#4-使用外部的JavaScript和CSS\" class=\"headerlink\" title=\"4.使用外部的JavaScript和CSS\"></a>4.使用外部的JavaScript和CSS</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内联脚本或者样式可以减少HTTP请求，按理说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存他们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。</span><br><span class=\"line\">影响原因：</span><br><span class=\"line\">用户产生的浏览量越少，内联脚本和样式的论据越强势。</span><br><span class=\"line\">如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-对文件进行压缩\"><a href=\"#5-对文件进行压缩\" class=\"headerlink\" title=\"5.对文件进行压缩\"></a>5.对文件进行压缩</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在服务器端对文件进行压缩，在浏览器端对文件解压，可以有效减少通信传输的数据量。</span><br><span class=\"line\">外部脚本和样式进行合并，多个合为一个，文本文件的压缩率可达80%以上。</span><br><span class=\"line\">但是服务器资源不足的情况下要权衡考虑。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-合并CSS图片\"><a href=\"#6-合并CSS图片\" class=\"headerlink\" title=\"6.合并CSS图片\"></a>6.合并CSS图片</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用CSS Sprites，减少请求数。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-JS代码的优化\"><a href=\"#7-JS代码的优化\" class=\"headerlink\" title=\"7.JS代码的优化\"></a>7.JS代码的优化</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">慎用with：在with代码块中访问非局部变量都是先从obj上开始查找，如果没有再一次按作用域链向上查找，使用with相当于增加了作用域链长度。查找需要消耗时间，过长的作用域链会导致性能下降。</span><br><span class=\"line\">避免使用<span class=\"built_in\">eval</span>和Function：每次使用，需要将源代码转换成可执行的代码，很消耗资源。使用该函数也不利于JavaScript压缩工具执行压缩。</span><br><span class=\"line\">减少作用域链查找：应该减少闭包的使用。</span><br><span class=\"line\">数据访问：对对象属性和任何数组成员的访问次数减少，尽可能减少对对象以及数组深度查找。</span><br><span class=\"line\">字符串拼接：在JavaScript使用“+”来拼接效率比较低，使用join函数更为高效（当拼接的字符串比较多的时候考虑使用此方法）。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Web前端性能优化的方式\"><a href=\"#Web前端性能优化的方式\" class=\"headerlink\" title=\"Web前端性能优化的方式\"></a>Web前端性能优化的方式</h2><h3 id=\"1-减少HTTP请求\"><a href=\"#1-减少HTTP请求\" class=\"headerlink\" title=\"1.减少HTTP请求\"></a>1.减少HTTP请求</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个页面80%~90%的时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-将样式表放在头部\"><a href=\"#2-将样式表放在头部\" class=\"headerlink\" title=\"2.将样式表放在头部\"></a>2.将样式表放在头部</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将样式表放在头部对于实际页面加载的时间影响不大，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，放置“白屏”。</span><br><span class=\"line\">将样式表放在文档底部会阻止浏览器中的内容逐步出现，为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为，如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前无需绘制任何东西。</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-将脚本放在底部\"><a href=\"#3-将脚本放在底部\" class=\"headerlink\" title=\"3.将脚本放在底部\"></a>3.将脚本放在底部</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">跟样式表相同，脚本放在底部对于实际页面加载的数据影响不大。</span><br><span class=\"line\">JS的下载和执行会阻塞DOM树的构建，所以script放在首屏范围内的HTML代码段里会截断首屏的内容。</span><br><span class=\"line\">下载脚本时并下载是禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-使用外部的JavaScript和CSS\"><a href=\"#4-使用外部的JavaScript和CSS\" class=\"headerlink\" title=\"4.使用外部的JavaScript和CSS\"></a>4.使用外部的JavaScript和CSS</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内联脚本或者样式可以减少HTTP请求，按理说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存他们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。</span><br><span class=\"line\">影响原因：</span><br><span class=\"line\">用户产生的浏览量越少，内联脚本和样式的论据越强势。</span><br><span class=\"line\">如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-对文件进行压缩\"><a href=\"#5-对文件进行压缩\" class=\"headerlink\" title=\"5.对文件进行压缩\"></a>5.对文件进行压缩</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在服务器端对文件进行压缩，在浏览器端对文件解压，可以有效减少通信传输的数据量。</span><br><span class=\"line\">外部脚本和样式进行合并，多个合为一个，文本文件的压缩率可达80%以上。</span><br><span class=\"line\">但是服务器资源不足的情况下要权衡考虑。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-合并CSS图片\"><a href=\"#6-合并CSS图片\" class=\"headerlink\" title=\"6.合并CSS图片\"></a>6.合并CSS图片</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用CSS Sprites，减少请求数。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-JS代码的优化\"><a href=\"#7-JS代码的优化\" class=\"headerlink\" title=\"7.JS代码的优化\"></a>7.JS代码的优化</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">慎用with：在with代码块中访问非局部变量都是先从obj上开始查找，如果没有再一次按作用域链向上查找，使用with相当于增加了作用域链长度。查找需要消耗时间，过长的作用域链会导致性能下降。</span><br><span class=\"line\">避免使用<span class=\"built_in\">eval</span>和Function：每次使用，需要将源代码转换成可执行的代码，很消耗资源。使用该函数也不利于JavaScript压缩工具执行压缩。</span><br><span class=\"line\">减少作用域链查找：应该减少闭包的使用。</span><br><span class=\"line\">数据访问：对对象属性和任何数组成员的访问次数减少，尽可能减少对对象以及数组深度查找。</span><br><span class=\"line\">字符串拼接：在JavaScript使用“+”来拼接效率比较低，使用join函数更为高效（当拼接的字符串比较多的时候考虑使用此方法）。</span><br></pre></td></tr></table></figure>"},{"title":"使用HEXO搭建个人博客","date":"2020-05-09T08:26:35.000Z","_content":"\n搭建博客过程!\n\n---\n## 2020/5/9 16:27 Write\n\n关键词：GitPage\n\n```bash\n下载安装git//下面的终端操作都使用Git Bush Here\nnpm install hexo-cli -g //安装hexo\nhexo init *****.github.io (****为自己的github名)//初始化博客\ncd *****.github.io //进入目录\nhexo g//生成静态页面\nhexo s//启动服务器，在localhost:4000上查看刚生成的博客页\nssh-keygen -t rsa -C \"**********\" (****为个人邮箱,注意引号)//配置SSH\n根据路径找到id_rsa.pub，复制里面的内容\n在Github项目当中Setting中找到SSH and GPG keys黏贴进去\nssh -T git@github.com (输入yes)//回到Git Bash中检查\n需要在主文件夹中的_config.yml文件配置deploy // 配置属性的时候需要在冒号后空一格，不然会报错\ndeploy:\n    type: git\n    repo: **********//你的项目地址 类：https://github.com/yourname/yourname.github.io.git\n    branch: master\nnpm install hexo-deployer-git --save //安装插件\nhexo clean //清理public文件夹\nhexo g//同上\nhexo d//部署到github的项目中\n许多坑，希望找到方法解决。\n```","source":"_posts/使用HEXO搭建个人博客.md","raw":"---\ntitle: 使用HEXO搭建个人博客\ndate: 2020-05-09 16:26:35\ntags:\n - HEXO\ncategories: 搭建博客\n---\n\n搭建博客过程!\n\n---\n## 2020/5/9 16:27 Write\n\n关键词：GitPage\n\n```bash\n下载安装git//下面的终端操作都使用Git Bush Here\nnpm install hexo-cli -g //安装hexo\nhexo init *****.github.io (****为自己的github名)//初始化博客\ncd *****.github.io //进入目录\nhexo g//生成静态页面\nhexo s//启动服务器，在localhost:4000上查看刚生成的博客页\nssh-keygen -t rsa -C \"**********\" (****为个人邮箱,注意引号)//配置SSH\n根据路径找到id_rsa.pub，复制里面的内容\n在Github项目当中Setting中找到SSH and GPG keys黏贴进去\nssh -T git@github.com (输入yes)//回到Git Bash中检查\n需要在主文件夹中的_config.yml文件配置deploy // 配置属性的时候需要在冒号后空一格，不然会报错\ndeploy:\n    type: git\n    repo: **********//你的项目地址 类：https://github.com/yourname/yourname.github.io.git\n    branch: master\nnpm install hexo-deployer-git --save //安装插件\nhexo clean //清理public文件夹\nhexo g//同上\nhexo d//部署到github的项目中\n许多坑，希望找到方法解决。\n```","slug":"使用HEXO搭建个人博客","published":1,"updated":"2020-06-30T01:18:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37e001tpcva00srfvvd","content":"<p>搭建博客过程!</p>\n<hr>\n<h2 id=\"2020-5-9-16-27-Write\"><a href=\"#2020-5-9-16-27-Write\" class=\"headerlink\" title=\"2020/5/9 16:27 Write\"></a>2020/5/9 16:27 Write</h2><p>关键词：GitPage</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下载安装git//下面的终端操作都使用Git Bush Here</span><br><span class=\"line\">npm install hexo-cli -g //安装hexo</span><br><span class=\"line\">hexo init *****.github.io (****为自己的github名)//初始化博客</span><br><span class=\"line\"><span class=\"built_in\">cd</span> *****.github.io //进入目录</span><br><span class=\"line\">hexo g//生成静态页面</span><br><span class=\"line\">hexo s//启动服务器，在localhost:4000上查看刚生成的博客页</span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"**********\"</span> (****为个人邮箱,注意引号)//配置SSH</span><br><span class=\"line\">根据路径找到id_rsa.pub，复制里面的内容</span><br><span class=\"line\">在Github项目当中Setting中找到SSH and GPG keys黏贴进去</span><br><span class=\"line\">ssh -T git@github.com (输入yes)//回到Git Bash中检查</span><br><span class=\"line\">需要在主文件夹中的_config.yml文件配置deploy // 配置属性的时候需要在冒号后空一格，不然会报错</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">    repo: **********//你的项目地址 类：https://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">    branch: master</span><br><span class=\"line\">npm install hexo-deployer-git --save //安装插件</span><br><span class=\"line\">hexo clean //清理public文件夹</span><br><span class=\"line\">hexo g//同上</span><br><span class=\"line\">hexo d//部署到github的项目中</span><br><span class=\"line\">许多坑，希望找到方法解决。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>搭建博客过程!</p>\n<hr>\n<h2 id=\"2020-5-9-16-27-Write\"><a href=\"#2020-5-9-16-27-Write\" class=\"headerlink\" title=\"2020/5/9 16:27 Write\"></a>2020/5/9 16:27 Write</h2><p>关键词：GitPage</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下载安装git//下面的终端操作都使用Git Bush Here</span><br><span class=\"line\">npm install hexo-cli -g //安装hexo</span><br><span class=\"line\">hexo init *****.github.io (****为自己的github名)//初始化博客</span><br><span class=\"line\"><span class=\"built_in\">cd</span> *****.github.io //进入目录</span><br><span class=\"line\">hexo g//生成静态页面</span><br><span class=\"line\">hexo s//启动服务器，在localhost:4000上查看刚生成的博客页</span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"**********\"</span> (****为个人邮箱,注意引号)//配置SSH</span><br><span class=\"line\">根据路径找到id_rsa.pub，复制里面的内容</span><br><span class=\"line\">在Github项目当中Setting中找到SSH and GPG keys黏贴进去</span><br><span class=\"line\">ssh -T git@github.com (输入yes)//回到Git Bash中检查</span><br><span class=\"line\">需要在主文件夹中的_config.yml文件配置deploy // 配置属性的时候需要在冒号后空一格，不然会报错</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">    repo: **********//你的项目地址 类：https://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">    branch: master</span><br><span class=\"line\">npm install hexo-deployer-git --save //安装插件</span><br><span class=\"line\">hexo clean //清理public文件夹</span><br><span class=\"line\">hexo g//同上</span><br><span class=\"line\">hexo d//部署到github的项目中</span><br><span class=\"line\">许多坑，希望找到方法解决。</span><br></pre></td></tr></table></figure>"},{"title":"learning","date":"2020-07-27T04:41:57.000Z","_content":"### 体制内\n公务员：依法履行公职，国家扶植\n两类：行政执法，管理技术\n层级：公务员(行政单位)>事业单位>国企>临时工\n级别：国家级正（副）职>省部级正（副）职>厅局级正（副）职>县处级正（副）职>乡科级正（副）职\n厅局级（职位大小）=巡视员>调研员>主任科员>科员（考入的职位）\n工作内容：综合管理类，执法类，技术类\n考试分类：国考，省考，选调生\n国考：中央举办（二级选择）（税务局和海关）基层（单位不行，工作多，待遇一般，提升小），中央部委（学历歧视）\n省考：省直辖市举办（岗位好的多）公平，歧视少\n选调生：中央选调，各省定向选调（学历歧视），垃圾选调普通学校（乡下）\n\n报名-笔试-面试-体检（政审）-录用\n报名（资格）：全日制或研究生或应届生或学位\n专业：法学，计算机（优势）——三不限\n年龄：28（硕士应届）,30（警察）,35（最大限制）,40（应届研究生）\n政治面貌：党员，团员，群众\n身份：应届/工作经验\n性别：监狱，执法等岗位\n户籍：部分省（限制外省报名）\n\n笔试：行测，申论，专业加试（部分岗位）\n行测：资料分析先做（先看题，不计算，不答题）得分率提高，涂答题卡，边做边涂\n申论：找合适干公务员的人（归纳概况，综合分析，提出问题，贯彻执行），看书，（理论热点面对面）最近三五年（注意出版社）看公文（找体制内员工）看要跟着写\n\n面试：结构化面试，4-5题，结合实际，以公务员的思维去回答，处理递进，首先，然后，最后。形象方面，稳重。男生（黑西装，白西装，皮鞋），得体体现自己的能力和沟通能力。\n\n体检：《公务员录用体检通用标准》《公务员录用体检操作手册》\n政审考察：\n1.考生本人：\n2.父母兄弟姐妹夫妻等直系亲属（一般）\n3.三代以内直系旁系（特殊）\n违法犯罪情况，历史问题，失信被执行人，本人在单位表现等。\n洁身自好\n\n选择：\n1.尽量选家乡\n2.异地，选省会或大城市\n3.想晋升上限高就选高级别单位\n4.高收入地区（苏南浙北，珠三角）\n5.性价比高地区：成都，重庆\n6.没有情怀就不要选艰苦单位\n7.佛系就不要选实权单位\n8.不是走投无路，尽量不要选乡镇和监狱\n\n\n\n\n\n\n\n\n","source":"_posts/learning.md","raw":"---\ntitle: learning\ndate: 2020-07-27 12:41:57\ntags:\n - 学习\ncategories: 学习\n---\n### 体制内\n公务员：依法履行公职，国家扶植\n两类：行政执法，管理技术\n层级：公务员(行政单位)>事业单位>国企>临时工\n级别：国家级正（副）职>省部级正（副）职>厅局级正（副）职>县处级正（副）职>乡科级正（副）职\n厅局级（职位大小）=巡视员>调研员>主任科员>科员（考入的职位）\n工作内容：综合管理类，执法类，技术类\n考试分类：国考，省考，选调生\n国考：中央举办（二级选择）（税务局和海关）基层（单位不行，工作多，待遇一般，提升小），中央部委（学历歧视）\n省考：省直辖市举办（岗位好的多）公平，歧视少\n选调生：中央选调，各省定向选调（学历歧视），垃圾选调普通学校（乡下）\n\n报名-笔试-面试-体检（政审）-录用\n报名（资格）：全日制或研究生或应届生或学位\n专业：法学，计算机（优势）——三不限\n年龄：28（硕士应届）,30（警察）,35（最大限制）,40（应届研究生）\n政治面貌：党员，团员，群众\n身份：应届/工作经验\n性别：监狱，执法等岗位\n户籍：部分省（限制外省报名）\n\n笔试：行测，申论，专业加试（部分岗位）\n行测：资料分析先做（先看题，不计算，不答题）得分率提高，涂答题卡，边做边涂\n申论：找合适干公务员的人（归纳概况，综合分析，提出问题，贯彻执行），看书，（理论热点面对面）最近三五年（注意出版社）看公文（找体制内员工）看要跟着写\n\n面试：结构化面试，4-5题，结合实际，以公务员的思维去回答，处理递进，首先，然后，最后。形象方面，稳重。男生（黑西装，白西装，皮鞋），得体体现自己的能力和沟通能力。\n\n体检：《公务员录用体检通用标准》《公务员录用体检操作手册》\n政审考察：\n1.考生本人：\n2.父母兄弟姐妹夫妻等直系亲属（一般）\n3.三代以内直系旁系（特殊）\n违法犯罪情况，历史问题，失信被执行人，本人在单位表现等。\n洁身自好\n\n选择：\n1.尽量选家乡\n2.异地，选省会或大城市\n3.想晋升上限高就选高级别单位\n4.高收入地区（苏南浙北，珠三角）\n5.性价比高地区：成都，重庆\n6.没有情怀就不要选艰苦单位\n7.佛系就不要选实权单位\n8.不是走投无路，尽量不要选乡镇和监狱\n\n\n\n\n\n\n\n\n","slug":"learning","published":1,"updated":"2020-07-27T06:10:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37f001wpcvahdv36onk","content":"<h3 id=\"体制内\"><a href=\"#体制内\" class=\"headerlink\" title=\"体制内\"></a>体制内</h3><p>公务员：依法履行公职，国家扶植<br>两类：行政执法，管理技术<br>层级：公务员(行政单位)&gt;事业单位&gt;国企&gt;临时工<br>级别：国家级正（副）职&gt;省部级正（副）职&gt;厅局级正（副）职&gt;县处级正（副）职&gt;乡科级正（副）职<br>厅局级（职位大小）=巡视员&gt;调研员&gt;主任科员&gt;科员（考入的职位）<br>工作内容：综合管理类，执法类，技术类<br>考试分类：国考，省考，选调生<br>国考：中央举办（二级选择）（税务局和海关）基层（单位不行，工作多，待遇一般，提升小），中央部委（学历歧视）<br>省考：省直辖市举办（岗位好的多）公平，歧视少<br>选调生：中央选调，各省定向选调（学历歧视），垃圾选调普通学校（乡下）</p>\n<p>报名-笔试-面试-体检（政审）-录用<br>报名（资格）：全日制或研究生或应届生或学位<br>专业：法学，计算机（优势）——三不限<br>年龄：28（硕士应届）,30（警察）,35（最大限制）,40（应届研究生）<br>政治面貌：党员，团员，群众<br>身份：应届/工作经验<br>性别：监狱，执法等岗位<br>户籍：部分省（限制外省报名）</p>\n<p>笔试：行测，申论，专业加试（部分岗位）<br>行测：资料分析先做（先看题，不计算，不答题）得分率提高，涂答题卡，边做边涂<br>申论：找合适干公务员的人（归纳概况，综合分析，提出问题，贯彻执行），看书，（理论热点面对面）最近三五年（注意出版社）看公文（找体制内员工）看要跟着写</p>\n<p>面试：结构化面试，4-5题，结合实际，以公务员的思维去回答，处理递进，首先，然后，最后。形象方面，稳重。男生（黑西装，白西装，皮鞋），得体体现自己的能力和沟通能力。</p>\n<p>体检：《公务员录用体检通用标准》《公务员录用体检操作手册》<br>政审考察：<br>1.考生本人：<br>2.父母兄弟姐妹夫妻等直系亲属（一般）<br>3.三代以内直系旁系（特殊）<br>违法犯罪情况，历史问题，失信被执行人，本人在单位表现等。<br>洁身自好</p>\n<p>选择：<br>1.尽量选家乡<br>2.异地，选省会或大城市<br>3.想晋升上限高就选高级别单位<br>4.高收入地区（苏南浙北，珠三角）<br>5.性价比高地区：成都，重庆<br>6.没有情怀就不要选艰苦单位<br>7.佛系就不要选实权单位<br>8.不是走投无路，尽量不要选乡镇和监狱</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"体制内\"><a href=\"#体制内\" class=\"headerlink\" title=\"体制内\"></a>体制内</h3><p>公务员：依法履行公职，国家扶植<br>两类：行政执法，管理技术<br>层级：公务员(行政单位)&gt;事业单位&gt;国企&gt;临时工<br>级别：国家级正（副）职&gt;省部级正（副）职&gt;厅局级正（副）职&gt;县处级正（副）职&gt;乡科级正（副）职<br>厅局级（职位大小）=巡视员&gt;调研员&gt;主任科员&gt;科员（考入的职位）<br>工作内容：综合管理类，执法类，技术类<br>考试分类：国考，省考，选调生<br>国考：中央举办（二级选择）（税务局和海关）基层（单位不行，工作多，待遇一般，提升小），中央部委（学历歧视）<br>省考：省直辖市举办（岗位好的多）公平，歧视少<br>选调生：中央选调，各省定向选调（学历歧视），垃圾选调普通学校（乡下）</p>\n<p>报名-笔试-面试-体检（政审）-录用<br>报名（资格）：全日制或研究生或应届生或学位<br>专业：法学，计算机（优势）——三不限<br>年龄：28（硕士应届）,30（警察）,35（最大限制）,40（应届研究生）<br>政治面貌：党员，团员，群众<br>身份：应届/工作经验<br>性别：监狱，执法等岗位<br>户籍：部分省（限制外省报名）</p>\n<p>笔试：行测，申论，专业加试（部分岗位）<br>行测：资料分析先做（先看题，不计算，不答题）得分率提高，涂答题卡，边做边涂<br>申论：找合适干公务员的人（归纳概况，综合分析，提出问题，贯彻执行），看书，（理论热点面对面）最近三五年（注意出版社）看公文（找体制内员工）看要跟着写</p>\n<p>面试：结构化面试，4-5题，结合实际，以公务员的思维去回答，处理递进，首先，然后，最后。形象方面，稳重。男生（黑西装，白西装，皮鞋），得体体现自己的能力和沟通能力。</p>\n<p>体检：《公务员录用体检通用标准》《公务员录用体检操作手册》<br>政审考察：<br>1.考生本人：<br>2.父母兄弟姐妹夫妻等直系亲属（一般）<br>3.三代以内直系旁系（特殊）<br>违法犯罪情况，历史问题，失信被执行人，本人在单位表现等。<br>洁身自好</p>\n<p>选择：<br>1.尽量选家乡<br>2.异地，选省会或大城市<br>3.想晋升上限高就选高级别单位<br>4.高收入地区（苏南浙北，珠三角）<br>5.性价比高地区：成都，重庆<br>6.没有情怀就不要选艰苦单位<br>7.佛系就不要选实权单位<br>8.不是走投无路，尽量不要选乡镇和监狱</p>\n"},{"title":"前端需求","date":"2020-08-20T08:02:44.000Z","_content":"1.git命令行\n2.HTML5 可\n3.css3 可\n4.BFC 可\n5.层叠上下文 可\n6.边距折叠 可\n7.浮动布局 可\n8.flex布局 可（多熟练）\n9.grid布局 可\n10.兼容 \n11.渲染机制 可\n12.白屏\n13.FOUC 可\n14.异步加载 可\n15.重绘与回流 可\n16.8种数据类型 可\n17.运算符优先级 可\n18.箭头函数 可\n19.声明前置 可\n20.函数作用域 可\n21.块级作用域 可\n22.作用域链 可\n23.IIFE\n24.递归 可\n25.递归优化 \n26.柯里化 可\n27.字符串数组方法（ES5/6）可\n28.引用类型  可\n29.深浅拷贝 可\n30.正则表达式（贪婪，分组，前瞻）\n31.同步与异步 可\n32.任务队列 可\n33.微任务与宏任务\n34.节流\n35.防抖\n36.原型\n37.class\n38.原型链\n39.object.create\n40.组合继承\n41.class继承\n42.call/apply/bind\n43.object.assign\n44.Mixin\n45.Getter/Setter\n46.闭包\n47.模块封装\n48.高阶函数\n49.DOM操作\n50.DOM事件流（冒泡，捕获，阻止默认，passive，事件代理）\n51.Cookie/Session鉴权机制\n52.HTTP：状态码，缓存，Session，JWT，Auth2机制，XSS，CSRF原理\n53.XMLHTTPRequest2：fetch，Ajax封装，Comet，WebSocket，Mock.js，curl，异步，回调，promise，async/await，同源策略，JSONP，CORS，服务器中转\n54.CommonJS规范，NPM，Yarn，开发Package，模块化，IIFE，Parcel.js，ES6的原生Module，NPM Scripts与工程化\n55.Webpack，手写loader与Plugin，Babel，编译原理\n56.Vue，Vue Router，Vuex，ElementUI/其他\n57.React，create-react-APP，CSS modules\n58.小程序，云开发\n59.网站性能优化，构建优化，typescript\n\n手写：\n封装Ajax\n封装bind\n封装防抖节流\n手写promise\n手写Webpack Loader，Plugin\n手写MVC，MVVM，React，模块加载器\n","source":"_posts/前端需求.md","raw":"---\ntitle: 前端需求\ndate: 2020-08-20 16:02:44\ntags:\n - 学习需求\ncategories: 前端\n---\n1.git命令行\n2.HTML5 可\n3.css3 可\n4.BFC 可\n5.层叠上下文 可\n6.边距折叠 可\n7.浮动布局 可\n8.flex布局 可（多熟练）\n9.grid布局 可\n10.兼容 \n11.渲染机制 可\n12.白屏\n13.FOUC 可\n14.异步加载 可\n15.重绘与回流 可\n16.8种数据类型 可\n17.运算符优先级 可\n18.箭头函数 可\n19.声明前置 可\n20.函数作用域 可\n21.块级作用域 可\n22.作用域链 可\n23.IIFE\n24.递归 可\n25.递归优化 \n26.柯里化 可\n27.字符串数组方法（ES5/6）可\n28.引用类型  可\n29.深浅拷贝 可\n30.正则表达式（贪婪，分组，前瞻）\n31.同步与异步 可\n32.任务队列 可\n33.微任务与宏任务\n34.节流\n35.防抖\n36.原型\n37.class\n38.原型链\n39.object.create\n40.组合继承\n41.class继承\n42.call/apply/bind\n43.object.assign\n44.Mixin\n45.Getter/Setter\n46.闭包\n47.模块封装\n48.高阶函数\n49.DOM操作\n50.DOM事件流（冒泡，捕获，阻止默认，passive，事件代理）\n51.Cookie/Session鉴权机制\n52.HTTP：状态码，缓存，Session，JWT，Auth2机制，XSS，CSRF原理\n53.XMLHTTPRequest2：fetch，Ajax封装，Comet，WebSocket，Mock.js，curl，异步，回调，promise，async/await，同源策略，JSONP，CORS，服务器中转\n54.CommonJS规范，NPM，Yarn，开发Package，模块化，IIFE，Parcel.js，ES6的原生Module，NPM Scripts与工程化\n55.Webpack，手写loader与Plugin，Babel，编译原理\n56.Vue，Vue Router，Vuex，ElementUI/其他\n57.React，create-react-APP，CSS modules\n58.小程序，云开发\n59.网站性能优化，构建优化，typescript\n\n手写：\n封装Ajax\n封装bind\n封装防抖节流\n手写promise\n手写Webpack Loader，Plugin\n手写MVC，MVVM，React，模块加载器\n","slug":"前端需求","published":1,"updated":"2021-02-05T00:57:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37g0020pcva69xl66dv","content":"<p>1.git命令行<br>2.HTML5 可<br>3.css3 可<br>4.BFC 可<br>5.层叠上下文 可<br>6.边距折叠 可<br>7.浮动布局 可<br>8.flex布局 可（多熟练）<br>9.grid布局 可<br>10.兼容<br>11.渲染机制 可<br>12.白屏<br>13.FOUC 可<br>14.异步加载 可<br>15.重绘与回流 可<br>16.8种数据类型 可<br>17.运算符优先级 可<br>18.箭头函数 可<br>19.声明前置 可<br>20.函数作用域 可<br>21.块级作用域 可<br>22.作用域链 可<br>23.IIFE<br>24.递归 可<br>25.递归优化<br>26.柯里化 可<br>27.字符串数组方法（ES5/6）可<br>28.引用类型  可<br>29.深浅拷贝 可<br>30.正则表达式（贪婪，分组，前瞻）<br>31.同步与异步 可<br>32.任务队列 可<br>33.微任务与宏任务<br>34.节流<br>35.防抖<br>36.原型<br>37.class<br>38.原型链<br>39.object.create<br>40.组合继承<br>41.class继承<br>42.call/apply/bind<br>43.object.assign<br>44.Mixin<br>45.Getter/Setter<br>46.闭包<br>47.模块封装<br>48.高阶函数<br>49.DOM操作<br>50.DOM事件流（冒泡，捕获，阻止默认，passive，事件代理）<br>51.Cookie/Session鉴权机制<br>52.HTTP：状态码，缓存，Session，JWT，Auth2机制，XSS，CSRF原理<br>53.XMLHTTPRequest2：fetch，Ajax封装，Comet，WebSocket，Mock.js，curl，异步，回调，promise，async/await，同源策略，JSONP，CORS，服务器中转<br>54.CommonJS规范，NPM，Yarn，开发Package，模块化，IIFE，Parcel.js，ES6的原生Module，NPM Scripts与工程化<br>55.Webpack，手写loader与Plugin，Babel，编译原理<br>56.Vue，Vue Router，Vuex，ElementUI/其他<br>57.React，create-react-APP，CSS modules<br>58.小程序，云开发<br>59.网站性能优化，构建优化，typescript</p>\n<p>手写：<br>封装Ajax<br>封装bind<br>封装防抖节流<br>手写promise<br>手写Webpack Loader，Plugin<br>手写MVC，MVVM，React，模块加载器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.git命令行<br>2.HTML5 可<br>3.css3 可<br>4.BFC 可<br>5.层叠上下文 可<br>6.边距折叠 可<br>7.浮动布局 可<br>8.flex布局 可（多熟练）<br>9.grid布局 可<br>10.兼容<br>11.渲染机制 可<br>12.白屏<br>13.FOUC 可<br>14.异步加载 可<br>15.重绘与回流 可<br>16.8种数据类型 可<br>17.运算符优先级 可<br>18.箭头函数 可<br>19.声明前置 可<br>20.函数作用域 可<br>21.块级作用域 可<br>22.作用域链 可<br>23.IIFE<br>24.递归 可<br>25.递归优化<br>26.柯里化 可<br>27.字符串数组方法（ES5/6）可<br>28.引用类型  可<br>29.深浅拷贝 可<br>30.正则表达式（贪婪，分组，前瞻）<br>31.同步与异步 可<br>32.任务队列 可<br>33.微任务与宏任务<br>34.节流<br>35.防抖<br>36.原型<br>37.class<br>38.原型链<br>39.object.create<br>40.组合继承<br>41.class继承<br>42.call/apply/bind<br>43.object.assign<br>44.Mixin<br>45.Getter/Setter<br>46.闭包<br>47.模块封装<br>48.高阶函数<br>49.DOM操作<br>50.DOM事件流（冒泡，捕获，阻止默认，passive，事件代理）<br>51.Cookie/Session鉴权机制<br>52.HTTP：状态码，缓存，Session，JWT，Auth2机制，XSS，CSRF原理<br>53.XMLHTTPRequest2：fetch，Ajax封装，Comet，WebSocket，Mock.js，curl，异步，回调，promise，async/await，同源策略，JSONP，CORS，服务器中转<br>54.CommonJS规范，NPM，Yarn，开发Package，模块化，IIFE，Parcel.js，ES6的原生Module，NPM Scripts与工程化<br>55.Webpack，手写loader与Plugin，Babel，编译原理<br>56.Vue，Vue Router，Vuex，ElementUI/其他<br>57.React，create-react-APP，CSS modules<br>58.小程序，云开发<br>59.网站性能优化，构建优化，typescript</p>\n<p>手写：<br>封装Ajax<br>封装bind<br>封装防抖节流<br>手写promise<br>手写Webpack Loader，Plugin<br>手写MVC，MVVM，React，模块加载器</p>\n"},{"title":"前端进阶之道","date":"2020-12-04T07:21:26.000Z","_content":"### 1. 数据类型\nJS分两种类型，原始类型和对象类型。\n原始类型：\n1.boolean\n2.number\n3.string\n4.undefined\n5.null\n6.symbol\n7.bigint\n对象类型：\n1.Object(Array,RegExp,Math,Map,Set)\n2.Function\n---\n### 2. 类型判断\n## 2.1 typeof\n原始类型中除了null，都可以用typeof判断。\ntypeof判断函数为function，其他均为object。\n## 2.2 instanceof\n常用于判断对象类型\n## 2.3 Object.prototype.toString\n最佳选择，能判断的类型最完整\n## 2.4 isXXX API\nisArray()，isNaN()\n### 3. 类型转换\n```\nNumber(false) // -> 0\nNumber('1')// -> 1\nNumber('zb')// -> NaN\n(1).toString()// '1'\n```\n转布尔值规则：\n1.undefined、null、false、NaN、''、0、-0都转为false\n2.其他所有值都转为true，包括所有对象\n转数字规则：\n1.true为1，false为0\n2.null为0，undefined为NaN，symbol报错\n3.字符串看内容，如果是数字或者进制值就正常转，否则就NaN\n4.对象的规则隐式转换再讲\n### 4. this\n## 4.1 普通函数\n谁调用this指向谁\n```\nvar c = new foo()\nc.a = 3\nconsole.log(c.a) // this绑定到c上，不会被任何方式修改\n```\n使用apply，call，bind改变this，优先级仅次于new\n## 4.2 箭头函数\n箭头函数的this取决于定义时的环境\n### 5. 闭包\n定义：加入一个函数能访问外部的变量，那么这个函数它就是一个闭包。\n闭包会将访问的变量存放在内部对象[[Scopes]]上，因此可以访问到本该销毁的变量\n局部变量才是被存储在栈上，全局变量存在静态区域上，其他都存在堆上。(只针对Chrome)\n### 6. new\nnew可以构建出一个实例，并绑定上this，执行步骤如下：\n1.新生成一个对象\n2.对象连接到构造函数原型上，并绑定this\n3.执行构造函数代码\n4.返回新对象\n当构造函数中返回一个对象时，内部创建的新对象会被我们返回的对象所覆盖，所以构造函数一般来说不返回对象。\n### 7. 作用域\n作用域有三类：\n1.全局作用域\n2.函数作用域\n3.块级作用域\n[[Scopes]],定义时就被确定下来，后续不会改变\n### 8. 原型\n原型更重要引出继承，概念：\n1.每个对象都有一个_proto_指向一个对象，就是原型\n2.每个对象的原型都可以通过constructor访问构造函数，构造函数通过prototype访问原型\n3.所有函数都可以通过_proto_找到Function对象\n4.所有对象都可以通过_proto_找到Object对象\n5.对象直接通过_proto_连接起来为原型链，顶层Object对象的原型为null\n### 9. 继承\n继承中的class，本质上还是一个函数。\nES5与6继承的区别：\n1.ES6继承的子类需要调用super()才能拿到子类，ES5的话是通过apply这种绑定的方式\n2.类声明不会提升，和let这些一致\n```\nfunction Super() {}\nSuper.prototype.getNumber = function() {\n  return 1\n}\n\nfunction Sub() {}\nSub.prototype = Object.create(Super.prototype, {\n  constructor: {\n    value: Sub,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n})\nlet s = new Sub()\ns.getNumber()\n```\n### 10. 深浅拷贝\n## 10.1 浅拷贝\n浅拷贝：第一层引用不同\n通过assign和扩展运算符实现浅拷贝\n```\nlet a = {age:1}\nlet b = Object.assign({},a)\nb = {...a}\n```\n## 10.2 深拷贝\n深拷贝：所有引用不同\n使用JSON.parse(JSON.stringify(object))可以实现，不过存在不少缺陷。\n也可以通过递归实现深拷贝：\n```\n// 利用 WeakMap 解决循环引用\nlet map = new WeakMap()\nfunction deepClone(obj) {\n  if (obj instanceof Object) {\n    if (map.has(obj)) {\n      return map.get(obj)\n    }\n    let newObj\n    if (obj instanceof Array) {\n      newObj = []\n    } else if (obj instanceof Function) {\n      newObj = function() {\n        return obj.apply(this, arguments)\n      }\n    } else if (obj instanceof RegExp) {\n      // 拼接正则\n      newobj = new RegExp(obj.source, obj.flags)\n    } else if (obj instanceof Date) {\n      newobj = new Date(obj)\n    } else {\n      newObj = {}\n    }\n    // 克隆一份对象出来\n    let desc = Object.getOwnPropertyDescriptors(obj)\n    let clone = Object.create(Object.getPrototypeOf(obj), desc)\n    map.set(obj, clone)\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = deepClone(obj[key])\n      }\n    }\n    return newObj\n  }\n  return obj\n}\n```\n### 11. Promise\n高频考点，涉及API，问到all，race。\nthen，catch，finally都为微任务。其他代码都是宏任务(同步执行)\n这些微任务在Promise状态为非pending时加入队列。\n同级then下，前一个then执行完后，后面的才会加入任务队列。\n最开始调用的then会首先依次加入任务队列。\n同一个promise的每个链式调用的开端会首先依次进入队列。\n## 11.1 async/await\nasync/await(ES8)\n阻塞await后面的内容。\n### 12. 事件循环\n异步只是延迟执行同步代码。其他线程不影响(Web worker)。\nTask(宏任务)：同步代码、setTimeout回调、setInterval回调、IO、UI交互事件、postMessage、MessageChannel。\nMicroTask(微任务)：Promise的回调，Mutation observer回调，queueMicrotask回调。\n执行顺序如下：\n1.执行同步代码\n2.执行完所有同步代码后且执行栈为空，判断是否有微任务需要执行\n3.执行所有微任务且微任务队列为空\n4.是否有必要渲染页面\n5.执行一个宏任务\n### 13. 模块化\nCommonJS，ES6的ESM\n### 14. 垃圾回收\n分两个空间，新生代和老生代。\n## 14.1 新生代\n使用Scavenge GC算法\n也分两个部分，From空间，To空间。\nFrom占满时，启动算法检查存活的对象复制到To空间中，会和To空间互换。\n## 14.2 老生代\n使用标记清除和标记压缩算法\n经历过Scavenge算法后还存活，To空间对象占比大小超过25%，会将新生代移到老生代。\n启动标记清除算法条件：\n1.某一个空间没有分块\n2.空间中被对象超过一定限制\n3.空间不能保证新生代中的对象移动到老生代中\n标记活对象，销毁没被标记的对象\n### 15. 其他\n0.1+0.2 !== 0.3\n浮点数用二进制表示的时候是无穷的，因为精度的问题，两个浮点数相加会造成截断丢失精度，因此再转换为十进制就出了问题。\n### 16. 手写题\n## 16.1 防抖\n## 16.2 节流\n## 16.3 Event Bus\n## 16.4 instanceof\n## 16.5 call，bind，apply \n","source":"_posts/前端进阶之道.md","raw":"---\ntitle: 前端进阶之道\ndate: 2020-12-04 15:21:26\ntags:\n - 前端学习\ncategories: Web前端\n---\n### 1. 数据类型\nJS分两种类型，原始类型和对象类型。\n原始类型：\n1.boolean\n2.number\n3.string\n4.undefined\n5.null\n6.symbol\n7.bigint\n对象类型：\n1.Object(Array,RegExp,Math,Map,Set)\n2.Function\n---\n### 2. 类型判断\n## 2.1 typeof\n原始类型中除了null，都可以用typeof判断。\ntypeof判断函数为function，其他均为object。\n## 2.2 instanceof\n常用于判断对象类型\n## 2.3 Object.prototype.toString\n最佳选择，能判断的类型最完整\n## 2.4 isXXX API\nisArray()，isNaN()\n### 3. 类型转换\n```\nNumber(false) // -> 0\nNumber('1')// -> 1\nNumber('zb')// -> NaN\n(1).toString()// '1'\n```\n转布尔值规则：\n1.undefined、null、false、NaN、''、0、-0都转为false\n2.其他所有值都转为true，包括所有对象\n转数字规则：\n1.true为1，false为0\n2.null为0，undefined为NaN，symbol报错\n3.字符串看内容，如果是数字或者进制值就正常转，否则就NaN\n4.对象的规则隐式转换再讲\n### 4. this\n## 4.1 普通函数\n谁调用this指向谁\n```\nvar c = new foo()\nc.a = 3\nconsole.log(c.a) // this绑定到c上，不会被任何方式修改\n```\n使用apply，call，bind改变this，优先级仅次于new\n## 4.2 箭头函数\n箭头函数的this取决于定义时的环境\n### 5. 闭包\n定义：加入一个函数能访问外部的变量，那么这个函数它就是一个闭包。\n闭包会将访问的变量存放在内部对象[[Scopes]]上，因此可以访问到本该销毁的变量\n局部变量才是被存储在栈上，全局变量存在静态区域上，其他都存在堆上。(只针对Chrome)\n### 6. new\nnew可以构建出一个实例，并绑定上this，执行步骤如下：\n1.新生成一个对象\n2.对象连接到构造函数原型上，并绑定this\n3.执行构造函数代码\n4.返回新对象\n当构造函数中返回一个对象时，内部创建的新对象会被我们返回的对象所覆盖，所以构造函数一般来说不返回对象。\n### 7. 作用域\n作用域有三类：\n1.全局作用域\n2.函数作用域\n3.块级作用域\n[[Scopes]],定义时就被确定下来，后续不会改变\n### 8. 原型\n原型更重要引出继承，概念：\n1.每个对象都有一个_proto_指向一个对象，就是原型\n2.每个对象的原型都可以通过constructor访问构造函数，构造函数通过prototype访问原型\n3.所有函数都可以通过_proto_找到Function对象\n4.所有对象都可以通过_proto_找到Object对象\n5.对象直接通过_proto_连接起来为原型链，顶层Object对象的原型为null\n### 9. 继承\n继承中的class，本质上还是一个函数。\nES5与6继承的区别：\n1.ES6继承的子类需要调用super()才能拿到子类，ES5的话是通过apply这种绑定的方式\n2.类声明不会提升，和let这些一致\n```\nfunction Super() {}\nSuper.prototype.getNumber = function() {\n  return 1\n}\n\nfunction Sub() {}\nSub.prototype = Object.create(Super.prototype, {\n  constructor: {\n    value: Sub,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n})\nlet s = new Sub()\ns.getNumber()\n```\n### 10. 深浅拷贝\n## 10.1 浅拷贝\n浅拷贝：第一层引用不同\n通过assign和扩展运算符实现浅拷贝\n```\nlet a = {age:1}\nlet b = Object.assign({},a)\nb = {...a}\n```\n## 10.2 深拷贝\n深拷贝：所有引用不同\n使用JSON.parse(JSON.stringify(object))可以实现，不过存在不少缺陷。\n也可以通过递归实现深拷贝：\n```\n// 利用 WeakMap 解决循环引用\nlet map = new WeakMap()\nfunction deepClone(obj) {\n  if (obj instanceof Object) {\n    if (map.has(obj)) {\n      return map.get(obj)\n    }\n    let newObj\n    if (obj instanceof Array) {\n      newObj = []\n    } else if (obj instanceof Function) {\n      newObj = function() {\n        return obj.apply(this, arguments)\n      }\n    } else if (obj instanceof RegExp) {\n      // 拼接正则\n      newobj = new RegExp(obj.source, obj.flags)\n    } else if (obj instanceof Date) {\n      newobj = new Date(obj)\n    } else {\n      newObj = {}\n    }\n    // 克隆一份对象出来\n    let desc = Object.getOwnPropertyDescriptors(obj)\n    let clone = Object.create(Object.getPrototypeOf(obj), desc)\n    map.set(obj, clone)\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = deepClone(obj[key])\n      }\n    }\n    return newObj\n  }\n  return obj\n}\n```\n### 11. Promise\n高频考点，涉及API，问到all，race。\nthen，catch，finally都为微任务。其他代码都是宏任务(同步执行)\n这些微任务在Promise状态为非pending时加入队列。\n同级then下，前一个then执行完后，后面的才会加入任务队列。\n最开始调用的then会首先依次加入任务队列。\n同一个promise的每个链式调用的开端会首先依次进入队列。\n## 11.1 async/await\nasync/await(ES8)\n阻塞await后面的内容。\n### 12. 事件循环\n异步只是延迟执行同步代码。其他线程不影响(Web worker)。\nTask(宏任务)：同步代码、setTimeout回调、setInterval回调、IO、UI交互事件、postMessage、MessageChannel。\nMicroTask(微任务)：Promise的回调，Mutation observer回调，queueMicrotask回调。\n执行顺序如下：\n1.执行同步代码\n2.执行完所有同步代码后且执行栈为空，判断是否有微任务需要执行\n3.执行所有微任务且微任务队列为空\n4.是否有必要渲染页面\n5.执行一个宏任务\n### 13. 模块化\nCommonJS，ES6的ESM\n### 14. 垃圾回收\n分两个空间，新生代和老生代。\n## 14.1 新生代\n使用Scavenge GC算法\n也分两个部分，From空间，To空间。\nFrom占满时，启动算法检查存活的对象复制到To空间中，会和To空间互换。\n## 14.2 老生代\n使用标记清除和标记压缩算法\n经历过Scavenge算法后还存活，To空间对象占比大小超过25%，会将新生代移到老生代。\n启动标记清除算法条件：\n1.某一个空间没有分块\n2.空间中被对象超过一定限制\n3.空间不能保证新生代中的对象移动到老生代中\n标记活对象，销毁没被标记的对象\n### 15. 其他\n0.1+0.2 !== 0.3\n浮点数用二进制表示的时候是无穷的，因为精度的问题，两个浮点数相加会造成截断丢失精度，因此再转换为十进制就出了问题。\n### 16. 手写题\n## 16.1 防抖\n## 16.2 节流\n## 16.3 Event Bus\n## 16.4 instanceof\n## 16.5 call，bind，apply \n","slug":"前端进阶之道","published":1,"updated":"2021-04-13T05:32:51.504Z","_id":"ckkrow37g0024pcva8ozv01zz","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h3><p>JS分两种类型，原始类型和对象类型。<br>原始类型：<br>1.boolean<br>2.number<br>3.string<br>4.undefined<br>5.null<br>6.symbol<br>7.bigint<br>对象类型：<br>1.Object(Array,RegExp,Math,Map,Set)<br>2.Function</p>\n<hr>\n<h3 id=\"2-类型判断\"><a href=\"#2-类型判断\" class=\"headerlink\" title=\"2. 类型判断\"></a>2. 类型判断</h3><h2 id=\"2-1-typeof\"><a href=\"#2-1-typeof\" class=\"headerlink\" title=\"2.1 typeof\"></a>2.1 typeof</h2><p>原始类型中除了null，都可以用typeof判断。<br>typeof判断函数为function，其他均为object。</p>\n<h2 id=\"2-2-instanceof\"><a href=\"#2-2-instanceof\" class=\"headerlink\" title=\"2.2 instanceof\"></a>2.2 instanceof</h2><p>常用于判断对象类型</p>\n<h2 id=\"2-3-Object-prototype-toString\"><a href=\"#2-3-Object-prototype-toString\" class=\"headerlink\" title=\"2.3 Object.prototype.toString\"></a>2.3 Object.prototype.toString</h2><p>最佳选择，能判断的类型最完整</p>\n<h2 id=\"2-4-isXXX-API\"><a href=\"#2-4-isXXX-API\" class=\"headerlink\" title=\"2.4 isXXX API\"></a>2.4 isXXX API</h2><p>isArray()，isNaN()</p>\n<h3 id=\"3-类型转换\"><a href=\"#3-类型转换\" class=\"headerlink\" title=\"3. 类型转换\"></a>3. 类型转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number(false) &#x2F;&#x2F; -&gt; 0</span><br><span class=\"line\">Number(&#39;1&#39;)&#x2F;&#x2F; -&gt; 1</span><br><span class=\"line\">Number(&#39;zb&#39;)&#x2F;&#x2F; -&gt; NaN</span><br><span class=\"line\">(1).toString()&#x2F;&#x2F; &#39;1&#39;</span><br></pre></td></tr></table></figure>\n<p>转布尔值规则：<br>1.undefined、null、false、NaN、’’、0、-0都转为false<br>2.其他所有值都转为true，包括所有对象<br>转数字规则：<br>1.true为1，false为0<br>2.null为0，undefined为NaN，symbol报错<br>3.字符串看内容，如果是数字或者进制值就正常转，否则就NaN<br>4.对象的规则隐式转换再讲</p>\n<h3 id=\"4-this\"><a href=\"#4-this\" class=\"headerlink\" title=\"4. this\"></a>4. this</h3><h2 id=\"4-1-普通函数\"><a href=\"#4-1-普通函数\" class=\"headerlink\" title=\"4.1 普通函数\"></a>4.1 普通函数</h2><p>谁调用this指向谁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var c &#x3D; new foo()</span><br><span class=\"line\">c.a &#x3D; 3</span><br><span class=\"line\">console.log(c.a) &#x2F;&#x2F; this绑定到c上，不会被任何方式修改</span><br></pre></td></tr></table></figure>\n<p>使用apply，call，bind改变this，优先级仅次于new</p>\n<h2 id=\"4-2-箭头函数\"><a href=\"#4-2-箭头函数\" class=\"headerlink\" title=\"4.2 箭头函数\"></a>4.2 箭头函数</h2><p>箭头函数的this取决于定义时的环境</p>\n<h3 id=\"5-闭包\"><a href=\"#5-闭包\" class=\"headerlink\" title=\"5. 闭包\"></a>5. 闭包</h3><p>定义：加入一个函数能访问外部的变量，那么这个函数它就是一个闭包。<br>闭包会将访问的变量存放在内部对象[[Scopes]]上，因此可以访问到本该销毁的变量<br>局部变量才是被存储在栈上，全局变量存在静态区域上，其他都存在堆上。(只针对Chrome)</p>\n<h3 id=\"6-new\"><a href=\"#6-new\" class=\"headerlink\" title=\"6. new\"></a>6. new</h3><p>new可以构建出一个实例，并绑定上this，执行步骤如下：<br>1.新生成一个对象<br>2.对象连接到构造函数原型上，并绑定this<br>3.执行构造函数代码<br>4.返回新对象<br>当构造函数中返回一个对象时，内部创建的新对象会被我们返回的对象所覆盖，所以构造函数一般来说不返回对象。</p>\n<h3 id=\"7-作用域\"><a href=\"#7-作用域\" class=\"headerlink\" title=\"7. 作用域\"></a>7. 作用域</h3><p>作用域有三类：<br>1.全局作用域<br>2.函数作用域<br>3.块级作用域<br>[[Scopes]],定义时就被确定下来，后续不会改变</p>\n<h3 id=\"8-原型\"><a href=\"#8-原型\" class=\"headerlink\" title=\"8. 原型\"></a>8. 原型</h3><p>原型更重要引出继承，概念：<br>1.每个对象都有一个_proto_指向一个对象，就是原型<br>2.每个对象的原型都可以通过constructor访问构造函数，构造函数通过prototype访问原型<br>3.所有函数都可以通过_proto_找到Function对象<br>4.所有对象都可以通过_proto_找到Object对象<br>5.对象直接通过_proto_连接起来为原型链，顶层Object对象的原型为null</p>\n<h3 id=\"9-继承\"><a href=\"#9-继承\" class=\"headerlink\" title=\"9. 继承\"></a>9. 继承</h3><p>继承中的class，本质上还是一个函数。<br>ES5与6继承的区别：<br>1.ES6继承的子类需要调用super()才能拿到子类，ES5的话是通过apply这种绑定的方式<br>2.类声明不会提升，和let这些一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super() &#123;&#125;</span><br><span class=\"line\">Super.prototype.getNumber &#x3D; function() &#123;</span><br><span class=\"line\">  return 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Sub() &#123;&#125;</span><br><span class=\"line\">Sub.prototype &#x3D; Object.create(Super.prototype, &#123;</span><br><span class=\"line\">  constructor: &#123;</span><br><span class=\"line\">    value: Sub,</span><br><span class=\"line\">    enumerable: false,</span><br><span class=\"line\">    writable: true,</span><br><span class=\"line\">    configurable: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let s &#x3D; new Sub()</span><br><span class=\"line\">s.getNumber()</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-深浅拷贝\"><a href=\"#10-深浅拷贝\" class=\"headerlink\" title=\"10. 深浅拷贝\"></a>10. 深浅拷贝</h3><h2 id=\"10-1-浅拷贝\"><a href=\"#10-1-浅拷贝\" class=\"headerlink\" title=\"10.1 浅拷贝\"></a>10.1 浅拷贝</h2><p>浅拷贝：第一层引用不同<br>通过assign和扩展运算符实现浅拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#123;age:1&#125;</span><br><span class=\"line\">let b &#x3D; Object.assign(&#123;&#125;,a)</span><br><span class=\"line\">b &#x3D; &#123;...a&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-2-深拷贝\"><a href=\"#10-2-深拷贝\" class=\"headerlink\" title=\"10.2 深拷贝\"></a>10.2 深拷贝</h2><p>深拷贝：所有引用不同<br>使用JSON.parse(JSON.stringify(object))可以实现，不过存在不少缺陷。<br>也可以通过递归实现深拷贝：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 利用 WeakMap 解决循环引用</span><br><span class=\"line\">let map &#x3D; new WeakMap()</span><br><span class=\"line\">function deepClone(obj) &#123;</span><br><span class=\"line\">  if (obj instanceof Object) &#123;</span><br><span class=\"line\">    if (map.has(obj)) &#123;</span><br><span class=\"line\">      return map.get(obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let newObj</span><br><span class=\"line\">    if (obj instanceof Array) &#123;</span><br><span class=\"line\">      newObj &#x3D; []</span><br><span class=\"line\">    &#125; else if (obj instanceof Function) &#123;</span><br><span class=\"line\">      newObj &#x3D; function() &#123;</span><br><span class=\"line\">        return obj.apply(this, arguments)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else if (obj instanceof RegExp) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 拼接正则</span><br><span class=\"line\">      newobj &#x3D; new RegExp(obj.source, obj.flags)</span><br><span class=\"line\">    &#125; else if (obj instanceof Date) &#123;</span><br><span class=\"line\">      newobj &#x3D; new Date(obj)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      newObj &#x3D; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 克隆一份对象出来</span><br><span class=\"line\">    let desc &#x3D; Object.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">    let clone &#x3D; Object.create(Object.getPrototypeOf(obj), desc)</span><br><span class=\"line\">    map.set(obj, clone)</span><br><span class=\"line\">    for (let key in obj) &#123;</span><br><span class=\"line\">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">        newObj[key] &#x3D; deepClone(obj[key])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newObj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-Promise\"><a href=\"#11-Promise\" class=\"headerlink\" title=\"11. Promise\"></a>11. Promise</h3><p>高频考点，涉及API，问到all，race。<br>then，catch，finally都为微任务。其他代码都是宏任务(同步执行)<br>这些微任务在Promise状态为非pending时加入队列。<br>同级then下，前一个then执行完后，后面的才会加入任务队列。<br>最开始调用的then会首先依次加入任务队列。<br>同一个promise的每个链式调用的开端会首先依次进入队列。</p>\n<h2 id=\"11-1-async-await\"><a href=\"#11-1-async-await\" class=\"headerlink\" title=\"11.1 async/await\"></a>11.1 async/await</h2><p>async/await(ES8)<br>阻塞await后面的内容。</p>\n<h3 id=\"12-事件循环\"><a href=\"#12-事件循环\" class=\"headerlink\" title=\"12. 事件循环\"></a>12. 事件循环</h3><p>异步只是延迟执行同步代码。其他线程不影响(Web worker)。<br>Task(宏任务)：同步代码、setTimeout回调、setInterval回调、IO、UI交互事件、postMessage、MessageChannel。<br>MicroTask(微任务)：Promise的回调，Mutation observer回调，queueMicrotask回调。<br>执行顺序如下：<br>1.执行同步代码<br>2.执行完所有同步代码后且执行栈为空，判断是否有微任务需要执行<br>3.执行所有微任务且微任务队列为空<br>4.是否有必要渲染页面<br>5.执行一个宏任务</p>\n<h3 id=\"13-模块化\"><a href=\"#13-模块化\" class=\"headerlink\" title=\"13. 模块化\"></a>13. 模块化</h3><p>CommonJS，ES6的ESM</p>\n<h3 id=\"14-垃圾回收\"><a href=\"#14-垃圾回收\" class=\"headerlink\" title=\"14. 垃圾回收\"></a>14. 垃圾回收</h3><p>分两个空间，新生代和老生代。</p>\n<h2 id=\"14-1-新生代\"><a href=\"#14-1-新生代\" class=\"headerlink\" title=\"14.1 新生代\"></a>14.1 新生代</h2><p>使用Scavenge GC算法<br>也分两个部分，From空间，To空间。<br>From占满时，启动算法检查存活的对象复制到To空间中，会和To空间互换。</p>\n<h2 id=\"14-2-老生代\"><a href=\"#14-2-老生代\" class=\"headerlink\" title=\"14.2 老生代\"></a>14.2 老生代</h2><p>使用标记清除和标记压缩算法<br>经历过Scavenge算法后还存活，To空间对象占比大小超过25%，会将新生代移到老生代。<br>启动标记清除算法条件：<br>1.某一个空间没有分块<br>2.空间中被对象超过一定限制<br>3.空间不能保证新生代中的对象移动到老生代中<br>标记活对象，销毁没被标记的对象</p>\n<h3 id=\"15-其他\"><a href=\"#15-其他\" class=\"headerlink\" title=\"15. 其他\"></a>15. 其他</h3><p>0.1+0.2 !== 0.3<br>浮点数用二进制表示的时候是无穷的，因为精度的问题，两个浮点数相加会造成截断丢失精度，因此再转换为十进制就出了问题。</p>\n<h3 id=\"16-手写题\"><a href=\"#16-手写题\" class=\"headerlink\" title=\"16. 手写题\"></a>16. 手写题</h3><h2 id=\"16-1-防抖\"><a href=\"#16-1-防抖\" class=\"headerlink\" title=\"16.1 防抖\"></a>16.1 防抖</h2><h2 id=\"16-2-节流\"><a href=\"#16-2-节流\" class=\"headerlink\" title=\"16.2 节流\"></a>16.2 节流</h2><h2 id=\"16-3-Event-Bus\"><a href=\"#16-3-Event-Bus\" class=\"headerlink\" title=\"16.3 Event Bus\"></a>16.3 Event Bus</h2><h2 id=\"16-4-instanceof\"><a href=\"#16-4-instanceof\" class=\"headerlink\" title=\"16.4 instanceof\"></a>16.4 instanceof</h2><h2 id=\"16-5-call，bind，apply\"><a href=\"#16-5-call，bind，apply\" class=\"headerlink\" title=\"16.5 call，bind，apply\"></a>16.5 call，bind，apply</h2>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h3><p>JS分两种类型，原始类型和对象类型。<br>原始类型：<br>1.boolean<br>2.number<br>3.string<br>4.undefined<br>5.null<br>6.symbol<br>7.bigint<br>对象类型：<br>1.Object(Array,RegExp,Math,Map,Set)<br>2.Function</p>\n<hr>\n<h3 id=\"2-类型判断\"><a href=\"#2-类型判断\" class=\"headerlink\" title=\"2. 类型判断\"></a>2. 类型判断</h3><h2 id=\"2-1-typeof\"><a href=\"#2-1-typeof\" class=\"headerlink\" title=\"2.1 typeof\"></a>2.1 typeof</h2><p>原始类型中除了null，都可以用typeof判断。<br>typeof判断函数为function，其他均为object。</p>\n<h2 id=\"2-2-instanceof\"><a href=\"#2-2-instanceof\" class=\"headerlink\" title=\"2.2 instanceof\"></a>2.2 instanceof</h2><p>常用于判断对象类型</p>\n<h2 id=\"2-3-Object-prototype-toString\"><a href=\"#2-3-Object-prototype-toString\" class=\"headerlink\" title=\"2.3 Object.prototype.toString\"></a>2.3 Object.prototype.toString</h2><p>最佳选择，能判断的类型最完整</p>\n<h2 id=\"2-4-isXXX-API\"><a href=\"#2-4-isXXX-API\" class=\"headerlink\" title=\"2.4 isXXX API\"></a>2.4 isXXX API</h2><p>isArray()，isNaN()</p>\n<h3 id=\"3-类型转换\"><a href=\"#3-类型转换\" class=\"headerlink\" title=\"3. 类型转换\"></a>3. 类型转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number(false) &#x2F;&#x2F; -&gt; 0</span><br><span class=\"line\">Number(&#39;1&#39;)&#x2F;&#x2F; -&gt; 1</span><br><span class=\"line\">Number(&#39;zb&#39;)&#x2F;&#x2F; -&gt; NaN</span><br><span class=\"line\">(1).toString()&#x2F;&#x2F; &#39;1&#39;</span><br></pre></td></tr></table></figure>\n<p>转布尔值规则：<br>1.undefined、null、false、NaN、’’、0、-0都转为false<br>2.其他所有值都转为true，包括所有对象<br>转数字规则：<br>1.true为1，false为0<br>2.null为0，undefined为NaN，symbol报错<br>3.字符串看内容，如果是数字或者进制值就正常转，否则就NaN<br>4.对象的规则隐式转换再讲</p>\n<h3 id=\"4-this\"><a href=\"#4-this\" class=\"headerlink\" title=\"4. this\"></a>4. this</h3><h2 id=\"4-1-普通函数\"><a href=\"#4-1-普通函数\" class=\"headerlink\" title=\"4.1 普通函数\"></a>4.1 普通函数</h2><p>谁调用this指向谁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var c &#x3D; new foo()</span><br><span class=\"line\">c.a &#x3D; 3</span><br><span class=\"line\">console.log(c.a) &#x2F;&#x2F; this绑定到c上，不会被任何方式修改</span><br></pre></td></tr></table></figure>\n<p>使用apply，call，bind改变this，优先级仅次于new</p>\n<h2 id=\"4-2-箭头函数\"><a href=\"#4-2-箭头函数\" class=\"headerlink\" title=\"4.2 箭头函数\"></a>4.2 箭头函数</h2><p>箭头函数的this取决于定义时的环境</p>\n<h3 id=\"5-闭包\"><a href=\"#5-闭包\" class=\"headerlink\" title=\"5. 闭包\"></a>5. 闭包</h3><p>定义：加入一个函数能访问外部的变量，那么这个函数它就是一个闭包。<br>闭包会将访问的变量存放在内部对象[[Scopes]]上，因此可以访问到本该销毁的变量<br>局部变量才是被存储在栈上，全局变量存在静态区域上，其他都存在堆上。(只针对Chrome)</p>\n<h3 id=\"6-new\"><a href=\"#6-new\" class=\"headerlink\" title=\"6. new\"></a>6. new</h3><p>new可以构建出一个实例，并绑定上this，执行步骤如下：<br>1.新生成一个对象<br>2.对象连接到构造函数原型上，并绑定this<br>3.执行构造函数代码<br>4.返回新对象<br>当构造函数中返回一个对象时，内部创建的新对象会被我们返回的对象所覆盖，所以构造函数一般来说不返回对象。</p>\n<h3 id=\"7-作用域\"><a href=\"#7-作用域\" class=\"headerlink\" title=\"7. 作用域\"></a>7. 作用域</h3><p>作用域有三类：<br>1.全局作用域<br>2.函数作用域<br>3.块级作用域<br>[[Scopes]],定义时就被确定下来，后续不会改变</p>\n<h3 id=\"8-原型\"><a href=\"#8-原型\" class=\"headerlink\" title=\"8. 原型\"></a>8. 原型</h3><p>原型更重要引出继承，概念：<br>1.每个对象都有一个_proto_指向一个对象，就是原型<br>2.每个对象的原型都可以通过constructor访问构造函数，构造函数通过prototype访问原型<br>3.所有函数都可以通过_proto_找到Function对象<br>4.所有对象都可以通过_proto_找到Object对象<br>5.对象直接通过_proto_连接起来为原型链，顶层Object对象的原型为null</p>\n<h3 id=\"9-继承\"><a href=\"#9-继承\" class=\"headerlink\" title=\"9. 继承\"></a>9. 继承</h3><p>继承中的class，本质上还是一个函数。<br>ES5与6继承的区别：<br>1.ES6继承的子类需要调用super()才能拿到子类，ES5的话是通过apply这种绑定的方式<br>2.类声明不会提升，和let这些一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Super() &#123;&#125;</span><br><span class=\"line\">Super.prototype.getNumber &#x3D; function() &#123;</span><br><span class=\"line\">  return 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Sub() &#123;&#125;</span><br><span class=\"line\">Sub.prototype &#x3D; Object.create(Super.prototype, &#123;</span><br><span class=\"line\">  constructor: &#123;</span><br><span class=\"line\">    value: Sub,</span><br><span class=\"line\">    enumerable: false,</span><br><span class=\"line\">    writable: true,</span><br><span class=\"line\">    configurable: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let s &#x3D; new Sub()</span><br><span class=\"line\">s.getNumber()</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-深浅拷贝\"><a href=\"#10-深浅拷贝\" class=\"headerlink\" title=\"10. 深浅拷贝\"></a>10. 深浅拷贝</h3><h2 id=\"10-1-浅拷贝\"><a href=\"#10-1-浅拷贝\" class=\"headerlink\" title=\"10.1 浅拷贝\"></a>10.1 浅拷贝</h2><p>浅拷贝：第一层引用不同<br>通过assign和扩展运算符实现浅拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#123;age:1&#125;</span><br><span class=\"line\">let b &#x3D; Object.assign(&#123;&#125;,a)</span><br><span class=\"line\">b &#x3D; &#123;...a&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-2-深拷贝\"><a href=\"#10-2-深拷贝\" class=\"headerlink\" title=\"10.2 深拷贝\"></a>10.2 深拷贝</h2><p>深拷贝：所有引用不同<br>使用JSON.parse(JSON.stringify(object))可以实现，不过存在不少缺陷。<br>也可以通过递归实现深拷贝：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 利用 WeakMap 解决循环引用</span><br><span class=\"line\">let map &#x3D; new WeakMap()</span><br><span class=\"line\">function deepClone(obj) &#123;</span><br><span class=\"line\">  if (obj instanceof Object) &#123;</span><br><span class=\"line\">    if (map.has(obj)) &#123;</span><br><span class=\"line\">      return map.get(obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let newObj</span><br><span class=\"line\">    if (obj instanceof Array) &#123;</span><br><span class=\"line\">      newObj &#x3D; []</span><br><span class=\"line\">    &#125; else if (obj instanceof Function) &#123;</span><br><span class=\"line\">      newObj &#x3D; function() &#123;</span><br><span class=\"line\">        return obj.apply(this, arguments)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else if (obj instanceof RegExp) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 拼接正则</span><br><span class=\"line\">      newobj &#x3D; new RegExp(obj.source, obj.flags)</span><br><span class=\"line\">    &#125; else if (obj instanceof Date) &#123;</span><br><span class=\"line\">      newobj &#x3D; new Date(obj)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      newObj &#x3D; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 克隆一份对象出来</span><br><span class=\"line\">    let desc &#x3D; Object.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">    let clone &#x3D; Object.create(Object.getPrototypeOf(obj), desc)</span><br><span class=\"line\">    map.set(obj, clone)</span><br><span class=\"line\">    for (let key in obj) &#123;</span><br><span class=\"line\">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">        newObj[key] &#x3D; deepClone(obj[key])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newObj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-Promise\"><a href=\"#11-Promise\" class=\"headerlink\" title=\"11. Promise\"></a>11. Promise</h3><p>高频考点，涉及API，问到all，race。<br>then，catch，finally都为微任务。其他代码都是宏任务(同步执行)<br>这些微任务在Promise状态为非pending时加入队列。<br>同级then下，前一个then执行完后，后面的才会加入任务队列。<br>最开始调用的then会首先依次加入任务队列。<br>同一个promise的每个链式调用的开端会首先依次进入队列。</p>\n<h2 id=\"11-1-async-await\"><a href=\"#11-1-async-await\" class=\"headerlink\" title=\"11.1 async/await\"></a>11.1 async/await</h2><p>async/await(ES8)<br>阻塞await后面的内容。</p>\n<h3 id=\"12-事件循环\"><a href=\"#12-事件循环\" class=\"headerlink\" title=\"12. 事件循环\"></a>12. 事件循环</h3><p>异步只是延迟执行同步代码。其他线程不影响(Web worker)。<br>Task(宏任务)：同步代码、setTimeout回调、setInterval回调、IO、UI交互事件、postMessage、MessageChannel。<br>MicroTask(微任务)：Promise的回调，Mutation observer回调，queueMicrotask回调。<br>执行顺序如下：<br>1.执行同步代码<br>2.执行完所有同步代码后且执行栈为空，判断是否有微任务需要执行<br>3.执行所有微任务且微任务队列为空<br>4.是否有必要渲染页面<br>5.执行一个宏任务</p>\n<h3 id=\"13-模块化\"><a href=\"#13-模块化\" class=\"headerlink\" title=\"13. 模块化\"></a>13. 模块化</h3><p>CommonJS，ES6的ESM</p>\n<h3 id=\"14-垃圾回收\"><a href=\"#14-垃圾回收\" class=\"headerlink\" title=\"14. 垃圾回收\"></a>14. 垃圾回收</h3><p>分两个空间，新生代和老生代。</p>\n<h2 id=\"14-1-新生代\"><a href=\"#14-1-新生代\" class=\"headerlink\" title=\"14.1 新生代\"></a>14.1 新生代</h2><p>使用Scavenge GC算法<br>也分两个部分，From空间，To空间。<br>From占满时，启动算法检查存活的对象复制到To空间中，会和To空间互换。</p>\n<h2 id=\"14-2-老生代\"><a href=\"#14-2-老生代\" class=\"headerlink\" title=\"14.2 老生代\"></a>14.2 老生代</h2><p>使用标记清除和标记压缩算法<br>经历过Scavenge算法后还存活，To空间对象占比大小超过25%，会将新生代移到老生代。<br>启动标记清除算法条件：<br>1.某一个空间没有分块<br>2.空间中被对象超过一定限制<br>3.空间不能保证新生代中的对象移动到老生代中<br>标记活对象，销毁没被标记的对象</p>\n<h3 id=\"15-其他\"><a href=\"#15-其他\" class=\"headerlink\" title=\"15. 其他\"></a>15. 其他</h3><p>0.1+0.2 !== 0.3<br>浮点数用二进制表示的时候是无穷的，因为精度的问题，两个浮点数相加会造成截断丢失精度，因此再转换为十进制就出了问题。</p>\n<h3 id=\"16-手写题\"><a href=\"#16-手写题\" class=\"headerlink\" title=\"16. 手写题\"></a>16. 手写题</h3><h2 id=\"16-1-防抖\"><a href=\"#16-1-防抖\" class=\"headerlink\" title=\"16.1 防抖\"></a>16.1 防抖</h2><h2 id=\"16-2-节流\"><a href=\"#16-2-节流\" class=\"headerlink\" title=\"16.2 节流\"></a>16.2 节流</h2><h2 id=\"16-3-Event-Bus\"><a href=\"#16-3-Event-Bus\" class=\"headerlink\" title=\"16.3 Event Bus\"></a>16.3 Event Bus</h2><h2 id=\"16-4-instanceof\"><a href=\"#16-4-instanceof\" class=\"headerlink\" title=\"16.4 instanceof\"></a>16.4 instanceof</h2><h2 id=\"16-5-call，bind，apply\"><a href=\"#16-5-call，bind，apply\" class=\"headerlink\" title=\"16.5 call，bind，apply\"></a>16.5 call，bind，apply</h2>"},{"title":"函数理解","date":"2020-07-01T01:15:30.000Z","_content":"\n## 隐式函数参数：arguments\n\narguments:不代表数组，允许我们访问传递给函数的所有参数。自带length属性。\narguments代表参数的别名，更改对象arguments的值会影响对应的函数参数。\narguments在strict模式下无法使用。arguments和参数值不互通（strict模式下）。\n\n## 函数上下文：this\nthis：面向对象编程的重要组成部分。\nthis通常指向定义当前方法的类的实例。\n函数有四种调用方式：\n```bash\n（function）：func()直接调用->此模式下调用，this为Windows对象（全局上下文），严格模式下为undefined\n（method）：ninja.func()关联对象，实现面向对象编程\n（constructor）：new ninja()实例化新对象\n（apply或call）：func.apply/call(ninja)\n```\n调用的方式不一样，返回的上下文也不一样\n作为函数被调用：\n```bash\nfunction ninja() {\n    return this;\n}\n\nfunction samurai() {\n   \"use strict\";//严格模式\n    return this;\n}\nninja();\nsamurai();\n```\n作为方法被调用：\n```bash\nfunction whatsMyContext() {\n      return this;\n    }\n\nassert(whatsMyContext() === window,\n  \"Function call on window\");\n\nvar getMyThis = whatsMyContext;\n\nassert(getMyThis() === window,\n  \"Another function call in window\");\n\nvar ninja1 = {\n   getMyThis: whatsMyContext\n};\n\nassert(ninja1.getMyThis() === ninja1,\n   \"Working with 1st ninja\");//getMyThis作为ninja对象的属性方法调用\n```\n作为构造函数调用：//初始化和实例对象\n```bash\nfunction Ninja() {\n   this.skulk = function() {\n   return this;\n   };\n}\n\nvar ninja1 = new Ninja();//创建一个新的空对象，该对象作为this参数传递给构造函数\nvar ninja2 = new Ninja();//新构造的对象作为new运算符的返回值\n\nassert(ninja1.skulk() === ninja1,\n   \"The 1st ninja is skulking\");\nassert(ninja2.skulk() === ninja2,\n   \"The 2nd ninja is skulking\");\n```\n返回原始值的构造函数：\n```bash\nfunction Ninja() {\n    this.skulk = function () {\n      return true;\n    };\n\n    return 1;\n  }\n  assert(Ninja() === 1,//作为函数调用返回值是1\n    \"Return value honored when not called as a constructor\");\n\n  var ninja = new Ninja();//作为构造函数调用，返回值是一个对象\n\n  assert(typeof ninja === \"object\",\n    \"Object returned when called as a constructor\");\n  assert(typeof ninja.skulk === \"function\",\n    \"ninja object has a skulk method\");\n```\n使用apply和call方法：\n```bash\nfunction juggle() {\n      var result = 0;\n      for (var n = 0; n < arguments.length; n++) {\n        result += arguments[n];\n      }\n      this.result = result;\n    }\n\n    var ninja1 = {};\n    var ninja2 = {};\n\n    juggle.apply(ninja1,[1,2,3,4]);//this：ninja1 传入一个this和一系列参数\n    juggle.call(ninja2, 5,6,7,8);//this：ninja2 传入一个this和一系列参数\n\n    assert(ninja1.result === 10, \"juggled via apply\");\n    assert(ninja2.result === 26, \"juggled via call\");\n```\n使用forEach迭代方法可以将函数的上下文设置为任意的对象\n箭头函数没有单独的this值，其this值与箭头函数的上下文相同\n\n使用bind方法：\n```bash\n    var button = {\n      clicked: false,\n      click: function(){\n        this.clicked = true;\n        assert(button.clicked,\"The button has been clicked\");\n      }\n    };\n    var elem = document.getElementById(\"test\");\n    elem.addEventListener(\"click\", button.click.bind(button));//使用bind函数创建新函数，绑定到button对象上\n\n    var boundFunction = button.click.bind(button);\n    assert(boundFunction !== button.click,\n           \"Calling bind creates a completyl new function\");\n```","source":"_posts/函数理解.md","raw":"---\ntitle: 函数理解\ndate: 2020-07-01 09:15:30\ntags:\n - JavaScript\n - 函数\ncategories: Web前端\n---\n\n## 隐式函数参数：arguments\n\narguments:不代表数组，允许我们访问传递给函数的所有参数。自带length属性。\narguments代表参数的别名，更改对象arguments的值会影响对应的函数参数。\narguments在strict模式下无法使用。arguments和参数值不互通（strict模式下）。\n\n## 函数上下文：this\nthis：面向对象编程的重要组成部分。\nthis通常指向定义当前方法的类的实例。\n函数有四种调用方式：\n```bash\n（function）：func()直接调用->此模式下调用，this为Windows对象（全局上下文），严格模式下为undefined\n（method）：ninja.func()关联对象，实现面向对象编程\n（constructor）：new ninja()实例化新对象\n（apply或call）：func.apply/call(ninja)\n```\n调用的方式不一样，返回的上下文也不一样\n作为函数被调用：\n```bash\nfunction ninja() {\n    return this;\n}\n\nfunction samurai() {\n   \"use strict\";//严格模式\n    return this;\n}\nninja();\nsamurai();\n```\n作为方法被调用：\n```bash\nfunction whatsMyContext() {\n      return this;\n    }\n\nassert(whatsMyContext() === window,\n  \"Function call on window\");\n\nvar getMyThis = whatsMyContext;\n\nassert(getMyThis() === window,\n  \"Another function call in window\");\n\nvar ninja1 = {\n   getMyThis: whatsMyContext\n};\n\nassert(ninja1.getMyThis() === ninja1,\n   \"Working with 1st ninja\");//getMyThis作为ninja对象的属性方法调用\n```\n作为构造函数调用：//初始化和实例对象\n```bash\nfunction Ninja() {\n   this.skulk = function() {\n   return this;\n   };\n}\n\nvar ninja1 = new Ninja();//创建一个新的空对象，该对象作为this参数传递给构造函数\nvar ninja2 = new Ninja();//新构造的对象作为new运算符的返回值\n\nassert(ninja1.skulk() === ninja1,\n   \"The 1st ninja is skulking\");\nassert(ninja2.skulk() === ninja2,\n   \"The 2nd ninja is skulking\");\n```\n返回原始值的构造函数：\n```bash\nfunction Ninja() {\n    this.skulk = function () {\n      return true;\n    };\n\n    return 1;\n  }\n  assert(Ninja() === 1,//作为函数调用返回值是1\n    \"Return value honored when not called as a constructor\");\n\n  var ninja = new Ninja();//作为构造函数调用，返回值是一个对象\n\n  assert(typeof ninja === \"object\",\n    \"Object returned when called as a constructor\");\n  assert(typeof ninja.skulk === \"function\",\n    \"ninja object has a skulk method\");\n```\n使用apply和call方法：\n```bash\nfunction juggle() {\n      var result = 0;\n      for (var n = 0; n < arguments.length; n++) {\n        result += arguments[n];\n      }\n      this.result = result;\n    }\n\n    var ninja1 = {};\n    var ninja2 = {};\n\n    juggle.apply(ninja1,[1,2,3,4]);//this：ninja1 传入一个this和一系列参数\n    juggle.call(ninja2, 5,6,7,8);//this：ninja2 传入一个this和一系列参数\n\n    assert(ninja1.result === 10, \"juggled via apply\");\n    assert(ninja2.result === 26, \"juggled via call\");\n```\n使用forEach迭代方法可以将函数的上下文设置为任意的对象\n箭头函数没有单独的this值，其this值与箭头函数的上下文相同\n\n使用bind方法：\n```bash\n    var button = {\n      clicked: false,\n      click: function(){\n        this.clicked = true;\n        assert(button.clicked,\"The button has been clicked\");\n      }\n    };\n    var elem = document.getElementById(\"test\");\n    elem.addEventListener(\"click\", button.click.bind(button));//使用bind函数创建新函数，绑定到button对象上\n\n    var boundFunction = button.click.bind(button);\n    assert(boundFunction !== button.click,\n           \"Calling bind creates a completyl new function\");\n```","slug":"函数理解","published":1,"updated":"2020-07-07T03:20:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37h0025pcva2hmbeoo7","content":"<h2 id=\"隐式函数参数：arguments\"><a href=\"#隐式函数参数：arguments\" class=\"headerlink\" title=\"隐式函数参数：arguments\"></a>隐式函数参数：arguments</h2><p>arguments:不代表数组，允许我们访问传递给函数的所有参数。自带length属性。<br>arguments代表参数的别名，更改对象arguments的值会影响对应的函数参数。<br>arguments在strict模式下无法使用。arguments和参数值不互通（strict模式下）。</p>\n<h2 id=\"函数上下文：this\"><a href=\"#函数上下文：this\" class=\"headerlink\" title=\"函数上下文：this\"></a>函数上下文：this</h2><p>this：面向对象编程的重要组成部分。<br>this通常指向定义当前方法的类的实例。<br>函数有四种调用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（<span class=\"keyword\">function</span>）：func()直接调用-&gt;此模式下调用，this为Windows对象（全局上下文），严格模式下为undefined</span><br><span class=\"line\">（method）：ninja.func()关联对象，实现面向对象编程</span><br><span class=\"line\">（constructor）：new ninja()实例化新对象</span><br><span class=\"line\">（apply或call）：func.apply/call(ninja)</span><br></pre></td></tr></table></figure>\n<p>调用的方式不一样，返回的上下文也不一样<br>作为函数被调用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">ninja</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">samurai</span></span>() &#123;</span><br><span class=\"line\">   <span class=\"string\">\"use strict\"</span>;//严格模式</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ninja();</span><br><span class=\"line\">samurai();</span><br></pre></td></tr></table></figure>\n<p>作为方法被调用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">whatsMyContext</span></span>() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(whatsMyContext() === window,</span><br><span class=\"line\">  <span class=\"string\">\"Function call on window\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">var getMyThis = whatsMyContext;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(getMyThis() === window,</span><br><span class=\"line\">  <span class=\"string\">\"Another function call in window\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">var ninja1 = &#123;</span><br><span class=\"line\">   getMyThis: whatsMyContext</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(ninja1.getMyThis() === ninja1,</span><br><span class=\"line\">   <span class=\"string\">\"Working with 1st ninja\"</span>);//getMyThis作为ninja对象的属性方法调用</span><br></pre></td></tr></table></figure>\n<p>作为构造函数调用：//初始化和实例对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Ninja</span></span>() &#123;</span><br><span class=\"line\">   this.skulk = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ninja1 = new Ninja();//创建一个新的空对象，该对象作为this参数传递给构造函数</span><br><span class=\"line\">var ninja2 = new Ninja();//新构造的对象作为new运算符的返回值</span><br><span class=\"line\"></span><br><span class=\"line\">assert(ninja1.skulk() === ninja1,</span><br><span class=\"line\">   <span class=\"string\">\"The 1st ninja is skulking\"</span>);</span><br><span class=\"line\">assert(ninja2.skulk() === ninja2,</span><br><span class=\"line\">   <span class=\"string\">\"The 2nd ninja is skulking\"</span>);</span><br></pre></td></tr></table></figure>\n<p>返回原始值的构造函数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Ninja</span></span>() &#123;</span><br><span class=\"line\">    this.skulk = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  assert(Ninja() === 1,//作为函数调用返回值是1</span><br><span class=\"line\">    <span class=\"string\">\"Return value honored when not called as a constructor\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  var ninja = new Ninja();//作为构造函数调用，返回值是一个对象</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(typeof ninja === <span class=\"string\">\"object\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Object returned when called as a constructor\"</span>);</span><br><span class=\"line\">  assert(typeof ninja.skulk === <span class=\"string\">\"function\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"ninja object has a skulk method\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用apply和call方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">juggle</span></span>() &#123;</span><br><span class=\"line\">      var result = 0;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (var n = 0; n &lt; arguments.length; n++) &#123;</span><br><span class=\"line\">        result += arguments[n];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.result = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var ninja1 = &#123;&#125;;</span><br><span class=\"line\">    var ninja2 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    juggle.apply(ninja1,[1,2,3,4]);//this：ninja1 传入一个this和一系列参数</span><br><span class=\"line\">    juggle.call(ninja2, 5,6,7,8);//this：ninja2 传入一个this和一系列参数</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(ninja1.result === 10, <span class=\"string\">\"juggled via apply\"</span>);</span><br><span class=\"line\">    assert(ninja2.result === 26, <span class=\"string\">\"juggled via call\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用forEach迭代方法可以将函数的上下文设置为任意的对象<br>箭头函数没有单独的this值，其this值与箭头函数的上下文相同</p>\n<p>使用bind方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var button = &#123;</span><br><span class=\"line\">  clicked: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  click: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">    this.clicked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    assert(button.clicked,<span class=\"string\">\"The button has been clicked\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var elem = document.getElementById(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">elem.addEventListener(<span class=\"string\">\"click\"</span>, button.click.bind(button));//使用<span class=\"built_in\">bind</span>函数创建新函数，绑定到button对象上</span><br><span class=\"line\"></span><br><span class=\"line\">var boundFunction = button.click.bind(button);</span><br><span class=\"line\">assert(boundFunction !== button.click,</span><br><span class=\"line\">       <span class=\"string\">\"Calling bind creates a completyl new function\"</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"隐式函数参数：arguments\"><a href=\"#隐式函数参数：arguments\" class=\"headerlink\" title=\"隐式函数参数：arguments\"></a>隐式函数参数：arguments</h2><p>arguments:不代表数组，允许我们访问传递给函数的所有参数。自带length属性。<br>arguments代表参数的别名，更改对象arguments的值会影响对应的函数参数。<br>arguments在strict模式下无法使用。arguments和参数值不互通（strict模式下）。</p>\n<h2 id=\"函数上下文：this\"><a href=\"#函数上下文：this\" class=\"headerlink\" title=\"函数上下文：this\"></a>函数上下文：this</h2><p>this：面向对象编程的重要组成部分。<br>this通常指向定义当前方法的类的实例。<br>函数有四种调用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（<span class=\"keyword\">function</span>）：func()直接调用-&gt;此模式下调用，this为Windows对象（全局上下文），严格模式下为undefined</span><br><span class=\"line\">（method）：ninja.func()关联对象，实现面向对象编程</span><br><span class=\"line\">（constructor）：new ninja()实例化新对象</span><br><span class=\"line\">（apply或call）：func.apply/call(ninja)</span><br></pre></td></tr></table></figure>\n<p>调用的方式不一样，返回的上下文也不一样<br>作为函数被调用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">ninja</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">samurai</span></span>() &#123;</span><br><span class=\"line\">   <span class=\"string\">\"use strict\"</span>;//严格模式</span><br><span class=\"line\">    <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ninja();</span><br><span class=\"line\">samurai();</span><br></pre></td></tr></table></figure>\n<p>作为方法被调用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">whatsMyContext</span></span>() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(whatsMyContext() === window,</span><br><span class=\"line\">  <span class=\"string\">\"Function call on window\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">var getMyThis = whatsMyContext;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(getMyThis() === window,</span><br><span class=\"line\">  <span class=\"string\">\"Another function call in window\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">var ninja1 = &#123;</span><br><span class=\"line\">   getMyThis: whatsMyContext</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">assert(ninja1.getMyThis() === ninja1,</span><br><span class=\"line\">   <span class=\"string\">\"Working with 1st ninja\"</span>);//getMyThis作为ninja对象的属性方法调用</span><br></pre></td></tr></table></figure>\n<p>作为构造函数调用：//初始化和实例对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Ninja</span></span>() &#123;</span><br><span class=\"line\">   this.skulk = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">   <span class=\"built_in\">return</span> this;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ninja1 = new Ninja();//创建一个新的空对象，该对象作为this参数传递给构造函数</span><br><span class=\"line\">var ninja2 = new Ninja();//新构造的对象作为new运算符的返回值</span><br><span class=\"line\"></span><br><span class=\"line\">assert(ninja1.skulk() === ninja1,</span><br><span class=\"line\">   <span class=\"string\">\"The 1st ninja is skulking\"</span>);</span><br><span class=\"line\">assert(ninja2.skulk() === ninja2,</span><br><span class=\"line\">   <span class=\"string\">\"The 2nd ninja is skulking\"</span>);</span><br></pre></td></tr></table></figure>\n<p>返回原始值的构造函数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Ninja</span></span>() &#123;</span><br><span class=\"line\">    this.skulk = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  assert(Ninja() === 1,//作为函数调用返回值是1</span><br><span class=\"line\">    <span class=\"string\">\"Return value honored when not called as a constructor\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  var ninja = new Ninja();//作为构造函数调用，返回值是一个对象</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(typeof ninja === <span class=\"string\">\"object\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Object returned when called as a constructor\"</span>);</span><br><span class=\"line\">  assert(typeof ninja.skulk === <span class=\"string\">\"function\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"ninja object has a skulk method\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用apply和call方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">juggle</span></span>() &#123;</span><br><span class=\"line\">      var result = 0;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (var n = 0; n &lt; arguments.length; n++) &#123;</span><br><span class=\"line\">        result += arguments[n];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.result = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var ninja1 = &#123;&#125;;</span><br><span class=\"line\">    var ninja2 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    juggle.apply(ninja1,[1,2,3,4]);//this：ninja1 传入一个this和一系列参数</span><br><span class=\"line\">    juggle.call(ninja2, 5,6,7,8);//this：ninja2 传入一个this和一系列参数</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(ninja1.result === 10, <span class=\"string\">\"juggled via apply\"</span>);</span><br><span class=\"line\">    assert(ninja2.result === 26, <span class=\"string\">\"juggled via call\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用forEach迭代方法可以将函数的上下文设置为任意的对象<br>箭头函数没有单独的this值，其this值与箭头函数的上下文相同</p>\n<p>使用bind方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var button = &#123;</span><br><span class=\"line\">  clicked: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  click: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">    this.clicked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    assert(button.clicked,<span class=\"string\">\"The button has been clicked\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var elem = document.getElementById(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">elem.addEventListener(<span class=\"string\">\"click\"</span>, button.click.bind(button));//使用<span class=\"built_in\">bind</span>函数创建新函数，绑定到button对象上</span><br><span class=\"line\"></span><br><span class=\"line\">var boundFunction = button.click.bind(button);</span><br><span class=\"line\">assert(boundFunction !== button.click,</span><br><span class=\"line\">       <span class=\"string\">\"Calling bind creates a completyl new function\"</span>);</span><br></pre></td></tr></table></figure>"},{"title":"单页面和多页面","date":"2021-01-21T01:38:11.000Z","_content":"单页面应用(SPA):只有一个主页面的应用，单页面跳转，仅刷新局部资源。多应用于PC端。\n多页面应用(MPA):就是指一个应用中有多个页面，页面跳转时是整页刷新，公共资源等选择性重新加载。\n单页面的优点：\n资源共用，页面局部刷新，切换速度快，用户体验良好。\n数据传递容易，维护成本较低。开发成本较高，需要借助框架。\n缺点：不利于SEO优化，可利用SSR优化。\n\n多页面优点：搜索引擎优化简易，开发成本较低，但重复代码多。\n缺点：公共资源不共用，页面切换加载慢，流畅度不够。无法实现跳转动画，\n依赖url，cookie，localstorage传参。维护成本较高。\n\n单页面适用场景：高要求的体验度、追求界面流畅的应用。\n多页面的适用场景：适用于追求高度支持搜索引擎的应用。","source":"_posts/单页面和多页面.md","raw":"---\ntitle: 单页面和多页面\ndate: 2021-01-21 09:38:11\ntags:\n - 单页面与多页面应用\ncategories: 业务\n---\n单页面应用(SPA):只有一个主页面的应用，单页面跳转，仅刷新局部资源。多应用于PC端。\n多页面应用(MPA):就是指一个应用中有多个页面，页面跳转时是整页刷新，公共资源等选择性重新加载。\n单页面的优点：\n资源共用，页面局部刷新，切换速度快，用户体验良好。\n数据传递容易，维护成本较低。开发成本较高，需要借助框架。\n缺点：不利于SEO优化，可利用SSR优化。\n\n多页面优点：搜索引擎优化简易，开发成本较低，但重复代码多。\n缺点：公共资源不共用，页面切换加载慢，流畅度不够。无法实现跳转动画，\n依赖url，cookie，localstorage传参。维护成本较高。\n\n单页面适用场景：高要求的体验度、追求界面流畅的应用。\n多页面的适用场景：适用于追求高度支持搜索引擎的应用。","slug":"单页面和多页面","published":1,"updated":"2021-01-21T02:38:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37i002apcvag7ncejmd","content":"<p>单页面应用(SPA):只有一个主页面的应用，单页面跳转，仅刷新局部资源。多应用于PC端。<br>多页面应用(MPA):就是指一个应用中有多个页面，页面跳转时是整页刷新，公共资源等选择性重新加载。<br>单页面的优点：<br>资源共用，页面局部刷新，切换速度快，用户体验良好。<br>数据传递容易，维护成本较低。开发成本较高，需要借助框架。<br>缺点：不利于SEO优化，可利用SSR优化。</p>\n<p>多页面优点：搜索引擎优化简易，开发成本较低，但重复代码多。<br>缺点：公共资源不共用，页面切换加载慢，流畅度不够。无法实现跳转动画，<br>依赖url，cookie，localstorage传参。维护成本较高。</p>\n<p>单页面适用场景：高要求的体验度、追求界面流畅的应用。<br>多页面的适用场景：适用于追求高度支持搜索引擎的应用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>单页面应用(SPA):只有一个主页面的应用，单页面跳转，仅刷新局部资源。多应用于PC端。<br>多页面应用(MPA):就是指一个应用中有多个页面，页面跳转时是整页刷新，公共资源等选择性重新加载。<br>单页面的优点：<br>资源共用，页面局部刷新，切换速度快，用户体验良好。<br>数据传递容易，维护成本较低。开发成本较高，需要借助框架。<br>缺点：不利于SEO优化，可利用SSR优化。</p>\n<p>多页面优点：搜索引擎优化简易，开发成本较低，但重复代码多。<br>缺点：公共资源不共用，页面切换加载慢，流畅度不够。无法实现跳转动画，<br>依赖url，cookie，localstorage传参。维护成本较高。</p>\n<p>单页面适用场景：高要求的体验度、追求界面流畅的应用。<br>多页面的适用场景：适用于追求高度支持搜索引擎的应用。</p>\n"},{"title":"小程序开发经验","date":"2020-05-09T06:46:57.000Z","_content":"\n小程序开发经验记录!\n\n---\n## 2020/5/9 14:52 Write\n\n关键词：小程序\n\n需要安装Node.js,然后安装vue-cli\n用到VsCode，安装Vetur插件\n\n```bash\nvue init mpvue/mpvue-quickstart firstapp //创建小程序项目\n```\n（终端）用vue-cli创建项目，与React相似~\n\n```bash\ncd firstapp //进入刚创建的文件夹\nnpm install //安装依赖包\n然后可以跑起项目了\n小程序的上下文需要注意，源生的小程序this值！！！！\n```\n使用开发者工具添加项目，编译，可以看到效果\n写法与Vue相同，生命周期结合小程序的生命周期\n\n优点：组件化，易于维护，可以代码复用，减少开发成本。熟悉Vue的开发人员能很快上手。\n缺点：slot问题","source":"_posts/小程序开发经验.md","raw":"---\ntitle: 小程序开发经验\ndate: 2020-05-09 14:46:57\ntags:\n - Mpvue\n - 开发者工具\ncategories: 小程序开发\n---\n\n小程序开发经验记录!\n\n---\n## 2020/5/9 14:52 Write\n\n关键词：小程序\n\n需要安装Node.js,然后安装vue-cli\n用到VsCode，安装Vetur插件\n\n```bash\nvue init mpvue/mpvue-quickstart firstapp //创建小程序项目\n```\n（终端）用vue-cli创建项目，与React相似~\n\n```bash\ncd firstapp //进入刚创建的文件夹\nnpm install //安装依赖包\n然后可以跑起项目了\n小程序的上下文需要注意，源生的小程序this值！！！！\n```\n使用开发者工具添加项目，编译，可以看到效果\n写法与Vue相同，生命周期结合小程序的生命周期\n\n优点：组件化，易于维护，可以代码复用，减少开发成本。熟悉Vue的开发人员能很快上手。\n缺点：slot问题","slug":"小程序开发经验","published":1,"updated":"2020-06-05T08:09:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37j002bpcvabs0o7ckv","content":"<p>小程序开发经验记录!</p>\n<hr>\n<h2 id=\"2020-5-9-14-52-Write\"><a href=\"#2020-5-9-14-52-Write\" class=\"headerlink\" title=\"2020/5/9 14:52 Write\"></a>2020/5/9 14:52 Write</h2><p>关键词：小程序</p>\n<p>需要安装Node.js,然后安装vue-cli<br>用到VsCode，安装Vetur插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init mpvue/mpvue-quickstart firstapp //创建小程序项目</span><br></pre></td></tr></table></figure>\n<p>（终端）用vue-cli创建项目，与React相似~</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> firstapp //进入刚创建的文件夹</span><br><span class=\"line\">npm install //安装依赖包</span><br><span class=\"line\">然后可以跑起项目了</span><br><span class=\"line\">小程序的上下文需要注意，源生的小程序this值！！！！</span><br></pre></td></tr></table></figure>\n<p>使用开发者工具添加项目，编译，可以看到效果<br>写法与Vue相同，生命周期结合小程序的生命周期</p>\n<p>优点：组件化，易于维护，可以代码复用，减少开发成本。熟悉Vue的开发人员能很快上手。<br>缺点：slot问题</p>\n","site":{"data":{}},"excerpt":"","more":"<p>小程序开发经验记录!</p>\n<hr>\n<h2 id=\"2020-5-9-14-52-Write\"><a href=\"#2020-5-9-14-52-Write\" class=\"headerlink\" title=\"2020/5/9 14:52 Write\"></a>2020/5/9 14:52 Write</h2><p>关键词：小程序</p>\n<p>需要安装Node.js,然后安装vue-cli<br>用到VsCode，安装Vetur插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init mpvue/mpvue-quickstart firstapp //创建小程序项目</span><br></pre></td></tr></table></figure>\n<p>（终端）用vue-cli创建项目，与React相似~</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> firstapp //进入刚创建的文件夹</span><br><span class=\"line\">npm install //安装依赖包</span><br><span class=\"line\">然后可以跑起项目了</span><br><span class=\"line\">小程序的上下文需要注意，源生的小程序this值！！！！</span><br></pre></td></tr></table></figure>\n<p>使用开发者工具添加项目，编译，可以看到效果<br>写法与Vue相同，生命周期结合小程序的生命周期</p>\n<p>优点：组件化，易于维护，可以代码复用，减少开发成本。熟悉Vue的开发人员能很快上手。<br>缺点：slot问题</p>\n"},{"title":"工作注意事项","date":"2020-09-11T02:53:39.000Z","_content":"## 项目流程：\n项目路线图->\n项目评估确认阶段\n项目立项\n需求开发\n设计阶段\n研发及生产\n测试及缺陷修复\n生产环境实施部署\n系统验收\n项目结项\n~~~以上为项目完整流程。\n---\n前端工作流程：\n立项--项目研讨--需求确认--产品出原型--后台开发，UI设计--前端开发--测试提bug--改bug--重复N次--产品验收\n\n注意工作内容，个人职责，只负责职责相关部分。\n需要讨论好工作分配。在职责范围内，与UI（页面），产品（功能），项目（需求）进行沟通完成后进行开发。\n需要注意以下几点：\n1.深刻理解需求，清楚需求的动机和缘由。\n2.换位思考\n3.不放过细节\n4.换一种方式说“不能实现”\n5.当遇到不合理的需求时，寻找替换方案\n6.必须遵循文档精神\n7.对自己的程序有一颗艺术的心\n\n归根结底：解决问题！！！！\n责任划分要清晰：口头确认---发email到责任人确认---通知上级\n\n\n","source":"_posts/工作注意事项.md","raw":"---\ntitle: 工作注意事项\ndate: 2020-09-11 10:53:39\ntags:\n - 工作职责\ncategories: 工作注意事项\n---\n## 项目流程：\n项目路线图->\n项目评估确认阶段\n项目立项\n需求开发\n设计阶段\n研发及生产\n测试及缺陷修复\n生产环境实施部署\n系统验收\n项目结项\n~~~以上为项目完整流程。\n---\n前端工作流程：\n立项--项目研讨--需求确认--产品出原型--后台开发，UI设计--前端开发--测试提bug--改bug--重复N次--产品验收\n\n注意工作内容，个人职责，只负责职责相关部分。\n需要讨论好工作分配。在职责范围内，与UI（页面），产品（功能），项目（需求）进行沟通完成后进行开发。\n需要注意以下几点：\n1.深刻理解需求，清楚需求的动机和缘由。\n2.换位思考\n3.不放过细节\n4.换一种方式说“不能实现”\n5.当遇到不合理的需求时，寻找替换方案\n6.必须遵循文档精神\n7.对自己的程序有一颗艺术的心\n\n归根结底：解决问题！！！！\n责任划分要清晰：口头确认---发email到责任人确认---通知上级\n\n\n","slug":"工作注意事项","published":1,"updated":"2020-09-11T03:40:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37k002fpcva3king599","content":"<h2 id=\"项目流程：\"><a href=\"#项目流程：\" class=\"headerlink\" title=\"项目流程：\"></a>项目流程：</h2><p>项目路线图-&gt;<br>项目评估确认阶段<br>项目立项<br>需求开发<br>设计阶段<br>研发及生产<br>测试及缺陷修复<br>生产环境实施部署<br>系统验收<br>项目结项</p>\n<pre><code class=\"以上为项目完整流程。\">---\n前端工作流程：\n立项--项目研讨--需求确认--产品出原型--后台开发，UI设计--前端开发--测试提bug--改bug--重复N次--产品验收\n\n注意工作内容，个人职责，只负责职责相关部分。\n需要讨论好工作分配。在职责范围内，与UI（页面），产品（功能），项目（需求）进行沟通完成后进行开发。\n需要注意以下几点：\n1.深刻理解需求，清楚需求的动机和缘由。\n2.换位思考\n3.不放过细节\n4.换一种方式说“不能实现”\n5.当遇到不合理的需求时，寻找替换方案\n6.必须遵循文档精神\n7.对自己的程序有一颗艺术的心\n\n归根结底：解决问题！！！！\n责任划分要清晰：口头确认---发email到责任人确认---通知上级\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"项目流程：\"><a href=\"#项目流程：\" class=\"headerlink\" title=\"项目流程：\"></a>项目流程：</h2><p>项目路线图-&gt;<br>项目评估确认阶段<br>项目立项<br>需求开发<br>设计阶段<br>研发及生产<br>测试及缺陷修复<br>生产环境实施部署<br>系统验收<br>项目结项</p>\n<pre><code class=\"以上为项目完整流程。\">---\n前端工作流程：\n立项--项目研讨--需求确认--产品出原型--后台开发，UI设计--前端开发--测试提bug--改bug--重复N次--产品验收\n\n注意工作内容，个人职责，只负责职责相关部分。\n需要讨论好工作分配。在职责范围内，与UI（页面），产品（功能），项目（需求）进行沟通完成后进行开发。\n需要注意以下几点：\n1.深刻理解需求，清楚需求的动机和缘由。\n2.换位思考\n3.不放过细节\n4.换一种方式说“不能实现”\n5.当遇到不合理的需求时，寻找替换方案\n6.必须遵循文档精神\n7.对自己的程序有一颗艺术的心\n\n归根结底：解决问题！！！！\n责任划分要清晰：口头确认---发email到责任人确认---通知上级\n\n</code></pre>\n"},{"title":"正则表达式","date":"2020-05-11T06:46:37.000Z","_content":"\n匹配搜索和验证\n\n---\n\n## 2020/5/11 14:48 Write\n\n关键词：JS\n\n### 常规\n\n```bash\n^ 匹配一个输入或一行的开头，/^a/匹配\"an A\"，而不匹配\"An a\"\n$ 匹配一个输入或一行的结尾，/a$/匹配\"An a\"，而不匹配\"an A\"\n* 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa\n+ 匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa\n? 匹配前面元字符0次或1次，/ba*/将匹配b,ba\n(x) 匹配x保存x在名为$1...$9的变量中\nx|y 匹配x或y\n{n} 精确匹配n次\n{n,} 匹配n次以上\n{n,m} 匹配n-m次\n[xyz] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)\n[^xyz] 不匹配这个集合中的任何一个字符\n[\\b] 匹配一个退格符\n\\b 匹配一个单词的边界\n\\B 匹配一个单词的非边界\n\\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M\n\\d 匹配一个字数字符，/\\d/ = /[0-9]/\n\\D 匹配一个非字数字符，/\\D/ = /[^0-9]/\n\\n 匹配一个换行符\n\\r 匹配一个回车符\n\\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等\n\\S 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/\n\\t 匹配一个制表符\n\\v 匹配一个重直制表符\n\\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配\"$5.98\"中的5，等于[a-zA-Z0-9]\n\\W 匹配一个不可以组成单词的字符，如[\\W]匹配\"$5.98\"中的$，等于[^a-zA-Z0-9]\n```\n### 特殊需求：\n```bash\nEmail地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n\n域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\n\nInternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n\n手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n\n电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n\n国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n\n身份证号(15位、18位数字)：^\\d{15}|\\d{18}$\n\n短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\n\n日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\n```","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2020-05-11 14:46:37\ntags:\n - JavaScript\n - 正则表达式\ncategories: Web前端\n---\n\n匹配搜索和验证\n\n---\n\n## 2020/5/11 14:48 Write\n\n关键词：JS\n\n### 常规\n\n```bash\n^ 匹配一个输入或一行的开头，/^a/匹配\"an A\"，而不匹配\"An a\"\n$ 匹配一个输入或一行的结尾，/a$/匹配\"An a\"，而不匹配\"an A\"\n* 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa\n+ 匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa\n? 匹配前面元字符0次或1次，/ba*/将匹配b,ba\n(x) 匹配x保存x在名为$1...$9的变量中\nx|y 匹配x或y\n{n} 精确匹配n次\n{n,} 匹配n次以上\n{n,m} 匹配n-m次\n[xyz] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)\n[^xyz] 不匹配这个集合中的任何一个字符\n[\\b] 匹配一个退格符\n\\b 匹配一个单词的边界\n\\B 匹配一个单词的非边界\n\\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M\n\\d 匹配一个字数字符，/\\d/ = /[0-9]/\n\\D 匹配一个非字数字符，/\\D/ = /[^0-9]/\n\\n 匹配一个换行符\n\\r 匹配一个回车符\n\\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等\n\\S 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/\n\\t 匹配一个制表符\n\\v 匹配一个重直制表符\n\\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配\"$5.98\"中的5，等于[a-zA-Z0-9]\n\\W 匹配一个不可以组成单词的字符，如[\\W]匹配\"$5.98\"中的$，等于[^a-zA-Z0-9]\n```\n### 特殊需求：\n```bash\nEmail地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n\n域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\n\nInternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n\n手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n\n电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n\n国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n\n身份证号(15位、18位数字)：^\\d{15}|\\d{18}$\n\n短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\n\n日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\n```","slug":"正则表达式","published":1,"updated":"2020-05-11T09:43:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37m002ipcvahg0gb0u1","content":"<p>匹配搜索和验证</p>\n<hr>\n<h2 id=\"2020-5-11-14-48-Write\"><a href=\"#2020-5-11-14-48-Write\" class=\"headerlink\" title=\"2020/5/11 14:48 Write\"></a>2020/5/11 14:48 Write</h2><p>关键词：JS</p>\n<h3 id=\"常规\"><a href=\"#常规\" class=\"headerlink\" title=\"常规\"></a>常规</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^ 匹配一个输入或一行的开头，/^a/匹配<span class=\"string\">\"an A\"</span>，而不匹配<span class=\"string\">\"An a\"</span></span><br><span class=\"line\">$ 匹配一个输入或一行的结尾，/a$/匹配<span class=\"string\">\"An a\"</span>，而不匹配<span class=\"string\">\"an A\"</span></span><br><span class=\"line\">* 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa</span><br><span class=\"line\">+ 匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa</span><br><span class=\"line\">? 匹配前面元字符0次或1次，/ba*/将匹配b,ba</span><br><span class=\"line\">(x) 匹配x保存x在名为<span class=\"variable\">$1</span>...<span class=\"variable\">$9</span>的变量中</span><br><span class=\"line\">x|y 匹配x或y</span><br><span class=\"line\">&#123;n&#125; 精确匹配n次</span><br><span class=\"line\">&#123;n,&#125; 匹配n次以上</span><br><span class=\"line\">&#123;n,m&#125; 匹配n-m次</span><br><span class=\"line\">[xyz] 字符集(character <span class=\"built_in\">set</span>)，匹配这个集合中的任一一个字符(或元字符)</span><br><span class=\"line\">[^xyz] 不匹配这个集合中的任何一个字符</span><br><span class=\"line\">[\\b] 匹配一个退格符</span><br><span class=\"line\">\\b 匹配一个单词的边界</span><br><span class=\"line\">\\B 匹配一个单词的非边界</span><br><span class=\"line\">\\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M</span><br><span class=\"line\">\\d 匹配一个字数字符，/\\d/ = /[0-9]/</span><br><span class=\"line\">\\D 匹配一个非字数字符，/\\D/ = /[^0-9]/</span><br><span class=\"line\">\\n 匹配一个换行符</span><br><span class=\"line\">\\r 匹配一个回车符</span><br><span class=\"line\">\\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等</span><br><span class=\"line\">\\S 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/</span><br><span class=\"line\">\\t 匹配一个制表符</span><br><span class=\"line\">\\v 匹配一个重直制表符</span><br><span class=\"line\">\\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配<span class=\"string\">\"<span class=\"variable\">$5</span>.98\"</span>中的5，等于[a-zA-Z0-9]</span><br><span class=\"line\">\\W 匹配一个不可以组成单词的字符，如[\\W]匹配<span class=\"string\">\"<span class=\"variable\">$5</span>.98\"</span>中的$，等于[^a-zA-Z0-9]</span><br></pre></td></tr></table></figure>\n<h3 id=\"特殊需求：\"><a href=\"#特殊需求：\" class=\"headerlink\" title=\"特殊需求：\"></a>特殊需求：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$</span><br><span class=\"line\"></span><br><span class=\"line\">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class=\"line\"></span><br><span class=\"line\">InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$</span><br><span class=\"line\"></span><br><span class=\"line\">手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$</span><br><span class=\"line\"></span><br><span class=\"line\">电话号码(<span class=\"string\">\"XXX-XXXXXXX\"</span>、<span class=\"string\">\"XXXX-XXXXXXXX\"</span>、<span class=\"string\">\"XXX-XXXXXXX\"</span>、<span class=\"string\">\"XXX-XXXXXXXX\"</span>、<span class=\"string\">\"XXXXXXX\"</span>和<span class=\"string\">\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>匹配搜索和验证</p>\n<hr>\n<h2 id=\"2020-5-11-14-48-Write\"><a href=\"#2020-5-11-14-48-Write\" class=\"headerlink\" title=\"2020/5/11 14:48 Write\"></a>2020/5/11 14:48 Write</h2><p>关键词：JS</p>\n<h3 id=\"常规\"><a href=\"#常规\" class=\"headerlink\" title=\"常规\"></a>常规</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^ 匹配一个输入或一行的开头，/^a/匹配<span class=\"string\">\"an A\"</span>，而不匹配<span class=\"string\">\"An a\"</span></span><br><span class=\"line\">$ 匹配一个输入或一行的结尾，/a$/匹配<span class=\"string\">\"An a\"</span>，而不匹配<span class=\"string\">\"an A\"</span></span><br><span class=\"line\">* 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa</span><br><span class=\"line\">+ 匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa</span><br><span class=\"line\">? 匹配前面元字符0次或1次，/ba*/将匹配b,ba</span><br><span class=\"line\">(x) 匹配x保存x在名为<span class=\"variable\">$1</span>...<span class=\"variable\">$9</span>的变量中</span><br><span class=\"line\">x|y 匹配x或y</span><br><span class=\"line\">&#123;n&#125; 精确匹配n次</span><br><span class=\"line\">&#123;n,&#125; 匹配n次以上</span><br><span class=\"line\">&#123;n,m&#125; 匹配n-m次</span><br><span class=\"line\">[xyz] 字符集(character <span class=\"built_in\">set</span>)，匹配这个集合中的任一一个字符(或元字符)</span><br><span class=\"line\">[^xyz] 不匹配这个集合中的任何一个字符</span><br><span class=\"line\">[\\b] 匹配一个退格符</span><br><span class=\"line\">\\b 匹配一个单词的边界</span><br><span class=\"line\">\\B 匹配一个单词的非边界</span><br><span class=\"line\">\\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M</span><br><span class=\"line\">\\d 匹配一个字数字符，/\\d/ = /[0-9]/</span><br><span class=\"line\">\\D 匹配一个非字数字符，/\\D/ = /[^0-9]/</span><br><span class=\"line\">\\n 匹配一个换行符</span><br><span class=\"line\">\\r 匹配一个回车符</span><br><span class=\"line\">\\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等</span><br><span class=\"line\">\\S 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/</span><br><span class=\"line\">\\t 匹配一个制表符</span><br><span class=\"line\">\\v 匹配一个重直制表符</span><br><span class=\"line\">\\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配<span class=\"string\">\"<span class=\"variable\">$5</span>.98\"</span>中的5，等于[a-zA-Z0-9]</span><br><span class=\"line\">\\W 匹配一个不可以组成单词的字符，如[\\W]匹配<span class=\"string\">\"<span class=\"variable\">$5</span>.98\"</span>中的$，等于[^a-zA-Z0-9]</span><br></pre></td></tr></table></figure>\n<h3 id=\"特殊需求：\"><a href=\"#特殊需求：\" class=\"headerlink\" title=\"特殊需求：\"></a>特殊需求：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$</span><br><span class=\"line\"></span><br><span class=\"line\">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class=\"line\"></span><br><span class=\"line\">InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$</span><br><span class=\"line\"></span><br><span class=\"line\">手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$</span><br><span class=\"line\"></span><br><span class=\"line\">电话号码(<span class=\"string\">\"XXX-XXXXXXX\"</span>、<span class=\"string\">\"XXXX-XXXXXXXX\"</span>、<span class=\"string\">\"XXX-XXXXXXX\"</span>、<span class=\"string\">\"XXX-XXXXXXXX\"</span>、<span class=\"string\">\"XXXXXXX\"</span>和<span class=\"string\">\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span></span><br></pre></td></tr></table></figure>"},{"title":"根据测试文档测试","date":"2020-05-18T07:29:40.000Z","_content":"\n## 根据对应的文档对功能进行操作测试\n\n### 得出相对应的问题，然后解决。\n\n```bash\n查询数据的重置问题\n联动数据的查询条件字段的重置问题\n删除数据时影响到的页数问题\n正则验证考虑全面的问题\n考虑功能操作的合理性\n```\n\n```bash\n测试步骤：\n根据文档中的测试用例进行测试\n编写并产生测试记录表，并且需要上传到SVN文件夹当中\n在RedMine上登记缺陷，并确定该缺陷的优先级\n```","source":"_posts/根据测试文档测试.md","raw":"---\ntitle: 根据测试文档测试\ndate: 2020-05-18 15:29:40\ntags:\n - 测试\ncategories: 测试\n---\n\n## 根据对应的文档对功能进行操作测试\n\n### 得出相对应的问题，然后解决。\n\n```bash\n查询数据的重置问题\n联动数据的查询条件字段的重置问题\n删除数据时影响到的页数问题\n正则验证考虑全面的问题\n考虑功能操作的合理性\n```\n\n```bash\n测试步骤：\n根据文档中的测试用例进行测试\n编写并产生测试记录表，并且需要上传到SVN文件夹当中\n在RedMine上登记缺陷，并确定该缺陷的优先级\n```","slug":"根据测试文档测试","published":1,"updated":"2020-05-25T02:59:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37n002mpcva6x6j7oph","content":"<h2 id=\"根据对应的文档对功能进行操作测试\"><a href=\"#根据对应的文档对功能进行操作测试\" class=\"headerlink\" title=\"根据对应的文档对功能进行操作测试\"></a>根据对应的文档对功能进行操作测试</h2><h3 id=\"得出相对应的问题，然后解决。\"><a href=\"#得出相对应的问题，然后解决。\" class=\"headerlink\" title=\"得出相对应的问题，然后解决。\"></a>得出相对应的问题，然后解决。</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询数据的重置问题</span><br><span class=\"line\">联动数据的查询条件字段的重置问题</span><br><span class=\"line\">删除数据时影响到的页数问题</span><br><span class=\"line\">正则验证考虑全面的问题</span><br><span class=\"line\">考虑功能操作的合理性</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">测试步骤：</span><br><span class=\"line\">根据文档中的测试用例进行测试</span><br><span class=\"line\">编写并产生测试记录表，并且需要上传到SVN文件夹当中</span><br><span class=\"line\">在RedMine上登记缺陷，并确定该缺陷的优先级</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"根据对应的文档对功能进行操作测试\"><a href=\"#根据对应的文档对功能进行操作测试\" class=\"headerlink\" title=\"根据对应的文档对功能进行操作测试\"></a>根据对应的文档对功能进行操作测试</h2><h3 id=\"得出相对应的问题，然后解决。\"><a href=\"#得出相对应的问题，然后解决。\" class=\"headerlink\" title=\"得出相对应的问题，然后解决。\"></a>得出相对应的问题，然后解决。</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询数据的重置问题</span><br><span class=\"line\">联动数据的查询条件字段的重置问题</span><br><span class=\"line\">删除数据时影响到的页数问题</span><br><span class=\"line\">正则验证考虑全面的问题</span><br><span class=\"line\">考虑功能操作的合理性</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">测试步骤：</span><br><span class=\"line\">根据文档中的测试用例进行测试</span><br><span class=\"line\">编写并产生测试记录表，并且需要上传到SVN文件夹当中</span><br><span class=\"line\">在RedMine上登记缺陷，并确定该缺陷的优先级</span><br></pre></td></tr></table></figure>"},{"title":"清除浮动的方法","date":"2020-05-11T08:55:12.000Z","_content":"\n页面UI设计与开发\n\n---\n\n## 2020/5/11 16:56 Write\n\n关键词：浮动\n\n在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。\n这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n</div>\n```\n![浮动溢出](浮动溢出.jpg)\n\n---\n\n清除浮动的方法\n\n### 方法一：使用带clear属性的空元素\n在浮动元素后使用一个空元素如{div class=\"clear\"></div}，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用{br class=\"clear\" /}或{hr class=\"clear\" /}来进行清理。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n.clear {\n  clear: both;\n  }\n\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n<div class=\"clear\"></div>\n</div>\n```\n优点：简单，代码少，浏览器兼容性好。\n缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。\n---\n\n### 方法二：使用CSS的overflow属性\n\n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  overflow: hidden;\n  *zoom: 1;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n</div>\n```\n---\n\n### 方法三：给浮动的元素的容器添加浮动\n\n给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。\n\n---\n\n### 方法四：使用邻接元素处理\n\n什么都不做，给浮动元素后面的元素添加clear属性。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n.content{\n  clear:both;\n  }\n\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n<div class=\"content\">***</div>\n</div>\n```\n注意这里的div.content有内容\n\n---\n\n### 方法五：使用CSS的:after伪元素\n\n结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。\n给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n.clearfix:after{\n  content: \"020\"; \n  display: block; \n  height: 0; \n  clear: both; \n  visibility: hidden;  \n  }\n\n.clearfix {\n  /* 触发 hasLayout */ \n  zoom: 1; \n  }\n```\n通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格\"020\"或点\".\"，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。\n\n---\n\n### 总结\n\n通过上面的例子，我们不难发现清除浮动的方法可以分成两类：\n\n一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。\n\n二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。\n\n在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。\n\n最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。","source":"_posts/清除浮动的方法.md","raw":"---\ntitle: 清除浮动的方法\ndate: 2020-05-11 16:55:12\ntags:\n - CSS\ncategories: UI设计开发\n---\n\n页面UI设计与开发\n\n---\n\n## 2020/5/11 16:56 Write\n\n关键词：浮动\n\n在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。\n这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n</div>\n```\n![浮动溢出](浮动溢出.jpg)\n\n---\n\n清除浮动的方法\n\n### 方法一：使用带clear属性的空元素\n在浮动元素后使用一个空元素如{div class=\"clear\"></div}，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用{br class=\"clear\" /}或{hr class=\"clear\" /}来进行清理。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n.clear {\n  clear: both;\n  }\n\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n<div class=\"clear\"></div>\n</div>\n```\n优点：简单，代码少，浏览器兼容性好。\n缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。\n---\n\n### 方法二：使用CSS的overflow属性\n\n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  overflow: hidden;\n  *zoom: 1;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n</div>\n```\n---\n\n### 方法三：给浮动的元素的容器添加浮动\n\n给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。\n\n---\n\n### 方法四：使用邻接元素处理\n\n什么都不做，给浮动元素后面的元素添加clear属性。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n.content{\n  clear:both;\n  }\n\n<div class=\"news\">\n<img src=\"news-pic.jpg\" />\n<p>some text</p>\n<div class=\"content\">***</div>\n</div>\n```\n注意这里的div.content有内容\n\n---\n\n### 方法五：使用CSS的:after伪元素\n\n结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。\n给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n\n```bash\n.news {\n  background-color: gray;\n  border: solid 1px black;\n  }\n\n.news img {\n  float: left;\n  }\n\n.news p {\n  float: right;\n  }\n\n.clearfix:after{\n  content: \"020\"; \n  display: block; \n  height: 0; \n  clear: both; \n  visibility: hidden;  \n  }\n\n.clearfix {\n  /* 触发 hasLayout */ \n  zoom: 1; \n  }\n```\n通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格\"020\"或点\".\"，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。\n\n---\n\n### 总结\n\n通过上面的例子，我们不难发现清除浮动的方法可以分成两类：\n\n一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。\n\n二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。\n\n在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。\n\n最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。","slug":"清除浮动的方法","published":1,"updated":"2020-05-11T09:43:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37o002ppcvaf9kr6g7x","content":"<p>页面UI设计与开发</p>\n<hr>\n<h2 id=\"2020-5-11-16-56-Write\"><a href=\"#2020-5-11-16-56-Write\" class=\"headerlink\" title=\"2020/5/11 16:56 Write\"></a>2020/5/11 16:56 Write</h2><p>关键词：浮动</p>\n<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。<br>这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/05/11/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/%E6%B5%AE%E5%8A%A8%E6%BA%A2%E5%87%BA.jpg\" alt=\"浮动溢出\"></p>\n<hr>\n<p>清除浮动的方法</p>\n<h3 id=\"方法一：使用带clear属性的空元素\"><a href=\"#方法一：使用带clear属性的空元素\" class=\"headerlink\" title=\"方法一：使用带clear属性的空元素\"></a>方法一：使用带clear属性的空元素</h3><p>在浮动元素后使用一个空元素如{div class=”clear”&gt;&lt;/div}，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用{br class=”clear” /}或{hr class=”clear” /}来进行清理。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clear &#123;</span><br><span class=\"line\">  clear: both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"clear\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>优点：简单，代码少，浏览器兼容性好。<br>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</p>\n<hr>\n<h3 id=\"方法二：使用CSS的overflow属性\"><a href=\"#方法二：使用CSS的overflow属性\" class=\"headerlink\" title=\"方法二：使用CSS的overflow属性\"></a>方法二：使用CSS的overflow属性</h3><p>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  *zoom: 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"方法三：给浮动的元素的容器添加浮动\"><a href=\"#方法三：给浮动的元素的容器添加浮动\" class=\"headerlink\" title=\"方法三：给浮动的元素的容器添加浮动\"></a>方法三：给浮动的元素的容器添加浮动</h3><p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p>\n<hr>\n<h3 id=\"方法四：使用邻接元素处理\"><a href=\"#方法四：使用邻接元素处理\" class=\"headerlink\" title=\"方法四：使用邻接元素处理\"></a>方法四：使用邻接元素处理</h3><p>什么都不做，给浮动元素后面的元素添加clear属性。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content&#123;</span><br><span class=\"line\">  clear:both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"content\"</span>&gt;***&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>注意这里的div.content有内容</p>\n<hr>\n<h3 id=\"方法五：使用CSS的-after伪元素\"><a href=\"#方法五：使用CSS的-after伪元素\" class=\"headerlink\" title=\"方法五：使用CSS的:after伪元素\"></a>方法五：使用CSS的:after伪元素</h3><p>结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。<br>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix:after&#123;</span><br><span class=\"line\">  content: <span class=\"string\">\"020\"</span>; </span><br><span class=\"line\">  display: block; </span><br><span class=\"line\">  height: 0; </span><br><span class=\"line\">  clear: both; </span><br><span class=\"line\">  visibility: hidden;  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix &#123;</span><br><span class=\"line\">  /* 触发 hasLayout */ </span><br><span class=\"line\">  zoom: 1; </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p>\n<p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。</p>\n<p>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。</p>\n<p>在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。</p>\n<p>最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>页面UI设计与开发</p>\n<hr>\n<h2 id=\"2020-5-11-16-56-Write\"><a href=\"#2020-5-11-16-56-Write\" class=\"headerlink\" title=\"2020/5/11 16:56 Write\"></a>2020/5/11 16:56 Write</h2><p>关键词：浮动</p>\n<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。<br>这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/05/11/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/%E6%B5%AE%E5%8A%A8%E6%BA%A2%E5%87%BA.jpg\" alt=\"浮动溢出\"></p>\n<hr>\n<p>清除浮动的方法</p>\n<h3 id=\"方法一：使用带clear属性的空元素\"><a href=\"#方法一：使用带clear属性的空元素\" class=\"headerlink\" title=\"方法一：使用带clear属性的空元素\"></a>方法一：使用带clear属性的空元素</h3><p>在浮动元素后使用一个空元素如{div class=”clear”&gt;&lt;/div}，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用{br class=”clear” /}或{hr class=”clear” /}来进行清理。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clear &#123;</span><br><span class=\"line\">  clear: both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"clear\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>优点：简单，代码少，浏览器兼容性好。<br>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</p>\n<hr>\n<h3 id=\"方法二：使用CSS的overflow属性\"><a href=\"#方法二：使用CSS的overflow属性\" class=\"headerlink\" title=\"方法二：使用CSS的overflow属性\"></a>方法二：使用CSS的overflow属性</h3><p>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  *zoom: 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"方法三：给浮动的元素的容器添加浮动\"><a href=\"#方法三：给浮动的元素的容器添加浮动\" class=\"headerlink\" title=\"方法三：给浮动的元素的容器添加浮动\"></a>方法三：给浮动的元素的容器添加浮动</h3><p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p>\n<hr>\n<h3 id=\"方法四：使用邻接元素处理\"><a href=\"#方法四：使用邻接元素处理\" class=\"headerlink\" title=\"方法四：使用邻接元素处理\"></a>方法四：使用邻接元素处理</h3><p>什么都不做，给浮动元素后面的元素添加clear属性。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content&#123;</span><br><span class=\"line\">  clear:both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"news\"</span>&gt;</span><br><span class=\"line\">&lt;img src=<span class=\"string\">\"news-pic.jpg\"</span> /&gt;</span><br><span class=\"line\">&lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">\"content\"</span>&gt;***&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>注意这里的div.content有内容</p>\n<hr>\n<h3 id=\"方法五：使用CSS的-after伪元素\"><a href=\"#方法五：使用CSS的-after伪元素\" class=\"headerlink\" title=\"方法五：使用CSS的:after伪元素\"></a>方法五：使用CSS的:after伪元素</h3><p>结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。<br>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.news &#123;</span><br><span class=\"line\">  background-color: gray;</span><br><span class=\"line\">  border: solid 1px black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news img &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.news p &#123;</span><br><span class=\"line\">  <span class=\"built_in\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix:after&#123;</span><br><span class=\"line\">  content: <span class=\"string\">\"020\"</span>; </span><br><span class=\"line\">  display: block; </span><br><span class=\"line\">  height: 0; </span><br><span class=\"line\">  clear: both; </span><br><span class=\"line\">  visibility: hidden;  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix &#123;</span><br><span class=\"line\">  /* 触发 hasLayout */ </span><br><span class=\"line\">  zoom: 1; </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p>\n<p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。</p>\n<p>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。</p>\n<p>在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。</p>\n<p>最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。</p>\n"},{"title":"生成器和promise","date":"2020-06-23T06:02:25.000Z","_content":"## 生成器，promise的使用和原理\n```bash\n使用try catch的问题：\nJS依赖于单线程执行模型，在操作结束前，无法渲染数据，用户会不满。\n解决办法：\n可以使用回调函数解决这个问题，这样每个数据获取后调用回调函数，不会导致UI渲染暂停。\n```\n```bash\nfunction* name(){} //在关键字function后面添加星号*定义生成器函数\nyield \"****\" //使用yield函数生成独立的值\n调用生成器会创建一个叫作迭代器的对象，与生成器通信。\nconst nameIterator = name() //调用生成器，得到一个迭代器，控制生成器的执行。\nconst result = nameIterator.next() //next将返回一个对象，包含返回值，以及一个指示器(done值)告诉我们是否还会生成值,返回undefined时代表状态已完成(done:true)\n每生成一个值后生成器会非阻塞地挂起执行，等待下一个值请求的到达。\nfor-of循环的原理如上，不同于next方法，for-of循环同时还需要查看生成器是否完成，它在后台自动做了完全相同的工作。\nfunction* WarriorGenerator(){\n   yield \"Sun Tzu\";\n   yield* NinjaGenerator();// yield*将执行权交给了另一个生成器，会先执行NinjaGenerator\n   yield \"Genghis Khan\"; // 执行完 NinjaGenerator后继续执行yield\n}  // 生成（输出）顺序为Sun Tzu,Hatori,Yoshi,Genghis Khan.\n\nfunction* NinjaGenerator(){\n   yield \"Hatori\";\n   yield \"Yoshi\";\n}\n生成器当中写无限循环的代码是可行的，每次调用一次next方法，while循环才会迭代一次并返回下一个ID值。\n```\n\n```bash\n还可以与生成器交互，在next函数中传入值，作为yield函数的返回值，第一次next无法提供初始值，可调用生成器自身的函数传入参数。\n也可使用try catch块，通过迭代器上有效的throw方法抛出异常，在catch函数中获取throw的值进行操作。\n生成器内部构成（像一个小程序，在状态中运动的状态机）\n步骤：挂起开始，执行，挂起让渡，完成。\n与闭包相似，每次使用函数就会创建一个上下文，生成器的上下文会被挂起来后恢复使。保持引用就不会被销毁。\n如果代码执行到return的时候，会进入完成状态。\n```\n\n```bash\npromise有两个状态，resolve和reject，resolve->fulfilled状态，reject->Rejected状态，都为已完成状态。\npromise案例的真实使用，通过Ajax请求数据，成功状态则处理数据，处理成功进入已完成状态，使用数据。\n请求失败则使用onerror函数调用reject回调函数，拒绝该请求。\n可以使用promise.all等待多个promise，then函数后有一个result参数，为一个数组，每一项都对应promise数组中的对应性。\n多个promise中有一个失败，整个对象都会被拒绝。使用promise.race函数传入一个promise数组，会返回一个新promise对象，某个被拒绝就这个promise就被拒绝。\n```","source":"_posts/生成器和promise.md","raw":"---\ntitle: 生成器和promise\ndate: 2020-06-23 14:02:25\ntags:\n - JavaScript\ncategories: Web前端\n---\n## 生成器，promise的使用和原理\n```bash\n使用try catch的问题：\nJS依赖于单线程执行模型，在操作结束前，无法渲染数据，用户会不满。\n解决办法：\n可以使用回调函数解决这个问题，这样每个数据获取后调用回调函数，不会导致UI渲染暂停。\n```\n```bash\nfunction* name(){} //在关键字function后面添加星号*定义生成器函数\nyield \"****\" //使用yield函数生成独立的值\n调用生成器会创建一个叫作迭代器的对象，与生成器通信。\nconst nameIterator = name() //调用生成器，得到一个迭代器，控制生成器的执行。\nconst result = nameIterator.next() //next将返回一个对象，包含返回值，以及一个指示器(done值)告诉我们是否还会生成值,返回undefined时代表状态已完成(done:true)\n每生成一个值后生成器会非阻塞地挂起执行，等待下一个值请求的到达。\nfor-of循环的原理如上，不同于next方法，for-of循环同时还需要查看生成器是否完成，它在后台自动做了完全相同的工作。\nfunction* WarriorGenerator(){\n   yield \"Sun Tzu\";\n   yield* NinjaGenerator();// yield*将执行权交给了另一个生成器，会先执行NinjaGenerator\n   yield \"Genghis Khan\"; // 执行完 NinjaGenerator后继续执行yield\n}  // 生成（输出）顺序为Sun Tzu,Hatori,Yoshi,Genghis Khan.\n\nfunction* NinjaGenerator(){\n   yield \"Hatori\";\n   yield \"Yoshi\";\n}\n生成器当中写无限循环的代码是可行的，每次调用一次next方法，while循环才会迭代一次并返回下一个ID值。\n```\n\n```bash\n还可以与生成器交互，在next函数中传入值，作为yield函数的返回值，第一次next无法提供初始值，可调用生成器自身的函数传入参数。\n也可使用try catch块，通过迭代器上有效的throw方法抛出异常，在catch函数中获取throw的值进行操作。\n生成器内部构成（像一个小程序，在状态中运动的状态机）\n步骤：挂起开始，执行，挂起让渡，完成。\n与闭包相似，每次使用函数就会创建一个上下文，生成器的上下文会被挂起来后恢复使。保持引用就不会被销毁。\n如果代码执行到return的时候，会进入完成状态。\n```\n\n```bash\npromise有两个状态，resolve和reject，resolve->fulfilled状态，reject->Rejected状态，都为已完成状态。\npromise案例的真实使用，通过Ajax请求数据，成功状态则处理数据，处理成功进入已完成状态，使用数据。\n请求失败则使用onerror函数调用reject回调函数，拒绝该请求。\n可以使用promise.all等待多个promise，then函数后有一个result参数，为一个数组，每一项都对应promise数组中的对应性。\n多个promise中有一个失败，整个对象都会被拒绝。使用promise.race函数传入一个promise数组，会返回一个新promise对象，某个被拒绝就这个promise就被拒绝。\n```","slug":"生成器和promise","published":1,"updated":"2020-06-29T06:40:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37p002spcva2wx1ggco","content":"<h2 id=\"生成器，promise的使用和原理\"><a href=\"#生成器，promise的使用和原理\" class=\"headerlink\" title=\"生成器，promise的使用和原理\"></a>生成器，promise的使用和原理</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用try catch的问题：</span><br><span class=\"line\">JS依赖于单线程执行模型，在操作结束前，无法渲染数据，用户会不满。</span><br><span class=\"line\">解决办法：</span><br><span class=\"line\">可以使用回调函数解决这个问题，这样每个数据获取后调用回调函数，不会导致UI渲染暂停。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"function\"><span class=\"title\">name</span></span>()&#123;&#125; //在关键字<span class=\"keyword\">function</span>后面添加星号*定义生成器函数</span><br><span class=\"line\">yield <span class=\"string\">\"****\"</span> //使用yield函数生成独立的值</span><br><span class=\"line\">调用生成器会创建一个叫作迭代器的对象，与生成器通信。</span><br><span class=\"line\">const nameIterator = name() //调用生成器，得到一个迭代器，控制生成器的执行。</span><br><span class=\"line\">const result = nameIterator.next() //next将返回一个对象，包含返回值，以及一个指示器(<span class=\"keyword\">done</span>值)告诉我们是否还会生成值,返回undefined时代表状态已完成(<span class=\"keyword\">done</span>:<span class=\"literal\">true</span>)</span><br><span class=\"line\">每生成一个值后生成器会非阻塞地挂起执行，等待下一个值请求的到达。</span><br><span class=\"line\"><span class=\"keyword\">for</span>-of循环的原理如上，不同于next方法，<span class=\"keyword\">for</span>-of循环同时还需要查看生成器是否完成，它在后台自动做了完全相同的工作。</span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"function\"><span class=\"title\">WarriorGenerator</span></span>()&#123;</span><br><span class=\"line\">   yield <span class=\"string\">\"Sun Tzu\"</span>;</span><br><span class=\"line\">   yield* NinjaGenerator();// yield*将执行权交给了另一个生成器，会先执行NinjaGenerator</span><br><span class=\"line\">   yield <span class=\"string\">\"Genghis Khan\"</span>; // 执行完 NinjaGenerator后继续执行yield</span><br><span class=\"line\">&#125;  // 生成（输出）顺序为Sun Tzu,Hatori,Yoshi,Genghis Khan.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"function\"><span class=\"title\">NinjaGenerator</span></span>()&#123;</span><br><span class=\"line\">   yield <span class=\"string\">\"Hatori\"</span>;</span><br><span class=\"line\">   yield <span class=\"string\">\"Yoshi\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">生成器当中写无限循环的代码是可行的，每次调用一次next方法，<span class=\"keyword\">while</span>循环才会迭代一次并返回下一个ID值。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以与生成器交互，在next函数中传入值，作为yield函数的返回值，第一次next无法提供初始值，可调用生成器自身的函数传入参数。</span><br><span class=\"line\">也可使用try catch块，通过迭代器上有效的throw方法抛出异常，在catch函数中获取throw的值进行操作。</span><br><span class=\"line\">生成器内部构成（像一个小程序，在状态中运动的状态机）</span><br><span class=\"line\">步骤：挂起开始，执行，挂起让渡，完成。</span><br><span class=\"line\">与闭包相似，每次使用函数就会创建一个上下文，生成器的上下文会被挂起来后恢复使。保持引用就不会被销毁。</span><br><span class=\"line\">如果代码执行到<span class=\"built_in\">return</span>的时候，会进入完成状态。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise有两个状态，resolve和reject，resolve-&gt;fulfilled状态，reject-&gt;Rejected状态，都为已完成状态。</span><br><span class=\"line\">promise案例的真实使用，通过Ajax请求数据，成功状态则处理数据，处理成功进入已完成状态，使用数据。</span><br><span class=\"line\">请求失败则使用onerror函数调用reject回调函数，拒绝该请求。</span><br><span class=\"line\">可以使用promise.all等待多个promise，<span class=\"keyword\">then</span>函数后有一个result参数，为一个数组，每一项都对应promise数组中的对应性。</span><br><span class=\"line\">多个promise中有一个失败，整个对象都会被拒绝。使用promise.race函数传入一个promise数组，会返回一个新promise对象，某个被拒绝就这个promise就被拒绝。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"生成器，promise的使用和原理\"><a href=\"#生成器，promise的使用和原理\" class=\"headerlink\" title=\"生成器，promise的使用和原理\"></a>生成器，promise的使用和原理</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用try catch的问题：</span><br><span class=\"line\">JS依赖于单线程执行模型，在操作结束前，无法渲染数据，用户会不满。</span><br><span class=\"line\">解决办法：</span><br><span class=\"line\">可以使用回调函数解决这个问题，这样每个数据获取后调用回调函数，不会导致UI渲染暂停。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"function\"><span class=\"title\">name</span></span>()&#123;&#125; //在关键字<span class=\"keyword\">function</span>后面添加星号*定义生成器函数</span><br><span class=\"line\">yield <span class=\"string\">\"****\"</span> //使用yield函数生成独立的值</span><br><span class=\"line\">调用生成器会创建一个叫作迭代器的对象，与生成器通信。</span><br><span class=\"line\">const nameIterator = name() //调用生成器，得到一个迭代器，控制生成器的执行。</span><br><span class=\"line\">const result = nameIterator.next() //next将返回一个对象，包含返回值，以及一个指示器(<span class=\"keyword\">done</span>值)告诉我们是否还会生成值,返回undefined时代表状态已完成(<span class=\"keyword\">done</span>:<span class=\"literal\">true</span>)</span><br><span class=\"line\">每生成一个值后生成器会非阻塞地挂起执行，等待下一个值请求的到达。</span><br><span class=\"line\"><span class=\"keyword\">for</span>-of循环的原理如上，不同于next方法，<span class=\"keyword\">for</span>-of循环同时还需要查看生成器是否完成，它在后台自动做了完全相同的工作。</span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"function\"><span class=\"title\">WarriorGenerator</span></span>()&#123;</span><br><span class=\"line\">   yield <span class=\"string\">\"Sun Tzu\"</span>;</span><br><span class=\"line\">   yield* NinjaGenerator();// yield*将执行权交给了另一个生成器，会先执行NinjaGenerator</span><br><span class=\"line\">   yield <span class=\"string\">\"Genghis Khan\"</span>; // 执行完 NinjaGenerator后继续执行yield</span><br><span class=\"line\">&#125;  // 生成（输出）顺序为Sun Tzu,Hatori,Yoshi,Genghis Khan.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"function\"><span class=\"title\">NinjaGenerator</span></span>()&#123;</span><br><span class=\"line\">   yield <span class=\"string\">\"Hatori\"</span>;</span><br><span class=\"line\">   yield <span class=\"string\">\"Yoshi\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">生成器当中写无限循环的代码是可行的，每次调用一次next方法，<span class=\"keyword\">while</span>循环才会迭代一次并返回下一个ID值。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以与生成器交互，在next函数中传入值，作为yield函数的返回值，第一次next无法提供初始值，可调用生成器自身的函数传入参数。</span><br><span class=\"line\">也可使用try catch块，通过迭代器上有效的throw方法抛出异常，在catch函数中获取throw的值进行操作。</span><br><span class=\"line\">生成器内部构成（像一个小程序，在状态中运动的状态机）</span><br><span class=\"line\">步骤：挂起开始，执行，挂起让渡，完成。</span><br><span class=\"line\">与闭包相似，每次使用函数就会创建一个上下文，生成器的上下文会被挂起来后恢复使。保持引用就不会被销毁。</span><br><span class=\"line\">如果代码执行到<span class=\"built_in\">return</span>的时候，会进入完成状态。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise有两个状态，resolve和reject，resolve-&gt;fulfilled状态，reject-&gt;Rejected状态，都为已完成状态。</span><br><span class=\"line\">promise案例的真实使用，通过Ajax请求数据，成功状态则处理数据，处理成功进入已完成状态，使用数据。</span><br><span class=\"line\">请求失败则使用onerror函数调用reject回调函数，拒绝该请求。</span><br><span class=\"line\">可以使用promise.all等待多个promise，<span class=\"keyword\">then</span>函数后有一个result参数，为一个数组，每一项都对应promise数组中的对应性。</span><br><span class=\"line\">多个promise中有一个失败，整个对象都会被拒绝。使用promise.race函数传入一个promise数组，会返回一个新promise对象，某个被拒绝就这个promise就被拒绝。</span><br></pre></td></tr></table></figure>"},{"title":"闭包","date":"2020-06-16T06:20:40.000Z","_content":"\n## 针对闭包基础的理解和使用\n\n### 1.什么是闭包\n```bash\n闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。\n```\n### 2.闭包使用例子\n```bash\nfunction Ninja() {\n      var feints = 0;\n      this.getFeints = function(){ \n        return feints;\n      };\n      this.feint = function(){\n        feints++;\n      };\n     }\n\n     var ninja1 = new Ninja(); //赋值一个实例\n     ninja1.feint(); //undefined 通过实例无法直接获取该变量值，但是能调用方法去改变变量值\n     assert(ninja1.feints === undefined,\n            \"And the private data is inaccessible to us.\");\n     assert(ninja1.getFeints() === 1,// 通过作用域内的方法获取私有变量的值，但是无法对该值进行直接操作\n           \"We're able to access the internal feint count.\")\n     var ninja2 = new Ninja();//新的实例有自己的私有变量\n     assert(ninja2.getFeints() === 0,\n            \"The second ninja object gets it’s own feints variable.\");\n```\n\n### 3.闭包的特性\n```bash\n类似于“气泡”效果，每个实例都有一个单独的闭包，不能访问其他闭包中的变量，作用域（scopes）强相关。\n关于执行上下文栈：上下文在变化。每次执行新的函数，都将创建新的函数上下文。内部代码结构可以访问外部代码结构中定义的变量。\n查找变量是从内往外根据环境来查找数据，直到外层环境global还未找到则返回错误。\n词法环境：块级环境，函数环境，全局环境\n```\n\n### 4.JS执行\n```bash\nJS引擎会访问并注册在当前词法环境中所声明的变量和函数。JS在第一阶段完成后开始执行第二阶段，具体执行取决于变量的类型（let，const，var，函数声明）以及环境类型（↑词法环境）。\nvar myFunExper = funtion(){};//指向语数表达式(无法在声明前访问函数)\nvar myArrow = (x) => x;//指向箭头表达式(无法在声明前访问函数)\nfunction fun(){}//作为函数声明进行定义(可以在声明前访问函数)\n变量提升！！\n```\n![过程](过程.png)\n\n### 5.闭包小结\n```bash\n闭包的高级功能：通过构造函数内的变量以及构造方法来模拟对象的私有属性；处理回调函数，简化代码。\n上下文栈的创建，推入，退出。\nJS引擎通过词法环境跟踪标识符（词法环境：俗称作用域）。\nvar 定义距离最近的函数级变量或全局变量\nlet和const定义距离最近级别的变量，包括块级变量。\n```","source":"_posts/闭包.md","raw":"---\ntitle: 闭包\ndate: 2020-06-16 14:20:40\ntags:\n - JavaScript\ncategories: Web前端\n---\n\n## 针对闭包基础的理解和使用\n\n### 1.什么是闭包\n```bash\n闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。\n```\n### 2.闭包使用例子\n```bash\nfunction Ninja() {\n      var feints = 0;\n      this.getFeints = function(){ \n        return feints;\n      };\n      this.feint = function(){\n        feints++;\n      };\n     }\n\n     var ninja1 = new Ninja(); //赋值一个实例\n     ninja1.feint(); //undefined 通过实例无法直接获取该变量值，但是能调用方法去改变变量值\n     assert(ninja1.feints === undefined,\n            \"And the private data is inaccessible to us.\");\n     assert(ninja1.getFeints() === 1,// 通过作用域内的方法获取私有变量的值，但是无法对该值进行直接操作\n           \"We're able to access the internal feint count.\")\n     var ninja2 = new Ninja();//新的实例有自己的私有变量\n     assert(ninja2.getFeints() === 0,\n            \"The second ninja object gets it’s own feints variable.\");\n```\n\n### 3.闭包的特性\n```bash\n类似于“气泡”效果，每个实例都有一个单独的闭包，不能访问其他闭包中的变量，作用域（scopes）强相关。\n关于执行上下文栈：上下文在变化。每次执行新的函数，都将创建新的函数上下文。内部代码结构可以访问外部代码结构中定义的变量。\n查找变量是从内往外根据环境来查找数据，直到外层环境global还未找到则返回错误。\n词法环境：块级环境，函数环境，全局环境\n```\n\n### 4.JS执行\n```bash\nJS引擎会访问并注册在当前词法环境中所声明的变量和函数。JS在第一阶段完成后开始执行第二阶段，具体执行取决于变量的类型（let，const，var，函数声明）以及环境类型（↑词法环境）。\nvar myFunExper = funtion(){};//指向语数表达式(无法在声明前访问函数)\nvar myArrow = (x) => x;//指向箭头表达式(无法在声明前访问函数)\nfunction fun(){}//作为函数声明进行定义(可以在声明前访问函数)\n变量提升！！\n```\n![过程](过程.png)\n\n### 5.闭包小结\n```bash\n闭包的高级功能：通过构造函数内的变量以及构造方法来模拟对象的私有属性；处理回调函数，简化代码。\n上下文栈的创建，推入，退出。\nJS引擎通过词法环境跟踪标识符（词法环境：俗称作用域）。\nvar 定义距离最近的函数级变量或全局变量\nlet和const定义距离最近级别的变量，包括块级变量。\n```","slug":"闭包","published":1,"updated":"2020-06-17T03:30:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37q002wpcva6pw50ej5","content":"<h2 id=\"针对闭包基础的理解和使用\"><a href=\"#针对闭包基础的理解和使用\" class=\"headerlink\" title=\"针对闭包基础的理解和使用\"></a>针对闭包基础的理解和使用</h2><h3 id=\"1-什么是闭包\"><a href=\"#1-什么是闭包\" class=\"headerlink\" title=\"1.什么是闭包\"></a>1.什么是闭包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-闭包使用例子\"><a href=\"#2-闭包使用例子\" class=\"headerlink\" title=\"2.闭包使用例子\"></a>2.闭包使用例子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Ninja</span></span>() &#123;</span><br><span class=\"line\">      var feints = 0;</span><br><span class=\"line\">      this.getFeints = <span class=\"function\"><span class=\"title\">function</span></span>()&#123; </span><br><span class=\"line\">        <span class=\"built_in\">return</span> feints;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      this.feint = <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">        feints++;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     var ninja1 = new Ninja(); //赋值一个实例</span><br><span class=\"line\">     ninja1.feint(); //undefined 通过实例无法直接获取该变量值，但是能调用方法去改变变量值</span><br><span class=\"line\">     assert(ninja1.feints === undefined,</span><br><span class=\"line\">            <span class=\"string\">\"And the private data is inaccessible to us.\"</span>);</span><br><span class=\"line\">     assert(ninja1.getFeints() === 1,// 通过作用域内的方法获取私有变量的值，但是无法对该值进行直接操作</span><br><span class=\"line\">           <span class=\"string\">\"We're able to access the internal feint count.\"</span>)</span><br><span class=\"line\">     var ninja2 = new Ninja();//新的实例有自己的私有变量</span><br><span class=\"line\">     assert(ninja2.getFeints() === 0,</span><br><span class=\"line\">            <span class=\"string\">\"The second ninja object gets it’s own feints variable.\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-闭包的特性\"><a href=\"#3-闭包的特性\" class=\"headerlink\" title=\"3.闭包的特性\"></a>3.闭包的特性</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类似于“气泡”效果，每个实例都有一个单独的闭包，不能访问其他闭包中的变量，作用域（scopes）强相关。</span><br><span class=\"line\">关于执行上下文栈：上下文在变化。每次执行新的函数，都将创建新的函数上下文。内部代码结构可以访问外部代码结构中定义的变量。</span><br><span class=\"line\">查找变量是从内往外根据环境来查找数据，直到外层环境global还未找到则返回错误。</span><br><span class=\"line\">词法环境：块级环境，函数环境，全局环境</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-JS执行\"><a href=\"#4-JS执行\" class=\"headerlink\" title=\"4.JS执行\"></a>4.JS执行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS引擎会访问并注册在当前词法环境中所声明的变量和函数。JS在第一阶段完成后开始执行第二阶段，具体执行取决于变量的类型（<span class=\"built_in\">let</span>，const，var，函数声明）以及环境类型（↑词法环境）。</span><br><span class=\"line\">var myFunExper = <span class=\"function\"><span class=\"title\">funtion</span></span>()&#123;&#125;;//指向语数表达式(无法在声明前访问函数)</span><br><span class=\"line\">var myArrow = (x) =&gt; x;//指向箭头表达式(无法在声明前访问函数)</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">fun</span></span>()&#123;&#125;//作为函数声明进行定义(可以在声明前访问函数)</span><br><span class=\"line\">变量提升！！</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/06/16/%E9%97%AD%E5%8C%85/%E8%BF%87%E7%A8%8B.png\" alt=\"过程\"></p>\n<h3 id=\"5-闭包小结\"><a href=\"#5-闭包小结\" class=\"headerlink\" title=\"5.闭包小结\"></a>5.闭包小结</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包的高级功能：通过构造函数内的变量以及构造方法来模拟对象的私有属性；处理回调函数，简化代码。</span><br><span class=\"line\">上下文栈的创建，推入，退出。</span><br><span class=\"line\">JS引擎通过词法环境跟踪标识符（词法环境：俗称作用域）。</span><br><span class=\"line\">var 定义距离最近的函数级变量或全局变量</span><br><span class=\"line\"><span class=\"built_in\">let</span>和const定义距离最近级别的变量，包括块级变量。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"针对闭包基础的理解和使用\"><a href=\"#针对闭包基础的理解和使用\" class=\"headerlink\" title=\"针对闭包基础的理解和使用\"></a>针对闭包基础的理解和使用</h2><h3 id=\"1-什么是闭包\"><a href=\"#1-什么是闭包\" class=\"headerlink\" title=\"1.什么是闭包\"></a>1.什么是闭包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-闭包使用例子\"><a href=\"#2-闭包使用例子\" class=\"headerlink\" title=\"2.闭包使用例子\"></a>2.闭包使用例子</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Ninja</span></span>() &#123;</span><br><span class=\"line\">      var feints = 0;</span><br><span class=\"line\">      this.getFeints = <span class=\"function\"><span class=\"title\">function</span></span>()&#123; </span><br><span class=\"line\">        <span class=\"built_in\">return</span> feints;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      this.feint = <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">        feints++;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     var ninja1 = new Ninja(); //赋值一个实例</span><br><span class=\"line\">     ninja1.feint(); //undefined 通过实例无法直接获取该变量值，但是能调用方法去改变变量值</span><br><span class=\"line\">     assert(ninja1.feints === undefined,</span><br><span class=\"line\">            <span class=\"string\">\"And the private data is inaccessible to us.\"</span>);</span><br><span class=\"line\">     assert(ninja1.getFeints() === 1,// 通过作用域内的方法获取私有变量的值，但是无法对该值进行直接操作</span><br><span class=\"line\">           <span class=\"string\">\"We're able to access the internal feint count.\"</span>)</span><br><span class=\"line\">     var ninja2 = new Ninja();//新的实例有自己的私有变量</span><br><span class=\"line\">     assert(ninja2.getFeints() === 0,</span><br><span class=\"line\">            <span class=\"string\">\"The second ninja object gets it’s own feints variable.\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-闭包的特性\"><a href=\"#3-闭包的特性\" class=\"headerlink\" title=\"3.闭包的特性\"></a>3.闭包的特性</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类似于“气泡”效果，每个实例都有一个单独的闭包，不能访问其他闭包中的变量，作用域（scopes）强相关。</span><br><span class=\"line\">关于执行上下文栈：上下文在变化。每次执行新的函数，都将创建新的函数上下文。内部代码结构可以访问外部代码结构中定义的变量。</span><br><span class=\"line\">查找变量是从内往外根据环境来查找数据，直到外层环境global还未找到则返回错误。</span><br><span class=\"line\">词法环境：块级环境，函数环境，全局环境</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-JS执行\"><a href=\"#4-JS执行\" class=\"headerlink\" title=\"4.JS执行\"></a>4.JS执行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS引擎会访问并注册在当前词法环境中所声明的变量和函数。JS在第一阶段完成后开始执行第二阶段，具体执行取决于变量的类型（<span class=\"built_in\">let</span>，const，var，函数声明）以及环境类型（↑词法环境）。</span><br><span class=\"line\">var myFunExper = <span class=\"function\"><span class=\"title\">funtion</span></span>()&#123;&#125;;//指向语数表达式(无法在声明前访问函数)</span><br><span class=\"line\">var myArrow = (x) =&gt; x;//指向箭头表达式(无法在声明前访问函数)</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">fun</span></span>()&#123;&#125;//作为函数声明进行定义(可以在声明前访问函数)</span><br><span class=\"line\">变量提升！！</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/06/16/%E9%97%AD%E5%8C%85/%E8%BF%87%E7%A8%8B.png\" alt=\"过程\"></p>\n<h3 id=\"5-闭包小结\"><a href=\"#5-闭包小结\" class=\"headerlink\" title=\"5.闭包小结\"></a>5.闭包小结</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闭包的高级功能：通过构造函数内的变量以及构造方法来模拟对象的私有属性；处理回调函数，简化代码。</span><br><span class=\"line\">上下文栈的创建，推入，退出。</span><br><span class=\"line\">JS引擎通过词法环境跟踪标识符（词法环境：俗称作用域）。</span><br><span class=\"line\">var 定义距离最近的函数级变量或全局变量</span><br><span class=\"line\"><span class=\"built_in\">let</span>和const定义距离最近级别的变量，包括块级变量。</span><br></pre></td></tr></table></figure>"},{"title":"设计模式","date":"2020-09-11T07:44:22.000Z","_content":"## 结构型模式\n---\n1.适配器模式\n特点：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n后台返回的数据格式不同，可以通过适配器修改。例：\n后台返回json格式的数据，通过方法检索出自己需要的数据进行显示，这个方法即为适配器。\n通常用来避免项目迭代后数据格式或者方法名发生改变出现的错误。\n最优解：项目开发过程中前后端协商讨论数据格式、文件名等代码规范。\n---\n2.代理模式\n为一个对象提供一个代用品或占位符，以便控制对他的访问。\n在一个对象中调用其他对象的方法（函数可以实例化成对象）\n保护代理：数据拦截（可以在函数中条件判断拦截数据从而执行不同下文）\n虚拟代理：数据通过这些代理传递没有被拦截（可实现图片懒加载）\n---\n3.桥接模式\n把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。\n需要一种方式让对象和行为分离，便于随意拼接。\n优点：分离抽象接口及其实现部分，提高可拓展性。\n缺点：增加系统的理解和设计难度\n```bash\nboy,girl,piano,guitar\nboy-piano,boy-guitar,girl-piano,girl-guitar\nfunction Boy(instrument) {\n      this.sayHi = function() {\n          console.log('hi, 我是男生')\n      }\n      this.playInstrument = function() {\n          instrument.play()\n      }\n  }\n  function Girl(instrument) {\n      this.sayHi = function() {\n          console.log('hi, 我是女生')\n      }\n      this.playInstrument = function() {\n          instrument.play()\n      }\n  }\n  function Piano() {\n      this.play = function() {\n          console.log('钢琴开始演奏')\n      }\n  }\n  function Guitar() {\n      this.play = function() {\n          console.log('吉他开始演奏')\n      }\n  }\n  let piano = new Piano()\n  let guitar = new Guitar()\n  let pianoBoy = new Boy(piano)\n  pianoBoy.playInstrument()\n  let guitarGirl = new Girl(guitar)\n  guitarGirl.playInstrument()\n```\n---\n4.装饰模式\n动态地给一个对象添加一些额外的职责。（类似魂斗罗的子弹种类变化，原来子弹还在）\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，继承的一个替代模式。\n缺点：多层装饰，比较复杂。\n类似闭包，在函数对象中添加调用其他函数，给对象增加功能\n---\n5.组合模式\n由小对象构建大对象，常和装饰者模式一起使用\n优点：通过对象的多态表现，使对单个对象和组合对象的使用具有一致性\n缺点：系统负担，性能\n小函数添加进一个对象（可以是实例化的函数），通过该函数去调用各种小函数，囊括这些功能。\n---\n## 创建型模式\n\n---\n\n## 行为型模式\n\n---\n","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\ndate: 2020-09-11 15:44:22\ntags:\n - 设计模式\ncategories: Web前端\n---\n## 结构型模式\n---\n1.适配器模式\n特点：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n后台返回的数据格式不同，可以通过适配器修改。例：\n后台返回json格式的数据，通过方法检索出自己需要的数据进行显示，这个方法即为适配器。\n通常用来避免项目迭代后数据格式或者方法名发生改变出现的错误。\n最优解：项目开发过程中前后端协商讨论数据格式、文件名等代码规范。\n---\n2.代理模式\n为一个对象提供一个代用品或占位符，以便控制对他的访问。\n在一个对象中调用其他对象的方法（函数可以实例化成对象）\n保护代理：数据拦截（可以在函数中条件判断拦截数据从而执行不同下文）\n虚拟代理：数据通过这些代理传递没有被拦截（可实现图片懒加载）\n---\n3.桥接模式\n把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。\n需要一种方式让对象和行为分离，便于随意拼接。\n优点：分离抽象接口及其实现部分，提高可拓展性。\n缺点：增加系统的理解和设计难度\n```bash\nboy,girl,piano,guitar\nboy-piano,boy-guitar,girl-piano,girl-guitar\nfunction Boy(instrument) {\n      this.sayHi = function() {\n          console.log('hi, 我是男生')\n      }\n      this.playInstrument = function() {\n          instrument.play()\n      }\n  }\n  function Girl(instrument) {\n      this.sayHi = function() {\n          console.log('hi, 我是女生')\n      }\n      this.playInstrument = function() {\n          instrument.play()\n      }\n  }\n  function Piano() {\n      this.play = function() {\n          console.log('钢琴开始演奏')\n      }\n  }\n  function Guitar() {\n      this.play = function() {\n          console.log('吉他开始演奏')\n      }\n  }\n  let piano = new Piano()\n  let guitar = new Guitar()\n  let pianoBoy = new Boy(piano)\n  pianoBoy.playInstrument()\n  let guitarGirl = new Girl(guitar)\n  guitarGirl.playInstrument()\n```\n---\n4.装饰模式\n动态地给一个对象添加一些额外的职责。（类似魂斗罗的子弹种类变化，原来子弹还在）\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，继承的一个替代模式。\n缺点：多层装饰，比较复杂。\n类似闭包，在函数对象中添加调用其他函数，给对象增加功能\n---\n5.组合模式\n由小对象构建大对象，常和装饰者模式一起使用\n优点：通过对象的多态表现，使对单个对象和组合对象的使用具有一致性\n缺点：系统负担，性能\n小函数添加进一个对象（可以是实例化的函数），通过该函数去调用各种小函数，囊括这些功能。\n---\n## 创建型模式\n\n---\n\n## 行为型模式\n\n---\n","slug":"设计模式","published":1,"updated":"2020-09-11T09:46:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkrow37r002zpcva7ui3hz97","content":"<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><hr>\n<p>1.适配器模式<br>特点：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。<br>后台返回的数据格式不同，可以通过适配器修改。例：<br>后台返回json格式的数据，通过方法检索出自己需要的数据进行显示，这个方法即为适配器。<br>通常用来避免项目迭代后数据格式或者方法名发生改变出现的错误。<br>最优解：项目开发过程中前后端协商讨论数据格式、文件名等代码规范。</p>\n<hr>\n<p>2.代理模式<br>为一个对象提供一个代用品或占位符，以便控制对他的访问。<br>在一个对象中调用其他对象的方法（函数可以实例化成对象）<br>保护代理：数据拦截（可以在函数中条件判断拦截数据从而执行不同下文）<br>虚拟代理：数据通过这些代理传递没有被拦截（可实现图片懒加载）</p>\n<hr>\n<p>3.桥接模式<br>把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。<br>需要一种方式让对象和行为分离，便于随意拼接。<br>优点：分离抽象接口及其实现部分，提高可拓展性。<br>缺点：增加系统的理解和设计难度</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boy,girl,piano,guitar</span><br><span class=\"line\">boy-piano,boy-guitar,girl-piano,girl-guitar</span><br><span class=\"line\"><span class=\"keyword\">function</span> Boy(instrument) &#123;</span><br><span class=\"line\">      this.sayHi = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'hi, 我是男生'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.playInstrument = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          instrument.play()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> Girl(instrument) &#123;</span><br><span class=\"line\">      this.sayHi = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'hi, 我是女生'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.playInstrument = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          instrument.play()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Piano</span></span>() &#123;</span><br><span class=\"line\">      this.play = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'钢琴开始演奏'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Guitar</span></span>() &#123;</span><br><span class=\"line\">      this.play = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'吉他开始演奏'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> piano = new Piano()</span><br><span class=\"line\">  <span class=\"built_in\">let</span> guitar = new Guitar()</span><br><span class=\"line\">  <span class=\"built_in\">let</span> pianoBoy = new Boy(piano)</span><br><span class=\"line\">  pianoBoy.playInstrument()</span><br><span class=\"line\">  <span class=\"built_in\">let</span> guitarGirl = new Girl(guitar)</span><br><span class=\"line\">  guitarGirl.playInstrument()</span><br></pre></td></tr></table></figure>\n<hr>\n<p>4.装饰模式<br>动态地给一个对象添加一些额外的职责。（类似魂斗罗的子弹种类变化，原来子弹还在）<br>优点：装饰类和被装饰类可以独立发展，不会相互耦合，继承的一个替代模式。<br>缺点：多层装饰，比较复杂。<br>类似闭包，在函数对象中添加调用其他函数，给对象增加功能</p>\n<hr>\n<p>5.组合模式<br>由小对象构建大对象，常和装饰者模式一起使用<br>优点：通过对象的多态表现，使对单个对象和组合对象的使用具有一致性<br>缺点：系统负担，性能<br>小函数添加进一个对象（可以是实例化的函数），通过该函数去调用各种小函数，囊括这些功能。</p>\n<hr>\n<h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><hr>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><hr>\n<p>1.适配器模式<br>特点：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。<br>后台返回的数据格式不同，可以通过适配器修改。例：<br>后台返回json格式的数据，通过方法检索出自己需要的数据进行显示，这个方法即为适配器。<br>通常用来避免项目迭代后数据格式或者方法名发生改变出现的错误。<br>最优解：项目开发过程中前后端协商讨论数据格式、文件名等代码规范。</p>\n<hr>\n<p>2.代理模式<br>为一个对象提供一个代用品或占位符，以便控制对他的访问。<br>在一个对象中调用其他对象的方法（函数可以实例化成对象）<br>保护代理：数据拦截（可以在函数中条件判断拦截数据从而执行不同下文）<br>虚拟代理：数据通过这些代理传递没有被拦截（可实现图片懒加载）</p>\n<hr>\n<p>3.桥接模式<br>把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。<br>需要一种方式让对象和行为分离，便于随意拼接。<br>优点：分离抽象接口及其实现部分，提高可拓展性。<br>缺点：增加系统的理解和设计难度</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boy,girl,piano,guitar</span><br><span class=\"line\">boy-piano,boy-guitar,girl-piano,girl-guitar</span><br><span class=\"line\"><span class=\"keyword\">function</span> Boy(instrument) &#123;</span><br><span class=\"line\">      this.sayHi = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'hi, 我是男生'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.playInstrument = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          instrument.play()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> Girl(instrument) &#123;</span><br><span class=\"line\">      this.sayHi = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'hi, 我是女生'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.playInstrument = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          instrument.play()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Piano</span></span>() &#123;</span><br><span class=\"line\">      this.play = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'钢琴开始演奏'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">Guitar</span></span>() &#123;</span><br><span class=\"line\">      this.play = <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">          console.log(<span class=\"string\">'吉他开始演奏'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">let</span> piano = new Piano()</span><br><span class=\"line\">  <span class=\"built_in\">let</span> guitar = new Guitar()</span><br><span class=\"line\">  <span class=\"built_in\">let</span> pianoBoy = new Boy(piano)</span><br><span class=\"line\">  pianoBoy.playInstrument()</span><br><span class=\"line\">  <span class=\"built_in\">let</span> guitarGirl = new Girl(guitar)</span><br><span class=\"line\">  guitarGirl.playInstrument()</span><br></pre></td></tr></table></figure>\n<hr>\n<p>4.装饰模式<br>动态地给一个对象添加一些额外的职责。（类似魂斗罗的子弹种类变化，原来子弹还在）<br>优点：装饰类和被装饰类可以独立发展，不会相互耦合，继承的一个替代模式。<br>缺点：多层装饰，比较复杂。<br>类似闭包，在函数对象中添加调用其他函数，给对象增加功能</p>\n<hr>\n<p>5.组合模式<br>由小对象构建大对象，常和装饰者模式一起使用<br>优点：通过对象的多态表现，使对单个对象和组合对象的使用具有一致性<br>缺点：系统负担，性能<br>小函数添加进一个对象（可以是实例化的函数），通过该函数去调用各种小函数，囊括这些功能。</p>\n<hr>\n<h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><hr>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><hr>\n"},{"title":"Vue-mixin","date":"2021-02-25T07:05:59.000Z","_content":"## 1. mixin是什么？\nMixin是一种类，提供方法实现。通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用，避免多继承的复杂。本质是一个JS对象，包含组件的任意功能，将功能传入mixins中就可以使用，可以局部混入，可以全局混入（不推荐！）。\n## 2. 如何使用？\n局部混入：\n```bash\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n// 组件通过mixins属性调用mixin对象\nVue.component('componentA',{\n  mixins: [myMixin]\n})\n// 使用该组件时，会混合mixin里的方法，自动执行钩子函数。也可以调用mixin里的data值\n```\n全局混入：\n```bash\nVue.mixin({\n  created: function () {\n      console.log(\"全局混入\")\n    }\n})\n// 全局混入需要特别注意，会影响到每个组件。\n```\n当组件存在于mixin对象相同的选项时，合并时会覆盖mixin的选项。\n生命周期钩子相同时，会合并成一个数组，先执行mixin的钩子。\n## 3. 使用场景\n相似或相同的代码，功能相对独立。\n```bash\nconst toggle = { // 编写mixin\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n\nconst Modal = {  // 使用时引入\n  template: '#modal',\n  mixins: [toggle]\n};\n```\n## 4. 源码分析\n## 5. 小结\n·替换型策略有props、methods、inject、computed，新参数替换旧\n·合并型策略是data，通过set方法进行合并和重新赋值\n·队列型策略有生命周期和watch，原理是将函数存入一个数组，然后正序遍历依次执行\n·叠加型有component、directives、filters，通过原型链进行层层叠加","source":"_posts/Vue-mixin.md","raw":"---\ntitle: Vue-mixin\ndate: 2021-02-25 15:05:59\ntags:\n - 前端框架\n - Vue\ncategories: web前端\n---\n## 1. mixin是什么？\nMixin是一种类，提供方法实现。通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用，避免多继承的复杂。本质是一个JS对象，包含组件的任意功能，将功能传入mixins中就可以使用，可以局部混入，可以全局混入（不推荐！）。\n## 2. 如何使用？\n局部混入：\n```bash\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n// 组件通过mixins属性调用mixin对象\nVue.component('componentA',{\n  mixins: [myMixin]\n})\n// 使用该组件时，会混合mixin里的方法，自动执行钩子函数。也可以调用mixin里的data值\n```\n全局混入：\n```bash\nVue.mixin({\n  created: function () {\n      console.log(\"全局混入\")\n    }\n})\n// 全局混入需要特别注意，会影响到每个组件。\n```\n当组件存在于mixin对象相同的选项时，合并时会覆盖mixin的选项。\n生命周期钩子相同时，会合并成一个数组，先执行mixin的钩子。\n## 3. 使用场景\n相似或相同的代码，功能相对独立。\n```bash\nconst toggle = { // 编写mixin\n  data() {\n    return {\n      isShowing: false\n    }\n  },\n  methods: {\n    toggleShow() {\n      this.isShowing = !this.isShowing;\n    }\n  }\n}\n\nconst Modal = {  // 使用时引入\n  template: '#modal',\n  mixins: [toggle]\n};\n```\n## 4. 源码分析\n## 5. 小结\n·替换型策略有props、methods、inject、computed，新参数替换旧\n·合并型策略是data，通过set方法进行合并和重新赋值\n·队列型策略有生命周期和watch，原理是将函数存入一个数组，然后正序遍历依次执行\n·叠加型有component、directives、filters，通过原型链进行层层叠加","slug":"Vue-mixin","published":1,"updated":"2021-02-25T08:13:48.622Z","_id":"cklkl9v3w0000ksvaa86paphi","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-mixin是什么？\"><a href=\"#1-mixin是什么？\" class=\"headerlink\" title=\"1. mixin是什么？\"></a>1. mixin是什么？</h2><p>Mixin是一种类，提供方法实现。通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用，避免多继承的复杂。本质是一个JS对象，包含组件的任意功能，将功能传入mixins中就可以使用，可以局部混入，可以全局混入（不推荐！）。</p>\n<h2 id=\"2-如何使用？\"><a href=\"#2-如何使用？\" class=\"headerlink\" title=\"2. 如何使用？\"></a>2. 如何使用？</h2><p>局部混入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMixin = &#123;</span><br><span class=\"line\">  created: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.hello()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    hello: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">      console.log(<span class=\"string\">'hello from mixin!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 组件通过mixins属性调用mixin对象</span><br><span class=\"line\">Vue.component(<span class=\"string\">'componentA'</span>,&#123;</span><br><span class=\"line\">  mixins: [myMixin]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 使用该组件时，会混合mixin里的方法，自动执行钩子函数。也可以调用mixin里的data值</span><br></pre></td></tr></table></figure>\n<p>全局混入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  created: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">      console.log(<span class=\"string\">\"全局混入\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 全局混入需要特别注意，会影响到每个组件。</span><br></pre></td></tr></table></figure>\n<p>当组件存在于mixin对象相同的选项时，合并时会覆盖mixin的选项。<br>生命周期钩子相同时，会合并成一个数组，先执行mixin的钩子。</p>\n<h2 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h2><p>相似或相同的代码，功能相对独立。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const toggle = &#123; // 编写mixin</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">data</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">      isShowing: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleShow</span></span>() &#123;</span><br><span class=\"line\">      this.isShowing = !this.isShowing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Modal = &#123;  // 使用时引入</span><br><span class=\"line\">  template: <span class=\"string\">'#modal'</span>,</span><br><span class=\"line\">  mixins: [toggle]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-源码分析\"><a href=\"#4-源码分析\" class=\"headerlink\" title=\"4. 源码分析\"></a>4. 源码分析</h2><h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>·替换型策略有props、methods、inject、computed，新参数替换旧<br>·合并型策略是data，通过set方法进行合并和重新赋值<br>·队列型策略有生命周期和watch，原理是将函数存入一个数组，然后正序遍历依次执行<br>·叠加型有component、directives、filters，通过原型链进行层层叠加</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-mixin是什么？\"><a href=\"#1-mixin是什么？\" class=\"headerlink\" title=\"1. mixin是什么？\"></a>1. mixin是什么？</h2><p>Mixin是一种类，提供方法实现。通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用，避免多继承的复杂。本质是一个JS对象，包含组件的任意功能，将功能传入mixins中就可以使用，可以局部混入，可以全局混入（不推荐！）。</p>\n<h2 id=\"2-如何使用？\"><a href=\"#2-如何使用？\" class=\"headerlink\" title=\"2. 如何使用？\"></a>2. 如何使用？</h2><p>局部混入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMixin = &#123;</span><br><span class=\"line\">  created: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    this.hello()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    hello: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">      console.log(<span class=\"string\">'hello from mixin!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 组件通过mixins属性调用mixin对象</span><br><span class=\"line\">Vue.component(<span class=\"string\">'componentA'</span>,&#123;</span><br><span class=\"line\">  mixins: [myMixin]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 使用该组件时，会混合mixin里的方法，自动执行钩子函数。也可以调用mixin里的data值</span><br></pre></td></tr></table></figure>\n<p>全局混入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  created: <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">      console.log(<span class=\"string\">\"全局混入\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 全局混入需要特别注意，会影响到每个组件。</span><br></pre></td></tr></table></figure>\n<p>当组件存在于mixin对象相同的选项时，合并时会覆盖mixin的选项。<br>生命周期钩子相同时，会合并成一个数组，先执行mixin的钩子。</p>\n<h2 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h2><p>相似或相同的代码，功能相对独立。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const toggle = &#123; // 编写mixin</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">data</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">return</span> &#123;</span><br><span class=\"line\">      isShowing: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleShow</span></span>() &#123;</span><br><span class=\"line\">      this.isShowing = !this.isShowing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const Modal = &#123;  // 使用时引入</span><br><span class=\"line\">  template: <span class=\"string\">'#modal'</span>,</span><br><span class=\"line\">  mixins: [toggle]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-源码分析\"><a href=\"#4-源码分析\" class=\"headerlink\" title=\"4. 源码分析\"></a>4. 源码分析</h2><h2 id=\"5-小结\"><a href=\"#5-小结\" class=\"headerlink\" title=\"5. 小结\"></a>5. 小结</h2><p>·替换型策略有props、methods、inject、computed，新参数替换旧<br>·合并型策略是data，通过set方法进行合并和重新赋值<br>·队列型策略有生命周期和watch，原理是将函数存入一个数组，然后正序遍历依次执行<br>·叠加型有component、directives、filters，通过原型链进行层层叠加</p>\n"},{"title":"Vue指令","date":"2021-02-25T06:05:04.000Z","_content":"## 1.指令是啥？\nVue有一套为数据驱动视图更方便的指令系统。v-开头的行内属性都是指令，不同指令可以实现不同的功能。\n\n## 2.如何实现？\n局部注册，全局注册。通过Vue.directive注册。\n全局注册：\n```bash\nVue.directive('focus', { // 注册v-focus指令\n   inserted: function (el) {\n      el.focus() // 让元素自动聚焦\n   }\n})\n```\n局部注册：\n```bash\ndirectives: {\n   focus: {\n      inserted: function (el) {\n         el.focus() //功能同上\n      }\n   }\n}\n```\n模板中的使用：\n```bash\n<input v-focus />\n```\n\n自定义指令也存在钩子函数：\n·bind：只调用一次，指令第一次绑定到元素时使用。初始化设置。\n·inserted：被绑定元素插入父节点时调用\n·update：所在组件VNode更新时调用\n·componentUpdated：所在组件VNode和子VNode全部更新后调用\n·unbind：只调用一次，指令与元素解绑时调用\n钩子函数的参数有：\n·el：指令绑定的元素，可操作DOM\n·binding：一个对象，包含name,value,oldValue,expression,arg,modifiers\n·vnode：虚拟节点\n·oldVnode：上一个虚拟节点\n\n## 3.应用场景\n·防抖\n```bash\n// 1.设置v-throttle自定义指令\nVue.directive('throttle', {\n  bind: (el, binding) => {\n    let throttleTime = binding.value; // 防抖时间\n    if (!throttleTime) { // 用户若不设置防抖时间，则默认2s\n      throttleTime = 2000;\n    }\n    let cbFun;\n    el.addEventListener('click', event => {\n      if (!cbFun) { // 第一次执行\n        cbFun = setTimeout(() => {\n          cbFun = null;\n        }, throttleTime);\n      } else {\n        event && event.stopImmediatePropagation();\n      }\n    }, true);\n  },\n});\n// 2.为button标签设置v-throttle自定义指令\n<button @click=\"sayHello\" v-throttle>提交</button>\n```\n·图片懒加载\n```bash\n// 1.设置v-throttle自定义指令\nVue.directive('throttle', {\n  bind: (el, binding) => {\n    let throttleTime = binding.value; // 防抖时间\n    if (!throttleTime) { // 用户若不设置防抖时间，则默认2s\n      throttleTime = 2000;\n    }\n    let cbFun;\n    el.addEventListener('click', event => {\n      if (!cbFun) { // 第一次执行\n        cbFun = setTimeout(() => {\n          cbFun = null;\n        }, throttleTime);\n      } else {\n        event && event.stopImmediatePropagation();\n      }\n    }, true);\n  },\n});\n// 2.为button标签设置v-throttle自定义指令\n<button @click=\"sayHello\" v-throttle>提交</button>\n图片懒加载\n设置一个v-lazy自定义组件完成图片懒加载\nconst LazyLoad = {\n    // install方法\n    install(Vue,options){\n       // 代替图片的loading图\n        let defaultSrc = options.default;\n        Vue.directive('lazy',{\n            bind(el,binding){\n                LazyLoad.init(el,binding.value,defaultSrc);\n            },\n            inserted(el){\n                // 兼容处理\n                if('IntersectionObserver' in window){\n                    LazyLoad.observe(el);\n                }else{\n                    LazyLoad.listenerScroll(el);\n                }\n                \n            },\n        })\n    },\n    // 初始化\n    init(el,val,def){\n        // data-src 储存真实src\n        el.setAttribute('data-src',val);\n        // 设置src为loading图\n        el.setAttribute('src',def);\n    },\n    // 利用IntersectionObserver监听el\n    observe(el){\n        let io = new IntersectionObserver(entries => {\n            let realSrc = el.dataset.src;\n            if(entries[0].isIntersecting){\n                if(realSrc){\n                    el.src = realSrc;\n                    el.removeAttribute('data-src');\n                }\n            }\n        });\n        io.observe(el);\n    },\n    // 监听scroll事件\n    listenerScroll(el){\n        let handler = LazyLoad.throttle(LazyLoad.load,300);\n        LazyLoad.load(el);\n        window.addEventListener('scroll',() => {\n            handler(el);\n        });\n    },\n    // 加载真实图片\n    load(el){\n        let windowHeight = document.documentElement.clientHeight\n        let elTop = el.getBoundingClientRect().top;\n        let elBtm = el.getBoundingClientRect().bottom;\n        let realSrc = el.dataset.src;\n        if(elTop - windowHeight<0&&elBtm > 0){\n            if(realSrc){\n                el.src = realSrc;\n                el.removeAttribute('data-src');\n            }\n        }\n    },\n    // 节流\n    throttle(fn,delay){\n        let timer; \n        let prevTime;\n        return function(...args){\n            let currTime = Date.now();\n            let context = this;\n            if(!prevTime) prevTime = currTime;\n            clearTimeout(timer);\n            \n            if(currTime - prevTime > delay){\n                prevTime = currTime;\n                fn.apply(context,args);\n                clearTimeout(timer);\n                return;\n            }\n\n            timer = setTimeout(function(){\n                prevTime = Date.now();\n                timer = null;\n                fn.apply(context,args);\n            },delay);\n        }\n    }\n\n}\nexport default LazyLoad;\n```\n·一键copy的功能\n```bash\nimport { Message } from 'ant-design-vue';\n\nconst vCopy = { //\n  /*\n    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置\n    el: 作用的 dom 对象\n    value: 传给指令的值，也就是我们要 copy 的值\n  */\n  bind(el, { value }) {\n    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到\n    el.handler = () => {\n      if (!el.$value) {\n      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意\n        Message.warning('无复制内容');\n        return;\n      }\n      // 动态创建 textarea 标签\n      const textarea = document.createElement('textarea');\n      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域\n      textarea.readOnly = 'readonly';\n      textarea.style.position = 'absolute';\n      textarea.style.left = '-9999px';\n      // 将要 copy 的值赋给 textarea 标签的 value 属性\n      textarea.value = el.$value;\n      // 将 textarea 插入到 body 中\n      document.body.appendChild(textarea);\n      // 选中值并复制\n      textarea.select();\n      // textarea.setSelectionRange(0, textarea.value.length);\n      const result = document.execCommand('Copy');\n      if (result) {\n        Message.success('复制成功');\n      }\n      document.body.removeChild(textarea);\n    };\n    // 绑定点击事件，就是所谓的一键 copy 啦\n    el.addEventListener('click', el.handler);\n  },\n  // 当传进来的值更新的时候触发\n  componentUpdated(el, { value }) {\n    el.$value = value;\n  },\n  // 指令与元素解绑的时候，移除事件绑定\n  unbind(el) {\n    el.removeEventListener('click', el.handler);\n  },\n};\n\nexport default vCopy;\n```\n还有拖拽指令、页面水印、权限校验等等\n\n\n\n","source":"_posts/Vue指令.md","raw":"---\ntitle: Vue指令\ndate: 2021-02-25 14:05:04\ntags:\n - 前端框架\n - Vue\ncategories: web前端\n---\n## 1.指令是啥？\nVue有一套为数据驱动视图更方便的指令系统。v-开头的行内属性都是指令，不同指令可以实现不同的功能。\n\n## 2.如何实现？\n局部注册，全局注册。通过Vue.directive注册。\n全局注册：\n```bash\nVue.directive('focus', { // 注册v-focus指令\n   inserted: function (el) {\n      el.focus() // 让元素自动聚焦\n   }\n})\n```\n局部注册：\n```bash\ndirectives: {\n   focus: {\n      inserted: function (el) {\n         el.focus() //功能同上\n      }\n   }\n}\n```\n模板中的使用：\n```bash\n<input v-focus />\n```\n\n自定义指令也存在钩子函数：\n·bind：只调用一次，指令第一次绑定到元素时使用。初始化设置。\n·inserted：被绑定元素插入父节点时调用\n·update：所在组件VNode更新时调用\n·componentUpdated：所在组件VNode和子VNode全部更新后调用\n·unbind：只调用一次，指令与元素解绑时调用\n钩子函数的参数有：\n·el：指令绑定的元素，可操作DOM\n·binding：一个对象，包含name,value,oldValue,expression,arg,modifiers\n·vnode：虚拟节点\n·oldVnode：上一个虚拟节点\n\n## 3.应用场景\n·防抖\n```bash\n// 1.设置v-throttle自定义指令\nVue.directive('throttle', {\n  bind: (el, binding) => {\n    let throttleTime = binding.value; // 防抖时间\n    if (!throttleTime) { // 用户若不设置防抖时间，则默认2s\n      throttleTime = 2000;\n    }\n    let cbFun;\n    el.addEventListener('click', event => {\n      if (!cbFun) { // 第一次执行\n        cbFun = setTimeout(() => {\n          cbFun = null;\n        }, throttleTime);\n      } else {\n        event && event.stopImmediatePropagation();\n      }\n    }, true);\n  },\n});\n// 2.为button标签设置v-throttle自定义指令\n<button @click=\"sayHello\" v-throttle>提交</button>\n```\n·图片懒加载\n```bash\n// 1.设置v-throttle自定义指令\nVue.directive('throttle', {\n  bind: (el, binding) => {\n    let throttleTime = binding.value; // 防抖时间\n    if (!throttleTime) { // 用户若不设置防抖时间，则默认2s\n      throttleTime = 2000;\n    }\n    let cbFun;\n    el.addEventListener('click', event => {\n      if (!cbFun) { // 第一次执行\n        cbFun = setTimeout(() => {\n          cbFun = null;\n        }, throttleTime);\n      } else {\n        event && event.stopImmediatePropagation();\n      }\n    }, true);\n  },\n});\n// 2.为button标签设置v-throttle自定义指令\n<button @click=\"sayHello\" v-throttle>提交</button>\n图片懒加载\n设置一个v-lazy自定义组件完成图片懒加载\nconst LazyLoad = {\n    // install方法\n    install(Vue,options){\n       // 代替图片的loading图\n        let defaultSrc = options.default;\n        Vue.directive('lazy',{\n            bind(el,binding){\n                LazyLoad.init(el,binding.value,defaultSrc);\n            },\n            inserted(el){\n                // 兼容处理\n                if('IntersectionObserver' in window){\n                    LazyLoad.observe(el);\n                }else{\n                    LazyLoad.listenerScroll(el);\n                }\n                \n            },\n        })\n    },\n    // 初始化\n    init(el,val,def){\n        // data-src 储存真实src\n        el.setAttribute('data-src',val);\n        // 设置src为loading图\n        el.setAttribute('src',def);\n    },\n    // 利用IntersectionObserver监听el\n    observe(el){\n        let io = new IntersectionObserver(entries => {\n            let realSrc = el.dataset.src;\n            if(entries[0].isIntersecting){\n                if(realSrc){\n                    el.src = realSrc;\n                    el.removeAttribute('data-src');\n                }\n            }\n        });\n        io.observe(el);\n    },\n    // 监听scroll事件\n    listenerScroll(el){\n        let handler = LazyLoad.throttle(LazyLoad.load,300);\n        LazyLoad.load(el);\n        window.addEventListener('scroll',() => {\n            handler(el);\n        });\n    },\n    // 加载真实图片\n    load(el){\n        let windowHeight = document.documentElement.clientHeight\n        let elTop = el.getBoundingClientRect().top;\n        let elBtm = el.getBoundingClientRect().bottom;\n        let realSrc = el.dataset.src;\n        if(elTop - windowHeight<0&&elBtm > 0){\n            if(realSrc){\n                el.src = realSrc;\n                el.removeAttribute('data-src');\n            }\n        }\n    },\n    // 节流\n    throttle(fn,delay){\n        let timer; \n        let prevTime;\n        return function(...args){\n            let currTime = Date.now();\n            let context = this;\n            if(!prevTime) prevTime = currTime;\n            clearTimeout(timer);\n            \n            if(currTime - prevTime > delay){\n                prevTime = currTime;\n                fn.apply(context,args);\n                clearTimeout(timer);\n                return;\n            }\n\n            timer = setTimeout(function(){\n                prevTime = Date.now();\n                timer = null;\n                fn.apply(context,args);\n            },delay);\n        }\n    }\n\n}\nexport default LazyLoad;\n```\n·一键copy的功能\n```bash\nimport { Message } from 'ant-design-vue';\n\nconst vCopy = { //\n  /*\n    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置\n    el: 作用的 dom 对象\n    value: 传给指令的值，也就是我们要 copy 的值\n  */\n  bind(el, { value }) {\n    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到\n    el.handler = () => {\n      if (!el.$value) {\n      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意\n        Message.warning('无复制内容');\n        return;\n      }\n      // 动态创建 textarea 标签\n      const textarea = document.createElement('textarea');\n      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域\n      textarea.readOnly = 'readonly';\n      textarea.style.position = 'absolute';\n      textarea.style.left = '-9999px';\n      // 将要 copy 的值赋给 textarea 标签的 value 属性\n      textarea.value = el.$value;\n      // 将 textarea 插入到 body 中\n      document.body.appendChild(textarea);\n      // 选中值并复制\n      textarea.select();\n      // textarea.setSelectionRange(0, textarea.value.length);\n      const result = document.execCommand('Copy');\n      if (result) {\n        Message.success('复制成功');\n      }\n      document.body.removeChild(textarea);\n    };\n    // 绑定点击事件，就是所谓的一键 copy 啦\n    el.addEventListener('click', el.handler);\n  },\n  // 当传进来的值更新的时候触发\n  componentUpdated(el, { value }) {\n    el.$value = value;\n  },\n  // 指令与元素解绑的时候，移除事件绑定\n  unbind(el) {\n    el.removeEventListener('click', el.handler);\n  },\n};\n\nexport default vCopy;\n```\n还有拖拽指令、页面水印、权限校验等等\n\n\n\n","slug":"Vue指令","published":1,"updated":"2021-02-25T08:14:15.888Z","_id":"cklkl9v410001ksvaef75a51m","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-指令是啥？\"><a href=\"#1-指令是啥？\" class=\"headerlink\" title=\"1.指令是啥？\"></a>1.指令是啥？</h2><p>Vue有一套为数据驱动视图更方便的指令系统。v-开头的行内属性都是指令，不同指令可以实现不同的功能。</p>\n<h2 id=\"2-如何实现？\"><a href=\"#2-如何实现？\" class=\"headerlink\" title=\"2.如何实现？\"></a>2.如何实现？</h2><p>局部注册，全局注册。通过Vue.directive注册。<br>全局注册：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123; // 注册v-focus指令</span><br><span class=\"line\">   inserted: <span class=\"keyword\">function</span> (el) &#123;</span><br><span class=\"line\">      el.focus() // 让元素自动聚焦</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>局部注册：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">directives: &#123;</span><br><span class=\"line\">   focus: &#123;</span><br><span class=\"line\">      inserted: <span class=\"keyword\">function</span> (el) &#123;</span><br><span class=\"line\">         el.focus() //功能同上</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模板中的使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>自定义指令也存在钩子函数：<br>·bind：只调用一次，指令第一次绑定到元素时使用。初始化设置。<br>·inserted：被绑定元素插入父节点时调用<br>·update：所在组件VNode更新时调用<br>·componentUpdated：所在组件VNode和子VNode全部更新后调用<br>·unbind：只调用一次，指令与元素解绑时调用<br>钩子函数的参数有：<br>·el：指令绑定的元素，可操作DOM<br>·binding：一个对象，包含name,value,oldValue,expression,arg,modifiers<br>·vnode：虚拟节点<br>·oldVnode：上一个虚拟节点</p>\n<h2 id=\"3-应用场景\"><a href=\"#3-应用场景\" class=\"headerlink\" title=\"3.应用场景\"></a>3.应用场景</h2><p>·防抖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.设置v-throttle自定义指令</span><br><span class=\"line\">Vue.directive(<span class=\"string\">'throttle'</span>, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bind</span>: (el, binding) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class=\"line\">      throttleTime = 2000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> cbFun;</span><br><span class=\"line\">    el.addEventListener(<span class=\"string\">'click'</span>, event =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class=\"line\">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          cbFun = null;</span><br><span class=\"line\">        &#125;, throttleTime);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 2.为button标签设置v-throttle自定义指令</span><br><span class=\"line\">&lt;button @click=<span class=\"string\">\"sayHello\"</span> v-throttle&gt;提交&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<p>·图片懒加载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.设置v-throttle自定义指令</span><br><span class=\"line\">Vue.directive(<span class=\"string\">'throttle'</span>, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bind</span>: (el, binding) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class=\"line\">      throttleTime = 2000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> cbFun;</span><br><span class=\"line\">    el.addEventListener(<span class=\"string\">'click'</span>, event =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class=\"line\">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          cbFun = null;</span><br><span class=\"line\">        &#125;, throttleTime);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 2.为button标签设置v-throttle自定义指令</span><br><span class=\"line\">&lt;button @click=<span class=\"string\">\"sayHello\"</span> v-throttle&gt;提交&lt;/button&gt;</span><br><span class=\"line\">图片懒加载</span><br><span class=\"line\">设置一个v-lazy自定义组件完成图片懒加载</span><br><span class=\"line\">const LazyLoad = &#123;</span><br><span class=\"line\">    // install方法</span><br><span class=\"line\">    install(Vue,options)&#123;</span><br><span class=\"line\">       // 代替图片的loading图</span><br><span class=\"line\">        <span class=\"built_in\">let</span> defaultSrc = options.default;</span><br><span class=\"line\">        Vue.directive(<span class=\"string\">'lazy'</span>,&#123;</span><br><span class=\"line\">            <span class=\"built_in\">bind</span>(el,binding)&#123;</span><br><span class=\"line\">                LazyLoad.init(el,binding.value,defaultSrc);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            inserted(el)&#123;</span><br><span class=\"line\">                // 兼容处理</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"string\">'IntersectionObserver'</span> <span class=\"keyword\">in</span> window)&#123;</span><br><span class=\"line\">                    LazyLoad.observe(el);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    LazyLoad.listenerScroll(el);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 初始化</span><br><span class=\"line\">    init(el,val,def)&#123;</span><br><span class=\"line\">        // data-src 储存真实src</span><br><span class=\"line\">        el.setAttribute(<span class=\"string\">'data-src'</span>,val);</span><br><span class=\"line\">        // 设置src为loading图</span><br><span class=\"line\">        el.setAttribute(<span class=\"string\">'src'</span>,def);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 利用IntersectionObserver监听el</span><br><span class=\"line\">    observe(el)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> io = new IntersectionObserver(entries =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">let</span> realSrc = el.dataset.src;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(entries[0].isIntersecting)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(realSrc)&#123;</span><br><span class=\"line\">                    el.src = realSrc;</span><br><span class=\"line\">                    el.removeAttribute(<span class=\"string\">'data-src'</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        io.observe(el);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 监听scroll事件</span><br><span class=\"line\">    listenerScroll(el)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> handler = LazyLoad.throttle(LazyLoad.load,300);</span><br><span class=\"line\">        LazyLoad.load(el);</span><br><span class=\"line\">        window.addEventListener(<span class=\"string\">'scroll'</span>,() =&gt; &#123;</span><br><span class=\"line\">            handler(el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 加载真实图片</span><br><span class=\"line\">    load(el)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> windowHeight = document.documentElement.clientHeight</span><br><span class=\"line\">        <span class=\"built_in\">let</span> elTop = el.getBoundingClientRect().top;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> elBtm = el.getBoundingClientRect().bottom;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> realSrc = el.dataset.src;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(realSrc)&#123;</span><br><span class=\"line\">                el.src = realSrc;</span><br><span class=\"line\">                el.removeAttribute(<span class=\"string\">'data-src'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 节流</span><br><span class=\"line\">    throttle(fn,delay)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> timer; </span><br><span class=\"line\">        <span class=\"built_in\">let</span> prevTime;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"keyword\">function</span>(...args)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">let</span> currTime = Date.now();</span><br><span class=\"line\">            <span class=\"built_in\">let</span> context = this;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!prevTime) prevTime = currTime;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(currTime - prevTime &gt; delay)&#123;</span><br><span class=\"line\">                prevTime = currTime;</span><br><span class=\"line\">                fn.apply(context,args);</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\">                <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            timer = setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                prevTime = Date.now();</span><br><span class=\"line\">                timer = null;</span><br><span class=\"line\">                fn.apply(context,args);</span><br><span class=\"line\">            &#125;,delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">export</span> default LazyLoad;</span><br></pre></td></tr></table></figure>\n<p>·一键copy的功能</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Message &#125; from <span class=\"string\">'ant-design-vue'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">const vCopy = &#123; //</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> 钩子函数，第一次绑定时调用，可以在这里做初始化设置</span><br><span class=\"line\">    el: 作用的 dom 对象</span><br><span class=\"line\">    value: 传给指令的值，也就是我们要 copy 的值</span><br><span class=\"line\">  */</span><br><span class=\"line\">  <span class=\"built_in\">bind</span>(el, &#123; value &#125;) &#123;</span><br><span class=\"line\">    el.<span class=\"variable\">$value</span> = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到</span><br><span class=\"line\">    el.handler = () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!el.<span class=\"variable\">$value</span>) &#123;</span><br><span class=\"line\">      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意</span><br><span class=\"line\">        Message.warning(<span class=\"string\">'无复制内容'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 动态创建 textarea 标签</span><br><span class=\"line\">      const textarea = document.createElement(<span class=\"string\">'textarea'</span>);</span><br><span class=\"line\">      // 将该 textarea 设为 <span class=\"built_in\">readonly</span> 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span><br><span class=\"line\">      textarea.readOnly = <span class=\"string\">'readonly'</span>;</span><br><span class=\"line\">      textarea.style.position = <span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">      textarea.style.left = <span class=\"string\">'-9999px'</span>;</span><br><span class=\"line\">      // 将要 copy 的值赋给 textarea 标签的 value 属性</span><br><span class=\"line\">      textarea.value = el.<span class=\"variable\">$value</span>;</span><br><span class=\"line\">      // 将 textarea 插入到 body 中</span><br><span class=\"line\">      document.body.appendChild(textarea);</span><br><span class=\"line\">      // 选中值并复制</span><br><span class=\"line\">      textarea.select();</span><br><span class=\"line\">      // textarea.setSelectionRange(0, textarea.value.length);</span><br><span class=\"line\">      const result = document.execCommand(<span class=\"string\">'Copy'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        Message.success(<span class=\"string\">'复制成功'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      document.body.removeChild(textarea);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 绑定点击事件，就是所谓的一键 copy 啦</span><br><span class=\"line\">    el.addEventListener(<span class=\"string\">'click'</span>, el.handler);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 当传进来的值更新的时候触发</span><br><span class=\"line\">  componentUpdated(el, &#123; value &#125;) &#123;</span><br><span class=\"line\">    el.<span class=\"variable\">$value</span> = value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 指令与元素解绑的时候，移除事件绑定</span><br><span class=\"line\">  unbind(el) &#123;</span><br><span class=\"line\">    el.removeEventListener(<span class=\"string\">'click'</span>, el.handler);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default vCopy;</span><br></pre></td></tr></table></figure>\n<p>还有拖拽指令、页面水印、权限校验等等</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-指令是啥？\"><a href=\"#1-指令是啥？\" class=\"headerlink\" title=\"1.指令是啥？\"></a>1.指令是啥？</h2><p>Vue有一套为数据驱动视图更方便的指令系统。v-开头的行内属性都是指令，不同指令可以实现不同的功能。</p>\n<h2 id=\"2-如何实现？\"><a href=\"#2-如何实现？\" class=\"headerlink\" title=\"2.如何实现？\"></a>2.如何实现？</h2><p>局部注册，全局注册。通过Vue.directive注册。<br>全局注册：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'focus'</span>, &#123; // 注册v-focus指令</span><br><span class=\"line\">   inserted: <span class=\"keyword\">function</span> (el) &#123;</span><br><span class=\"line\">      el.focus() // 让元素自动聚焦</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>局部注册：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">directives: &#123;</span><br><span class=\"line\">   focus: &#123;</span><br><span class=\"line\">      inserted: <span class=\"keyword\">function</span> (el) &#123;</span><br><span class=\"line\">         el.focus() //功能同上</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模板中的使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>自定义指令也存在钩子函数：<br>·bind：只调用一次，指令第一次绑定到元素时使用。初始化设置。<br>·inserted：被绑定元素插入父节点时调用<br>·update：所在组件VNode更新时调用<br>·componentUpdated：所在组件VNode和子VNode全部更新后调用<br>·unbind：只调用一次，指令与元素解绑时调用<br>钩子函数的参数有：<br>·el：指令绑定的元素，可操作DOM<br>·binding：一个对象，包含name,value,oldValue,expression,arg,modifiers<br>·vnode：虚拟节点<br>·oldVnode：上一个虚拟节点</p>\n<h2 id=\"3-应用场景\"><a href=\"#3-应用场景\" class=\"headerlink\" title=\"3.应用场景\"></a>3.应用场景</h2><p>·防抖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.设置v-throttle自定义指令</span><br><span class=\"line\">Vue.directive(<span class=\"string\">'throttle'</span>, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bind</span>: (el, binding) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class=\"line\">      throttleTime = 2000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> cbFun;</span><br><span class=\"line\">    el.addEventListener(<span class=\"string\">'click'</span>, event =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class=\"line\">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          cbFun = null;</span><br><span class=\"line\">        &#125;, throttleTime);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 2.为button标签设置v-throttle自定义指令</span><br><span class=\"line\">&lt;button @click=<span class=\"string\">\"sayHello\"</span> v-throttle&gt;提交&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n<p>·图片懒加载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.设置v-throttle自定义指令</span><br><span class=\"line\">Vue.directive(<span class=\"string\">'throttle'</span>, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bind</span>: (el, binding) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> throttleTime = binding.value; // 防抖时间</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!throttleTime) &#123; // 用户若不设置防抖时间，则默认2s</span><br><span class=\"line\">      throttleTime = 2000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">let</span> cbFun;</span><br><span class=\"line\">    el.addEventListener(<span class=\"string\">'click'</span>, event =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cbFun) &#123; // 第一次执行</span><br><span class=\"line\">        cbFun = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          cbFun = null;</span><br><span class=\"line\">        &#125;, throttleTime);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        event &amp;&amp; event.stopImmediatePropagation();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 2.为button标签设置v-throttle自定义指令</span><br><span class=\"line\">&lt;button @click=<span class=\"string\">\"sayHello\"</span> v-throttle&gt;提交&lt;/button&gt;</span><br><span class=\"line\">图片懒加载</span><br><span class=\"line\">设置一个v-lazy自定义组件完成图片懒加载</span><br><span class=\"line\">const LazyLoad = &#123;</span><br><span class=\"line\">    // install方法</span><br><span class=\"line\">    install(Vue,options)&#123;</span><br><span class=\"line\">       // 代替图片的loading图</span><br><span class=\"line\">        <span class=\"built_in\">let</span> defaultSrc = options.default;</span><br><span class=\"line\">        Vue.directive(<span class=\"string\">'lazy'</span>,&#123;</span><br><span class=\"line\">            <span class=\"built_in\">bind</span>(el,binding)&#123;</span><br><span class=\"line\">                LazyLoad.init(el,binding.value,defaultSrc);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            inserted(el)&#123;</span><br><span class=\"line\">                // 兼容处理</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"string\">'IntersectionObserver'</span> <span class=\"keyword\">in</span> window)&#123;</span><br><span class=\"line\">                    LazyLoad.observe(el);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    LazyLoad.listenerScroll(el);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 初始化</span><br><span class=\"line\">    init(el,val,def)&#123;</span><br><span class=\"line\">        // data-src 储存真实src</span><br><span class=\"line\">        el.setAttribute(<span class=\"string\">'data-src'</span>,val);</span><br><span class=\"line\">        // 设置src为loading图</span><br><span class=\"line\">        el.setAttribute(<span class=\"string\">'src'</span>,def);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 利用IntersectionObserver监听el</span><br><span class=\"line\">    observe(el)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> io = new IntersectionObserver(entries =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">let</span> realSrc = el.dataset.src;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(entries[0].isIntersecting)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(realSrc)&#123;</span><br><span class=\"line\">                    el.src = realSrc;</span><br><span class=\"line\">                    el.removeAttribute(<span class=\"string\">'data-src'</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        io.observe(el);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 监听scroll事件</span><br><span class=\"line\">    listenerScroll(el)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> handler = LazyLoad.throttle(LazyLoad.load,300);</span><br><span class=\"line\">        LazyLoad.load(el);</span><br><span class=\"line\">        window.addEventListener(<span class=\"string\">'scroll'</span>,() =&gt; &#123;</span><br><span class=\"line\">            handler(el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 加载真实图片</span><br><span class=\"line\">    load(el)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> windowHeight = document.documentElement.clientHeight</span><br><span class=\"line\">        <span class=\"built_in\">let</span> elTop = el.getBoundingClientRect().top;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> elBtm = el.getBoundingClientRect().bottom;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> realSrc = el.dataset.src;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(realSrc)&#123;</span><br><span class=\"line\">                el.src = realSrc;</span><br><span class=\"line\">                el.removeAttribute(<span class=\"string\">'data-src'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 节流</span><br><span class=\"line\">    throttle(fn,delay)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">let</span> timer; </span><br><span class=\"line\">        <span class=\"built_in\">let</span> prevTime;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"keyword\">function</span>(...args)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">let</span> currTime = Date.now();</span><br><span class=\"line\">            <span class=\"built_in\">let</span> context = this;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!prevTime) prevTime = currTime;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(currTime - prevTime &gt; delay)&#123;</span><br><span class=\"line\">                prevTime = currTime;</span><br><span class=\"line\">                fn.apply(context,args);</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\">                <span class=\"built_in\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            timer = setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">                prevTime = Date.now();</span><br><span class=\"line\">                timer = null;</span><br><span class=\"line\">                fn.apply(context,args);</span><br><span class=\"line\">            &#125;,delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">export</span> default LazyLoad;</span><br></pre></td></tr></table></figure>\n<p>·一键copy的功能</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Message &#125; from <span class=\"string\">'ant-design-vue'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">const vCopy = &#123; //</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    <span class=\"built_in\">bind</span> 钩子函数，第一次绑定时调用，可以在这里做初始化设置</span><br><span class=\"line\">    el: 作用的 dom 对象</span><br><span class=\"line\">    value: 传给指令的值，也就是我们要 copy 的值</span><br><span class=\"line\">  */</span><br><span class=\"line\">  <span class=\"built_in\">bind</span>(el, &#123; value &#125;) &#123;</span><br><span class=\"line\">    el.<span class=\"variable\">$value</span> = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到</span><br><span class=\"line\">    el.handler = () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!el.<span class=\"variable\">$value</span>) &#123;</span><br><span class=\"line\">      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意</span><br><span class=\"line\">        Message.warning(<span class=\"string\">'无复制内容'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 动态创建 textarea 标签</span><br><span class=\"line\">      const textarea = document.createElement(<span class=\"string\">'textarea'</span>);</span><br><span class=\"line\">      // 将该 textarea 设为 <span class=\"built_in\">readonly</span> 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span><br><span class=\"line\">      textarea.readOnly = <span class=\"string\">'readonly'</span>;</span><br><span class=\"line\">      textarea.style.position = <span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">      textarea.style.left = <span class=\"string\">'-9999px'</span>;</span><br><span class=\"line\">      // 将要 copy 的值赋给 textarea 标签的 value 属性</span><br><span class=\"line\">      textarea.value = el.<span class=\"variable\">$value</span>;</span><br><span class=\"line\">      // 将 textarea 插入到 body 中</span><br><span class=\"line\">      document.body.appendChild(textarea);</span><br><span class=\"line\">      // 选中值并复制</span><br><span class=\"line\">      textarea.select();</span><br><span class=\"line\">      // textarea.setSelectionRange(0, textarea.value.length);</span><br><span class=\"line\">      const result = document.execCommand(<span class=\"string\">'Copy'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        Message.success(<span class=\"string\">'复制成功'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      document.body.removeChild(textarea);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 绑定点击事件，就是所谓的一键 copy 啦</span><br><span class=\"line\">    el.addEventListener(<span class=\"string\">'click'</span>, el.handler);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 当传进来的值更新的时候触发</span><br><span class=\"line\">  componentUpdated(el, &#123; value &#125;) &#123;</span><br><span class=\"line\">    el.<span class=\"variable\">$value</span> = value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 指令与元素解绑的时候，移除事件绑定</span><br><span class=\"line\">  unbind(el) &#123;</span><br><span class=\"line\">    el.removeEventListener(<span class=\"string\">'click'</span>, el.handler);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> default vCopy;</span><br></pre></td></tr></table></figure>\n<p>还有拖拽指令、页面水印、权限校验等等</p>\n"},{"title":"JavaScript基础","date":"2021-02-26T07:17:21.000Z","_content":"## 1. 原型链\n每个函数都有prototype，指向了一个对象，该对象为实例的原型。\n每个JS对象（除了null）都具有_proto_属性，指向该对象的原型。\n每个原型都具有constructor属性，指向关联的构造函数。\nObject.prototype._proto_为null代表该对象没有原型。\n## 2. 继承\n - 原型链继承\n```\nfunction Parent () {\n    this.name = 'kevin';\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nconsole.log(child1.getName()) // kevin\n\nvar child1 = new Child(); // 引用类型的属性被所有实例共享\n\nchild1.names.push('yayu'); \n\nconsole.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]\n\nvar child2 = new Child(); // 创建child实例时无法向Parent传参\n\nconsole.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"]\n```\n - 借用构造函数（经典继承）\n```\nfunction Parent () {\n    this.names = ['kevin', 'daisy'];\n}\n\nfunction Child () {\n    Parent.call(this);\n}\n\nvar child1 = new Child();\n\nchild1.names.push('yayu');\n\nconsole.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // [\"kevin\", \"daisy\"]\n\nfunction Parent (name) {\n    this.name = name;\n}\n\nfunction Child (name) {\n    Parent.call(this, name);\n}\n\nvar child1 = new Child('kevin');\n\nconsole.log(child1.name); // kevin\n\nvar child2 = new Child('daisy');\n\nconsole.log(child2.name); // daisy\n```\n优点：\n1.避免了引用类型的属性被所有实例共享\n2.可以在Child中向Parent传参\n缺点：\n方法都在构造函数中定义，每次创建实例都会创建一遍方法。\n - 组合继承\n原型链继承和经典继承合并。\n```\nfunction Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n    Parent.call(this, name);\n    \n    this.age = age;\n\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('kevin', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // kevin\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\nvar child2 = new Child('daisy', '20');\n\nconsole.log(child2.name); // daisy\nconsole.log(child2.age); // 20\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n```\n融合原型链和构造函数的优点，最常用的继承模式。\n - 原型式继承\n```\nfunction createObj(o) {\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n```\nES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。\n缺点：\n包含引用类型的属性值始终会共享相应的值，与原型链继承一样。\n - 寄生式继承\n创建一个仅用与封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。\n```\nfunction createObj (o) {\n    var clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n```\n缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。\n - 寄生组合式继承\n```\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\n// 关键的三步\nvar F = function () {};\n\nF.prototype = Parent.prototype;\n\nChild.prototype = new F();\n\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n//封装\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction prototype(child, parent) {\n    var prototype = object(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\n// 当我们使用的时候：\nprototype(Child, Parent);\n```\n普遍认为是最理想的继承范式。\n## 3. 作用域\n对于每个执行上下文，都有三个重要属性：\n - 变量对象（Variable）\n - 作用域链（Scope）\n - this\n全局作用域：\nwindow对象的上下文\n块级作用域：\n用let声明的代码块{}内\n函数作用域：\n函数上下文的作用域{}内\n作用域链：\n不断向上访问，直到全局作用域\n## 4. 闭包\n理解：引用另一个函数作用域中变量的函数。\n闭包可以传入this对象作为参数，通过该对象访问this上下文的值。\n由于闭包会保留他们包含函数的作用域，所以使用闭包要注意，内存的回收。\n## 5. 变量提升\nvar声明的变量和方法，都会提升到全局对象上。\n全局对象就是由Object构造函数实例化的一个对象。\n函数上下文的变量对象初始化只包括Arguments对象\n在进入执行上下文时会给变量对象添加形参(arguments)、函数声明(func)、变量声明(var)等初始化的属性值\n在代码执行阶段，会再次修改变量对象的属性值\n进入执行上下文中，首先会处理函数声明，其次处理变量声明，如果变量名称跟已声明的元素相同，则声明不会干扰已经存在的这类属性。\n## 6. this的指向\n执行上下文都有this属性\n标准函数中，this引用的是把函数当成方法调用的上下值。\n箭头函数会保留定义它时的上下文\n## 7. 立即执行函数\n调用需要在后面添加()，也需要在前面将函数用()包裹。\n后面的()可以用来传值，立即执行会保存闭包的状态。\n前面的()包裹函数则被解析成表达式，匿名函数后面的()被用于调用，将前面的函数当成声明。\nIIFE（立即自执行）\n模块模式：\n```\nvar counter = (function(){\n    var i = 0;\n    return {\n        get: function(){\n            return i;\n        },\n        set: function(val){\n            i = val;\n        },\n        increment: function(){\n            return ++i;\n        }\n    }\n    }());\n    counter.get();//0\n    counter.set(3);\n    counter.increment();//4\n    counter.increment();//5\n\n    conuter.i;//undefined (`i` is not a property of the returned object)\n    i;//ReferenceError: i is not defined (it only exists inside the closure)\n```\n最小化了全局变量的污染，创造了使用变量。\n## 8. instanceof原理\ntypeof也可用于判断object类型，但判断null会显示object。(typeof用于判断基本数据类型，包括symbol都是没问题的，避免null)\ninstanceof用于判断object类型，判断null时会报错，显示null不是object。\n也可使用Object.prototype.toString来判断一个变量的类型（比较准确）。\n原理：\n根据原型链判断，遍历原型链查找相同的类型。\n一边查找函数的原型，一边查找实例的原型。\n总结：准确判断对象实例类型，可以使用Object.prototype.toString.call，\ntypeof只适合判断基本数据类型，instanceof判断null为Object。\n## 9. bind的实现\nbind()方法会创建一个新的函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。\nbind特点：\n - 返回一个函数\n - 可以传入参数\n当bind返回的函数作为构造函数时，bind指定的this会失效，但参数生效。\n```\nFunction.prototype.bind2 = function (context) {\n\n    if (typeof this !== \"function\") {\n      throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fNOP = function () {};\n\n    var fBound = function () {\n        var bindArgs = Array.prototype.slice.call(arguments);\n        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));\n    }\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n}\n```\n## 10. apply和call\n共同点：\n - 改变上下文tihs\n - 必须是函数调用\n区别：\n - call传入多个参数\n - apply传入参数数组或类数组(具有length和for遍历)\ncall使用场景：\n1.继承对象\n2.借用方法\napply使用场景：\n1.Math.max\n2.两个数组合并\n3.实现bind\n## 11. 柯里化\n定义：将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n用途：参数复用，降低通用性，提高适用性。\n实现：\n```\nvar curry = function (fn) {\n    var args = [].slice.call(arguments, 1);\n    return function() {\n        var newArgs = args.concat([].slice.call(arguments));\n        return fn.apply(this, newArgs);\n    };\n};\n```\n本质上是用函数包裹原函数，给原函数传入之前的参数，当执行func()()时，执行包裹函数，返回原函数，调用sub_curry再包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的书目达到要求为止。\n## 12. v8垃圾回收机制\n1.为什么要垃圾回收？\n避免内存泄漏，性能下降\n2.V8引擎内存限制\n64位系统，1.4G\n32位系统，0.7G\n由于JS单线程机制，垃圾回收会影响程序执行。为了减少对应用的性能影响，V8直接限制内存大小。\n3.V8的垃圾回收策略\n分代式垃圾回收机制，根据存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。\nV8有如下内存结构：\n - 新生代：一般分配内存，一般用于垃圾回收时保存保留对象\n - 老生代：新生代对象一段时候后转移的地方\n - 大对象区：存放体积较大的对象，垃圾回收不会移动该区\n - 代码区：代码对象，会被分配在这里，唯一拥有执行权限的内存区域\n - map区：存放cell和map，区域存放相同大小\n新生代回收算法：\nScavenge算法：Cheney算法，二分空间From和To，先From，回收时复制到To，然后将To变成From，From清空变为To。\n对象晋升：\n多次存活后转到老生代的对象，过程称为对象晋升。\n条件：\n - 经过过一次Scavenge算法\n - To空间的内存占比超过25%\n老生代回收算法：\n采用Mark-Sweep标记清除和Mark-Compact标记清理算法\n引用计数，如果对象没有被指针引用，则被视为垃圾回收。\n4. 避免内存泄漏\n - 尽可能减少全局变量\n - 手动清除计时器\n - 少用闭包\n - 清除DOM引用\n - 弱引用\n5. 总结\n新生代，老生代，算法，垃圾回收机制，避免内存泄漏。\n## 13. 浮点数精度\n## 14. new操作符\n## 15. 事件循环机制\n## 16. promise原理\n## 17. generator原理","source":"_posts/JavaScript基础.md","raw":"---\ntitle: JavaScript基础\ndate: 2021-02-26 15:17:21\ntags:\n - JavaScript\ncategories: web前端\n---\n## 1. 原型链\n每个函数都有prototype，指向了一个对象，该对象为实例的原型。\n每个JS对象（除了null）都具有_proto_属性，指向该对象的原型。\n每个原型都具有constructor属性，指向关联的构造函数。\nObject.prototype._proto_为null代表该对象没有原型。\n## 2. 继承\n - 原型链继承\n```\nfunction Parent () {\n    this.name = 'kevin';\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nconsole.log(child1.getName()) // kevin\n\nvar child1 = new Child(); // 引用类型的属性被所有实例共享\n\nchild1.names.push('yayu'); \n\nconsole.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]\n\nvar child2 = new Child(); // 创建child实例时无法向Parent传参\n\nconsole.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"]\n```\n - 借用构造函数（经典继承）\n```\nfunction Parent () {\n    this.names = ['kevin', 'daisy'];\n}\n\nfunction Child () {\n    Parent.call(this);\n}\n\nvar child1 = new Child();\n\nchild1.names.push('yayu');\n\nconsole.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // [\"kevin\", \"daisy\"]\n\nfunction Parent (name) {\n    this.name = name;\n}\n\nfunction Child (name) {\n    Parent.call(this, name);\n}\n\nvar child1 = new Child('kevin');\n\nconsole.log(child1.name); // kevin\n\nvar child2 = new Child('daisy');\n\nconsole.log(child2.name); // daisy\n```\n优点：\n1.避免了引用类型的属性被所有实例共享\n2.可以在Child中向Parent传参\n缺点：\n方法都在构造函数中定义，每次创建实例都会创建一遍方法。\n - 组合继承\n原型链继承和经典继承合并。\n```\nfunction Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n    Parent.call(this, name);\n    \n    this.age = age;\n\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('kevin', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // kevin\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\nvar child2 = new Child('daisy', '20');\n\nconsole.log(child2.name); // daisy\nconsole.log(child2.age); // 20\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n```\n融合原型链和构造函数的优点，最常用的继承模式。\n - 原型式继承\n```\nfunction createObj(o) {\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n```\nES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。\n缺点：\n包含引用类型的属性值始终会共享相应的值，与原型链继承一样。\n - 寄生式继承\n创建一个仅用与封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。\n```\nfunction createObj (o) {\n    var clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n```\n缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。\n - 寄生组合式继承\n```\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\n// 关键的三步\nvar F = function () {};\n\nF.prototype = Parent.prototype;\n\nChild.prototype = new F();\n\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n//封装\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction prototype(child, parent) {\n    var prototype = object(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\n// 当我们使用的时候：\nprototype(Child, Parent);\n```\n普遍认为是最理想的继承范式。\n## 3. 作用域\n对于每个执行上下文，都有三个重要属性：\n - 变量对象（Variable）\n - 作用域链（Scope）\n - this\n全局作用域：\nwindow对象的上下文\n块级作用域：\n用let声明的代码块{}内\n函数作用域：\n函数上下文的作用域{}内\n作用域链：\n不断向上访问，直到全局作用域\n## 4. 闭包\n理解：引用另一个函数作用域中变量的函数。\n闭包可以传入this对象作为参数，通过该对象访问this上下文的值。\n由于闭包会保留他们包含函数的作用域，所以使用闭包要注意，内存的回收。\n## 5. 变量提升\nvar声明的变量和方法，都会提升到全局对象上。\n全局对象就是由Object构造函数实例化的一个对象。\n函数上下文的变量对象初始化只包括Arguments对象\n在进入执行上下文时会给变量对象添加形参(arguments)、函数声明(func)、变量声明(var)等初始化的属性值\n在代码执行阶段，会再次修改变量对象的属性值\n进入执行上下文中，首先会处理函数声明，其次处理变量声明，如果变量名称跟已声明的元素相同，则声明不会干扰已经存在的这类属性。\n## 6. this的指向\n执行上下文都有this属性\n标准函数中，this引用的是把函数当成方法调用的上下值。\n箭头函数会保留定义它时的上下文\n## 7. 立即执行函数\n调用需要在后面添加()，也需要在前面将函数用()包裹。\n后面的()可以用来传值，立即执行会保存闭包的状态。\n前面的()包裹函数则被解析成表达式，匿名函数后面的()被用于调用，将前面的函数当成声明。\nIIFE（立即自执行）\n模块模式：\n```\nvar counter = (function(){\n    var i = 0;\n    return {\n        get: function(){\n            return i;\n        },\n        set: function(val){\n            i = val;\n        },\n        increment: function(){\n            return ++i;\n        }\n    }\n    }());\n    counter.get();//0\n    counter.set(3);\n    counter.increment();//4\n    counter.increment();//5\n\n    conuter.i;//undefined (`i` is not a property of the returned object)\n    i;//ReferenceError: i is not defined (it only exists inside the closure)\n```\n最小化了全局变量的污染，创造了使用变量。\n## 8. instanceof原理\ntypeof也可用于判断object类型，但判断null会显示object。(typeof用于判断基本数据类型，包括symbol都是没问题的，避免null)\ninstanceof用于判断object类型，判断null时会报错，显示null不是object。\n也可使用Object.prototype.toString来判断一个变量的类型（比较准确）。\n原理：\n根据原型链判断，遍历原型链查找相同的类型。\n一边查找函数的原型，一边查找实例的原型。\n总结：准确判断对象实例类型，可以使用Object.prototype.toString.call，\ntypeof只适合判断基本数据类型，instanceof判断null为Object。\n## 9. bind的实现\nbind()方法会创建一个新的函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。\nbind特点：\n - 返回一个函数\n - 可以传入参数\n当bind返回的函数作为构造函数时，bind指定的this会失效，但参数生效。\n```\nFunction.prototype.bind2 = function (context) {\n\n    if (typeof this !== \"function\") {\n      throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fNOP = function () {};\n\n    var fBound = function () {\n        var bindArgs = Array.prototype.slice.call(arguments);\n        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));\n    }\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n}\n```\n## 10. apply和call\n共同点：\n - 改变上下文tihs\n - 必须是函数调用\n区别：\n - call传入多个参数\n - apply传入参数数组或类数组(具有length和for遍历)\ncall使用场景：\n1.继承对象\n2.借用方法\napply使用场景：\n1.Math.max\n2.两个数组合并\n3.实现bind\n## 11. 柯里化\n定义：将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n用途：参数复用，降低通用性，提高适用性。\n实现：\n```\nvar curry = function (fn) {\n    var args = [].slice.call(arguments, 1);\n    return function() {\n        var newArgs = args.concat([].slice.call(arguments));\n        return fn.apply(this, newArgs);\n    };\n};\n```\n本质上是用函数包裹原函数，给原函数传入之前的参数，当执行func()()时，执行包裹函数，返回原函数，调用sub_curry再包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的书目达到要求为止。\n## 12. v8垃圾回收机制\n1.为什么要垃圾回收？\n避免内存泄漏，性能下降\n2.V8引擎内存限制\n64位系统，1.4G\n32位系统，0.7G\n由于JS单线程机制，垃圾回收会影响程序执行。为了减少对应用的性能影响，V8直接限制内存大小。\n3.V8的垃圾回收策略\n分代式垃圾回收机制，根据存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。\nV8有如下内存结构：\n - 新生代：一般分配内存，一般用于垃圾回收时保存保留对象\n - 老生代：新生代对象一段时候后转移的地方\n - 大对象区：存放体积较大的对象，垃圾回收不会移动该区\n - 代码区：代码对象，会被分配在这里，唯一拥有执行权限的内存区域\n - map区：存放cell和map，区域存放相同大小\n新生代回收算法：\nScavenge算法：Cheney算法，二分空间From和To，先From，回收时复制到To，然后将To变成From，From清空变为To。\n对象晋升：\n多次存活后转到老生代的对象，过程称为对象晋升。\n条件：\n - 经过过一次Scavenge算法\n - To空间的内存占比超过25%\n老生代回收算法：\n采用Mark-Sweep标记清除和Mark-Compact标记清理算法\n引用计数，如果对象没有被指针引用，则被视为垃圾回收。\n4. 避免内存泄漏\n - 尽可能减少全局变量\n - 手动清除计时器\n - 少用闭包\n - 清除DOM引用\n - 弱引用\n5. 总结\n新生代，老生代，算法，垃圾回收机制，避免内存泄漏。\n## 13. 浮点数精度\n## 14. new操作符\n## 15. 事件循环机制\n## 16. promise原理\n## 17. generator原理","slug":"JavaScript基础","published":1,"updated":"2021-03-25T07:07:27.018Z","_id":"cklm4c58i0000lgva0pz3e43i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-原型链\"><a href=\"#1-原型链\" class=\"headerlink\" title=\"1. 原型链\"></a>1. 原型链</h2><p>每个函数都有prototype，指向了一个对象，该对象为实例的原型。<br>每个JS对象（除了null）都具有_proto_属性，指向该对象的原型。<br>每个原型都具有constructor属性，指向关联的构造函数。<br>Object.prototype._proto_为null代表该对象没有原型。</p>\n<h2 id=\"2-继承\"><a href=\"#2-继承\" class=\"headerlink\" title=\"2. 继承\"></a>2. 继承</h2><ul>\n<li>原型链继承<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent () &#123;</span><br><span class=\"line\">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype &#x3D; new Parent();</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(); &#x2F;&#x2F; 引用类型的属性被所有实例共享</span><br><span class=\"line\"></span><br><span class=\"line\">child1.names.push(&#39;yayu&#39;); </span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child(); &#x2F;&#x2F; 创建child实例时无法向Parent传参</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure></li>\n<li>借用构造函数（经典继承）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent () &#123;</span><br><span class=\"line\">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child () &#123;</span><br><span class=\"line\">    Parent.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">child1.names.push(&#39;yayu&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">function Parent (name) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child (name) &#123;</span><br><span class=\"line\">    Parent.call(this, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure>\n优点：<br>1.避免了引用类型的属性被所有实例共享<br>2.可以在Child中向Parent传参<br>缺点：<br>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li>\n<li>组合继承<br>原型链继承和经典继承合并。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent (name) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child (name, age) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Parent.call(this, name);</span><br><span class=\"line\">    </span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype &#x3D; new Parent();</span><br><span class=\"line\">Child.prototype.constructor &#x3D; Child;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">child1.colors.push(&#39;black&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class=\"line\">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class=\"line\">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class=\"line\">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class=\"line\">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>\n融合原型链和构造函数的优点，最常用的继承模式。</li>\n<li>原型式继承<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj(o) &#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype &#x3D; o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：<br>包含引用类型的属性值始终会共享相应的值，与原型链继承一样。</li>\n<li>寄生式继承<br>创建一个仅用与封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj (o) &#123;</span><br><span class=\"line\">    var clone &#x3D; Object.create(o);</span><br><span class=\"line\">    clone.sayName &#x3D; function () &#123;</span><br><span class=\"line\">        console.log(&#39;hi&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</li>\n<li>寄生组合式继承<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Child (name, age) &#123;</span><br><span class=\"line\">    Parent.call(this, name);</span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 关键的三步</span><br><span class=\"line\">var F &#x3D; function () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">F.prototype &#x3D; Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype &#x3D; new F();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1);</span><br><span class=\"line\">&#x2F;&#x2F;封装</span><br><span class=\"line\">function object(o) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype &#x3D; o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function prototype(child, parent) &#123;</span><br><span class=\"line\">    var prototype &#x3D; object(parent.prototype);</span><br><span class=\"line\">    prototype.constructor &#x3D; child;</span><br><span class=\"line\">    child.prototype &#x3D; prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class=\"line\">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>\n普遍认为是最理想的继承范式。<h2 id=\"3-作用域\"><a href=\"#3-作用域\" class=\"headerlink\" title=\"3. 作用域\"></a>3. 作用域</h2>对于每个执行上下文，都有三个重要属性：</li>\n<li>变量对象（Variable）</li>\n<li>作用域链（Scope）</li>\n<li>this<br>全局作用域：<br>window对象的上下文<br>块级作用域：<br>用let声明的代码块{}内<br>函数作用域：<br>函数上下文的作用域{}内<br>作用域链：<br>不断向上访问，直到全局作用域<h2 id=\"4-闭包\"><a href=\"#4-闭包\" class=\"headerlink\" title=\"4. 闭包\"></a>4. 闭包</h2>理解：引用另一个函数作用域中变量的函数。<br>闭包可以传入this对象作为参数，通过该对象访问this上下文的值。<br>由于闭包会保留他们包含函数的作用域，所以使用闭包要注意，内存的回收。<h2 id=\"5-变量提升\"><a href=\"#5-变量提升\" class=\"headerlink\" title=\"5. 变量提升\"></a>5. 变量提升</h2>var声明的变量和方法，都会提升到全局对象上。<br>全局对象就是由Object构造函数实例化的一个对象。<br>函数上下文的变量对象初始化只包括Arguments对象<br>在进入执行上下文时会给变量对象添加形参(arguments)、函数声明(func)、变量声明(var)等初始化的属性值<br>在代码执行阶段，会再次修改变量对象的属性值<br>进入执行上下文中，首先会处理函数声明，其次处理变量声明，如果变量名称跟已声明的元素相同，则声明不会干扰已经存在的这类属性。<h2 id=\"6-this的指向\"><a href=\"#6-this的指向\" class=\"headerlink\" title=\"6. this的指向\"></a>6. this的指向</h2>执行上下文都有this属性<br>标准函数中，this引用的是把函数当成方法调用的上下值。<br>箭头函数会保留定义它时的上下文<h2 id=\"7-立即执行函数\"><a href=\"#7-立即执行函数\" class=\"headerlink\" title=\"7. 立即执行函数\"></a>7. 立即执行函数</h2>调用需要在后面添加()，也需要在前面将函数用()包裹。<br>后面的()可以用来传值，立即执行会保存闭包的状态。<br>前面的()包裹函数则被解析成表达式，匿名函数后面的()被用于调用，将前面的函数当成声明。<br>IIFE（立即自执行）<br>模块模式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter &#x3D; (function()&#123;</span><br><span class=\"line\">    var i &#x3D; 0;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        get: function()&#123;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: function(val)&#123;</span><br><span class=\"line\">            i &#x3D; val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        increment: function()&#123;</span><br><span class=\"line\">            return ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;());</span><br><span class=\"line\">    counter.get();&#x2F;&#x2F;0</span><br><span class=\"line\">    counter.set(3);</span><br><span class=\"line\">    counter.increment();&#x2F;&#x2F;4</span><br><span class=\"line\">    counter.increment();&#x2F;&#x2F;5</span><br><span class=\"line\"></span><br><span class=\"line\">    conuter.i;&#x2F;&#x2F;undefined (&#96;i&#96; is not a property of the returned object)</span><br><span class=\"line\">    i;&#x2F;&#x2F;ReferenceError: i is not defined (it only exists inside the closure)</span><br></pre></td></tr></table></figure>\n最小化了全局变量的污染，创造了使用变量。<h2 id=\"8-instanceof原理\"><a href=\"#8-instanceof原理\" class=\"headerlink\" title=\"8. instanceof原理\"></a>8. instanceof原理</h2>typeof也可用于判断object类型，但判断null会显示object。(typeof用于判断基本数据类型，包括symbol都是没问题的，避免null)<br>instanceof用于判断object类型，判断null时会报错，显示null不是object。<br>也可使用Object.prototype.toString来判断一个变量的类型（比较准确）。<br>原理：<br>根据原型链判断，遍历原型链查找相同的类型。<br>一边查找函数的原型，一边查找实例的原型。<br>总结：准确判断对象实例类型，可以使用Object.prototype.toString.call，<br>typeof只适合判断基本数据类型，instanceof判断null为Object。<h2 id=\"9-bind的实现\"><a href=\"#9-bind的实现\" class=\"headerlink\" title=\"9. bind的实现\"></a>9. bind的实现</h2>bind()方法会创建一个新的函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。<br>bind特点：</li>\n<li>返回一个函数</li>\n<li>可以传入参数<br>当bind返回的函数作为构造函数时，bind指定的this会失效，但参数生效。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class=\"line\">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var self &#x3D; this;</span><br><span class=\"line\">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    var fBound &#x3D; function () &#123;</span><br><span class=\"line\">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class=\"line\">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fNOP.prototype &#x3D; this.prototype;</span><br><span class=\"line\">    fBound.prototype &#x3D; new fNOP();</span><br><span class=\"line\">    return fBound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-apply和call\"><a href=\"#10-apply和call\" class=\"headerlink\" title=\"10. apply和call\"></a>10. apply和call</h2>共同点：</li>\n<li>改变上下文tihs</li>\n<li>必须是函数调用<br>区别：</li>\n<li>call传入多个参数</li>\n<li>apply传入参数数组或类数组(具有length和for遍历)<br>call使用场景：<br>1.继承对象<br>2.借用方法<br>apply使用场景：<br>1.Math.max<br>2.两个数组合并<br>3.实现bind<h2 id=\"11-柯里化\"><a href=\"#11-柯里化\" class=\"headerlink\" title=\"11. 柯里化\"></a>11. 柯里化</h2>定义：将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>用途：参数复用，降低通用性，提高适用性。<br>实现：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry &#x3D; function (fn) &#123;</span><br><span class=\"line\">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class=\"line\">        return fn.apply(this, newArgs);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n本质上是用函数包裹原函数，给原函数传入之前的参数，当执行func()()时，执行包裹函数，返回原函数，调用sub_curry再包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的书目达到要求为止。<h2 id=\"12-v8垃圾回收机制\"><a href=\"#12-v8垃圾回收机制\" class=\"headerlink\" title=\"12. v8垃圾回收机制\"></a>12. v8垃圾回收机制</h2>1.为什么要垃圾回收？<br>避免内存泄漏，性能下降<br>2.V8引擎内存限制<br>64位系统，1.4G<br>32位系统，0.7G<br>由于JS单线程机制，垃圾回收会影响程序执行。为了减少对应用的性能影响，V8直接限制内存大小。<br>3.V8的垃圾回收策略<br>分代式垃圾回收机制，根据存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。<br>V8有如下内存结构：</li>\n<li>新生代：一般分配内存，一般用于垃圾回收时保存保留对象</li>\n<li>老生代：新生代对象一段时候后转移的地方</li>\n<li>大对象区：存放体积较大的对象，垃圾回收不会移动该区</li>\n<li>代码区：代码对象，会被分配在这里，唯一拥有执行权限的内存区域</li>\n<li>map区：存放cell和map，区域存放相同大小<br>新生代回收算法：<br>Scavenge算法：Cheney算法，二分空间From和To，先From，回收时复制到To，然后将To变成From，From清空变为To。<br>对象晋升：<br>多次存活后转到老生代的对象，过程称为对象晋升。<br>条件：</li>\n<li>经过过一次Scavenge算法</li>\n<li>To空间的内存占比超过25%<br>老生代回收算法：<br>采用Mark-Sweep标记清除和Mark-Compact标记清理算法<br>引用计数，如果对象没有被指针引用，则被视为垃圾回收。<ol start=\"4\">\n<li>避免内存泄漏</li>\n</ol>\n</li>\n<li>尽可能减少全局变量</li>\n<li>手动清除计时器</li>\n<li>少用闭包</li>\n<li>清除DOM引用</li>\n<li>弱引用<ol start=\"5\">\n<li>总结<br>新生代，老生代，算法，垃圾回收机制，避免内存泄漏。<h2 id=\"13-浮点数精度\"><a href=\"#13-浮点数精度\" class=\"headerlink\" title=\"13. 浮点数精度\"></a>13. 浮点数精度</h2><h2 id=\"14-new操作符\"><a href=\"#14-new操作符\" class=\"headerlink\" title=\"14. new操作符\"></a>14. new操作符</h2><h2 id=\"15-事件循环机制\"><a href=\"#15-事件循环机制\" class=\"headerlink\" title=\"15. 事件循环机制\"></a>15. 事件循环机制</h2><h2 id=\"16-promise原理\"><a href=\"#16-promise原理\" class=\"headerlink\" title=\"16. promise原理\"></a>16. promise原理</h2><h2 id=\"17-generator原理\"><a href=\"#17-generator原理\" class=\"headerlink\" title=\"17. generator原理\"></a>17. generator原理</h2></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-原型链\"><a href=\"#1-原型链\" class=\"headerlink\" title=\"1. 原型链\"></a>1. 原型链</h2><p>每个函数都有prototype，指向了一个对象，该对象为实例的原型。<br>每个JS对象（除了null）都具有_proto_属性，指向该对象的原型。<br>每个原型都具有constructor属性，指向关联的构造函数。<br>Object.prototype._proto_为null代表该对象没有原型。</p>\n<h2 id=\"2-继承\"><a href=\"#2-继承\" class=\"headerlink\" title=\"2. 继承\"></a>2. 继承</h2><ul>\n<li>原型链继承<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent () &#123;</span><br><span class=\"line\">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype &#x3D; new Parent();</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(); &#x2F;&#x2F; 引用类型的属性被所有实例共享</span><br><span class=\"line\"></span><br><span class=\"line\">child1.names.push(&#39;yayu&#39;); </span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child(); &#x2F;&#x2F; 创建child实例时无法向Parent传参</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure></li>\n<li>借用构造函数（经典继承）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent () &#123;</span><br><span class=\"line\">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child () &#123;</span><br><span class=\"line\">    Parent.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">child1.names.push(&#39;yayu&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">function Parent (name) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child (name) &#123;</span><br><span class=\"line\">    Parent.call(this, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure>\n优点：<br>1.避免了引用类型的属性被所有实例共享<br>2.可以在Child中向Parent传参<br>缺点：<br>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li>\n<li>组合继承<br>原型链继承和经典继承合并。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent (name) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">    console.log(this.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child (name, age) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Parent.call(this, name);</span><br><span class=\"line\">    </span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype &#x3D; new Parent();</span><br><span class=\"line\">Child.prototype.constructor &#x3D; Child;</span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">child1.colors.push(&#39;black&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class=\"line\">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class=\"line\">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class=\"line\">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class=\"line\">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>\n融合原型链和构造函数的优点，最常用的继承模式。</li>\n<li>原型式继承<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj(o) &#123;</span><br><span class=\"line\">    function F()&#123;&#125;</span><br><span class=\"line\">    F.prototype &#x3D; o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：<br>包含引用类型的属性值始终会共享相应的值，与原型链继承一样。</li>\n<li>寄生式继承<br>创建一个仅用与封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj (o) &#123;</span><br><span class=\"line\">    var clone &#x3D; Object.create(o);</span><br><span class=\"line\">    clone.sayName &#x3D; function () &#123;</span><br><span class=\"line\">        console.log(&#39;hi&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</li>\n<li>寄生组合式继承<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Child (name, age) &#123;</span><br><span class=\"line\">    Parent.call(this, name);</span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 关键的三步</span><br><span class=\"line\">var F &#x3D; function () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">F.prototype &#x3D; Parent.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype &#x3D; new F();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(child1);</span><br><span class=\"line\">&#x2F;&#x2F;封装</span><br><span class=\"line\">function object(o) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype &#x3D; o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function prototype(child, parent) &#123;</span><br><span class=\"line\">    var prototype &#x3D; object(parent.prototype);</span><br><span class=\"line\">    prototype.constructor &#x3D; child;</span><br><span class=\"line\">    child.prototype &#x3D; prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class=\"line\">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>\n普遍认为是最理想的继承范式。<h2 id=\"3-作用域\"><a href=\"#3-作用域\" class=\"headerlink\" title=\"3. 作用域\"></a>3. 作用域</h2>对于每个执行上下文，都有三个重要属性：</li>\n<li>变量对象（Variable）</li>\n<li>作用域链（Scope）</li>\n<li>this<br>全局作用域：<br>window对象的上下文<br>块级作用域：<br>用let声明的代码块{}内<br>函数作用域：<br>函数上下文的作用域{}内<br>作用域链：<br>不断向上访问，直到全局作用域<h2 id=\"4-闭包\"><a href=\"#4-闭包\" class=\"headerlink\" title=\"4. 闭包\"></a>4. 闭包</h2>理解：引用另一个函数作用域中变量的函数。<br>闭包可以传入this对象作为参数，通过该对象访问this上下文的值。<br>由于闭包会保留他们包含函数的作用域，所以使用闭包要注意，内存的回收。<h2 id=\"5-变量提升\"><a href=\"#5-变量提升\" class=\"headerlink\" title=\"5. 变量提升\"></a>5. 变量提升</h2>var声明的变量和方法，都会提升到全局对象上。<br>全局对象就是由Object构造函数实例化的一个对象。<br>函数上下文的变量对象初始化只包括Arguments对象<br>在进入执行上下文时会给变量对象添加形参(arguments)、函数声明(func)、变量声明(var)等初始化的属性值<br>在代码执行阶段，会再次修改变量对象的属性值<br>进入执行上下文中，首先会处理函数声明，其次处理变量声明，如果变量名称跟已声明的元素相同，则声明不会干扰已经存在的这类属性。<h2 id=\"6-this的指向\"><a href=\"#6-this的指向\" class=\"headerlink\" title=\"6. this的指向\"></a>6. this的指向</h2>执行上下文都有this属性<br>标准函数中，this引用的是把函数当成方法调用的上下值。<br>箭头函数会保留定义它时的上下文<h2 id=\"7-立即执行函数\"><a href=\"#7-立即执行函数\" class=\"headerlink\" title=\"7. 立即执行函数\"></a>7. 立即执行函数</h2>调用需要在后面添加()，也需要在前面将函数用()包裹。<br>后面的()可以用来传值，立即执行会保存闭包的状态。<br>前面的()包裹函数则被解析成表达式，匿名函数后面的()被用于调用，将前面的函数当成声明。<br>IIFE（立即自执行）<br>模块模式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter &#x3D; (function()&#123;</span><br><span class=\"line\">    var i &#x3D; 0;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        get: function()&#123;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: function(val)&#123;</span><br><span class=\"line\">            i &#x3D; val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        increment: function()&#123;</span><br><span class=\"line\">            return ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;());</span><br><span class=\"line\">    counter.get();&#x2F;&#x2F;0</span><br><span class=\"line\">    counter.set(3);</span><br><span class=\"line\">    counter.increment();&#x2F;&#x2F;4</span><br><span class=\"line\">    counter.increment();&#x2F;&#x2F;5</span><br><span class=\"line\"></span><br><span class=\"line\">    conuter.i;&#x2F;&#x2F;undefined (&#96;i&#96; is not a property of the returned object)</span><br><span class=\"line\">    i;&#x2F;&#x2F;ReferenceError: i is not defined (it only exists inside the closure)</span><br></pre></td></tr></table></figure>\n最小化了全局变量的污染，创造了使用变量。<h2 id=\"8-instanceof原理\"><a href=\"#8-instanceof原理\" class=\"headerlink\" title=\"8. instanceof原理\"></a>8. instanceof原理</h2>typeof也可用于判断object类型，但判断null会显示object。(typeof用于判断基本数据类型，包括symbol都是没问题的，避免null)<br>instanceof用于判断object类型，判断null时会报错，显示null不是object。<br>也可使用Object.prototype.toString来判断一个变量的类型（比较准确）。<br>原理：<br>根据原型链判断，遍历原型链查找相同的类型。<br>一边查找函数的原型，一边查找实例的原型。<br>总结：准确判断对象实例类型，可以使用Object.prototype.toString.call，<br>typeof只适合判断基本数据类型，instanceof判断null为Object。<h2 id=\"9-bind的实现\"><a href=\"#9-bind的实现\" class=\"headerlink\" title=\"9. bind的实现\"></a>9. bind的实现</h2>bind()方法会创建一个新的函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。<br>bind特点：</li>\n<li>返回一个函数</li>\n<li>可以传入参数<br>当bind返回的函数作为构造函数时，bind指定的this会失效，但参数生效。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class=\"line\">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var self &#x3D; this;</span><br><span class=\"line\">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    var fBound &#x3D; function () &#123;</span><br><span class=\"line\">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class=\"line\">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fNOP.prototype &#x3D; this.prototype;</span><br><span class=\"line\">    fBound.prototype &#x3D; new fNOP();</span><br><span class=\"line\">    return fBound;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-apply和call\"><a href=\"#10-apply和call\" class=\"headerlink\" title=\"10. apply和call\"></a>10. apply和call</h2>共同点：</li>\n<li>改变上下文tihs</li>\n<li>必须是函数调用<br>区别：</li>\n<li>call传入多个参数</li>\n<li>apply传入参数数组或类数组(具有length和for遍历)<br>call使用场景：<br>1.继承对象<br>2.借用方法<br>apply使用场景：<br>1.Math.max<br>2.两个数组合并<br>3.实现bind<h2 id=\"11-柯里化\"><a href=\"#11-柯里化\" class=\"headerlink\" title=\"11. 柯里化\"></a>11. 柯里化</h2>定义：将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>用途：参数复用，降低通用性，提高适用性。<br>实现：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry &#x3D; function (fn) &#123;</span><br><span class=\"line\">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class=\"line\">        return fn.apply(this, newArgs);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n本质上是用函数包裹原函数，给原函数传入之前的参数，当执行func()()时，执行包裹函数，返回原函数，调用sub_curry再包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的书目达到要求为止。<h2 id=\"12-v8垃圾回收机制\"><a href=\"#12-v8垃圾回收机制\" class=\"headerlink\" title=\"12. v8垃圾回收机制\"></a>12. v8垃圾回收机制</h2>1.为什么要垃圾回收？<br>避免内存泄漏，性能下降<br>2.V8引擎内存限制<br>64位系统，1.4G<br>32位系统，0.7G<br>由于JS单线程机制，垃圾回收会影响程序执行。为了减少对应用的性能影响，V8直接限制内存大小。<br>3.V8的垃圾回收策略<br>分代式垃圾回收机制，根据存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。<br>V8有如下内存结构：</li>\n<li>新生代：一般分配内存，一般用于垃圾回收时保存保留对象</li>\n<li>老生代：新生代对象一段时候后转移的地方</li>\n<li>大对象区：存放体积较大的对象，垃圾回收不会移动该区</li>\n<li>代码区：代码对象，会被分配在这里，唯一拥有执行权限的内存区域</li>\n<li>map区：存放cell和map，区域存放相同大小<br>新生代回收算法：<br>Scavenge算法：Cheney算法，二分空间From和To，先From，回收时复制到To，然后将To变成From，From清空变为To。<br>对象晋升：<br>多次存活后转到老生代的对象，过程称为对象晋升。<br>条件：</li>\n<li>经过过一次Scavenge算法</li>\n<li>To空间的内存占比超过25%<br>老生代回收算法：<br>采用Mark-Sweep标记清除和Mark-Compact标记清理算法<br>引用计数，如果对象没有被指针引用，则被视为垃圾回收。<ol start=\"4\">\n<li>避免内存泄漏</li>\n</ol>\n</li>\n<li>尽可能减少全局变量</li>\n<li>手动清除计时器</li>\n<li>少用闭包</li>\n<li>清除DOM引用</li>\n<li>弱引用<ol start=\"5\">\n<li>总结<br>新生代，老生代，算法，垃圾回收机制，避免内存泄漏。<h2 id=\"13-浮点数精度\"><a href=\"#13-浮点数精度\" class=\"headerlink\" title=\"13. 浮点数精度\"></a>13. 浮点数精度</h2><h2 id=\"14-new操作符\"><a href=\"#14-new操作符\" class=\"headerlink\" title=\"14. new操作符\"></a>14. new操作符</h2><h2 id=\"15-事件循环机制\"><a href=\"#15-事件循环机制\" class=\"headerlink\" title=\"15. 事件循环机制\"></a>15. 事件循环机制</h2><h2 id=\"16-promise原理\"><a href=\"#16-promise原理\" class=\"headerlink\" title=\"16. promise原理\"></a>16. promise原理</h2><h2 id=\"17-generator原理\"><a href=\"#17-generator原理\" class=\"headerlink\" title=\"17. generator原理\"></a>17. generator原理</h2></li>\n</ol>\n</li>\n</ul>\n"},{"title":"vue权限管理","date":"2021-02-26T02:30:39.000Z","_content":"## 1. 权限是啥？\n权限是对特定资源的访问许可，确保用户只能访问到被分配的资源。其原理是请求发起权，请求发起有两种形式：\n - 页面加载触发\n - 页面上的按钮点击触发\n实现目标：\n - 路由方面，只能看到有权访问的菜单\n - 视图方面，只能看到自己有权浏览的内容和有权操作的控件\n - 请求控制，越权请求在前端进行拦截\n## 2. 如何实现？\n权限控制可以分四个方面：\n - 接口权限\n - 按钮权限\n - 菜单权限\n - 路由权限\n# 接口权限\n接口权限一般采用jwt的形式来严重，登录完拿到token将token保存，每次请求拦截器进行拦截，请求头部带token\n# 路由权限控制\n方案一：在路由标记相应的权限信息，路由跳转前做校验\n```\nconst routerMap = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/index',\n    alwaysShow: true, // will always show the root menu\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [{\n      path: 'page',\n      component: () => import('@/views/permission/page'),\n      name: 'pagePermission',\n      meta: {\n        title: 'pagePermission',\n        roles: ['admin'] // or you can only set roles in sub nav\n      }\n    }, {\n      path: 'directive',\n      component: () => import('@/views/permission/directive'),\n      name: 'directivePermission',\n      meta: {\n        title: 'directivePermission'\n        // if do not set roles, means: this page does not require permission\n      }\n    }]\n  }]\n```\n缺点：\n - 加载所有的路由，如果路由很多，而用户并不是所有路由都有权限访问，会性能会有影响\n - 全局路由守卫里，每次路由跳转都要做权限判断\n - 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n方案二：\n初始化的时候挂载公共路由，比如404，登录页。登录后获取用户的权限信息筛选有权限访问的路由在全局路由守卫调用addRoutes添加路由\n```\n// permission judge function\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') >= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role => permissionRoles.indexOf(role) >= 0)\n}\n\nconst whiteList = ['/login', '/authredirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  NProgress.start() // start progress bar\n  if (getToken()) { // determine if there has token\n    /* has token*/\n    if (to.path === '/login') {\n      next({ path: '/' })\n      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch('GetUserInfo').then(res => { // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']\n          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch((err) => {\n          store.dispatch('FedLogOut').then(() => {\n            Message.error(err || 'Verification failed, please login again')\n            next({ path: '/' })\n          })\n        })\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next()//\n        } else {\n          next({ path: '/401', replace: true, query: { noGoBack: true }})\n        }\n        // 可删 ↑\n      }\n    }\n  } else {\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login') // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    }\n  }\n})\n\nrouter.afterEach(() => {\n  NProgress.done() // finish progress bar\n})\n```\n缺点：\n - 全局路由守卫里，每次路由跳转都要做判断\n - 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n# 菜单权限\n菜单权限可以理解成将页面与路由进行解耦\n方案一\n菜单与路由分离，菜单由后端返回\n前端定义路由信息，name属性不得为空，需要此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验\n```\nfunction hasPermission(router, accessMenu) {\n  if (whiteList.indexOf(router.path) !== -1) {\n    return true;\n  }\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) {\n    return true;\n  }\n  return false;\n\n}\n\nRouter.beforeEach(async (to, from, next) => {\n  if (getToken()) {\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) {\n      try {\n        await store.dispatch(\"GetUserInfo\")\n        await store.dispatch('updateAccessMenu')\n        if (to.path === '/login') {\n          next({ name: 'home_index' })\n        } else {\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由\n        }\n      }  \n      catch (e) {\n        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n          next()\n        } else {\n          next('/login')\n        }\n      }\n    } else {\n      if (to.path === '/login') {\n        next({ name: 'home_index' })\n      } else {\n        if (hasPermission(to, store.getters.accessMenu)) {\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        } else {\n          next({ path: '/403',replace:true })\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login')\n    }\n  }\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n});\n\nRouter.afterEach((to) => {\n  window.scrollTo(0, 0);\n});\n```\n缺点：\n - 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，菜单配置不对会导致应用不能正常使用\n - 全局路由守卫里，每次路由跳转都要做判断\n方案二\n菜单和路由都由后端返回，前端统一定义路由组件\n```\nconst Home = () => import(\"../pages/Home.vue\");\nconst UserInfo = () => import(\"../pages/UserInfo.vue\");\nexport default {\n    home: Home,\n    userInfo: UserInfo\n};\n```\n后端路由组件返回以下格式\n```\n[\n    {\n        name: \"home\",\n        path: \"/\",\n        component: \"home\"\n    },\n    {\n        name: \"home\",\n        path: \"/userinfo\",\n        component: \"userInfo\"\n    }\n]\n```\n前后端都需要做相应的路由处理\n缺点：\n - 全局路由守卫里，每次路由跳转都要做判断\n - 前后端的配合要求更高\n# 按钮权限\n方案一\n按钮权限用v-if判断，但是页面过多情况下，每个页面都要获取用户权限role和路由表里的meta.Permission，再做判断\n方案二\n通过自定义指令进行权限判断\n配置路由\n```\n{\n    path: '/permission',\n    component: Layout,\n    name: '权限测试',\n    meta: {\n        btnPermissions: ['admin', 'supper', 'normal']\n    },\n    //页面需要的权限\n    children: [{\n        path: 'supper',\n        component: _import('system/supper'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin', 'supper']\n        } //页面需要的权限\n    },\n    {\n        path: 'normal',\n        component: _import('system/normal'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin']\n        } //页面需要的权限\n    }]\n}\n```\n自定义权限鉴定指令\n```\n/**权限指令**/\nconst has = Vue.directive('has', {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value){\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        }else{\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        }\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\");\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) > -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}\n```\n\n# 小结\n根据项目进行方案考虑，如考虑路由与菜单是否分离\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n","source":"_posts/vue权限管理.md","raw":"---\ntitle: vue权限管理\ndate: 2021-02-26 10:30:39\ntags:\n - 前端框架\n - Vue\ncategories: web前端\n---\n## 1. 权限是啥？\n权限是对特定资源的访问许可，确保用户只能访问到被分配的资源。其原理是请求发起权，请求发起有两种形式：\n - 页面加载触发\n - 页面上的按钮点击触发\n实现目标：\n - 路由方面，只能看到有权访问的菜单\n - 视图方面，只能看到自己有权浏览的内容和有权操作的控件\n - 请求控制，越权请求在前端进行拦截\n## 2. 如何实现？\n权限控制可以分四个方面：\n - 接口权限\n - 按钮权限\n - 菜单权限\n - 路由权限\n# 接口权限\n接口权限一般采用jwt的形式来严重，登录完拿到token将token保存，每次请求拦截器进行拦截，请求头部带token\n# 路由权限控制\n方案一：在路由标记相应的权限信息，路由跳转前做校验\n```\nconst routerMap = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/index',\n    alwaysShow: true, // will always show the root menu\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [{\n      path: 'page',\n      component: () => import('@/views/permission/page'),\n      name: 'pagePermission',\n      meta: {\n        title: 'pagePermission',\n        roles: ['admin'] // or you can only set roles in sub nav\n      }\n    }, {\n      path: 'directive',\n      component: () => import('@/views/permission/directive'),\n      name: 'directivePermission',\n      meta: {\n        title: 'directivePermission'\n        // if do not set roles, means: this page does not require permission\n      }\n    }]\n  }]\n```\n缺点：\n - 加载所有的路由，如果路由很多，而用户并不是所有路由都有权限访问，会性能会有影响\n - 全局路由守卫里，每次路由跳转都要做权限判断\n - 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n方案二：\n初始化的时候挂载公共路由，比如404，登录页。登录后获取用户的权限信息筛选有权限访问的路由在全局路由守卫调用addRoutes添加路由\n```\n// permission judge function\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') >= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role => permissionRoles.indexOf(role) >= 0)\n}\n\nconst whiteList = ['/login', '/authredirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  NProgress.start() // start progress bar\n  if (getToken()) { // determine if there has token\n    /* has token*/\n    if (to.path === '/login') {\n      next({ path: '/' })\n      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch('GetUserInfo').then(res => { // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']\n          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch((err) => {\n          store.dispatch('FedLogOut').then(() => {\n            Message.error(err || 'Verification failed, please login again')\n            next({ path: '/' })\n          })\n        })\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next()//\n        } else {\n          next({ path: '/401', replace: true, query: { noGoBack: true }})\n        }\n        // 可删 ↑\n      }\n    }\n  } else {\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login') // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    }\n  }\n})\n\nrouter.afterEach(() => {\n  NProgress.done() // finish progress bar\n})\n```\n缺点：\n - 全局路由守卫里，每次路由跳转都要做判断\n - 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n# 菜单权限\n菜单权限可以理解成将页面与路由进行解耦\n方案一\n菜单与路由分离，菜单由后端返回\n前端定义路由信息，name属性不得为空，需要此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验\n```\nfunction hasPermission(router, accessMenu) {\n  if (whiteList.indexOf(router.path) !== -1) {\n    return true;\n  }\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) {\n    return true;\n  }\n  return false;\n\n}\n\nRouter.beforeEach(async (to, from, next) => {\n  if (getToken()) {\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) {\n      try {\n        await store.dispatch(\"GetUserInfo\")\n        await store.dispatch('updateAccessMenu')\n        if (to.path === '/login') {\n          next({ name: 'home_index' })\n        } else {\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由\n        }\n      }  \n      catch (e) {\n        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n          next()\n        } else {\n          next('/login')\n        }\n      }\n    } else {\n      if (to.path === '/login') {\n        next({ name: 'home_index' })\n      } else {\n        if (hasPermission(to, store.getters.accessMenu)) {\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        } else {\n          next({ path: '/403',replace:true })\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login')\n    }\n  }\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n});\n\nRouter.afterEach((to) => {\n  window.scrollTo(0, 0);\n});\n```\n缺点：\n - 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，菜单配置不对会导致应用不能正常使用\n - 全局路由守卫里，每次路由跳转都要做判断\n方案二\n菜单和路由都由后端返回，前端统一定义路由组件\n```\nconst Home = () => import(\"../pages/Home.vue\");\nconst UserInfo = () => import(\"../pages/UserInfo.vue\");\nexport default {\n    home: Home,\n    userInfo: UserInfo\n};\n```\n后端路由组件返回以下格式\n```\n[\n    {\n        name: \"home\",\n        path: \"/\",\n        component: \"home\"\n    },\n    {\n        name: \"home\",\n        path: \"/userinfo\",\n        component: \"userInfo\"\n    }\n]\n```\n前后端都需要做相应的路由处理\n缺点：\n - 全局路由守卫里，每次路由跳转都要做判断\n - 前后端的配合要求更高\n# 按钮权限\n方案一\n按钮权限用v-if判断，但是页面过多情况下，每个页面都要获取用户权限role和路由表里的meta.Permission，再做判断\n方案二\n通过自定义指令进行权限判断\n配置路由\n```\n{\n    path: '/permission',\n    component: Layout,\n    name: '权限测试',\n    meta: {\n        btnPermissions: ['admin', 'supper', 'normal']\n    },\n    //页面需要的权限\n    children: [{\n        path: 'supper',\n        component: _import('system/supper'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin', 'supper']\n        } //页面需要的权限\n    },\n    {\n        path: 'normal',\n        component: _import('system/normal'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin']\n        } //页面需要的权限\n    }]\n}\n```\n自定义权限鉴定指令\n```\n/**权限指令**/\nconst has = Vue.directive('has', {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value){\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        }else{\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        }\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\");\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) > -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}\n```\n\n# 小结\n根据项目进行方案考虑，如考虑路由与菜单是否分离\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n","slug":"vue权限管理","published":1,"updated":"2021-02-26T04:03:31.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklm4c58p0001lgvae6jle1yw","content":"<h2 id=\"1-权限是啥？\"><a href=\"#1-权限是啥？\" class=\"headerlink\" title=\"1. 权限是啥？\"></a>1. 权限是啥？</h2><p>权限是对特定资源的访问许可，确保用户只能访问到被分配的资源。其原理是请求发起权，请求发起有两种形式：</p>\n<ul>\n<li>页面加载触发</li>\n<li>页面上的按钮点击触发<br>实现目标：</li>\n<li>路由方面，只能看到有权访问的菜单</li>\n<li>视图方面，只能看到自己有权浏览的内容和有权操作的控件</li>\n<li>请求控制，越权请求在前端进行拦截<h2 id=\"2-如何实现？\"><a href=\"#2-如何实现？\" class=\"headerlink\" title=\"2. 如何实现？\"></a>2. 如何实现？</h2>权限控制可以分四个方面：</li>\n<li>接口权限</li>\n<li>按钮权限</li>\n<li>菜单权限</li>\n<li>路由权限<h1 id=\"接口权限\"><a href=\"#接口权限\" class=\"headerlink\" title=\"接口权限\"></a>接口权限</h1>接口权限一般采用jwt的形式来严重，登录完拿到token将token保存，每次请求拦截器进行拦截，请求头部带token<h1 id=\"路由权限控制\"><a href=\"#路由权限控制\" class=\"headerlink\" title=\"路由权限控制\"></a>路由权限控制</h1>方案一：在路由标记相应的权限信息，路由跳转前做校验<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routerMap &#x3D; [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#39;&#x2F;permission&#39;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &#39;&#x2F;permission&#x2F;index&#39;,</span><br><span class=\"line\">    alwaysShow: true, &#x2F;&#x2F; will always show the root menu</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#39;permission&#39;,</span><br><span class=\"line\">      icon: &#39;lock&#39;,</span><br><span class=\"line\">      roles: [&#39;admin&#39;, &#39;editor&#39;] &#x2F;&#x2F; you can set roles in root nav</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      path: &#39;page&#39;,</span><br><span class=\"line\">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;page&#39;),</span><br><span class=\"line\">      name: &#39;pagePermission&#39;,</span><br><span class=\"line\">      meta: &#123;</span><br><span class=\"line\">        title: &#39;pagePermission&#39;,</span><br><span class=\"line\">        roles: [&#39;admin&#39;] &#x2F;&#x2F; or you can only set roles in sub nav</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      path: &#39;directive&#39;,</span><br><span class=\"line\">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;directive&#39;),</span><br><span class=\"line\">      name: &#39;directivePermission&#39;,</span><br><span class=\"line\">      meta: &#123;</span><br><span class=\"line\">        title: &#39;directivePermission&#39;</span><br><span class=\"line\">        &#x2F;&#x2F; if do not set roles, means: this page does not require permission</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br></pre></td></tr></table></figure>\n缺点：</li>\n<li>加载所有的路由，如果路由很多，而用户并不是所有路由都有权限访问，会性能会有影响</li>\n<li>全局路由守卫里，每次路由跳转都要做权限判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<br>方案二：<br>初始化的时候挂载公共路由，比如404，登录页。登录后获取用户的权限信息筛选有权限访问的路由在全局路由守卫调用addRoutes添加路由<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; permission judge function</span><br><span class=\"line\">function hasPermission(roles, permissionRoles) &#123;</span><br><span class=\"line\">  if (roles.indexOf(&#39;admin&#39;) &gt;&#x3D; 0) return true &#x2F;&#x2F; admin permission passed directly</span><br><span class=\"line\">  if (!permissionRoles) return true</span><br><span class=\"line\">  return roles.some(role &#x3D;&gt; permissionRoles.indexOf(role) &gt;&#x3D; 0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const whiteList &#x3D; [&#39;&#x2F;login&#39;, &#39;&#x2F;authredirect&#39;]&#x2F;&#x2F; no redirect whitelist</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">  NProgress.start() &#x2F;&#x2F; start progress bar</span><br><span class=\"line\">  if (getToken()) &#123; &#x2F;&#x2F; determine if there has token</span><br><span class=\"line\">    &#x2F;* has token*&#x2F;</span><br><span class=\"line\">    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">      next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class=\"line\">      NProgress.done() &#x2F;&#x2F; if current page is dashboard will not trigger afterEach hook, so manually handle it</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      if (store.getters.roles.length &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断当前用户是否已拉取完user_info信息</span><br><span class=\"line\">        store.dispatch(&#39;GetUserInfo&#39;).then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 拉取user_info</span><br><span class=\"line\">          const roles &#x3D; res.data.roles &#x2F;&#x2F; note: roles must be a array! such as: [&#39;editor&#39;,&#39;develop&#39;]</span><br><span class=\"line\">          store.dispatch(&#39;GenerateRoutes&#39;, &#123; roles &#125;).then(() &#x3D;&gt; &#123; &#x2F;&#x2F; 根据roles权限生成可访问的路由表</span><br><span class=\"line\">            router.addRoutes(store.getters.addRouters) &#x2F;&#x2F; 动态添加可访问路由表</span><br><span class=\"line\">            next(&#123; ...to, replace: true &#125;) &#x2F;&#x2F; hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class=\"line\">          store.dispatch(&#39;FedLogOut&#39;).then(() &#x3D;&gt; &#123;</span><br><span class=\"line\">            Message.error(err || &#39;Verification failed, please login again&#39;)</span><br><span class=\"line\">            next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓</span><br><span class=\"line\">        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;</span><br><span class=\"line\">          next()&#x2F;&#x2F;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          next(&#123; path: &#39;&#x2F;401&#39;, replace: true, query: &#123; noGoBack: true &#125;&#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 可删 ↑</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    &#x2F;* has no token*&#x2F;</span><br><span class=\"line\">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class=\"line\">      next()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      next(&#39;&#x2F;login&#39;) &#x2F;&#x2F; 否则全部重定向到登录页</span><br><span class=\"line\">      NProgress.done() &#x2F;&#x2F; if current page is login will not trigger afterEach hook, so manually handle it</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(() &#x3D;&gt; &#123;</span><br><span class=\"line\">  NProgress.done() &#x2F;&#x2F; finish progress bar</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n缺点：</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<h1 id=\"菜单权限\"><a href=\"#菜单权限\" class=\"headerlink\" title=\"菜单权限\"></a>菜单权限</h1>菜单权限可以理解成将页面与路由进行解耦<br>方案一<br>菜单与路由分离，菜单由后端返回<br>前端定义路由信息，name属性不得为空，需要此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hasPermission(router, accessMenu) &#123;</span><br><span class=\"line\">  if (whiteList.indexOf(router.path) !&#x3D;&#x3D; -1) &#123;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let menu &#x3D; Util.getMenuByName(router.name, accessMenu);</span><br><span class=\"line\">  if (menu.name) &#123;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.beforeEach(async (to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">  if (getToken()) &#123;</span><br><span class=\"line\">    let userInfo &#x3D; store.state.user.userInfo;</span><br><span class=\"line\">    if (!userInfo.name) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        await store.dispatch(&quot;GetUserInfo&quot;)</span><br><span class=\"line\">        await store.dispatch(&#39;updateAccessMenu&#39;)</span><br><span class=\"line\">        if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">          next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          &#x2F;&#x2F;Util.toDefaultPage([...routers], to.name, router, next);</span><br><span class=\"line\">          next(&#123; ...to, replace: true &#125;)&#x2F;&#x2F;菜单权限更新完成,重新进一次当前路由</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      catch (e) &#123;</span><br><span class=\"line\">        if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class=\"line\">          next()</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          next(&#39;&#x2F;login&#39;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">        next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        if (hasPermission(to, store.getters.accessMenu)) &#123;</span><br><span class=\"line\">          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          next(&#123; path: &#39;&#x2F;403&#39;,replace:true &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class=\"line\">      next()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      next(&#39;&#x2F;login&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let menu &#x3D; Util.getMenuByName(to.name, store.getters.accessMenu);</span><br><span class=\"line\">  Util.title(menu.title);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Router.afterEach((to) &#x3D;&gt; &#123;</span><br><span class=\"line\">  window.scrollTo(0, 0);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n缺点：</li>\n<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，菜单配置不对会导致应用不能正常使用</li>\n<li>全局路由守卫里，每次路由跳转都要做判断<br>方案二<br>菜单和路由都由后端返回，前端统一定义路由组件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Home &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;Home.vue&quot;);</span><br><span class=\"line\">const UserInfo &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;UserInfo.vue&quot;);</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    home: Home,</span><br><span class=\"line\">    userInfo: UserInfo</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n后端路由组件返回以下格式<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &quot;home&quot;,</span><br><span class=\"line\">        path: &quot;&#x2F;&quot;,</span><br><span class=\"line\">        component: &quot;home&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &quot;home&quot;,</span><br><span class=\"line\">        path: &quot;&#x2F;userinfo&quot;,</span><br><span class=\"line\">        component: &quot;userInfo&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n前后端都需要做相应的路由处理<br>缺点：</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>前后端的配合要求更高<h1 id=\"按钮权限\"><a href=\"#按钮权限\" class=\"headerlink\" title=\"按钮权限\"></a>按钮权限</h1>方案一<br>按钮权限用v-if判断，但是页面过多情况下，每个页面都要获取用户权限role和路由表里的meta.Permission，再做判断<br>方案二<br>通过自定义指令进行权限判断<br>配置路由<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#39;&#x2F;permission&#39;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    name: &#39;权限测试&#39;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">        btnPermissions: [&#39;admin&#39;, &#39;supper&#39;, &#39;normal&#39;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;页面需要的权限</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        path: &#39;supper&#39;,</span><br><span class=\"line\">        component: _import(&#39;system&#x2F;supper&#39;),</span><br><span class=\"line\">        name: &#39;权限测试页&#39;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">            btnPermissions: [&#39;admin&#39;, &#39;supper&#39;]</span><br><span class=\"line\">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        path: &#39;normal&#39;,</span><br><span class=\"line\">        component: _import(&#39;system&#x2F;normal&#39;),</span><br><span class=\"line\">        name: &#39;权限测试页&#39;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">            btnPermissions: [&#39;admin&#39;]</span><br><span class=\"line\">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n自定义权限鉴定指令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**权限指令**&#x2F;</span><br><span class=\"line\">const has &#x3D; Vue.directive(&#39;has&#39;, &#123;</span><br><span class=\"line\">    bind: function (el, binding, vnode) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取页面按钮权限</span><br><span class=\"line\">        let btnPermissionsArr &#x3D; [];</span><br><span class=\"line\">        if(binding.value)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。</span><br><span class=\"line\">            btnPermissionsArr &#x3D; Array.of(binding.value);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。</span><br><span class=\"line\">            btnPermissionsArr &#x3D; vnode.context.$route.meta.btnPermissions;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;</span><br><span class=\"line\">            el.parentNode.removeChild(el);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F; 权限检查方法</span><br><span class=\"line\">Vue.prototype.$_has &#x3D; function (value) &#123;</span><br><span class=\"line\">    let isExist &#x3D; false;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取用户按钮权限</span><br><span class=\"line\">    let btnPermissionsStr &#x3D; sessionStorage.getItem(&quot;btnPermissions&quot;);</span><br><span class=\"line\">    if (btnPermissionsStr &#x3D;&#x3D; undefined || btnPermissionsStr &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;</span><br><span class=\"line\">        isExist &#x3D; true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isExist;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export &#123;has&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>根据项目进行方案考虑，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-权限是啥？\"><a href=\"#1-权限是啥？\" class=\"headerlink\" title=\"1. 权限是啥？\"></a>1. 权限是啥？</h2><p>权限是对特定资源的访问许可，确保用户只能访问到被分配的资源。其原理是请求发起权，请求发起有两种形式：</p>\n<ul>\n<li>页面加载触发</li>\n<li>页面上的按钮点击触发<br>实现目标：</li>\n<li>路由方面，只能看到有权访问的菜单</li>\n<li>视图方面，只能看到自己有权浏览的内容和有权操作的控件</li>\n<li>请求控制，越权请求在前端进行拦截<h2 id=\"2-如何实现？\"><a href=\"#2-如何实现？\" class=\"headerlink\" title=\"2. 如何实现？\"></a>2. 如何实现？</h2>权限控制可以分四个方面：</li>\n<li>接口权限</li>\n<li>按钮权限</li>\n<li>菜单权限</li>\n<li>路由权限<h1 id=\"接口权限\"><a href=\"#接口权限\" class=\"headerlink\" title=\"接口权限\"></a>接口权限</h1>接口权限一般采用jwt的形式来严重，登录完拿到token将token保存，每次请求拦截器进行拦截，请求头部带token<h1 id=\"路由权限控制\"><a href=\"#路由权限控制\" class=\"headerlink\" title=\"路由权限控制\"></a>路由权限控制</h1>方案一：在路由标记相应的权限信息，路由跳转前做校验<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routerMap &#x3D; [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#39;&#x2F;permission&#39;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    redirect: &#39;&#x2F;permission&#x2F;index&#39;,</span><br><span class=\"line\">    alwaysShow: true, &#x2F;&#x2F; will always show the root menu</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">      title: &#39;permission&#39;,</span><br><span class=\"line\">      icon: &#39;lock&#39;,</span><br><span class=\"line\">      roles: [&#39;admin&#39;, &#39;editor&#39;] &#x2F;&#x2F; you can set roles in root nav</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      path: &#39;page&#39;,</span><br><span class=\"line\">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;page&#39;),</span><br><span class=\"line\">      name: &#39;pagePermission&#39;,</span><br><span class=\"line\">      meta: &#123;</span><br><span class=\"line\">        title: &#39;pagePermission&#39;,</span><br><span class=\"line\">        roles: [&#39;admin&#39;] &#x2F;&#x2F; or you can only set roles in sub nav</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      path: &#39;directive&#39;,</span><br><span class=\"line\">      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;permission&#x2F;directive&#39;),</span><br><span class=\"line\">      name: &#39;directivePermission&#39;,</span><br><span class=\"line\">      meta: &#123;</span><br><span class=\"line\">        title: &#39;directivePermission&#39;</span><br><span class=\"line\">        &#x2F;&#x2F; if do not set roles, means: this page does not require permission</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br></pre></td></tr></table></figure>\n缺点：</li>\n<li>加载所有的路由，如果路由很多，而用户并不是所有路由都有权限访问，会性能会有影响</li>\n<li>全局路由守卫里，每次路由跳转都要做权限判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<br>方案二：<br>初始化的时候挂载公共路由，比如404，登录页。登录后获取用户的权限信息筛选有权限访问的路由在全局路由守卫调用addRoutes添加路由<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; permission judge function</span><br><span class=\"line\">function hasPermission(roles, permissionRoles) &#123;</span><br><span class=\"line\">  if (roles.indexOf(&#39;admin&#39;) &gt;&#x3D; 0) return true &#x2F;&#x2F; admin permission passed directly</span><br><span class=\"line\">  if (!permissionRoles) return true</span><br><span class=\"line\">  return roles.some(role &#x3D;&gt; permissionRoles.indexOf(role) &gt;&#x3D; 0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const whiteList &#x3D; [&#39;&#x2F;login&#39;, &#39;&#x2F;authredirect&#39;]&#x2F;&#x2F; no redirect whitelist</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">  NProgress.start() &#x2F;&#x2F; start progress bar</span><br><span class=\"line\">  if (getToken()) &#123; &#x2F;&#x2F; determine if there has token</span><br><span class=\"line\">    &#x2F;* has token*&#x2F;</span><br><span class=\"line\">    if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">      next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class=\"line\">      NProgress.done() &#x2F;&#x2F; if current page is dashboard will not trigger afterEach hook, so manually handle it</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      if (store.getters.roles.length &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断当前用户是否已拉取完user_info信息</span><br><span class=\"line\">        store.dispatch(&#39;GetUserInfo&#39;).then(res &#x3D;&gt; &#123; &#x2F;&#x2F; 拉取user_info</span><br><span class=\"line\">          const roles &#x3D; res.data.roles &#x2F;&#x2F; note: roles must be a array! such as: [&#39;editor&#39;,&#39;develop&#39;]</span><br><span class=\"line\">          store.dispatch(&#39;GenerateRoutes&#39;, &#123; roles &#125;).then(() &#x3D;&gt; &#123; &#x2F;&#x2F; 根据roles权限生成可访问的路由表</span><br><span class=\"line\">            router.addRoutes(store.getters.addRouters) &#x2F;&#x2F; 动态添加可访问路由表</span><br><span class=\"line\">            next(&#123; ...to, replace: true &#125;) &#x2F;&#x2F; hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class=\"line\">          store.dispatch(&#39;FedLogOut&#39;).then(() &#x3D;&gt; &#123;</span><br><span class=\"line\">            Message.error(err || &#39;Verification failed, please login again&#39;)</span><br><span class=\"line\">            next(&#123; path: &#39;&#x2F;&#39; &#125;)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓</span><br><span class=\"line\">        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;</span><br><span class=\"line\">          next()&#x2F;&#x2F;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          next(&#123; path: &#39;&#x2F;401&#39;, replace: true, query: &#123; noGoBack: true &#125;&#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; 可删 ↑</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    &#x2F;* has no token*&#x2F;</span><br><span class=\"line\">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class=\"line\">      next()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      next(&#39;&#x2F;login&#39;) &#x2F;&#x2F; 否则全部重定向到登录页</span><br><span class=\"line\">      NProgress.done() &#x2F;&#x2F; if current page is login will not trigger afterEach hook, so manually handle it</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(() &#x3D;&gt; &#123;</span><br><span class=\"line\">  NProgress.done() &#x2F;&#x2F; finish progress bar</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n缺点：</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识<h1 id=\"菜单权限\"><a href=\"#菜单权限\" class=\"headerlink\" title=\"菜单权限\"></a>菜单权限</h1>菜单权限可以理解成将页面与路由进行解耦<br>方案一<br>菜单与路由分离，菜单由后端返回<br>前端定义路由信息，name属性不得为空，需要此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hasPermission(router, accessMenu) &#123;</span><br><span class=\"line\">  if (whiteList.indexOf(router.path) !&#x3D;&#x3D; -1) &#123;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let menu &#x3D; Util.getMenuByName(router.name, accessMenu);</span><br><span class=\"line\">  if (menu.name) &#123;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.beforeEach(async (to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">  if (getToken()) &#123;</span><br><span class=\"line\">    let userInfo &#x3D; store.state.user.userInfo;</span><br><span class=\"line\">    if (!userInfo.name) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        await store.dispatch(&quot;GetUserInfo&quot;)</span><br><span class=\"line\">        await store.dispatch(&#39;updateAccessMenu&#39;)</span><br><span class=\"line\">        if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">          next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          &#x2F;&#x2F;Util.toDefaultPage([...routers], to.name, router, next);</span><br><span class=\"line\">          next(&#123; ...to, replace: true &#125;)&#x2F;&#x2F;菜单权限更新完成,重新进一次当前路由</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      catch (e) &#123;</span><br><span class=\"line\">        if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class=\"line\">          next()</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          next(&#39;&#x2F;login&#39;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">        next(&#123; name: &#39;home_index&#39; &#125;)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        if (hasPermission(to, store.getters.accessMenu)) &#123;</span><br><span class=\"line\">          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          next(&#123; path: &#39;&#x2F;403&#39;,replace:true &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    if (whiteList.indexOf(to.path) !&#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; 在免登录白名单，直接进入</span><br><span class=\"line\">      next()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      next(&#39;&#x2F;login&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let menu &#x3D; Util.getMenuByName(to.name, store.getters.accessMenu);</span><br><span class=\"line\">  Util.title(menu.title);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Router.afterEach((to) &#x3D;&gt; &#123;</span><br><span class=\"line\">  window.scrollTo(0, 0);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n缺点：</li>\n<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，菜单配置不对会导致应用不能正常使用</li>\n<li>全局路由守卫里，每次路由跳转都要做判断<br>方案二<br>菜单和路由都由后端返回，前端统一定义路由组件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Home &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;Home.vue&quot;);</span><br><span class=\"line\">const UserInfo &#x3D; () &#x3D;&gt; import(&quot;..&#x2F;pages&#x2F;UserInfo.vue&quot;);</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    home: Home,</span><br><span class=\"line\">    userInfo: UserInfo</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n后端路由组件返回以下格式<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &quot;home&quot;,</span><br><span class=\"line\">        path: &quot;&#x2F;&quot;,</span><br><span class=\"line\">        component: &quot;home&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &quot;home&quot;,</span><br><span class=\"line\">        path: &quot;&#x2F;userinfo&quot;,</span><br><span class=\"line\">        component: &quot;userInfo&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n前后端都需要做相应的路由处理<br>缺点：</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>前后端的配合要求更高<h1 id=\"按钮权限\"><a href=\"#按钮权限\" class=\"headerlink\" title=\"按钮权限\"></a>按钮权限</h1>方案一<br>按钮权限用v-if判断，但是页面过多情况下，每个页面都要获取用户权限role和路由表里的meta.Permission，再做判断<br>方案二<br>通过自定义指令进行权限判断<br>配置路由<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &#39;&#x2F;permission&#39;,</span><br><span class=\"line\">    component: Layout,</span><br><span class=\"line\">    name: &#39;权限测试&#39;,</span><br><span class=\"line\">    meta: &#123;</span><br><span class=\"line\">        btnPermissions: [&#39;admin&#39;, &#39;supper&#39;, &#39;normal&#39;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;页面需要的权限</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        path: &#39;supper&#39;,</span><br><span class=\"line\">        component: _import(&#39;system&#x2F;supper&#39;),</span><br><span class=\"line\">        name: &#39;权限测试页&#39;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">            btnPermissions: [&#39;admin&#39;, &#39;supper&#39;]</span><br><span class=\"line\">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        path: &#39;normal&#39;,</span><br><span class=\"line\">        component: _import(&#39;system&#x2F;normal&#39;),</span><br><span class=\"line\">        name: &#39;权限测试页&#39;,</span><br><span class=\"line\">        meta: &#123;</span><br><span class=\"line\">            btnPermissions: [&#39;admin&#39;]</span><br><span class=\"line\">        &#125; &#x2F;&#x2F;页面需要的权限</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n自定义权限鉴定指令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**权限指令**&#x2F;</span><br><span class=\"line\">const has &#x3D; Vue.directive(&#39;has&#39;, &#123;</span><br><span class=\"line\">    bind: function (el, binding, vnode) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取页面按钮权限</span><br><span class=\"line\">        let btnPermissionsArr &#x3D; [];</span><br><span class=\"line\">        if(binding.value)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。</span><br><span class=\"line\">            btnPermissionsArr &#x3D; Array.of(binding.value);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。</span><br><span class=\"line\">            btnPermissionsArr &#x3D; vnode.context.$route.meta.btnPermissions;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;</span><br><span class=\"line\">            el.parentNode.removeChild(el);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F; 权限检查方法</span><br><span class=\"line\">Vue.prototype.$_has &#x3D; function (value) &#123;</span><br><span class=\"line\">    let isExist &#x3D; false;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取用户按钮权限</span><br><span class=\"line\">    let btnPermissionsStr &#x3D; sessionStorage.getItem(&quot;btnPermissions&quot;);</span><br><span class=\"line\">    if (btnPermissionsStr &#x3D;&#x3D; undefined || btnPermissionsStr &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;</span><br><span class=\"line\">        isExist &#x3D; true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isExist;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export &#123;has&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>根据项目进行方案考虑，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>\n"},{"title":"CSS基础","date":"2021-03-15T02:26:23.000Z","_content":"### 1. 盒模型？\n盒模型：框模型，包含content(内容)、padding(内边距)、border(边框)、margin(外边距)。\n## 1. IE模型和标准模型的区别？\nIE模型：width=content+padding，height=content+padding\n标准模型：width=content，height=content\n## 2. CSS设置方式\n可通过CSS3新增的属性box-sizing设置盒模型的模式，content-box(标准模型)，IE模型(border-box)。\n## 3. JavaScript设置盒模型的宽高\n1.dom.style.width/height //只能取到行内样式的宽和高，style标签中的link外链取不到。\n2.dom.currentStyle.width/height //取到的是最终渲染后的宽高，只IE支持\n3.window.getComputedStyle(dom).width/height //同(2)，IE9以上支持，其他浏览器支持\n4.dom.getBoundingClientRect().width/height //同(3)，还可取到对于视窗的上下左右的距离\n## 4. 外边距重叠\n当两个垂直外边距相遇时，会形成外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。普通文档流才会发生，行内框，浮动框和绝对定位之间的外边距不会合并。\n## 5. BFC\nBFC：块级格式化上下文\n - BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠。\n - BFC的区域不会与浮动元素的布局重叠。\n - BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。\n - 计算BFC高度的时候，浮动元素也会参与计算（清楚浮动）。\n## 6. 触发条件\n - overflow部位visible；\n - float的值不为none；\n - position的值不为static或relative；\n - display属性为inline-block，table，table-cell，table-caption，flex，inline-flex\n当子元素浮动不会影响父元素时，可以给父元素触发BFC。\n---\n### 2. CSS选择器\n选择器类型：\n - 简单选择器：通过元素类型(元素名)、class(.)或id(#)匹配一个或多个元素\n - 属性选择器：通过属性/属性值匹配一个或多个元素\n - 伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点(:)\n - 伪元素：匹配处于相关的确定位置的一个或多个元素(::)\n - 组合器：不仅是选择器本身，还以有效的方式组合老两个或更多的选择器用于非常特定的选择的方法。(嵌套)\n - 多用选择器：以逗号分隔开的多个选择器放在一个CSS规则下面\n---\n### 3. BFC\n块级格式化上下文，独立的容器，不影响外面的布局。\n触发条件：\n - body根元素\n - 浮动元素\n - 绝对定位元素\n - display(inline-block、table-cells、flex)\n - overflow(hidden、auto、scroll)\n特性：\n - 在同一个BFC中，外边距会发生折叠\n - BFC可以包含浮动的元素(清除浮动)\n - 可以阻止元素被浮动元素覆盖\n---\n### 4. position\n - 默认是static(静态定位)\n - 相对定位(relative)\n - 绝对定位(absolute)\n - 固定定位(fixed)\n - sticky(fixed和relative的混合)\n元素根据z-index决定显示层级\n---\n### 4. flex布局\n根据主轴和交叉轴进行排列\nalign-items(交叉轴方向)：对齐方式\njustify-content(主轴方向)：对齐方式\n---\n### 5. CSS优先级\n根据权重决定\n - 行内样式+1000\n - id选择器+100\n - 属性,class选择器,伪类+10\n - 元素选择器,伪元素+1\n - 通配符+0\n - !important提升样式优先级(最高)，最好不用\ncss样式单线程，依次从上向下加载，优先级和加载顺序有关\n!important>行内>内联and外联\n权重相等时，靠近目标的优先\n总结：\n - !important > id > class > tag\n - !important可以提升，不建议使用，会影响子属性\n - 同样的!important，按权重决定\n - 同一个CSS样式写两次，前面会被覆盖\n - 样式指向同一元素，权重规则生效，权重大的被应用\n - 样式指向同一元素，权重规则生效，权重相同，就近原则，后面的样式应用\n - 样式不指向同一元素，权重失效，就近原则，离目标近的样式应用\n---\n### 6. 双飞翼/圣杯布局\n## 6.1 圣杯\n1.给left、middle、right设置float:left，脱离文档流\n2.给container设置overflow:hidden，形成BFC撑开文档\n3.left，right设置上各自的宽度\n4.middle设置width:100%\n5.给left,middle,right设置positon:relative\n6.left设置left:-leftWidth,right设置right:-rightWidth\n7.container设置padding:0,rightWidth,0,leftWidth\n```\n.left middle right {position:relative;float:left;word-break:break-all}\n.left{margin-left:-100%;left:-200px;width:200px;}\n.right{margin-left:-220px;right:-220px;width:220px;}\n.middle{width:100%}\n```\n## 6.2 双飞翼布局\n1.middle增加inner\n2.给left,middle,right设置float:left脱离文档流\n3.container加上overflow:hidden,触发BFC\n4.left,right设置宽度\n5.middle设置width:100%\n6.left设置margin-left:-100%,right设置right:-rightWidth;\n7.container设置padding:0,rightWidth,0,leftWidth;\n```\n.left middle right {float:left;word-break:break-all}\n.left{margin-left:-100%;width:200px}\n.right{margin-left:-220px;width:220px;}\n.middle{width:100%;height:100%}\n```\n由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width>LeftWidth+RightWidth\n---\n### 7. CSS3新特性\n## 7.1 过渡\ntransition: CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)\ntransition:width,.5s,ease,.2s\n## 7.2 动画\nanimation:动画名称，花费时间，运动曲线，动画延迟，播放次数，是否反向动画，是否暂停动画\nanimation:logo2-line 2s linear;\n## 7.3 形状转换\ntranform:适用于2D或3D转换的元素\ntransform:rotate(30deg);\n## 7.4 选择器\n[CSS选择器参考手册](https://www.w3school.com.cn/cssref/css_selectors.asp)\n## 7.5 阴影\nbox-shadow:水平阴影位置 垂直阴影位置 模糊距离 阴影大小 阴影颜色等\nbox-shadow:10px 10px 5px #888888\n## 7.6 边框\nborder-image:..//边框图\nborder-radius:..//边框圆角\n## 7.7 背景\nbackground-clip:padding-box;//content-box\n## 7.8 反射\n-webkit-box-reflect:方向[above-上|below-下|right-右|left-左]\n## 7.9 文字\n\n\n","source":"_posts/CSS基础.md","raw":"---\ntitle: CSS基础\ndate: 2021-03-15 10:26:23\ntags:\n - CSS\n - 响应式布局\ncategories: 页面样式\n---\n### 1. 盒模型？\n盒模型：框模型，包含content(内容)、padding(内边距)、border(边框)、margin(外边距)。\n## 1. IE模型和标准模型的区别？\nIE模型：width=content+padding，height=content+padding\n标准模型：width=content，height=content\n## 2. CSS设置方式\n可通过CSS3新增的属性box-sizing设置盒模型的模式，content-box(标准模型)，IE模型(border-box)。\n## 3. JavaScript设置盒模型的宽高\n1.dom.style.width/height //只能取到行内样式的宽和高，style标签中的link外链取不到。\n2.dom.currentStyle.width/height //取到的是最终渲染后的宽高，只IE支持\n3.window.getComputedStyle(dom).width/height //同(2)，IE9以上支持，其他浏览器支持\n4.dom.getBoundingClientRect().width/height //同(3)，还可取到对于视窗的上下左右的距离\n## 4. 外边距重叠\n当两个垂直外边距相遇时，会形成外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。普通文档流才会发生，行内框，浮动框和绝对定位之间的外边距不会合并。\n## 5. BFC\nBFC：块级格式化上下文\n - BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠。\n - BFC的区域不会与浮动元素的布局重叠。\n - BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。\n - 计算BFC高度的时候，浮动元素也会参与计算（清楚浮动）。\n## 6. 触发条件\n - overflow部位visible；\n - float的值不为none；\n - position的值不为static或relative；\n - display属性为inline-block，table，table-cell，table-caption，flex，inline-flex\n当子元素浮动不会影响父元素时，可以给父元素触发BFC。\n---\n### 2. CSS选择器\n选择器类型：\n - 简单选择器：通过元素类型(元素名)、class(.)或id(#)匹配一个或多个元素\n - 属性选择器：通过属性/属性值匹配一个或多个元素\n - 伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点(:)\n - 伪元素：匹配处于相关的确定位置的一个或多个元素(::)\n - 组合器：不仅是选择器本身，还以有效的方式组合老两个或更多的选择器用于非常特定的选择的方法。(嵌套)\n - 多用选择器：以逗号分隔开的多个选择器放在一个CSS规则下面\n---\n### 3. BFC\n块级格式化上下文，独立的容器，不影响外面的布局。\n触发条件：\n - body根元素\n - 浮动元素\n - 绝对定位元素\n - display(inline-block、table-cells、flex)\n - overflow(hidden、auto、scroll)\n特性：\n - 在同一个BFC中，外边距会发生折叠\n - BFC可以包含浮动的元素(清除浮动)\n - 可以阻止元素被浮动元素覆盖\n---\n### 4. position\n - 默认是static(静态定位)\n - 相对定位(relative)\n - 绝对定位(absolute)\n - 固定定位(fixed)\n - sticky(fixed和relative的混合)\n元素根据z-index决定显示层级\n---\n### 4. flex布局\n根据主轴和交叉轴进行排列\nalign-items(交叉轴方向)：对齐方式\njustify-content(主轴方向)：对齐方式\n---\n### 5. CSS优先级\n根据权重决定\n - 行内样式+1000\n - id选择器+100\n - 属性,class选择器,伪类+10\n - 元素选择器,伪元素+1\n - 通配符+0\n - !important提升样式优先级(最高)，最好不用\ncss样式单线程，依次从上向下加载，优先级和加载顺序有关\n!important>行内>内联and外联\n权重相等时，靠近目标的优先\n总结：\n - !important > id > class > tag\n - !important可以提升，不建议使用，会影响子属性\n - 同样的!important，按权重决定\n - 同一个CSS样式写两次，前面会被覆盖\n - 样式指向同一元素，权重规则生效，权重大的被应用\n - 样式指向同一元素，权重规则生效，权重相同，就近原则，后面的样式应用\n - 样式不指向同一元素，权重失效，就近原则，离目标近的样式应用\n---\n### 6. 双飞翼/圣杯布局\n## 6.1 圣杯\n1.给left、middle、right设置float:left，脱离文档流\n2.给container设置overflow:hidden，形成BFC撑开文档\n3.left，right设置上各自的宽度\n4.middle设置width:100%\n5.给left,middle,right设置positon:relative\n6.left设置left:-leftWidth,right设置right:-rightWidth\n7.container设置padding:0,rightWidth,0,leftWidth\n```\n.left middle right {position:relative;float:left;word-break:break-all}\n.left{margin-left:-100%;left:-200px;width:200px;}\n.right{margin-left:-220px;right:-220px;width:220px;}\n.middle{width:100%}\n```\n## 6.2 双飞翼布局\n1.middle增加inner\n2.给left,middle,right设置float:left脱离文档流\n3.container加上overflow:hidden,触发BFC\n4.left,right设置宽度\n5.middle设置width:100%\n6.left设置margin-left:-100%,right设置right:-rightWidth;\n7.container设置padding:0,rightWidth,0,leftWidth;\n```\n.left middle right {float:left;word-break:break-all}\n.left{margin-left:-100%;width:200px}\n.right{margin-left:-220px;width:220px;}\n.middle{width:100%;height:100%}\n```\n由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width>LeftWidth+RightWidth\n---\n### 7. CSS3新特性\n## 7.1 过渡\ntransition: CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)\ntransition:width,.5s,ease,.2s\n## 7.2 动画\nanimation:动画名称，花费时间，运动曲线，动画延迟，播放次数，是否反向动画，是否暂停动画\nanimation:logo2-line 2s linear;\n## 7.3 形状转换\ntranform:适用于2D或3D转换的元素\ntransform:rotate(30deg);\n## 7.4 选择器\n[CSS选择器参考手册](https://www.w3school.com.cn/cssref/css_selectors.asp)\n## 7.5 阴影\nbox-shadow:水平阴影位置 垂直阴影位置 模糊距离 阴影大小 阴影颜色等\nbox-shadow:10px 10px 5px #888888\n## 7.6 边框\nborder-image:..//边框图\nborder-radius:..//边框圆角\n## 7.7 背景\nbackground-clip:padding-box;//content-box\n## 7.8 反射\n-webkit-box-reflect:方向[above-上|below-下|right-右|left-左]\n## 7.9 文字\n\n\n","slug":"CSS基础","published":1,"updated":"2021-03-31T13:59:17.058Z","_id":"ckmafka6w0000qgva4b765vx8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-盒模型？\"><a href=\"#1-盒模型？\" class=\"headerlink\" title=\"1. 盒模型？\"></a>1. 盒模型？</h3><p>盒模型：框模型，包含content(内容)、padding(内边距)、border(边框)、margin(外边距)。</p>\n<h2 id=\"1-IE模型和标准模型的区别？\"><a href=\"#1-IE模型和标准模型的区别？\" class=\"headerlink\" title=\"1. IE模型和标准模型的区别？\"></a>1. IE模型和标准模型的区别？</h2><p>IE模型：width=content+padding，height=content+padding<br>标准模型：width=content，height=content</p>\n<h2 id=\"2-CSS设置方式\"><a href=\"#2-CSS设置方式\" class=\"headerlink\" title=\"2. CSS设置方式\"></a>2. CSS设置方式</h2><p>可通过CSS3新增的属性box-sizing设置盒模型的模式，content-box(标准模型)，IE模型(border-box)。</p>\n<h2 id=\"3-JavaScript设置盒模型的宽高\"><a href=\"#3-JavaScript设置盒模型的宽高\" class=\"headerlink\" title=\"3. JavaScript设置盒模型的宽高\"></a>3. JavaScript设置盒模型的宽高</h2><p>1.dom.style.width/height //只能取到行内样式的宽和高，style标签中的link外链取不到。<br>2.dom.currentStyle.width/height //取到的是最终渲染后的宽高，只IE支持<br>3.window.getComputedStyle(dom).width/height //同(2)，IE9以上支持，其他浏览器支持<br>4.dom.getBoundingClientRect().width/height //同(3)，还可取到对于视窗的上下左右的距离</p>\n<h2 id=\"4-外边距重叠\"><a href=\"#4-外边距重叠\" class=\"headerlink\" title=\"4. 外边距重叠\"></a>4. 外边距重叠</h2><p>当两个垂直外边距相遇时，会形成外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。普通文档流才会发生，行内框，浮动框和绝对定位之间的外边距不会合并。</p>\n<h2 id=\"5-BFC\"><a href=\"#5-BFC\" class=\"headerlink\" title=\"5. BFC\"></a>5. BFC</h2><p>BFC：块级格式化上下文</p>\n<ul>\n<li>BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠。</li>\n<li>BFC的区域不会与浮动元素的布局重叠。</li>\n<li>BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。</li>\n<li>计算BFC高度的时候，浮动元素也会参与计算（清楚浮动）。<h2 id=\"6-触发条件\"><a href=\"#6-触发条件\" class=\"headerlink\" title=\"6. 触发条件\"></a>6. 触发条件</h2></li>\n<li>overflow部位visible；</li>\n<li>float的值不为none；</li>\n<li>position的值不为static或relative；</li>\n<li>display属性为inline-block，table，table-cell，table-caption，flex，inline-flex<br>当子元素浮动不会影响父元素时，可以给父元素触发BFC。</li>\n</ul>\n<hr>\n<h3 id=\"2-CSS选择器\"><a href=\"#2-CSS选择器\" class=\"headerlink\" title=\"2. CSS选择器\"></a>2. CSS选择器</h3><p>选择器类型：</p>\n<ul>\n<li>简单选择器：通过元素类型(元素名)、class(.)或id(#)匹配一个或多个元素</li>\n<li>属性选择器：通过属性/属性值匹配一个或多个元素</li>\n<li>伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点(:)</li>\n<li>伪元素：匹配处于相关的确定位置的一个或多个元素(::)</li>\n<li>组合器：不仅是选择器本身，还以有效的方式组合老两个或更多的选择器用于非常特定的选择的方法。(嵌套)</li>\n<li>多用选择器：以逗号分隔开的多个选择器放在一个CSS规则下面</li>\n</ul>\n<hr>\n<h3 id=\"3-BFC\"><a href=\"#3-BFC\" class=\"headerlink\" title=\"3. BFC\"></a>3. BFC</h3><p>块级格式化上下文，独立的容器，不影响外面的布局。<br>触发条件：</p>\n<ul>\n<li>body根元素</li>\n<li>浮动元素</li>\n<li>绝对定位元素</li>\n<li>display(inline-block、table-cells、flex)</li>\n<li>overflow(hidden、auto、scroll)<br>特性：</li>\n<li>在同一个BFC中，外边距会发生折叠</li>\n<li>BFC可以包含浮动的元素(清除浮动)</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ul>\n<hr>\n<h3 id=\"4-position\"><a href=\"#4-position\" class=\"headerlink\" title=\"4. position\"></a>4. position</h3><ul>\n<li>默认是static(静态定位)</li>\n<li>相对定位(relative)</li>\n<li>绝对定位(absolute)</li>\n<li>固定定位(fixed)</li>\n<li>sticky(fixed和relative的混合)<br>元素根据z-index决定显示层级</li>\n</ul>\n<hr>\n<h3 id=\"4-flex布局\"><a href=\"#4-flex布局\" class=\"headerlink\" title=\"4. flex布局\"></a>4. flex布局</h3><p>根据主轴和交叉轴进行排列<br>align-items(交叉轴方向)：对齐方式<br>justify-content(主轴方向)：对齐方式</p>\n<hr>\n<h3 id=\"5-CSS优先级\"><a href=\"#5-CSS优先级\" class=\"headerlink\" title=\"5. CSS优先级\"></a>5. CSS优先级</h3><p>根据权重决定</p>\n<ul>\n<li>行内样式+1000</li>\n<li>id选择器+100</li>\n<li>属性,class选择器,伪类+10</li>\n<li>元素选择器,伪元素+1</li>\n<li>通配符+0</li>\n<li>!important提升样式优先级(最高)，最好不用<br>css样式单线程，依次从上向下加载，优先级和加载顺序有关<br>!important&gt;行内&gt;内联and外联<br>权重相等时，靠近目标的优先<br>总结：</li>\n<li>!important &gt; id &gt; class &gt; tag</li>\n<li>!important可以提升，不建议使用，会影响子属性</li>\n<li>同样的!important，按权重决定</li>\n<li>同一个CSS样式写两次，前面会被覆盖</li>\n<li>样式指向同一元素，权重规则生效，权重大的被应用</li>\n<li>样式指向同一元素，权重规则生效，权重相同，就近原则，后面的样式应用</li>\n<li>样式不指向同一元素，权重失效，就近原则，离目标近的样式应用</li>\n</ul>\n<hr>\n<h3 id=\"6-双飞翼-圣杯布局\"><a href=\"#6-双飞翼-圣杯布局\" class=\"headerlink\" title=\"6. 双飞翼/圣杯布局\"></a>6. 双飞翼/圣杯布局</h3><h2 id=\"6-1-圣杯\"><a href=\"#6-1-圣杯\" class=\"headerlink\" title=\"6.1 圣杯\"></a>6.1 圣杯</h2><p>1.给left、middle、right设置float:left，脱离文档流<br>2.给container设置overflow:hidden，形成BFC撑开文档<br>3.left，right设置上各自的宽度<br>4.middle设置width:100%<br>5.给left,middle,right设置positon:relative<br>6.left设置left:-leftWidth,right设置right:-rightWidth<br>7.container设置padding:0,rightWidth,0,leftWidth</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left middle right &#123;position:relative;float:left;word-break:break-all&#125;</span><br><span class=\"line\">.left&#123;margin-left:-100%;left:-200px;width:200px;&#125;</span><br><span class=\"line\">.right&#123;margin-left:-220px;right:-220px;width:220px;&#125;</span><br><span class=\"line\">.middle&#123;width:100%&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-双飞翼布局\"><a href=\"#6-2-双飞翼布局\" class=\"headerlink\" title=\"6.2 双飞翼布局\"></a>6.2 双飞翼布局</h2><p>1.middle增加inner<br>2.给left,middle,right设置float:left脱离文档流<br>3.container加上overflow:hidden,触发BFC<br>4.left,right设置宽度<br>5.middle设置width:100%<br>6.left设置margin-left:-100%,right设置right:-rightWidth;<br>7.container设置padding:0,rightWidth,0,leftWidth;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left middle right &#123;float:left;word-break:break-all&#125;</span><br><span class=\"line\">.left&#123;margin-left:-100%;width:200px&#125;</span><br><span class=\"line\">.right&#123;margin-left:-220px;width:220px;&#125;</span><br><span class=\"line\">.middle&#123;width:100%;height:100%&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width-gt-LeftWidth-RightWidth\"><a href=\"#由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width-gt-LeftWidth-RightWidth\" class=\"headerlink\" title=\"由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width&gt;LeftWidth+RightWidth\"></a>由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width&gt;LeftWidth+RightWidth</h2><h3 id=\"7-CSS3新特性\"><a href=\"#7-CSS3新特性\" class=\"headerlink\" title=\"7. CSS3新特性\"></a>7. CSS3新特性</h3><h2 id=\"7-1-过渡\"><a href=\"#7-1-过渡\" class=\"headerlink\" title=\"7.1 过渡\"></a>7.1 过渡</h2><p>transition: CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)<br>transition:width,.5s,ease,.2s</p>\n<h2 id=\"7-2-动画\"><a href=\"#7-2-动画\" class=\"headerlink\" title=\"7.2 动画\"></a>7.2 动画</h2><p>animation:动画名称，花费时间，运动曲线，动画延迟，播放次数，是否反向动画，是否暂停动画<br>animation:logo2-line 2s linear;</p>\n<h2 id=\"7-3-形状转换\"><a href=\"#7-3-形状转换\" class=\"headerlink\" title=\"7.3 形状转换\"></a>7.3 形状转换</h2><p>tranform:适用于2D或3D转换的元素<br>transform:rotate(30deg);</p>\n<h2 id=\"7-4-选择器\"><a href=\"#7-4-选择器\" class=\"headerlink\" title=\"7.4 选择器\"></a>7.4 选择器</h2><p><a href=\"https://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"noopener\">CSS选择器参考手册</a></p>\n<h2 id=\"7-5-阴影\"><a href=\"#7-5-阴影\" class=\"headerlink\" title=\"7.5 阴影\"></a>7.5 阴影</h2><p>box-shadow:水平阴影位置 垂直阴影位置 模糊距离 阴影大小 阴影颜色等<br>box-shadow:10px 10px 5px #888888</p>\n<h2 id=\"7-6-边框\"><a href=\"#7-6-边框\" class=\"headerlink\" title=\"7.6 边框\"></a>7.6 边框</h2><p>border-image:..//边框图<br>border-radius:..//边框圆角</p>\n<h2 id=\"7-7-背景\"><a href=\"#7-7-背景\" class=\"headerlink\" title=\"7.7 背景\"></a>7.7 背景</h2><p>background-clip:padding-box;//content-box</p>\n<h2 id=\"7-8-反射\"><a href=\"#7-8-反射\" class=\"headerlink\" title=\"7.8 反射\"></a>7.8 反射</h2><p>-webkit-box-reflect:方向[above-上|below-下|right-右|left-左]</p>\n<h2 id=\"7-9-文字\"><a href=\"#7-9-文字\" class=\"headerlink\" title=\"7.9 文字\"></a>7.9 文字</h2>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-盒模型？\"><a href=\"#1-盒模型？\" class=\"headerlink\" title=\"1. 盒模型？\"></a>1. 盒模型？</h3><p>盒模型：框模型，包含content(内容)、padding(内边距)、border(边框)、margin(外边距)。</p>\n<h2 id=\"1-IE模型和标准模型的区别？\"><a href=\"#1-IE模型和标准模型的区别？\" class=\"headerlink\" title=\"1. IE模型和标准模型的区别？\"></a>1. IE模型和标准模型的区别？</h2><p>IE模型：width=content+padding，height=content+padding<br>标准模型：width=content，height=content</p>\n<h2 id=\"2-CSS设置方式\"><a href=\"#2-CSS设置方式\" class=\"headerlink\" title=\"2. CSS设置方式\"></a>2. CSS设置方式</h2><p>可通过CSS3新增的属性box-sizing设置盒模型的模式，content-box(标准模型)，IE模型(border-box)。</p>\n<h2 id=\"3-JavaScript设置盒模型的宽高\"><a href=\"#3-JavaScript设置盒模型的宽高\" class=\"headerlink\" title=\"3. JavaScript设置盒模型的宽高\"></a>3. JavaScript设置盒模型的宽高</h2><p>1.dom.style.width/height //只能取到行内样式的宽和高，style标签中的link外链取不到。<br>2.dom.currentStyle.width/height //取到的是最终渲染后的宽高，只IE支持<br>3.window.getComputedStyle(dom).width/height //同(2)，IE9以上支持，其他浏览器支持<br>4.dom.getBoundingClientRect().width/height //同(3)，还可取到对于视窗的上下左右的距离</p>\n<h2 id=\"4-外边距重叠\"><a href=\"#4-外边距重叠\" class=\"headerlink\" title=\"4. 外边距重叠\"></a>4. 外边距重叠</h2><p>当两个垂直外边距相遇时，会形成外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。普通文档流才会发生，行内框，浮动框和绝对定位之间的外边距不会合并。</p>\n<h2 id=\"5-BFC\"><a href=\"#5-BFC\" class=\"headerlink\" title=\"5. BFC\"></a>5. BFC</h2><p>BFC：块级格式化上下文</p>\n<ul>\n<li>BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠。</li>\n<li>BFC的区域不会与浮动元素的布局重叠。</li>\n<li>BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。</li>\n<li>计算BFC高度的时候，浮动元素也会参与计算（清楚浮动）。<h2 id=\"6-触发条件\"><a href=\"#6-触发条件\" class=\"headerlink\" title=\"6. 触发条件\"></a>6. 触发条件</h2></li>\n<li>overflow部位visible；</li>\n<li>float的值不为none；</li>\n<li>position的值不为static或relative；</li>\n<li>display属性为inline-block，table，table-cell，table-caption，flex，inline-flex<br>当子元素浮动不会影响父元素时，可以给父元素触发BFC。</li>\n</ul>\n<hr>\n<h3 id=\"2-CSS选择器\"><a href=\"#2-CSS选择器\" class=\"headerlink\" title=\"2. CSS选择器\"></a>2. CSS选择器</h3><p>选择器类型：</p>\n<ul>\n<li>简单选择器：通过元素类型(元素名)、class(.)或id(#)匹配一个或多个元素</li>\n<li>属性选择器：通过属性/属性值匹配一个或多个元素</li>\n<li>伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点(:)</li>\n<li>伪元素：匹配处于相关的确定位置的一个或多个元素(::)</li>\n<li>组合器：不仅是选择器本身，还以有效的方式组合老两个或更多的选择器用于非常特定的选择的方法。(嵌套)</li>\n<li>多用选择器：以逗号分隔开的多个选择器放在一个CSS规则下面</li>\n</ul>\n<hr>\n<h3 id=\"3-BFC\"><a href=\"#3-BFC\" class=\"headerlink\" title=\"3. BFC\"></a>3. BFC</h3><p>块级格式化上下文，独立的容器，不影响外面的布局。<br>触发条件：</p>\n<ul>\n<li>body根元素</li>\n<li>浮动元素</li>\n<li>绝对定位元素</li>\n<li>display(inline-block、table-cells、flex)</li>\n<li>overflow(hidden、auto、scroll)<br>特性：</li>\n<li>在同一个BFC中，外边距会发生折叠</li>\n<li>BFC可以包含浮动的元素(清除浮动)</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ul>\n<hr>\n<h3 id=\"4-position\"><a href=\"#4-position\" class=\"headerlink\" title=\"4. position\"></a>4. position</h3><ul>\n<li>默认是static(静态定位)</li>\n<li>相对定位(relative)</li>\n<li>绝对定位(absolute)</li>\n<li>固定定位(fixed)</li>\n<li>sticky(fixed和relative的混合)<br>元素根据z-index决定显示层级</li>\n</ul>\n<hr>\n<h3 id=\"4-flex布局\"><a href=\"#4-flex布局\" class=\"headerlink\" title=\"4. flex布局\"></a>4. flex布局</h3><p>根据主轴和交叉轴进行排列<br>align-items(交叉轴方向)：对齐方式<br>justify-content(主轴方向)：对齐方式</p>\n<hr>\n<h3 id=\"5-CSS优先级\"><a href=\"#5-CSS优先级\" class=\"headerlink\" title=\"5. CSS优先级\"></a>5. CSS优先级</h3><p>根据权重决定</p>\n<ul>\n<li>行内样式+1000</li>\n<li>id选择器+100</li>\n<li>属性,class选择器,伪类+10</li>\n<li>元素选择器,伪元素+1</li>\n<li>通配符+0</li>\n<li>!important提升样式优先级(最高)，最好不用<br>css样式单线程，依次从上向下加载，优先级和加载顺序有关<br>!important&gt;行内&gt;内联and外联<br>权重相等时，靠近目标的优先<br>总结：</li>\n<li>!important &gt; id &gt; class &gt; tag</li>\n<li>!important可以提升，不建议使用，会影响子属性</li>\n<li>同样的!important，按权重决定</li>\n<li>同一个CSS样式写两次，前面会被覆盖</li>\n<li>样式指向同一元素，权重规则生效，权重大的被应用</li>\n<li>样式指向同一元素，权重规则生效，权重相同，就近原则，后面的样式应用</li>\n<li>样式不指向同一元素，权重失效，就近原则，离目标近的样式应用</li>\n</ul>\n<hr>\n<h3 id=\"6-双飞翼-圣杯布局\"><a href=\"#6-双飞翼-圣杯布局\" class=\"headerlink\" title=\"6. 双飞翼/圣杯布局\"></a>6. 双飞翼/圣杯布局</h3><h2 id=\"6-1-圣杯\"><a href=\"#6-1-圣杯\" class=\"headerlink\" title=\"6.1 圣杯\"></a>6.1 圣杯</h2><p>1.给left、middle、right设置float:left，脱离文档流<br>2.给container设置overflow:hidden，形成BFC撑开文档<br>3.left，right设置上各自的宽度<br>4.middle设置width:100%<br>5.给left,middle,right设置positon:relative<br>6.left设置left:-leftWidth,right设置right:-rightWidth<br>7.container设置padding:0,rightWidth,0,leftWidth</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left middle right &#123;position:relative;float:left;word-break:break-all&#125;</span><br><span class=\"line\">.left&#123;margin-left:-100%;left:-200px;width:200px;&#125;</span><br><span class=\"line\">.right&#123;margin-left:-220px;right:-220px;width:220px;&#125;</span><br><span class=\"line\">.middle&#123;width:100%&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-双飞翼布局\"><a href=\"#6-2-双飞翼布局\" class=\"headerlink\" title=\"6.2 双飞翼布局\"></a>6.2 双飞翼布局</h2><p>1.middle增加inner<br>2.给left,middle,right设置float:left脱离文档流<br>3.container加上overflow:hidden,触发BFC<br>4.left,right设置宽度<br>5.middle设置width:100%<br>6.left设置margin-left:-100%,right设置right:-rightWidth;<br>7.container设置padding:0,rightWidth,0,leftWidth;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left middle right &#123;float:left;word-break:break-all&#125;</span><br><span class=\"line\">.left&#123;margin-left:-100%;width:200px&#125;</span><br><span class=\"line\">.right&#123;margin-left:-220px;width:220px;&#125;</span><br><span class=\"line\">.middle&#123;width:100%;height:100%&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width-gt-LeftWidth-RightWidth\"><a href=\"#由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width-gt-LeftWidth-RightWidth\" class=\"headerlink\" title=\"由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width&gt;LeftWidth+RightWidth\"></a>由于双飞翼布局会压缩中间部分的宽度，所以需要设置min-width&gt;LeftWidth+RightWidth</h2><h3 id=\"7-CSS3新特性\"><a href=\"#7-CSS3新特性\" class=\"headerlink\" title=\"7. CSS3新特性\"></a>7. CSS3新特性</h3><h2 id=\"7-1-过渡\"><a href=\"#7-1-过渡\" class=\"headerlink\" title=\"7.1 过渡\"></a>7.1 过渡</h2><p>transition: CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)<br>transition:width,.5s,ease,.2s</p>\n<h2 id=\"7-2-动画\"><a href=\"#7-2-动画\" class=\"headerlink\" title=\"7.2 动画\"></a>7.2 动画</h2><p>animation:动画名称，花费时间，运动曲线，动画延迟，播放次数，是否反向动画，是否暂停动画<br>animation:logo2-line 2s linear;</p>\n<h2 id=\"7-3-形状转换\"><a href=\"#7-3-形状转换\" class=\"headerlink\" title=\"7.3 形状转换\"></a>7.3 形状转换</h2><p>tranform:适用于2D或3D转换的元素<br>transform:rotate(30deg);</p>\n<h2 id=\"7-4-选择器\"><a href=\"#7-4-选择器\" class=\"headerlink\" title=\"7.4 选择器\"></a>7.4 选择器</h2><p><a href=\"https://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"noopener\">CSS选择器参考手册</a></p>\n<h2 id=\"7-5-阴影\"><a href=\"#7-5-阴影\" class=\"headerlink\" title=\"7.5 阴影\"></a>7.5 阴影</h2><p>box-shadow:水平阴影位置 垂直阴影位置 模糊距离 阴影大小 阴影颜色等<br>box-shadow:10px 10px 5px #888888</p>\n<h2 id=\"7-6-边框\"><a href=\"#7-6-边框\" class=\"headerlink\" title=\"7.6 边框\"></a>7.6 边框</h2><p>border-image:..//边框图<br>border-radius:..//边框圆角</p>\n<h2 id=\"7-7-背景\"><a href=\"#7-7-背景\" class=\"headerlink\" title=\"7.7 背景\"></a>7.7 背景</h2><p>background-clip:padding-box;//content-box</p>\n<h2 id=\"7-8-反射\"><a href=\"#7-8-反射\" class=\"headerlink\" title=\"7.8 反射\"></a>7.8 反射</h2><p>-webkit-box-reflect:方向[above-上|below-下|right-右|left-左]</p>\n<h2 id=\"7-9-文字\"><a href=\"#7-9-文字\" class=\"headerlink\" title=\"7.9 文字\"></a>7.9 文字</h2>"},{"title":"Vue响应式原理","date":"2021-03-15T02:56:14.000Z","_content":"## 1. 数据初始化\nVue源码中在initState中进行了数据初始化，为数据添加响应式。针对props，methods，data，computed和watch，做数据的初始化处理，响应式转换。\n## 2. initProps\nProps用于父子组件间传值(父传子)。\n:test=test会被解析成{attrs: {test: test}}，并作为子组件的render函数。\n创建VNode遇到child占位符时，根据attrs属性进行规范校验，最后以propsData形式传入Vnode构造器中。\n通过proxy为props做了一层代理，可通过vue实例代理访问到props的值，本质上是利用Object.defineProperty对数据的getter和setter方法进行重写。\n总结：props以propsData的形式在Vnode的属性存在，通过proxy进行代理，然后实例访问。\n## 3. initMethods\nmethods方法定义必须是函数，命名不能与props重复。定义的方法都将挂载在根实例上。\n## 4. initData\n核心方法是observe，在observe方法中将数据对象标记为响应式对象，然后进行响应式处理。同props，通过proxy对data做一层处理，可通过实例访问对象属性。\n## 5. initComputed\n1.computed可以是对象，也可以是函数，函数必须有getter。\n2.针对每个computed属性都需要创建一个监听的依赖(watcher)。\ncomputed的命名防止与props，data冲突\n## 6. 响应式系统\nobserve：挂载组件，引入observe类，通过Object.defineProperty，对数据的getter和setter进行改写，读取getter进行依赖手机，在setter时进行依赖更新。\nwatcher：一个watcher实例急速一个依赖，watcher记录这个依赖监听的状态以及如何更新操作的方法。渲染数据到真实DOM时会创建watcher。\n## 7. 小结\n最终都是调用Object.defineProperty进行数据拦截。\n\n\n\n","source":"_posts/Vue响应式原理.md","raw":"---\ntitle: Vue响应式原理\ndate: 2021-03-15 10:56:14\ntags:\n - 前端框架\n - Vue\ncategories: Web前端\n---\n## 1. 数据初始化\nVue源码中在initState中进行了数据初始化，为数据添加响应式。针对props，methods，data，computed和watch，做数据的初始化处理，响应式转换。\n## 2. initProps\nProps用于父子组件间传值(父传子)。\n:test=test会被解析成{attrs: {test: test}}，并作为子组件的render函数。\n创建VNode遇到child占位符时，根据attrs属性进行规范校验，最后以propsData形式传入Vnode构造器中。\n通过proxy为props做了一层代理，可通过vue实例代理访问到props的值，本质上是利用Object.defineProperty对数据的getter和setter方法进行重写。\n总结：props以propsData的形式在Vnode的属性存在，通过proxy进行代理，然后实例访问。\n## 3. initMethods\nmethods方法定义必须是函数，命名不能与props重复。定义的方法都将挂载在根实例上。\n## 4. initData\n核心方法是observe，在observe方法中将数据对象标记为响应式对象，然后进行响应式处理。同props，通过proxy对data做一层处理，可通过实例访问对象属性。\n## 5. initComputed\n1.computed可以是对象，也可以是函数，函数必须有getter。\n2.针对每个computed属性都需要创建一个监听的依赖(watcher)。\ncomputed的命名防止与props，data冲突\n## 6. 响应式系统\nobserve：挂载组件，引入observe类，通过Object.defineProperty，对数据的getter和setter进行改写，读取getter进行依赖手机，在setter时进行依赖更新。\nwatcher：一个watcher实例急速一个依赖，watcher记录这个依赖监听的状态以及如何更新操作的方法。渲染数据到真实DOM时会创建watcher。\n## 7. 小结\n最终都是调用Object.defineProperty进行数据拦截。\n\n\n\n","slug":"Vue响应式原理","published":1,"updated":"2021-03-16T03:03:51.069Z","_id":"ckmafka730001qgva1gow2ny1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-数据初始化\"><a href=\"#1-数据初始化\" class=\"headerlink\" title=\"1. 数据初始化\"></a>1. 数据初始化</h2><p>Vue源码中在initState中进行了数据初始化，为数据添加响应式。针对props，methods，data，computed和watch，做数据的初始化处理，响应式转换。</p>\n<h2 id=\"2-initProps\"><a href=\"#2-initProps\" class=\"headerlink\" title=\"2. initProps\"></a>2. initProps</h2><p>Props用于父子组件间传值(父传子)。<br>:test=test会被解析成{attrs: {test: test}}，并作为子组件的render函数。<br>创建VNode遇到child占位符时，根据attrs属性进行规范校验，最后以propsData形式传入Vnode构造器中。<br>通过proxy为props做了一层代理，可通过vue实例代理访问到props的值，本质上是利用Object.defineProperty对数据的getter和setter方法进行重写。<br>总结：props以propsData的形式在Vnode的属性存在，通过proxy进行代理，然后实例访问。</p>\n<h2 id=\"3-initMethods\"><a href=\"#3-initMethods\" class=\"headerlink\" title=\"3. initMethods\"></a>3. initMethods</h2><p>methods方法定义必须是函数，命名不能与props重复。定义的方法都将挂载在根实例上。</p>\n<h2 id=\"4-initData\"><a href=\"#4-initData\" class=\"headerlink\" title=\"4. initData\"></a>4. initData</h2><p>核心方法是observe，在observe方法中将数据对象标记为响应式对象，然后进行响应式处理。同props，通过proxy对data做一层处理，可通过实例访问对象属性。</p>\n<h2 id=\"5-initComputed\"><a href=\"#5-initComputed\" class=\"headerlink\" title=\"5. initComputed\"></a>5. initComputed</h2><p>1.computed可以是对象，也可以是函数，函数必须有getter。<br>2.针对每个computed属性都需要创建一个监听的依赖(watcher)。<br>computed的命名防止与props，data冲突</p>\n<h2 id=\"6-响应式系统\"><a href=\"#6-响应式系统\" class=\"headerlink\" title=\"6. 响应式系统\"></a>6. 响应式系统</h2><p>observe：挂载组件，引入observe类，通过Object.defineProperty，对数据的getter和setter进行改写，读取getter进行依赖手机，在setter时进行依赖更新。<br>watcher：一个watcher实例急速一个依赖，watcher记录这个依赖监听的状态以及如何更新操作的方法。渲染数据到真实DOM时会创建watcher。</p>\n<h2 id=\"7-小结\"><a href=\"#7-小结\" class=\"headerlink\" title=\"7. 小结\"></a>7. 小结</h2><p>最终都是调用Object.defineProperty进行数据拦截。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-数据初始化\"><a href=\"#1-数据初始化\" class=\"headerlink\" title=\"1. 数据初始化\"></a>1. 数据初始化</h2><p>Vue源码中在initState中进行了数据初始化，为数据添加响应式。针对props，methods，data，computed和watch，做数据的初始化处理，响应式转换。</p>\n<h2 id=\"2-initProps\"><a href=\"#2-initProps\" class=\"headerlink\" title=\"2. initProps\"></a>2. initProps</h2><p>Props用于父子组件间传值(父传子)。<br>:test=test会被解析成{attrs: {test: test}}，并作为子组件的render函数。<br>创建VNode遇到child占位符时，根据attrs属性进行规范校验，最后以propsData形式传入Vnode构造器中。<br>通过proxy为props做了一层代理，可通过vue实例代理访问到props的值，本质上是利用Object.defineProperty对数据的getter和setter方法进行重写。<br>总结：props以propsData的形式在Vnode的属性存在，通过proxy进行代理，然后实例访问。</p>\n<h2 id=\"3-initMethods\"><a href=\"#3-initMethods\" class=\"headerlink\" title=\"3. initMethods\"></a>3. initMethods</h2><p>methods方法定义必须是函数，命名不能与props重复。定义的方法都将挂载在根实例上。</p>\n<h2 id=\"4-initData\"><a href=\"#4-initData\" class=\"headerlink\" title=\"4. initData\"></a>4. initData</h2><p>核心方法是observe，在observe方法中将数据对象标记为响应式对象，然后进行响应式处理。同props，通过proxy对data做一层处理，可通过实例访问对象属性。</p>\n<h2 id=\"5-initComputed\"><a href=\"#5-initComputed\" class=\"headerlink\" title=\"5. initComputed\"></a>5. initComputed</h2><p>1.computed可以是对象，也可以是函数，函数必须有getter。<br>2.针对每个computed属性都需要创建一个监听的依赖(watcher)。<br>computed的命名防止与props，data冲突</p>\n<h2 id=\"6-响应式系统\"><a href=\"#6-响应式系统\" class=\"headerlink\" title=\"6. 响应式系统\"></a>6. 响应式系统</h2><p>observe：挂载组件，引入observe类，通过Object.defineProperty，对数据的getter和setter进行改写，读取getter进行依赖手机，在setter时进行依赖更新。<br>watcher：一个watcher实例急速一个依赖，watcher记录这个依赖监听的状态以及如何更新操作的方法。渲染数据到真实DOM时会创建watcher。</p>\n<h2 id=\"7-小结\"><a href=\"#7-小结\" class=\"headerlink\" title=\"7. 小结\"></a>7. 小结</h2><p>最终都是调用Object.defineProperty进行数据拦截。</p>\n"},{"title":"前端工程化","date":"2021-03-15T07:46:44.000Z","_content":"### 1. 模块化\n## 1.1 什么是模块化\n - 将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起\n - 块的内部数据与实现是私有的，只向外部暴露一些接口（方法）与外部其他模块通信\n## 1.2 模块化的进行过程\n - 全局function模式：将不同的功能封装成不同的全局函数\n编码：将不同的功能封装成不同的全局函数\n问题：污染全局命名空间，容易引起命名冲突或数据不安全，模块之间看不出关系\n - namespace模式：简单对象封装\n作用：减少全局变量，解决命名冲突\n问题：数据不安全\n - IIFE模式：匿名函数自调用（闭包）\n作用：数据是私有的，外部只能通过暴露的方法操作\n编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口\n问题：如果当前这个模块依赖另一个模块怎么办？\n - IIFE模式增强：引入依赖\n## 1.3 模块化的好处\n - 避免命名冲突\n - 更好的分离，按需加载\n - 更高复用性\n - 高可维护性\n## 1.4 引入多个script后出现问题\n - 请求过多\n - 依赖模糊\n - 难以维护\n### 2. AST\n## 2.1 什么是AST\n抽象语法树，源代码的抽象语法结构的树状表现形式。\n## 2.2 词法分析和语法分析\nJS是解释型语言，通过词法分析->语法分析->语法书，执行。\n词法分析：扫描，将字符流转换为记号流(token)，读取代码按照一定的规则合成一个个的标识。\n语法分析：解析器，将词法分析出来的数组转换成树的形式，验证语法。有错则报错。\n## 2.3 AST过程\n - 语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等\n - 代码混淆压缩\n - 优化变更代码，改变代码结构等\n### 3. babel工作原理\n解决了ES6兼容问题，把ES6代码转换为ES5代码，用了AST。\n配置presets,plugins使用插件\n访问者模式，访问某一个路径的时候进行匹配，然后在节点修改\n引入babel插件，使用babel对代码进行转换，过程会改变AST语法树，然后生成新代码\n## 3.1 babylon\nbabel使用的引擎是Babylon\n\n","source":"_posts/前端工程化.md","raw":"---\ntitle: 前端工程化\ndate: 2021-03-15 15:46:44\ntags:\n - 工程化\ncategories: Web前端\n---\n### 1. 模块化\n## 1.1 什么是模块化\n - 将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起\n - 块的内部数据与实现是私有的，只向外部暴露一些接口（方法）与外部其他模块通信\n## 1.2 模块化的进行过程\n - 全局function模式：将不同的功能封装成不同的全局函数\n编码：将不同的功能封装成不同的全局函数\n问题：污染全局命名空间，容易引起命名冲突或数据不安全，模块之间看不出关系\n - namespace模式：简单对象封装\n作用：减少全局变量，解决命名冲突\n问题：数据不安全\n - IIFE模式：匿名函数自调用（闭包）\n作用：数据是私有的，外部只能通过暴露的方法操作\n编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口\n问题：如果当前这个模块依赖另一个模块怎么办？\n - IIFE模式增强：引入依赖\n## 1.3 模块化的好处\n - 避免命名冲突\n - 更好的分离，按需加载\n - 更高复用性\n - 高可维护性\n## 1.4 引入多个script后出现问题\n - 请求过多\n - 依赖模糊\n - 难以维护\n### 2. AST\n## 2.1 什么是AST\n抽象语法树，源代码的抽象语法结构的树状表现形式。\n## 2.2 词法分析和语法分析\nJS是解释型语言，通过词法分析->语法分析->语法书，执行。\n词法分析：扫描，将字符流转换为记号流(token)，读取代码按照一定的规则合成一个个的标识。\n语法分析：解析器，将词法分析出来的数组转换成树的形式，验证语法。有错则报错。\n## 2.3 AST过程\n - 语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等\n - 代码混淆压缩\n - 优化变更代码，改变代码结构等\n### 3. babel工作原理\n解决了ES6兼容问题，把ES6代码转换为ES5代码，用了AST。\n配置presets,plugins使用插件\n访问者模式，访问某一个路径的时候进行匹配，然后在节点修改\n引入babel插件，使用babel对代码进行转换，过程会改变AST语法树，然后生成新代码\n## 3.1 babylon\nbabel使用的引擎是Babylon\n\n","slug":"前端工程化","published":1,"updated":"2021-03-25T09:10:47.918Z","_id":"ckmafka7b0004qgva56he4z8i","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-模块化\"><a href=\"#1-模块化\" class=\"headerlink\" title=\"1. 模块化\"></a>1. 模块化</h3><h2 id=\"1-1-什么是模块化\"><a href=\"#1-1-什么是模块化\" class=\"headerlink\" title=\"1.1 什么是模块化\"></a>1.1 什么是模块化</h2><ul>\n<li>将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起</li>\n<li>块的内部数据与实现是私有的，只向外部暴露一些接口（方法）与外部其他模块通信<h2 id=\"1-2-模块化的进行过程\"><a href=\"#1-2-模块化的进行过程\" class=\"headerlink\" title=\"1.2 模块化的进行过程\"></a>1.2 模块化的进行过程</h2></li>\n<li>全局function模式：将不同的功能封装成不同的全局函数<br>编码：将不同的功能封装成不同的全局函数<br>问题：污染全局命名空间，容易引起命名冲突或数据不安全，模块之间看不出关系</li>\n<li>namespace模式：简单对象封装<br>作用：减少全局变量，解决命名冲突<br>问题：数据不安全</li>\n<li>IIFE模式：匿名函数自调用（闭包）<br>作用：数据是私有的，外部只能通过暴露的方法操作<br>编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口<br>问题：如果当前这个模块依赖另一个模块怎么办？</li>\n<li>IIFE模式增强：引入依赖<h2 id=\"1-3-模块化的好处\"><a href=\"#1-3-模块化的好处\" class=\"headerlink\" title=\"1.3 模块化的好处\"></a>1.3 模块化的好处</h2></li>\n<li>避免命名冲突</li>\n<li>更好的分离，按需加载</li>\n<li>更高复用性</li>\n<li>高可维护性<h2 id=\"1-4-引入多个script后出现问题\"><a href=\"#1-4-引入多个script后出现问题\" class=\"headerlink\" title=\"1.4 引入多个script后出现问题\"></a>1.4 引入多个script后出现问题</h2></li>\n<li>请求过多</li>\n<li>依赖模糊</li>\n<li>难以维护<h3 id=\"2-AST\"><a href=\"#2-AST\" class=\"headerlink\" title=\"2. AST\"></a>2. AST</h3><h2 id=\"2-1-什么是AST\"><a href=\"#2-1-什么是AST\" class=\"headerlink\" title=\"2.1 什么是AST\"></a>2.1 什么是AST</h2>抽象语法树，源代码的抽象语法结构的树状表现形式。<h2 id=\"2-2-词法分析和语法分析\"><a href=\"#2-2-词法分析和语法分析\" class=\"headerlink\" title=\"2.2 词法分析和语法分析\"></a>2.2 词法分析和语法分析</h2>JS是解释型语言，通过词法分析-&gt;语法分析-&gt;语法书，执行。<br>词法分析：扫描，将字符流转换为记号流(token)，读取代码按照一定的规则合成一个个的标识。<br>语法分析：解析器，将词法分析出来的数组转换成树的形式，验证语法。有错则报错。<h2 id=\"2-3-AST过程\"><a href=\"#2-3-AST过程\" class=\"headerlink\" title=\"2.3 AST过程\"></a>2.3 AST过程</h2></li>\n<li>语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等</li>\n<li>代码混淆压缩</li>\n<li>优化变更代码，改变代码结构等<h3 id=\"3-babel工作原理\"><a href=\"#3-babel工作原理\" class=\"headerlink\" title=\"3. babel工作原理\"></a>3. babel工作原理</h3>解决了ES6兼容问题，把ES6代码转换为ES5代码，用了AST。<br>配置presets,plugins使用插件<br>访问者模式，访问某一个路径的时候进行匹配，然后在节点修改<br>引入babel插件，使用babel对代码进行转换，过程会改变AST语法树，然后生成新代码<h2 id=\"3-1-babylon\"><a href=\"#3-1-babylon\" class=\"headerlink\" title=\"3.1 babylon\"></a>3.1 babylon</h2>babel使用的引擎是Babylon</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-模块化\"><a href=\"#1-模块化\" class=\"headerlink\" title=\"1. 模块化\"></a>1. 模块化</h3><h2 id=\"1-1-什么是模块化\"><a href=\"#1-1-什么是模块化\" class=\"headerlink\" title=\"1.1 什么是模块化\"></a>1.1 什么是模块化</h2><ul>\n<li>将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起</li>\n<li>块的内部数据与实现是私有的，只向外部暴露一些接口（方法）与外部其他模块通信<h2 id=\"1-2-模块化的进行过程\"><a href=\"#1-2-模块化的进行过程\" class=\"headerlink\" title=\"1.2 模块化的进行过程\"></a>1.2 模块化的进行过程</h2></li>\n<li>全局function模式：将不同的功能封装成不同的全局函数<br>编码：将不同的功能封装成不同的全局函数<br>问题：污染全局命名空间，容易引起命名冲突或数据不安全，模块之间看不出关系</li>\n<li>namespace模式：简单对象封装<br>作用：减少全局变量，解决命名冲突<br>问题：数据不安全</li>\n<li>IIFE模式：匿名函数自调用（闭包）<br>作用：数据是私有的，外部只能通过暴露的方法操作<br>编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口<br>问题：如果当前这个模块依赖另一个模块怎么办？</li>\n<li>IIFE模式增强：引入依赖<h2 id=\"1-3-模块化的好处\"><a href=\"#1-3-模块化的好处\" class=\"headerlink\" title=\"1.3 模块化的好处\"></a>1.3 模块化的好处</h2></li>\n<li>避免命名冲突</li>\n<li>更好的分离，按需加载</li>\n<li>更高复用性</li>\n<li>高可维护性<h2 id=\"1-4-引入多个script后出现问题\"><a href=\"#1-4-引入多个script后出现问题\" class=\"headerlink\" title=\"1.4 引入多个script后出现问题\"></a>1.4 引入多个script后出现问题</h2></li>\n<li>请求过多</li>\n<li>依赖模糊</li>\n<li>难以维护<h3 id=\"2-AST\"><a href=\"#2-AST\" class=\"headerlink\" title=\"2. AST\"></a>2. AST</h3><h2 id=\"2-1-什么是AST\"><a href=\"#2-1-什么是AST\" class=\"headerlink\" title=\"2.1 什么是AST\"></a>2.1 什么是AST</h2>抽象语法树，源代码的抽象语法结构的树状表现形式。<h2 id=\"2-2-词法分析和语法分析\"><a href=\"#2-2-词法分析和语法分析\" class=\"headerlink\" title=\"2.2 词法分析和语法分析\"></a>2.2 词法分析和语法分析</h2>JS是解释型语言，通过词法分析-&gt;语法分析-&gt;语法书，执行。<br>词法分析：扫描，将字符流转换为记号流(token)，读取代码按照一定的规则合成一个个的标识。<br>语法分析：解析器，将词法分析出来的数组转换成树的形式，验证语法。有错则报错。<h2 id=\"2-3-AST过程\"><a href=\"#2-3-AST过程\" class=\"headerlink\" title=\"2.3 AST过程\"></a>2.3 AST过程</h2></li>\n<li>语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等</li>\n<li>代码混淆压缩</li>\n<li>优化变更代码，改变代码结构等<h3 id=\"3-babel工作原理\"><a href=\"#3-babel工作原理\" class=\"headerlink\" title=\"3. babel工作原理\"></a>3. babel工作原理</h3>解决了ES6兼容问题，把ES6代码转换为ES5代码，用了AST。<br>配置presets,plugins使用插件<br>访问者模式，访问某一个路径的时候进行匹配，然后在节点修改<br>引入babel插件，使用babel对代码进行转换，过程会改变AST语法树，然后生成新代码<h2 id=\"3-1-babylon\"><a href=\"#3-1-babylon\" class=\"headerlink\" title=\"3.1 babylon\"></a>3.1 babylon</h2>babel使用的引擎是Babylon</li>\n</ul>\n"},{"title":"Vue插槽","date":"2021-03-18T10:08:07.000Z","_content":"### 1. 普通插槽\n以不同于严格的父子关系组合组件。将内容放置到新位置或使组件更通用的出口。\n插槽将slot作为子组件承载分发的载体。\n","source":"_posts/Vue插槽.md","raw":"---\ntitle: Vue插槽\ndate: 2021-03-18 18:08:07\ntags:\n - 前端框架\n - Vue\ncategories: web前端\n---\n### 1. 普通插槽\n以不同于严格的父子关系组合组件。将内容放置到新位置或使组件更通用的出口。\n插槽将slot作为子组件承载分发的载体。\n","slug":"Vue插槽","published":1,"updated":"2021-03-18T10:13:46.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmewjlt40000fkva3ndc62ed","content":"<h3 id=\"1-普通插槽\"><a href=\"#1-普通插槽\" class=\"headerlink\" title=\"1. 普通插槽\"></a>1. 普通插槽</h3><p>以不同于严格的父子关系组合组件。将内容放置到新位置或使组件更通用的出口。<br>插槽将slot作为子组件承载分发的载体。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-普通插槽\"><a href=\"#1-普通插槽\" class=\"headerlink\" title=\"1. 普通插槽\"></a>1. 普通插槽</h3><p>以不同于严格的父子关系组合组件。将内容放置到新位置或使组件更通用的出口。<br>插槽将slot作为子组件承载分发的载体。</p>\n"},{"title":"computed和watch","date":"2021-03-16T03:03:14.000Z","_content":"### 1. computed用法\n类似于watch的计算属性，根据所依赖的数据动态设置新的计算结果。computed的值在getter执行后会被缓存。\n应用场景：\n - 适用于一些重复使用数据或复杂及费时的运算。\n - 依赖于其他数据的数据\n---\n### 2. computed和methods的区别？\n1.methods无响应式，不会动态更改\n2.computed可以定义成函数，也可以定义成get/set\n---\n### 3. watch用法\n对data里的数据监听回调。\n应用场景：当data数据更新时需要操作或数据变化时执行异步，开销较大的操作时使用。\n普通监听：watch内调用，根据newval和oldval执行函数\n深度监听：有immediate属性，可立即执行方法，deep属性，针对对象属性的监听，性能开销较大\n---\n### 4. watch和computed的区别\n相同：都是观察页面数据变化\n不同：computed只有当依赖数据变化才会计算，当数据没有变化会读取缓存。watch每次都需要执行函数，无缓存，更适用于数据变化时的异步。\n---\n### 5. 原理及源码\n在initState函数中，initComputed函数，判断是否有computed后执行，循环遍历computed，根据key实例化watcher，通过Object.defineProperty()函数来监听。回调时调用mount.call()，跟响应式原理一样。\n\n\n","source":"_posts/computed和watch.md","raw":"---\ntitle: computed和watch\ndate: 2021-03-16 11:03:14\ntags:\n - 前端框架\n - Vue\ncategories: Web前端\n---\n### 1. computed用法\n类似于watch的计算属性，根据所依赖的数据动态设置新的计算结果。computed的值在getter执行后会被缓存。\n应用场景：\n - 适用于一些重复使用数据或复杂及费时的运算。\n - 依赖于其他数据的数据\n---\n### 2. computed和methods的区别？\n1.methods无响应式，不会动态更改\n2.computed可以定义成函数，也可以定义成get/set\n---\n### 3. watch用法\n对data里的数据监听回调。\n应用场景：当data数据更新时需要操作或数据变化时执行异步，开销较大的操作时使用。\n普通监听：watch内调用，根据newval和oldval执行函数\n深度监听：有immediate属性，可立即执行方法，deep属性，针对对象属性的监听，性能开销较大\n---\n### 4. watch和computed的区别\n相同：都是观察页面数据变化\n不同：computed只有当依赖数据变化才会计算，当数据没有变化会读取缓存。watch每次都需要执行函数，无缓存，更适用于数据变化时的异步。\n---\n### 5. 原理及源码\n在initState函数中，initComputed函数，判断是否有computed后执行，循环遍历computed，根据key实例化watcher，通过Object.defineProperty()函数来监听。回调时调用mount.call()，跟响应式原理一样。\n\n\n","slug":"computed和watch","published":1,"updated":"2021-03-31T04:55:58.504Z","_id":"ckmewjlta0001fkva0uoo85iv","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-computed用法\"><a href=\"#1-computed用法\" class=\"headerlink\" title=\"1. computed用法\"></a>1. computed用法</h3><p>类似于watch的计算属性，根据所依赖的数据动态设置新的计算结果。computed的值在getter执行后会被缓存。<br>应用场景：</p>\n<ul>\n<li>适用于一些重复使用数据或复杂及费时的运算。</li>\n<li>依赖于其他数据的数据</li>\n</ul>\n<hr>\n<h3 id=\"2-computed和methods的区别？\"><a href=\"#2-computed和methods的区别？\" class=\"headerlink\" title=\"2. computed和methods的区别？\"></a>2. computed和methods的区别？</h3><p>1.methods无响应式，不会动态更改<br>2.computed可以定义成函数，也可以定义成get/set</p>\n<hr>\n<h3 id=\"3-watch用法\"><a href=\"#3-watch用法\" class=\"headerlink\" title=\"3. watch用法\"></a>3. watch用法</h3><p>对data里的数据监听回调。<br>应用场景：当data数据更新时需要操作或数据变化时执行异步，开销较大的操作时使用。<br>普通监听：watch内调用，根据newval和oldval执行函数<br>深度监听：有immediate属性，可立即执行方法，deep属性，针对对象属性的监听，性能开销较大</p>\n<hr>\n<h3 id=\"4-watch和computed的区别\"><a href=\"#4-watch和computed的区别\" class=\"headerlink\" title=\"4. watch和computed的区别\"></a>4. watch和computed的区别</h3><p>相同：都是观察页面数据变化<br>不同：computed只有当依赖数据变化才会计算，当数据没有变化会读取缓存。watch每次都需要执行函数，无缓存，更适用于数据变化时的异步。</p>\n<hr>\n<h3 id=\"5-原理及源码\"><a href=\"#5-原理及源码\" class=\"headerlink\" title=\"5. 原理及源码\"></a>5. 原理及源码</h3><p>在initState函数中，initComputed函数，判断是否有computed后执行，循环遍历computed，根据key实例化watcher，通过Object.defineProperty()函数来监听。回调时调用mount.call()，跟响应式原理一样。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-computed用法\"><a href=\"#1-computed用法\" class=\"headerlink\" title=\"1. computed用法\"></a>1. computed用法</h3><p>类似于watch的计算属性，根据所依赖的数据动态设置新的计算结果。computed的值在getter执行后会被缓存。<br>应用场景：</p>\n<ul>\n<li>适用于一些重复使用数据或复杂及费时的运算。</li>\n<li>依赖于其他数据的数据</li>\n</ul>\n<hr>\n<h3 id=\"2-computed和methods的区别？\"><a href=\"#2-computed和methods的区别？\" class=\"headerlink\" title=\"2. computed和methods的区别？\"></a>2. computed和methods的区别？</h3><p>1.methods无响应式，不会动态更改<br>2.computed可以定义成函数，也可以定义成get/set</p>\n<hr>\n<h3 id=\"3-watch用法\"><a href=\"#3-watch用法\" class=\"headerlink\" title=\"3. watch用法\"></a>3. watch用法</h3><p>对data里的数据监听回调。<br>应用场景：当data数据更新时需要操作或数据变化时执行异步，开销较大的操作时使用。<br>普通监听：watch内调用，根据newval和oldval执行函数<br>深度监听：有immediate属性，可立即执行方法，deep属性，针对对象属性的监听，性能开销较大</p>\n<hr>\n<h3 id=\"4-watch和computed的区别\"><a href=\"#4-watch和computed的区别\" class=\"headerlink\" title=\"4. watch和computed的区别\"></a>4. watch和computed的区别</h3><p>相同：都是观察页面数据变化<br>不同：computed只有当依赖数据变化才会计算，当数据没有变化会读取缓存。watch每次都需要执行函数，无缓存，更适用于数据变化时的异步。</p>\n<hr>\n<h3 id=\"5-原理及源码\"><a href=\"#5-原理及源码\" class=\"headerlink\" title=\"5. 原理及源码\"></a>5. 原理及源码</h3><p>在initState函数中，initComputed函数，判断是否有computed后执行，循环遍历computed，根据key实例化watcher，通过Object.defineProperty()函数来监听。回调时调用mount.call()，跟响应式原理一样。</p>\n"},{"title":"单点登录SSO","date":"2021-03-25T02:38:58.000Z","_content":"# 1. SSO是什么\n单点登录，简称SSO。是在多个应用系统中用户只需要登录一次就可以访问所有相互信任的应用系统。\nSSO一般都需要一个独立的认证中心(passport)，子系统登录均通过passport，子系统本身将不参与登录操作。\n授权以后，会建立局部会话，一定时间内无需再次向passport发起认证。\n---\n# 2. 如何实现\n - 同域名下的单点登录\ncookie的domin属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径。\n利用cookie的该特点，将cookie的path属性设置为根路径，将Session ID保存到父域中。子域应用就都可以访问到这个cookie。\n不过需要在主域名相同的情况下可以通过这种方式来实现单点登录。\n - 不同域名下的单点登录(一)\n不同域下，Cookie不共享。需要部署一个认证中心，用于专门处理登录请求的独立的Web服务。\n验证token，如果没有则跳转到认证中心，跳转时携带Cookie(带有token)，根据Cookie判断登录状态。\n已登录的用户在跳转前生成一个Token拼接在目标URL的后面，回传给目标应用系统，写入Cookie。\n - 不同域名下的单点登录(二)\n可以将SessionID保存到LocalStorage中，每次请求时，将LocalStorage的数据传递给服务端，后端在登录后返回SessionID或Token。\n通过iframe+postMessage方式，将token写入多个域下的LocalStorage，可以被多个域所共享。\n---\n# 3. 流程\n用户登录成功后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话。\n用户与各个子系统建立的会话称为局部会话，局部会话建立后，用户访问子系统受保护资源将不再通过SSO认证中心。\n全局会话与局部会话存在如下约束关系：\n - 局部会话存在，全局会话一定存在\n - 全局会话存在，局部会话不一定存在\n - 全局会话销毁，局部会话必须销毁\n\n","source":"_posts/单点登录SSO.md","raw":"---\ntitle: 单点登录SSO\ndate: 2021-03-25 10:38:58\ntags:\n - 前端\ncategories: web前端\n---\n# 1. SSO是什么\n单点登录，简称SSO。是在多个应用系统中用户只需要登录一次就可以访问所有相互信任的应用系统。\nSSO一般都需要一个独立的认证中心(passport)，子系统登录均通过passport，子系统本身将不参与登录操作。\n授权以后，会建立局部会话，一定时间内无需再次向passport发起认证。\n---\n# 2. 如何实现\n - 同域名下的单点登录\ncookie的domin属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径。\n利用cookie的该特点，将cookie的path属性设置为根路径，将Session ID保存到父域中。子域应用就都可以访问到这个cookie。\n不过需要在主域名相同的情况下可以通过这种方式来实现单点登录。\n - 不同域名下的单点登录(一)\n不同域下，Cookie不共享。需要部署一个认证中心，用于专门处理登录请求的独立的Web服务。\n验证token，如果没有则跳转到认证中心，跳转时携带Cookie(带有token)，根据Cookie判断登录状态。\n已登录的用户在跳转前生成一个Token拼接在目标URL的后面，回传给目标应用系统，写入Cookie。\n - 不同域名下的单点登录(二)\n可以将SessionID保存到LocalStorage中，每次请求时，将LocalStorage的数据传递给服务端，后端在登录后返回SessionID或Token。\n通过iframe+postMessage方式，将token写入多个域下的LocalStorage，可以被多个域所共享。\n---\n# 3. 流程\n用户登录成功后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话。\n用户与各个子系统建立的会话称为局部会话，局部会话建立后，用户访问子系统受保护资源将不再通过SSO认证中心。\n全局会话与局部会话存在如下约束关系：\n - 局部会话存在，全局会话一定存在\n - 全局会话存在，局部会话不一定存在\n - 全局会话销毁，局部会话必须销毁\n\n","slug":"单点登录SSO","published":1,"updated":"2021-03-31T04:54:42.248Z","_id":"ckmol1ivn0000bovahyys81z8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-SSO是什么\"><a href=\"#1-SSO是什么\" class=\"headerlink\" title=\"1. SSO是什么\"></a>1. SSO是什么</h1><p>单点登录，简称SSO。是在多个应用系统中用户只需要登录一次就可以访问所有相互信任的应用系统。<br>SSO一般都需要一个独立的认证中心(passport)，子系统登录均通过passport，子系统本身将不参与登录操作。<br>授权以后，会建立局部会话，一定时间内无需再次向passport发起认证。</p>\n<hr>\n<h1 id=\"2-如何实现\"><a href=\"#2-如何实现\" class=\"headerlink\" title=\"2. 如何实现\"></a>2. 如何实现</h1><ul>\n<li>同域名下的单点登录<br>cookie的domin属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径。<br>利用cookie的该特点，将cookie的path属性设置为根路径，将Session ID保存到父域中。子域应用就都可以访问到这个cookie。<br>不过需要在主域名相同的情况下可以通过这种方式来实现单点登录。</li>\n<li>不同域名下的单点登录(一)<br>不同域下，Cookie不共享。需要部署一个认证中心，用于专门处理登录请求的独立的Web服务。<br>验证token，如果没有则跳转到认证中心，跳转时携带Cookie(带有token)，根据Cookie判断登录状态。<br>已登录的用户在跳转前生成一个Token拼接在目标URL的后面，回传给目标应用系统，写入Cookie。</li>\n<li>不同域名下的单点登录(二)<br>可以将SessionID保存到LocalStorage中，每次请求时，将LocalStorage的数据传递给服务端，后端在登录后返回SessionID或Token。<br>通过iframe+postMessage方式，将token写入多个域下的LocalStorage，可以被多个域所共享。</li>\n</ul>\n<hr>\n<h1 id=\"3-流程\"><a href=\"#3-流程\" class=\"headerlink\" title=\"3. 流程\"></a>3. 流程</h1><p>用户登录成功后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话。<br>用户与各个子系统建立的会话称为局部会话，局部会话建立后，用户访问子系统受保护资源将不再通过SSO认证中心。<br>全局会话与局部会话存在如下约束关系：</p>\n<ul>\n<li>局部会话存在，全局会话一定存在</li>\n<li>全局会话存在，局部会话不一定存在</li>\n<li>全局会话销毁，局部会话必须销毁</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-SSO是什么\"><a href=\"#1-SSO是什么\" class=\"headerlink\" title=\"1. SSO是什么\"></a>1. SSO是什么</h1><p>单点登录，简称SSO。是在多个应用系统中用户只需要登录一次就可以访问所有相互信任的应用系统。<br>SSO一般都需要一个独立的认证中心(passport)，子系统登录均通过passport，子系统本身将不参与登录操作。<br>授权以后，会建立局部会话，一定时间内无需再次向passport发起认证。</p>\n<hr>\n<h1 id=\"2-如何实现\"><a href=\"#2-如何实现\" class=\"headerlink\" title=\"2. 如何实现\"></a>2. 如何实现</h1><ul>\n<li>同域名下的单点登录<br>cookie的domin属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径。<br>利用cookie的该特点，将cookie的path属性设置为根路径，将Session ID保存到父域中。子域应用就都可以访问到这个cookie。<br>不过需要在主域名相同的情况下可以通过这种方式来实现单点登录。</li>\n<li>不同域名下的单点登录(一)<br>不同域下，Cookie不共享。需要部署一个认证中心，用于专门处理登录请求的独立的Web服务。<br>验证token，如果没有则跳转到认证中心，跳转时携带Cookie(带有token)，根据Cookie判断登录状态。<br>已登录的用户在跳转前生成一个Token拼接在目标URL的后面，回传给目标应用系统，写入Cookie。</li>\n<li>不同域名下的单点登录(二)<br>可以将SessionID保存到LocalStorage中，每次请求时，将LocalStorage的数据传递给服务端，后端在登录后返回SessionID或Token。<br>通过iframe+postMessage方式，将token写入多个域下的LocalStorage，可以被多个域所共享。</li>\n</ul>\n<hr>\n<h1 id=\"3-流程\"><a href=\"#3-流程\" class=\"headerlink\" title=\"3. 流程\"></a>3. 流程</h1><p>用户登录成功后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话。<br>用户与各个子系统建立的会话称为局部会话，局部会话建立后，用户访问子系统受保护资源将不再通过SSO认证中心。<br>全局会话与局部会话存在如下约束关系：</p>\n<ul>\n<li>局部会话存在，全局会话一定存在</li>\n<li>全局会话存在，局部会话不一定存在</li>\n<li>全局会话销毁，局部会话必须销毁</li>\n</ul>\n"},{"title":"uni-app初试","date":"2021-03-31T01:14:10.000Z","_content":"### 1. 文档查阅\n初始化hello-uniapp项目，查看项目相关文件，src为主要文件夹\ncommon：文件夹为一些配置插件封装\ncomponents：组件目录\nhybrid：存放本地HTML文件\nplatforms：存放各平台专用页面文件\npages：业务页面文件存放目录\nstatic：存放本地静态资源\nwxcomponents：存放小程序组件\nmanifest.json：配置应用名称、appid、logo、版本等打包信息\npages.json：配置页面路由、导航条、选项卡等页面类信息\n\n## 1.1 写法\n标签与小程序相似\npage相当于body节点\n```\npage{\n   background:#ccc;\n}\n```\n### 2. 疑难杂症\n1.引入iconfont方式，添加图标到创建的项目文件夹中，然后Unicode选项生成代码，直接讲代码复制到新建的css文件中，然后在app.vue文件引入该CSS文件。使用时:\n```\nstyle:iconfont{\n   font-family:\"iconfont\" //之前css文件里的font-family值\n   font-size:16rpx; //等\n}\n<text class=\"iconfont\">{复制的图标代码}</text>//class为定义的iconfont\n```\n添加新图标只需要生成新代码复制到css文件中即可\n2.使用uview组件库，搜索框，input输入框无法设置宽度\n套一层view设置宽度即可 //反应失灵\n3.引入uview组件时，需要安装sass解析，根据官网指令安装后，出现版本适配问题。\n使用指令 npm uninstall less-loader 卸载\nnpm install less-loader@5.0.0 安装 成功后再次运行 出现同样的问题\n将版本改为7.3.0 运行 同样失效 将版本改为4.1.0 运行 同样失效\n修改package.json中的版本，重装后运行成功 uview未导入成功\n运行指令 npm i node-sass -D npm i sass-loader -D 运行成功\n再修正easycom的规则，终成功。\n4.开发小程序与H5端不同，引入iconfont较为麻烦，最终采用png格式贴图。\n5.弧度背景可以使用背景图片\n6.点击tabBar底部跳转，通过onTabItemTap回调函数触发\n\n\n\n\n","source":"_posts/uni-app初试.md","raw":"---\ntitle: uni-app初试\ndate: 2021-03-31 09:14:10\ntags:\n - 移动端开发\n - Vue\ncategories: 移动端\n---\n### 1. 文档查阅\n初始化hello-uniapp项目，查看项目相关文件，src为主要文件夹\ncommon：文件夹为一些配置插件封装\ncomponents：组件目录\nhybrid：存放本地HTML文件\nplatforms：存放各平台专用页面文件\npages：业务页面文件存放目录\nstatic：存放本地静态资源\nwxcomponents：存放小程序组件\nmanifest.json：配置应用名称、appid、logo、版本等打包信息\npages.json：配置页面路由、导航条、选项卡等页面类信息\n\n## 1.1 写法\n标签与小程序相似\npage相当于body节点\n```\npage{\n   background:#ccc;\n}\n```\n### 2. 疑难杂症\n1.引入iconfont方式，添加图标到创建的项目文件夹中，然后Unicode选项生成代码，直接讲代码复制到新建的css文件中，然后在app.vue文件引入该CSS文件。使用时:\n```\nstyle:iconfont{\n   font-family:\"iconfont\" //之前css文件里的font-family值\n   font-size:16rpx; //等\n}\n<text class=\"iconfont\">{复制的图标代码}</text>//class为定义的iconfont\n```\n添加新图标只需要生成新代码复制到css文件中即可\n2.使用uview组件库，搜索框，input输入框无法设置宽度\n套一层view设置宽度即可 //反应失灵\n3.引入uview组件时，需要安装sass解析，根据官网指令安装后，出现版本适配问题。\n使用指令 npm uninstall less-loader 卸载\nnpm install less-loader@5.0.0 安装 成功后再次运行 出现同样的问题\n将版本改为7.3.0 运行 同样失效 将版本改为4.1.0 运行 同样失效\n修改package.json中的版本，重装后运行成功 uview未导入成功\n运行指令 npm i node-sass -D npm i sass-loader -D 运行成功\n再修正easycom的规则，终成功。\n4.开发小程序与H5端不同，引入iconfont较为麻烦，最终采用png格式贴图。\n5.弧度背景可以使用背景图片\n6.点击tabBar底部跳转，通过onTabItemTap回调函数触发\n\n\n\n\n","slug":"uni-app初试","published":1,"updated":"2021-04-06T07:03:40.787Z","_id":"ckmwz6dh60000d4vadasf0w0s","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-文档查阅\"><a href=\"#1-文档查阅\" class=\"headerlink\" title=\"1. 文档查阅\"></a>1. 文档查阅</h3><p>初始化hello-uniapp项目，查看项目相关文件，src为主要文件夹<br>common：文件夹为一些配置插件封装<br>components：组件目录<br>hybrid：存放本地HTML文件<br>platforms：存放各平台专用页面文件<br>pages：业务页面文件存放目录<br>static：存放本地静态资源<br>wxcomponents：存放小程序组件<br>manifest.json：配置应用名称、appid、logo、版本等打包信息<br>pages.json：配置页面路由、导航条、选项卡等页面类信息</p>\n<h2 id=\"1-1-写法\"><a href=\"#1-1-写法\" class=\"headerlink\" title=\"1.1 写法\"></a>1.1 写法</h2><p>标签与小程序相似<br>page相当于body节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page&#123;</span><br><span class=\"line\">   background:#ccc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-疑难杂症\"><a href=\"#2-疑难杂症\" class=\"headerlink\" title=\"2. 疑难杂症\"></a>2. 疑难杂症</h3><p>1.引入iconfont方式，添加图标到创建的项目文件夹中，然后Unicode选项生成代码，直接讲代码复制到新建的css文件中，然后在app.vue文件引入该CSS文件。使用时:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style:iconfont&#123;</span><br><span class=\"line\">   font-family:&quot;iconfont&quot; &#x2F;&#x2F;之前css文件里的font-family值</span><br><span class=\"line\">   font-size:16rpx; &#x2F;&#x2F;等</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;text class&#x3D;&quot;iconfont&quot;&gt;&#123;复制的图标代码&#125;&lt;&#x2F;text&gt;&#x2F;&#x2F;class为定义的iconfont</span><br></pre></td></tr></table></figure>\n<p>添加新图标只需要生成新代码复制到css文件中即可<br>2.使用uview组件库，搜索框，input输入框无法设置宽度<br>套一层view设置宽度即可 //反应失灵<br>3.引入uview组件时，需要安装sass解析，根据官网指令安装后，出现版本适配问题。<br>使用指令 npm uninstall less-loader 卸载<br>npm install <a href=\"mailto:less-loader@5.0.0\">less-loader@5.0.0</a> 安装 成功后再次运行 出现同样的问题<br>将版本改为7.3.0 运行 同样失效 将版本改为4.1.0 运行 同样失效<br>修改package.json中的版本，重装后运行成功 uview未导入成功<br>运行指令 npm i node-sass -D npm i sass-loader -D 运行成功<br>再修正easycom的规则，终成功。<br>4.开发小程序与H5端不同，引入iconfont较为麻烦，最终采用png格式贴图。<br>5.弧度背景可以使用背景图片<br>6.点击tabBar底部跳转，通过onTabItemTap回调函数触发</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-文档查阅\"><a href=\"#1-文档查阅\" class=\"headerlink\" title=\"1. 文档查阅\"></a>1. 文档查阅</h3><p>初始化hello-uniapp项目，查看项目相关文件，src为主要文件夹<br>common：文件夹为一些配置插件封装<br>components：组件目录<br>hybrid：存放本地HTML文件<br>platforms：存放各平台专用页面文件<br>pages：业务页面文件存放目录<br>static：存放本地静态资源<br>wxcomponents：存放小程序组件<br>manifest.json：配置应用名称、appid、logo、版本等打包信息<br>pages.json：配置页面路由、导航条、选项卡等页面类信息</p>\n<h2 id=\"1-1-写法\"><a href=\"#1-1-写法\" class=\"headerlink\" title=\"1.1 写法\"></a>1.1 写法</h2><p>标签与小程序相似<br>page相当于body节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page&#123;</span><br><span class=\"line\">   background:#ccc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-疑难杂症\"><a href=\"#2-疑难杂症\" class=\"headerlink\" title=\"2. 疑难杂症\"></a>2. 疑难杂症</h3><p>1.引入iconfont方式，添加图标到创建的项目文件夹中，然后Unicode选项生成代码，直接讲代码复制到新建的css文件中，然后在app.vue文件引入该CSS文件。使用时:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style:iconfont&#123;</span><br><span class=\"line\">   font-family:&quot;iconfont&quot; &#x2F;&#x2F;之前css文件里的font-family值</span><br><span class=\"line\">   font-size:16rpx; &#x2F;&#x2F;等</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;text class&#x3D;&quot;iconfont&quot;&gt;&#123;复制的图标代码&#125;&lt;&#x2F;text&gt;&#x2F;&#x2F;class为定义的iconfont</span><br></pre></td></tr></table></figure>\n<p>添加新图标只需要生成新代码复制到css文件中即可<br>2.使用uview组件库，搜索框，input输入框无法设置宽度<br>套一层view设置宽度即可 //反应失灵<br>3.引入uview组件时，需要安装sass解析，根据官网指令安装后，出现版本适配问题。<br>使用指令 npm uninstall less-loader 卸载<br>npm install <a href=\"mailto:less-loader@5.0.0\">less-loader@5.0.0</a> 安装 成功后再次运行 出现同样的问题<br>将版本改为7.3.0 运行 同样失效 将版本改为4.1.0 运行 同样失效<br>修改package.json中的版本，重装后运行成功 uview未导入成功<br>运行指令 npm i node-sass -D npm i sass-loader -D 运行成功<br>再修正easycom的规则，终成功。<br>4.开发小程序与H5端不同，引入iconfont较为麻烦，最终采用png格式贴图。<br>5.弧度背景可以使用背景图片<br>6.点击tabBar底部跳转，通过onTabItemTap回调函数触发</p>\n"},{"title":"Web安全性","date":"2021-03-26T05:43:14.000Z","_content":"### 1. Web攻击\n植入恶意代码，修改网站权限，获取网站用户隐私信息等等。\n常见Web攻击方式有：\n - XSS(Cross Site Scripting)跨站脚本攻击\n - CSRF(Cross-site request forgery)跨站请求伪造\n - SQL注入攻击\n### 2. XSS\n跨站脚本攻击，允许攻击者将恶意代码植入到提供给其他用户使用的页面中。\nXSS涉及到三方，即攻击者、客户端与Web应用。\nXSS是盗取存储在客户端的Cookie或者其他网站用于识别客户端身份的敏感信息。获取合法用户的信息后，假冒合法用户与网站交互。\nXSS攻击可以分成：\n## 2.1 存储型\n步骤：\n - 攻击者将恶意代码提交到目标网站的数据库中\n - 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器\n - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\n## 2.2 反射型\n步骤：\n - 攻击者构造出特殊的URL，其中包含恶意代码\n - 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器\n - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n一个在数据库里，一个在URL里。\n反射型常用语URL传递参数的功能，如网站搜索、跳转等。\n## 2.3 DOM型\n步骤：\n - 攻击者构造出特殊的URL，其中包含恶意代码\n - 用户打开带有恶意代码的URL\n - 用户浏览器接收到响应后解析执行，前端JS取出URL中的恶意代码并执行\n - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\nDOM型的XSS攻击由浏览器端完成，是JS自身的安全漏洞，其他两种都属于服务端的安全漏洞\n## 2.4 如何预防\nXSS攻击的两大要素\n1.攻击者提交恶意代码\n2.浏览器执行恶意代码\n将一些符号写入数据库前用特殊符号替换，不要将不可信的数据作为HTML插到页面上\nDOM中的一些内联事件监听器，a标签，settimeout，setInterval等都能把字符串作为代码运行。不可信的数据拼接到字符串中传递给这些API中很容易产生安全隐患。\n### 3. CSRF\nCSRF(Cross-site request forgery)跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求\n流程：\n - 登录a.com，保留了登录凭证(Cookie)\n - 攻击者引诱受害者访问了b.com\n - b.com向a.com发送了一个请求：默认携带a的Cookie\n - a.com收到请求后，误以为是受害者自己发送的请求\n - a.com以受害者的名义执行了act\n - 攻击完成\nCSRF可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求\n特点：\n - 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生\n - 攻击利用受害者在攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据\n - 整个过程攻击并不能获取到受害者的登录凭证，仅仅是“冒用”\n - 跨站请求可以用各种方式，图片URL，超链接，CORS，Form提交等等。部分请求方式可以直接嵌入在第三方论坛，文章中，难以追踪\n## 3.1 如何预防\nCSRF通常从第三方网站发起，只能从增强自己的网站针对CSRF的防护能力来提升安全性。\n方案如下：\n - 阻止不明的外域的访问\n通过同源检测，Samesite Cookie\n - 提交时要求附加本域才能获取的信息\n通过CSRF Token，双重Cookie验证\n### 4.SQL注入\n通过将恶意的sql查询或添加语句插入到应用的输入参数中，再在后台sql服务器上解析执行进行的攻击\n流程：\n - 找出SQL漏洞的注入点\n - 判断数据库的类型以及版本\n - 猜解用户名和密码\n - 利用工具查找web后台管理入口\n - 入侵和破坏\n预防：\n - 严格检查输入变量的类型和格式\n - 过滤和转义特殊字符\n - 对访问数据库的web应用程序采用Web应用防火墙\n\n","source":"_posts/Web安全性.md","raw":"---\ntitle: Web安全性\ndate: 2021-03-26 13:43:14\ntags:\n - 网络安全\ncategories: web前端\n---\n### 1. Web攻击\n植入恶意代码，修改网站权限，获取网站用户隐私信息等等。\n常见Web攻击方式有：\n - XSS(Cross Site Scripting)跨站脚本攻击\n - CSRF(Cross-site request forgery)跨站请求伪造\n - SQL注入攻击\n### 2. XSS\n跨站脚本攻击，允许攻击者将恶意代码植入到提供给其他用户使用的页面中。\nXSS涉及到三方，即攻击者、客户端与Web应用。\nXSS是盗取存储在客户端的Cookie或者其他网站用于识别客户端身份的敏感信息。获取合法用户的信息后，假冒合法用户与网站交互。\nXSS攻击可以分成：\n## 2.1 存储型\n步骤：\n - 攻击者将恶意代码提交到目标网站的数据库中\n - 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器\n - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\n## 2.2 反射型\n步骤：\n - 攻击者构造出特殊的URL，其中包含恶意代码\n - 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器\n - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n一个在数据库里，一个在URL里。\n反射型常用语URL传递参数的功能，如网站搜索、跳转等。\n## 2.3 DOM型\n步骤：\n - 攻击者构造出特殊的URL，其中包含恶意代码\n - 用户打开带有恶意代码的URL\n - 用户浏览器接收到响应后解析执行，前端JS取出URL中的恶意代码并执行\n - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\nDOM型的XSS攻击由浏览器端完成，是JS自身的安全漏洞，其他两种都属于服务端的安全漏洞\n## 2.4 如何预防\nXSS攻击的两大要素\n1.攻击者提交恶意代码\n2.浏览器执行恶意代码\n将一些符号写入数据库前用特殊符号替换，不要将不可信的数据作为HTML插到页面上\nDOM中的一些内联事件监听器，a标签，settimeout，setInterval等都能把字符串作为代码运行。不可信的数据拼接到字符串中传递给这些API中很容易产生安全隐患。\n### 3. CSRF\nCSRF(Cross-site request forgery)跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求\n流程：\n - 登录a.com，保留了登录凭证(Cookie)\n - 攻击者引诱受害者访问了b.com\n - b.com向a.com发送了一个请求：默认携带a的Cookie\n - a.com收到请求后，误以为是受害者自己发送的请求\n - a.com以受害者的名义执行了act\n - 攻击完成\nCSRF可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求\n特点：\n - 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生\n - 攻击利用受害者在攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据\n - 整个过程攻击并不能获取到受害者的登录凭证，仅仅是“冒用”\n - 跨站请求可以用各种方式，图片URL，超链接，CORS，Form提交等等。部分请求方式可以直接嵌入在第三方论坛，文章中，难以追踪\n## 3.1 如何预防\nCSRF通常从第三方网站发起，只能从增强自己的网站针对CSRF的防护能力来提升安全性。\n方案如下：\n - 阻止不明的外域的访问\n通过同源检测，Samesite Cookie\n - 提交时要求附加本域才能获取的信息\n通过CSRF Token，双重Cookie验证\n### 4.SQL注入\n通过将恶意的sql查询或添加语句插入到应用的输入参数中，再在后台sql服务器上解析执行进行的攻击\n流程：\n - 找出SQL漏洞的注入点\n - 判断数据库的类型以及版本\n - 猜解用户名和密码\n - 利用工具查找web后台管理入口\n - 入侵和破坏\n预防：\n - 严格检查输入变量的类型和格式\n - 过滤和转义特殊字符\n - 对访问数据库的web应用程序采用Web应用防火墙\n\n","slug":"Web安全性","published":1,"updated":"2021-03-26T08:01:08.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmwz6dhc0001d4vabk6d4gjm","content":"<h3 id=\"1-Web攻击\"><a href=\"#1-Web攻击\" class=\"headerlink\" title=\"1. Web攻击\"></a>1. Web攻击</h3><p>植入恶意代码，修改网站权限，获取网站用户隐私信息等等。<br>常见Web攻击方式有：</p>\n<ul>\n<li>XSS(Cross Site Scripting)跨站脚本攻击</li>\n<li>CSRF(Cross-site request forgery)跨站请求伪造</li>\n<li>SQL注入攻击<h3 id=\"2-XSS\"><a href=\"#2-XSS\" class=\"headerlink\" title=\"2. XSS\"></a>2. XSS</h3>跨站脚本攻击，允许攻击者将恶意代码植入到提供给其他用户使用的页面中。<br>XSS涉及到三方，即攻击者、客户端与Web应用。<br>XSS是盗取存储在客户端的Cookie或者其他网站用于识别客户端身份的敏感信息。获取合法用户的信息后，假冒合法用户与网站交互。<br>XSS攻击可以分成：<h2 id=\"2-1-存储型\"><a href=\"#2-1-存储型\" class=\"headerlink\" title=\"2.1 存储型\"></a>2.1 存储型</h2>步骤：</li>\n<li>攻击者将恶意代码提交到目标网站的数据库中</li>\n<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作<br>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等<h2 id=\"2-2-反射型\"><a href=\"#2-2-反射型\" class=\"headerlink\" title=\"2.2 反射型\"></a>2.2 反射型</h2>步骤：</li>\n<li>攻击者构造出特殊的URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作<br>一个在数据库里，一个在URL里。<br>反射型常用语URL传递参数的功能，如网站搜索、跳转等。<h2 id=\"2-3-DOM型\"><a href=\"#2-3-DOM型\" class=\"headerlink\" title=\"2.3 DOM型\"></a>2.3 DOM型</h2>步骤：</li>\n<li>攻击者构造出特殊的URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的URL</li>\n<li>用户浏览器接收到响应后解析执行，前端JS取出URL中的恶意代码并执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作<br>DOM型的XSS攻击由浏览器端完成，是JS自身的安全漏洞，其他两种都属于服务端的安全漏洞<h2 id=\"2-4-如何预防\"><a href=\"#2-4-如何预防\" class=\"headerlink\" title=\"2.4 如何预防\"></a>2.4 如何预防</h2>XSS攻击的两大要素<br>1.攻击者提交恶意代码<br>2.浏览器执行恶意代码<br>将一些符号写入数据库前用特殊符号替换，不要将不可信的数据作为HTML插到页面上<br>DOM中的一些内联事件监听器，a标签，settimeout，setInterval等都能把字符串作为代码运行。不可信的数据拼接到字符串中传递给这些API中很容易产生安全隐患。<h3 id=\"3-CSRF\"><a href=\"#3-CSRF\" class=\"headerlink\" title=\"3. CSRF\"></a>3. CSRF</h3>CSRF(Cross-site request forgery)跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求<br>流程：</li>\n<li>登录a.com，保留了登录凭证(Cookie)</li>\n<li>攻击者引诱受害者访问了b.com</li>\n<li>b.com向a.com发送了一个请求：默认携带a的Cookie</li>\n<li>a.com收到请求后，误以为是受害者自己发送的请求</li>\n<li>a.com以受害者的名义执行了act</li>\n<li>攻击完成<br>CSRF可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求<br>特点：</li>\n<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li>\n<li>攻击利用受害者在攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li>\n<li>整个过程攻击并不能获取到受害者的登录凭证，仅仅是“冒用”</li>\n<li>跨站请求可以用各种方式，图片URL，超链接，CORS，Form提交等等。部分请求方式可以直接嵌入在第三方论坛，文章中，难以追踪<h2 id=\"3-1-如何预防\"><a href=\"#3-1-如何预防\" class=\"headerlink\" title=\"3.1 如何预防\"></a>3.1 如何预防</h2>CSRF通常从第三方网站发起，只能从增强自己的网站针对CSRF的防护能力来提升安全性。<br>方案如下：</li>\n<li>阻止不明的外域的访问<br>通过同源检测，Samesite Cookie</li>\n<li>提交时要求附加本域才能获取的信息<br>通过CSRF Token，双重Cookie验证<h3 id=\"4-SQL注入\"><a href=\"#4-SQL注入\" class=\"headerlink\" title=\"4.SQL注入\"></a>4.SQL注入</h3>通过将恶意的sql查询或添加语句插入到应用的输入参数中，再在后台sql服务器上解析执行进行的攻击<br>流程：</li>\n<li>找出SQL漏洞的注入点</li>\n<li>判断数据库的类型以及版本</li>\n<li>猜解用户名和密码</li>\n<li>利用工具查找web后台管理入口</li>\n<li>入侵和破坏<br>预防：</li>\n<li>严格检查输入变量的类型和格式</li>\n<li>过滤和转义特殊字符</li>\n<li>对访问数据库的web应用程序采用Web应用防火墙</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-Web攻击\"><a href=\"#1-Web攻击\" class=\"headerlink\" title=\"1. Web攻击\"></a>1. Web攻击</h3><p>植入恶意代码，修改网站权限，获取网站用户隐私信息等等。<br>常见Web攻击方式有：</p>\n<ul>\n<li>XSS(Cross Site Scripting)跨站脚本攻击</li>\n<li>CSRF(Cross-site request forgery)跨站请求伪造</li>\n<li>SQL注入攻击<h3 id=\"2-XSS\"><a href=\"#2-XSS\" class=\"headerlink\" title=\"2. XSS\"></a>2. XSS</h3>跨站脚本攻击，允许攻击者将恶意代码植入到提供给其他用户使用的页面中。<br>XSS涉及到三方，即攻击者、客户端与Web应用。<br>XSS是盗取存储在客户端的Cookie或者其他网站用于识别客户端身份的敏感信息。获取合法用户的信息后，假冒合法用户与网站交互。<br>XSS攻击可以分成：<h2 id=\"2-1-存储型\"><a href=\"#2-1-存储型\" class=\"headerlink\" title=\"2.1 存储型\"></a>2.1 存储型</h2>步骤：</li>\n<li>攻击者将恶意代码提交到目标网站的数据库中</li>\n<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作<br>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等<h2 id=\"2-2-反射型\"><a href=\"#2-2-反射型\" class=\"headerlink\" title=\"2.2 反射型\"></a>2.2 反射型</h2>步骤：</li>\n<li>攻击者构造出特殊的URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作<br>一个在数据库里，一个在URL里。<br>反射型常用语URL传递参数的功能，如网站搜索、跳转等。<h2 id=\"2-3-DOM型\"><a href=\"#2-3-DOM型\" class=\"headerlink\" title=\"2.3 DOM型\"></a>2.3 DOM型</h2>步骤：</li>\n<li>攻击者构造出特殊的URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的URL</li>\n<li>用户浏览器接收到响应后解析执行，前端JS取出URL中的恶意代码并执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作<br>DOM型的XSS攻击由浏览器端完成，是JS自身的安全漏洞，其他两种都属于服务端的安全漏洞<h2 id=\"2-4-如何预防\"><a href=\"#2-4-如何预防\" class=\"headerlink\" title=\"2.4 如何预防\"></a>2.4 如何预防</h2>XSS攻击的两大要素<br>1.攻击者提交恶意代码<br>2.浏览器执行恶意代码<br>将一些符号写入数据库前用特殊符号替换，不要将不可信的数据作为HTML插到页面上<br>DOM中的一些内联事件监听器，a标签，settimeout，setInterval等都能把字符串作为代码运行。不可信的数据拼接到字符串中传递给这些API中很容易产生安全隐患。<h3 id=\"3-CSRF\"><a href=\"#3-CSRF\" class=\"headerlink\" title=\"3. CSRF\"></a>3. CSRF</h3>CSRF(Cross-site request forgery)跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求<br>流程：</li>\n<li>登录a.com，保留了登录凭证(Cookie)</li>\n<li>攻击者引诱受害者访问了b.com</li>\n<li>b.com向a.com发送了一个请求：默认携带a的Cookie</li>\n<li>a.com收到请求后，误以为是受害者自己发送的请求</li>\n<li>a.com以受害者的名义执行了act</li>\n<li>攻击完成<br>CSRF可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求<br>特点：</li>\n<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li>\n<li>攻击利用受害者在攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li>\n<li>整个过程攻击并不能获取到受害者的登录凭证，仅仅是“冒用”</li>\n<li>跨站请求可以用各种方式，图片URL，超链接，CORS，Form提交等等。部分请求方式可以直接嵌入在第三方论坛，文章中，难以追踪<h2 id=\"3-1-如何预防\"><a href=\"#3-1-如何预防\" class=\"headerlink\" title=\"3.1 如何预防\"></a>3.1 如何预防</h2>CSRF通常从第三方网站发起，只能从增强自己的网站针对CSRF的防护能力来提升安全性。<br>方案如下：</li>\n<li>阻止不明的外域的访问<br>通过同源检测，Samesite Cookie</li>\n<li>提交时要求附加本域才能获取的信息<br>通过CSRF Token，双重Cookie验证<h3 id=\"4-SQL注入\"><a href=\"#4-SQL注入\" class=\"headerlink\" title=\"4.SQL注入\"></a>4.SQL注入</h3>通过将恶意的sql查询或添加语句插入到应用的输入参数中，再在后台sql服务器上解析执行进行的攻击<br>流程：</li>\n<li>找出SQL漏洞的注入点</li>\n<li>判断数据库的类型以及版本</li>\n<li>猜解用户名和密码</li>\n<li>利用工具查找web后台管理入口</li>\n<li>入侵和破坏<br>预防：</li>\n<li>严格检查输入变量的类型和格式</li>\n<li>过滤和转义特殊字符</li>\n<li>对访问数据库的web应用程序采用Web应用防火墙</li>\n</ul>\n"},{"title":"不同情况下PX的区别","date":"2021-04-01T00:51:34.000Z","_content":"### 1. CSS像素\nCSS分相对单位和绝对单位。\n相对单位一般指设备像素(device pixel),一般情况页面缩比为1,1个css像素等于一个设备独立像素，页面缩放时也会影响px的变化。\nCSS像素有两个方面的相对性：\n1.在同一个设备上，每一个CSS像素所代表的设备像素是可以变化的(分辨率)\n2.在不同的设备之间，每一个CSS像素所代表的设备像素是可以变化的(不同手机)\n受到以下因素的影响而变化：\n1.每英寸像素(PRI)\n2.设备像素比(DPR)\n---\n### 2. 设备像素\n设备像素(device pixels)，物理像素，指设备能控制的最小物理单位。\n一般设备像素点是固定不变的，单位为pt。\n### 3. 设备独立像素\n与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括CSS像素。\n可通过window.screen.width/window.screen.height查看\n### 4. DPR\ndpr(device pixel ratio)，设备像素比，设备独立像素到设备像素的转换关系，可以通过window.devicePixelRatio获取。\n计算公式：DPR=设备像素/设备独立像素\nDRP=1，1X1个设备像素=1个CSS像素\nDRP=2，2X2个设备像素=4个CSS像素\nDPR=3，3X3个设备像素=9个CSS像素\n### 5. PPI\nppi(pixel per inch)，每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。\n屏幕分辨率:X*Y PPI=根号X^2+Y^2 / 屏幕尺寸\n### 6. 总结\n无缩放情况下，1CSS像素=1设备独立像素。\n设备像素确定后不发生改变，设备独立像素是虚拟单位，会改变。\n移动端中，标准屏幕(160ppi)下1个设备独立像素=1个设备像素。\n设备像素比(dpr) = 设备像素 / 设备独立像素\n每英寸像素(ppi)，值越大，图像越清晰。","source":"_posts/不同情况下PX的区别.md","raw":"---\ntitle: 不同情况下PX的区别\ndate: 2021-04-01 08:51:34\ntags:\n - CSS\ncategories: 页面样式\n---\n### 1. CSS像素\nCSS分相对单位和绝对单位。\n相对单位一般指设备像素(device pixel),一般情况页面缩比为1,1个css像素等于一个设备独立像素，页面缩放时也会影响px的变化。\nCSS像素有两个方面的相对性：\n1.在同一个设备上，每一个CSS像素所代表的设备像素是可以变化的(分辨率)\n2.在不同的设备之间，每一个CSS像素所代表的设备像素是可以变化的(不同手机)\n受到以下因素的影响而变化：\n1.每英寸像素(PRI)\n2.设备像素比(DPR)\n---\n### 2. 设备像素\n设备像素(device pixels)，物理像素，指设备能控制的最小物理单位。\n一般设备像素点是固定不变的，单位为pt。\n### 3. 设备独立像素\n与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括CSS像素。\n可通过window.screen.width/window.screen.height查看\n### 4. DPR\ndpr(device pixel ratio)，设备像素比，设备独立像素到设备像素的转换关系，可以通过window.devicePixelRatio获取。\n计算公式：DPR=设备像素/设备独立像素\nDRP=1，1X1个设备像素=1个CSS像素\nDRP=2，2X2个设备像素=4个CSS像素\nDPR=3，3X3个设备像素=9个CSS像素\n### 5. PPI\nppi(pixel per inch)，每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。\n屏幕分辨率:X*Y PPI=根号X^2+Y^2 / 屏幕尺寸\n### 6. 总结\n无缩放情况下，1CSS像素=1设备独立像素。\n设备像素确定后不发生改变，设备独立像素是虚拟单位，会改变。\n移动端中，标准屏幕(160ppi)下1个设备独立像素=1个设备像素。\n设备像素比(dpr) = 设备像素 / 设备独立像素\n每英寸像素(ppi)，值越大，图像越清晰。","slug":"不同情况下PX的区别","published":1,"updated":"2021-04-01T01:19:59.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmy6y2050000j8vaf918h3ej","content":"<h3 id=\"1-CSS像素\"><a href=\"#1-CSS像素\" class=\"headerlink\" title=\"1. CSS像素\"></a>1. CSS像素</h3><p>CSS分相对单位和绝对单位。<br>相对单位一般指设备像素(device pixel),一般情况页面缩比为1,1个css像素等于一个设备独立像素，页面缩放时也会影响px的变化。<br>CSS像素有两个方面的相对性：<br>1.在同一个设备上，每一个CSS像素所代表的设备像素是可以变化的(分辨率)<br>2.在不同的设备之间，每一个CSS像素所代表的设备像素是可以变化的(不同手机)<br>受到以下因素的影响而变化：<br>1.每英寸像素(PRI)<br>2.设备像素比(DPR)</p>\n<hr>\n<h3 id=\"2-设备像素\"><a href=\"#2-设备像素\" class=\"headerlink\" title=\"2. 设备像素\"></a>2. 设备像素</h3><p>设备像素(device pixels)，物理像素，指设备能控制的最小物理单位。<br>一般设备像素点是固定不变的，单位为pt。</p>\n<h3 id=\"3-设备独立像素\"><a href=\"#3-设备独立像素\" class=\"headerlink\" title=\"3. 设备独立像素\"></a>3. 设备独立像素</h3><p>与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括CSS像素。<br>可通过window.screen.width/window.screen.height查看</p>\n<h3 id=\"4-DPR\"><a href=\"#4-DPR\" class=\"headerlink\" title=\"4. DPR\"></a>4. DPR</h3><p>dpr(device pixel ratio)，设备像素比，设备独立像素到设备像素的转换关系，可以通过window.devicePixelRatio获取。<br>计算公式：DPR=设备像素/设备独立像素<br>DRP=1，1X1个设备像素=1个CSS像素<br>DRP=2，2X2个设备像素=4个CSS像素<br>DPR=3，3X3个设备像素=9个CSS像素</p>\n<h3 id=\"5-PPI\"><a href=\"#5-PPI\" class=\"headerlink\" title=\"5. PPI\"></a>5. PPI</h3><p>ppi(pixel per inch)，每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。<br>屏幕分辨率:X*Y PPI=根号X^2+Y^2 / 屏幕尺寸</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>无缩放情况下，1CSS像素=1设备独立像素。<br>设备像素确定后不发生改变，设备独立像素是虚拟单位，会改变。<br>移动端中，标准屏幕(160ppi)下1个设备独立像素=1个设备像素。<br>设备像素比(dpr) = 设备像素 / 设备独立像素<br>每英寸像素(ppi)，值越大，图像越清晰。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-CSS像素\"><a href=\"#1-CSS像素\" class=\"headerlink\" title=\"1. CSS像素\"></a>1. CSS像素</h3><p>CSS分相对单位和绝对单位。<br>相对单位一般指设备像素(device pixel),一般情况页面缩比为1,1个css像素等于一个设备独立像素，页面缩放时也会影响px的变化。<br>CSS像素有两个方面的相对性：<br>1.在同一个设备上，每一个CSS像素所代表的设备像素是可以变化的(分辨率)<br>2.在不同的设备之间，每一个CSS像素所代表的设备像素是可以变化的(不同手机)<br>受到以下因素的影响而变化：<br>1.每英寸像素(PRI)<br>2.设备像素比(DPR)</p>\n<hr>\n<h3 id=\"2-设备像素\"><a href=\"#2-设备像素\" class=\"headerlink\" title=\"2. 设备像素\"></a>2. 设备像素</h3><p>设备像素(device pixels)，物理像素，指设备能控制的最小物理单位。<br>一般设备像素点是固定不变的，单位为pt。</p>\n<h3 id=\"3-设备独立像素\"><a href=\"#3-设备独立像素\" class=\"headerlink\" title=\"3. 设备独立像素\"></a>3. 设备独立像素</h3><p>与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括CSS像素。<br>可通过window.screen.width/window.screen.height查看</p>\n<h3 id=\"4-DPR\"><a href=\"#4-DPR\" class=\"headerlink\" title=\"4. DPR\"></a>4. DPR</h3><p>dpr(device pixel ratio)，设备像素比，设备独立像素到设备像素的转换关系，可以通过window.devicePixelRatio获取。<br>计算公式：DPR=设备像素/设备独立像素<br>DRP=1，1X1个设备像素=1个CSS像素<br>DRP=2，2X2个设备像素=4个CSS像素<br>DPR=3，3X3个设备像素=9个CSS像素</p>\n<h3 id=\"5-PPI\"><a href=\"#5-PPI\" class=\"headerlink\" title=\"5. PPI\"></a>5. PPI</h3><p>ppi(pixel per inch)，每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。<br>屏幕分辨率:X*Y PPI=根号X^2+Y^2 / 屏幕尺寸</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>无缩放情况下，1CSS像素=1设备独立像素。<br>设备像素确定后不发生改变，设备独立像素是虚拟单位，会改变。<br>移动端中，标准屏幕(160ppi)下1个设备独立像素=1个设备像素。<br>设备像素比(dpr) = 设备像素 / 设备独立像素<br>每英寸像素(ppi)，值越大，图像越清晰。</p>\n"},{"title":"BFC","date":"2021-04-06T07:11:18.000Z","_content":"### 1. BFC\nBFC(Block Formatting Context)，即块级格式化上下文，有自己的渲染区域和渲染规则：\n - 内部的盒子会在垂直方向上一个接一个的放置\n - 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关\n - 每个元素的左外边距与包含块的左边界相接触（从左到右），即使元素浮动也是如此\n - BFC的区域不会与float的元素区域重叠\n - 计算BFC的高度时，浮动子元素也参与计算\n - BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然\n - BFC就是一个相对于外界独立的空间，内部的子元素不影响外部的元素\n---\n### 2. 触发条件\n - 根元素，HTML元素\n - 浮动元素(float)\n - overflow值部位visible\n - display值为inline-block(cell,caption,table,flex,grid),flex,grid,table\n - position值为absolute或fixed\n---\n### 3. 应用场景\n - 放置margin重叠(塌陷)\n - 清除内部浮动\n - 自适应多栏布局\n---\n\n","source":"_posts/BFC.md","raw":"---\ntitle: BFC\ndate: 2021-04-06 15:11:18\ntags:\n - CSS\ncategories: UI设计开发\n---\n### 1. BFC\nBFC(Block Formatting Context)，即块级格式化上下文，有自己的渲染区域和渲染规则：\n - 内部的盒子会在垂直方向上一个接一个的放置\n - 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关\n - 每个元素的左外边距与包含块的左边界相接触（从左到右），即使元素浮动也是如此\n - BFC的区域不会与float的元素区域重叠\n - 计算BFC的高度时，浮动子元素也参与计算\n - BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然\n - BFC就是一个相对于外界独立的空间，内部的子元素不影响外部的元素\n---\n### 2. 触发条件\n - 根元素，HTML元素\n - 浮动元素(float)\n - overflow值部位visible\n - display值为inline-block(cell,caption,table,flex,grid),flex,grid,table\n - position值为absolute或fixed\n---\n### 3. 应用场景\n - 放置margin重叠(塌陷)\n - 清除内部浮动\n - 自适应多栏布局\n---\n\n","slug":"BFC","published":1,"updated":"2021-04-06T07:20:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5qjyo2000090vah75q6ry3","content":"<h3 id=\"1-BFC\"><a href=\"#1-BFC\" class=\"headerlink\" title=\"1. BFC\"></a>1. BFC</h3><p>BFC(Block Formatting Context)，即块级格式化上下文，有自己的渲染区域和渲染规则：</p>\n<ul>\n<li>内部的盒子会在垂直方向上一个接一个的放置</li>\n<li>对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关</li>\n<li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使元素浮动也是如此</li>\n<li>BFC的区域不会与float的元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>\n<li>BFC就是一个相对于外界独立的空间，内部的子元素不影响外部的元素</li>\n</ul>\n<hr>\n<h3 id=\"2-触发条件\"><a href=\"#2-触发条件\" class=\"headerlink\" title=\"2. 触发条件\"></a>2. 触发条件</h3><ul>\n<li>根元素，HTML元素</li>\n<li>浮动元素(float)</li>\n<li>overflow值部位visible</li>\n<li>display值为inline-block(cell,caption,table,flex,grid),flex,grid,table</li>\n<li>position值为absolute或fixed</li>\n</ul>\n<hr>\n<h3 id=\"3-应用场景\"><a href=\"#3-应用场景\" class=\"headerlink\" title=\"3. 应用场景\"></a>3. 应用场景</h3><ul>\n<li>放置margin重叠(塌陷)</li>\n<li>清除内部浮动</li>\n<li>自适应多栏布局</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-BFC\"><a href=\"#1-BFC\" class=\"headerlink\" title=\"1. BFC\"></a>1. BFC</h3><p>BFC(Block Formatting Context)，即块级格式化上下文，有自己的渲染区域和渲染规则：</p>\n<ul>\n<li>内部的盒子会在垂直方向上一个接一个的放置</li>\n<li>对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关</li>\n<li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使元素浮动也是如此</li>\n<li>BFC的区域不会与float的元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>\n<li>BFC就是一个相对于外界独立的空间，内部的子元素不影响外部的元素</li>\n</ul>\n<hr>\n<h3 id=\"2-触发条件\"><a href=\"#2-触发条件\" class=\"headerlink\" title=\"2. 触发条件\"></a>2. 触发条件</h3><ul>\n<li>根元素，HTML元素</li>\n<li>浮动元素(float)</li>\n<li>overflow值部位visible</li>\n<li>display值为inline-block(cell,caption,table,flex,grid),flex,grid,table</li>\n<li>position值为absolute或fixed</li>\n</ul>\n<hr>\n<h3 id=\"3-应用场景\"><a href=\"#3-应用场景\" class=\"headerlink\" title=\"3. 应用场景\"></a>3. 应用场景</h3><ul>\n<li>放置margin重叠(塌陷)</li>\n<li>清除内部浮动</li>\n<li>自适应多栏布局</li>\n</ul>\n<hr>\n"},{"title":"CSS隐藏元素","date":"2021-04-02T02:06:33.000Z","_content":"### 1. CSS隐藏方法\n - display:none\n - visibility:hidden\n - opacity:0\n - 设置height、width模型属性为0\n - position:absolute\n - clip-path\n---\n### 2. display:none\n最为常用的方法 .hide{ display:none }\n元素会彻底消失，本身空间会被其他元素占有，导致重排和重绘。\n消失后，绑定的事件不会触发，也不会有过渡效果。\n特点：元素不可见，不占据空间，无法响应点击事件。\n### 3. visibility:hidden\n也是常见的隐藏元素的方法\n仅仅隐藏，DOM依然存在，处于不可见的状态。\n不会触发重排，但是会触发重绘。\n特点：元素不可见，占据页面空间，无法响应点击事件。\n### 4. opacity:0\nopacity表示元素的透明度，设置为0后，元素为隐藏状态。\n不会引发重排，一般情况下也会引发重绘。\n自身事件会触发，但被其遮挡的元素无法触发事件。\n子元素无法设置opacity来达到显示的效果。\n特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件。\n### 5. height,width属性为0\n.hiddenBox{margin:0;border:0;padding:0;height:0;width:0;overflow:hidden}\n特点：元素不可见，不占据页面空间，无法响应点击事件\n### 6. postion:absolute\n将元素移除可视区域\n.hidden{position: absolute;top:-9999px;left:-9999px}\n特点：元素不可见，不影响页面布局\n### 7. clip-path\n通过裁剪的形式\n.hide{clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px)}\n特点：元素不可见，占据页面空间，无法响应点击事件\n### 8. 小结\n最常用的还是display:none,visubility:hidden","source":"_posts/CSS隐藏元素.md","raw":"---\ntitle: CSS隐藏元素\ndate: 2021-04-02 10:06:33\ntags:\n - CSS\ncategories: 页面样式\n---\n### 1. CSS隐藏方法\n - display:none\n - visibility:hidden\n - opacity:0\n - 设置height、width模型属性为0\n - position:absolute\n - clip-path\n---\n### 2. display:none\n最为常用的方法 .hide{ display:none }\n元素会彻底消失，本身空间会被其他元素占有，导致重排和重绘。\n消失后，绑定的事件不会触发，也不会有过渡效果。\n特点：元素不可见，不占据空间，无法响应点击事件。\n### 3. visibility:hidden\n也是常见的隐藏元素的方法\n仅仅隐藏，DOM依然存在，处于不可见的状态。\n不会触发重排，但是会触发重绘。\n特点：元素不可见，占据页面空间，无法响应点击事件。\n### 4. opacity:0\nopacity表示元素的透明度，设置为0后，元素为隐藏状态。\n不会引发重排，一般情况下也会引发重绘。\n自身事件会触发，但被其遮挡的元素无法触发事件。\n子元素无法设置opacity来达到显示的效果。\n特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件。\n### 5. height,width属性为0\n.hiddenBox{margin:0;border:0;padding:0;height:0;width:0;overflow:hidden}\n特点：元素不可见，不占据页面空间，无法响应点击事件\n### 6. postion:absolute\n将元素移除可视区域\n.hidden{position: absolute;top:-9999px;left:-9999px}\n特点：元素不可见，不影响页面布局\n### 7. clip-path\n通过裁剪的形式\n.hide{clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px)}\n特点：元素不可见，占据页面空间，无法响应点击事件\n### 8. 小结\n最常用的还是display:none,visubility:hidden","slug":"CSS隐藏元素","published":1,"updated":"2021-04-02T15:17:32.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5qjyo6000190vahhz06x2r","content":"<h3 id=\"1-CSS隐藏方法\"><a href=\"#1-CSS隐藏方法\" class=\"headerlink\" title=\"1. CSS隐藏方法\"></a>1. CSS隐藏方法</h3><ul>\n<li>display:none</li>\n<li>visibility:hidden</li>\n<li>opacity:0</li>\n<li>设置height、width模型属性为0</li>\n<li>position:absolute</li>\n<li>clip-path</li>\n</ul>\n<hr>\n<h3 id=\"2-display-none\"><a href=\"#2-display-none\" class=\"headerlink\" title=\"2. display:none\"></a>2. display:none</h3><p>最为常用的方法 .hide{ display:none }<br>元素会彻底消失，本身空间会被其他元素占有，导致重排和重绘。<br>消失后，绑定的事件不会触发，也不会有过渡效果。<br>特点：元素不可见，不占据空间，无法响应点击事件。</p>\n<h3 id=\"3-visibility-hidden\"><a href=\"#3-visibility-hidden\" class=\"headerlink\" title=\"3. visibility:hidden\"></a>3. visibility:hidden</h3><p>也是常见的隐藏元素的方法<br>仅仅隐藏，DOM依然存在，处于不可见的状态。<br>不会触发重排，但是会触发重绘。<br>特点：元素不可见，占据页面空间，无法响应点击事件。</p>\n<h3 id=\"4-opacity-0\"><a href=\"#4-opacity-0\" class=\"headerlink\" title=\"4. opacity:0\"></a>4. opacity:0</h3><p>opacity表示元素的透明度，设置为0后，元素为隐藏状态。<br>不会引发重排，一般情况下也会引发重绘。<br>自身事件会触发，但被其遮挡的元素无法触发事件。<br>子元素无法设置opacity来达到显示的效果。<br>特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件。</p>\n<h3 id=\"5-height-width属性为0\"><a href=\"#5-height-width属性为0\" class=\"headerlink\" title=\"5. height,width属性为0\"></a>5. height,width属性为0</h3><p>.hiddenBox{margin:0;border:0;padding:0;height:0;width:0;overflow:hidden}<br>特点：元素不可见，不占据页面空间，无法响应点击事件</p>\n<h3 id=\"6-postion-absolute\"><a href=\"#6-postion-absolute\" class=\"headerlink\" title=\"6. postion:absolute\"></a>6. postion:absolute</h3><p>将元素移除可视区域<br>.hidden{position: absolute;top:-9999px;left:-9999px}<br>特点：元素不可见，不影响页面布局</p>\n<h3 id=\"7-clip-path\"><a href=\"#7-clip-path\" class=\"headerlink\" title=\"7. clip-path\"></a>7. clip-path</h3><p>通过裁剪的形式<br>.hide{clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px)}<br>特点：元素不可见，占据页面空间，无法响应点击事件</p>\n<h3 id=\"8-小结\"><a href=\"#8-小结\" class=\"headerlink\" title=\"8. 小结\"></a>8. 小结</h3><p>最常用的还是display:none,visubility:hidden</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-CSS隐藏方法\"><a href=\"#1-CSS隐藏方法\" class=\"headerlink\" title=\"1. CSS隐藏方法\"></a>1. CSS隐藏方法</h3><ul>\n<li>display:none</li>\n<li>visibility:hidden</li>\n<li>opacity:0</li>\n<li>设置height、width模型属性为0</li>\n<li>position:absolute</li>\n<li>clip-path</li>\n</ul>\n<hr>\n<h3 id=\"2-display-none\"><a href=\"#2-display-none\" class=\"headerlink\" title=\"2. display:none\"></a>2. display:none</h3><p>最为常用的方法 .hide{ display:none }<br>元素会彻底消失，本身空间会被其他元素占有，导致重排和重绘。<br>消失后，绑定的事件不会触发，也不会有过渡效果。<br>特点：元素不可见，不占据空间，无法响应点击事件。</p>\n<h3 id=\"3-visibility-hidden\"><a href=\"#3-visibility-hidden\" class=\"headerlink\" title=\"3. visibility:hidden\"></a>3. visibility:hidden</h3><p>也是常见的隐藏元素的方法<br>仅仅隐藏，DOM依然存在，处于不可见的状态。<br>不会触发重排，但是会触发重绘。<br>特点：元素不可见，占据页面空间，无法响应点击事件。</p>\n<h3 id=\"4-opacity-0\"><a href=\"#4-opacity-0\" class=\"headerlink\" title=\"4. opacity:0\"></a>4. opacity:0</h3><p>opacity表示元素的透明度，设置为0后，元素为隐藏状态。<br>不会引发重排，一般情况下也会引发重绘。<br>自身事件会触发，但被其遮挡的元素无法触发事件。<br>子元素无法设置opacity来达到显示的效果。<br>特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件。</p>\n<h3 id=\"5-height-width属性为0\"><a href=\"#5-height-width属性为0\" class=\"headerlink\" title=\"5. height,width属性为0\"></a>5. height,width属性为0</h3><p>.hiddenBox{margin:0;border:0;padding:0;height:0;width:0;overflow:hidden}<br>特点：元素不可见，不占据页面空间，无法响应点击事件</p>\n<h3 id=\"6-postion-absolute\"><a href=\"#6-postion-absolute\" class=\"headerlink\" title=\"6. postion:absolute\"></a>6. postion:absolute</h3><p>将元素移除可视区域<br>.hidden{position: absolute;top:-9999px;left:-9999px}<br>特点：元素不可见，不影响页面布局</p>\n<h3 id=\"7-clip-path\"><a href=\"#7-clip-path\" class=\"headerlink\" title=\"7. clip-path\"></a>7. clip-path</h3><p>通过裁剪的形式<br>.hide{clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px)}<br>特点：元素不可见，占据页面空间，无法响应点击事件</p>\n<h3 id=\"8-小结\"><a href=\"#8-小结\" class=\"headerlink\" title=\"8. 小结\"></a>8. 小结</h3><p>最常用的还是display:none,visubility:hidden</p>\n"},{"title":"两栏布局和三栏布局","date":"2021-04-08T05:01:15.000Z","_content":"### 1. 双栏布局\n - 使用float左浮左边栏\n - 右边模块使用margin-left撑出内容块做内容展示\n - 为父级元素添加BFC，防止下方元素飞到上方内容\n```\n<style>\n    .box{\n        overflow: hidden; 添加BFC\n    }\n    .left {\n        float: left;\n        width: 200px;\n        background-color: gray;\n        height: 400px;\n    }\n    .right {\n        margin-left: 210px;\n        background-color: lightgray;\n        height: 200px;\n    }\n</style>\n<div class=\"box\">\n    <div class=\"left\">左边</div>\n    <div class=\"right\">右边</div>\n</div>\n采用弹性布局也可\n<style>\n    .box{\n        display: flex;\n    }\n    .left {\n        width: 100px;\n    }\n    .right {\n        flex: 1;\n    }\n</style>\n<div class=\"box\">\n    <div class=\"left\">左边</div>\n    <div class=\"right\">右边</div>\n</div>\n```\n---\n### 2. 三栏布局\n - 两边使用float，中间使用margin\n - 两边使用absolute，中间使用margin\n - 两边使用float和负margin\n - display：table实现\n - flex实现\n - grid网格布局\n```\n<style>\n    .wrap {\n        background: #eee;\n        overflow: hidden; <!-- 生成BFC，计算高度时考虑浮动的元素 -->\n        padding: 20px;\n        height: 200px;\n    }\n    .left {\n        width: 200px;\n        height: 200px;\n        float: left;\n        background: coral;\n    }\n    .right {\n        width: 120px;\n        height: 200px;\n        float: right;\n        background: lightblue;\n    }\n    .middle {\n        margin-left: 220px;\n        height: 200px;\n        background: lightpink;\n        margin-right: 140px;\n    }\n</style>\n<div class=\"wrap\">\n    <div class=\"left\">左侧</div>\n    <div class=\"right\">右侧</div>\n    <div class=\"middle\">中间</div>\n</div>\n\n<style>\n  .container {\n    position: relative;\n  }\n  \n  .left,\n  .right,\n  .main {\n    height: 200px;\n    line-height: 200px;\n    text-align: center;\n  }\n\n  .left {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100px;\n    background: green;\n  }\n\n  .right {\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100px;\n    background: green;\n  }\n\n  .main {\n    margin: 0 110px;\n    background: black;\n    color: white;\n  }\n</style>\n\n<div class=\"container\">\n  <div class=\"left\">左边固定宽度</div>\n  <div class=\"right\">右边固定宽度</div>\n  <div class=\"main\">中间自适应</div>\n</div>\n\n<style>\n  .left,\n  .right,\n  .main {\n    height: 200px;\n    line-height: 200px;\n    text-align: center;\n  }\n\n  .main-wrapper {\n    float: left;\n    width: 100%;\n  }\n\n  .main {\n    margin: 0 110px;\n    background: black;\n    color: white;\n  }\n\n  .left,\n  .right {\n    float: left;\n    width: 100px;\n    margin-left: -100%;\n    background: green;\n  }\n\n  .right {\n    margin-left: -100px; /* 同自身宽度 */\n  }\n</style>\n\n<div class=\"main-wrapper\">\n  <div class=\"main\">中间自适应</div>\n</div>\n<div class=\"left\">左边固定宽度</div>\n<div class=\"right\">右边固定宽度</div>\n```\n","source":"_posts/两栏布局和三栏布局.md","raw":"---\ntitle: 两栏布局和三栏布局\ndate: 2021-04-08 13:01:15\ntags:\n - CSS\ncategories: 页面样式\n---\n### 1. 双栏布局\n - 使用float左浮左边栏\n - 右边模块使用margin-left撑出内容块做内容展示\n - 为父级元素添加BFC，防止下方元素飞到上方内容\n```\n<style>\n    .box{\n        overflow: hidden; 添加BFC\n    }\n    .left {\n        float: left;\n        width: 200px;\n        background-color: gray;\n        height: 400px;\n    }\n    .right {\n        margin-left: 210px;\n        background-color: lightgray;\n        height: 200px;\n    }\n</style>\n<div class=\"box\">\n    <div class=\"left\">左边</div>\n    <div class=\"right\">右边</div>\n</div>\n采用弹性布局也可\n<style>\n    .box{\n        display: flex;\n    }\n    .left {\n        width: 100px;\n    }\n    .right {\n        flex: 1;\n    }\n</style>\n<div class=\"box\">\n    <div class=\"left\">左边</div>\n    <div class=\"right\">右边</div>\n</div>\n```\n---\n### 2. 三栏布局\n - 两边使用float，中间使用margin\n - 两边使用absolute，中间使用margin\n - 两边使用float和负margin\n - display：table实现\n - flex实现\n - grid网格布局\n```\n<style>\n    .wrap {\n        background: #eee;\n        overflow: hidden; <!-- 生成BFC，计算高度时考虑浮动的元素 -->\n        padding: 20px;\n        height: 200px;\n    }\n    .left {\n        width: 200px;\n        height: 200px;\n        float: left;\n        background: coral;\n    }\n    .right {\n        width: 120px;\n        height: 200px;\n        float: right;\n        background: lightblue;\n    }\n    .middle {\n        margin-left: 220px;\n        height: 200px;\n        background: lightpink;\n        margin-right: 140px;\n    }\n</style>\n<div class=\"wrap\">\n    <div class=\"left\">左侧</div>\n    <div class=\"right\">右侧</div>\n    <div class=\"middle\">中间</div>\n</div>\n\n<style>\n  .container {\n    position: relative;\n  }\n  \n  .left,\n  .right,\n  .main {\n    height: 200px;\n    line-height: 200px;\n    text-align: center;\n  }\n\n  .left {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100px;\n    background: green;\n  }\n\n  .right {\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100px;\n    background: green;\n  }\n\n  .main {\n    margin: 0 110px;\n    background: black;\n    color: white;\n  }\n</style>\n\n<div class=\"container\">\n  <div class=\"left\">左边固定宽度</div>\n  <div class=\"right\">右边固定宽度</div>\n  <div class=\"main\">中间自适应</div>\n</div>\n\n<style>\n  .left,\n  .right,\n  .main {\n    height: 200px;\n    line-height: 200px;\n    text-align: center;\n  }\n\n  .main-wrapper {\n    float: left;\n    width: 100%;\n  }\n\n  .main {\n    margin: 0 110px;\n    background: black;\n    color: white;\n  }\n\n  .left,\n  .right {\n    float: left;\n    width: 100px;\n    margin-left: -100%;\n    background: green;\n  }\n\n  .right {\n    margin-left: -100px; /* 同自身宽度 */\n  }\n</style>\n\n<div class=\"main-wrapper\">\n  <div class=\"main\">中间自适应</div>\n</div>\n<div class=\"left\">左边固定宽度</div>\n<div class=\"right\">右边固定宽度</div>\n```\n","slug":"两栏布局和三栏布局","published":1,"updated":"2021-04-09T08:26:00.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckna1opse0000w8va1uw42wke","content":"<h3 id=\"1-双栏布局\"><a href=\"#1-双栏布局\" class=\"headerlink\" title=\"1. 双栏布局\"></a>1. 双栏布局</h3><ul>\n<li>使用float左浮左边栏</li>\n<li>右边模块使用margin-left撑出内容块做内容展示</li>\n<li>为父级元素添加BFC，防止下方元素飞到上方内容<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .box&#123;</span><br><span class=\"line\">        overflow: hidden; 添加BFC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        background-color: gray;</span><br><span class=\"line\">        height: 400px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">        margin-left: 210px;</span><br><span class=\"line\">        background-color: lightgray;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;left&quot;&gt;左边&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">采用弹性布局也可</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .box&#123;</span><br><span class=\"line\">        display: flex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">        flex: 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;left&quot;&gt;左边&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-三栏布局\"><a href=\"#2-三栏布局\" class=\"headerlink\" title=\"2. 三栏布局\"></a>2. 三栏布局</h3><ul>\n<li>两边使用float，中间使用margin</li>\n<li>两边使用absolute，中间使用margin</li>\n<li>两边使用float和负margin</li>\n<li>display：table实现</li>\n<li>flex实现</li>\n<li>grid网格布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .wrap &#123;</span><br><span class=\"line\">        background: #eee;</span><br><span class=\"line\">        overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;</span><br><span class=\"line\">        padding: 20px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        background: coral;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">        width: 120px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        float: right;</span><br><span class=\"line\">        background: lightblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .middle &#123;</span><br><span class=\"line\">        margin-left: 220px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: lightpink;</span><br><span class=\"line\">        margin-right: 140px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;wrap&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;left&quot;&gt;左侧&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;right&quot;&gt;右侧&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;middle&quot;&gt;中间&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .container &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  .left,</span><br><span class=\"line\">  .right,</span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    line-height: 200px;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .left &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .right &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    margin: 0 110px;</span><br><span class=\"line\">    background: black;</span><br><span class=\"line\">    color: white;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;left&quot;&gt;左边固定宽度&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;right&quot;&gt;右边固定宽度&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;main&quot;&gt;中间自适应&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .left,</span><br><span class=\"line\">  .right,</span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    line-height: 200px;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .main-wrapper &#123;</span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 100%;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    margin: 0 110px;</span><br><span class=\"line\">    background: black;</span><br><span class=\"line\">    color: white;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .left,</span><br><span class=\"line\">  .right &#123;</span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    margin-left: -100%;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .right &#123;</span><br><span class=\"line\">    margin-left: -100px; &#x2F;* 同自身宽度 *&#x2F;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class&#x3D;&quot;main-wrapper&quot;&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;main&quot;&gt;中间自适应&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;left&quot;&gt;左边固定宽度&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;right&quot;&gt;右边固定宽度&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-双栏布局\"><a href=\"#1-双栏布局\" class=\"headerlink\" title=\"1. 双栏布局\"></a>1. 双栏布局</h3><ul>\n<li>使用float左浮左边栏</li>\n<li>右边模块使用margin-left撑出内容块做内容展示</li>\n<li>为父级元素添加BFC，防止下方元素飞到上方内容<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .box&#123;</span><br><span class=\"line\">        overflow: hidden; 添加BFC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        background-color: gray;</span><br><span class=\"line\">        height: 400px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">        margin-left: 210px;</span><br><span class=\"line\">        background-color: lightgray;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;left&quot;&gt;左边&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">采用弹性布局也可</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .box&#123;</span><br><span class=\"line\">        display: flex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">        flex: 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;left&quot;&gt;左边&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-三栏布局\"><a href=\"#2-三栏布局\" class=\"headerlink\" title=\"2. 三栏布局\"></a>2. 三栏布局</h3><ul>\n<li>两边使用float，中间使用margin</li>\n<li>两边使用absolute，中间使用margin</li>\n<li>两边使用float和负margin</li>\n<li>display：table实现</li>\n<li>flex实现</li>\n<li>grid网格布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .wrap &#123;</span><br><span class=\"line\">        background: #eee;</span><br><span class=\"line\">        overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;</span><br><span class=\"line\">        padding: 20px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        background: coral;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">        width: 120px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        float: right;</span><br><span class=\"line\">        background: lightblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .middle &#123;</span><br><span class=\"line\">        margin-left: 220px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: lightpink;</span><br><span class=\"line\">        margin-right: 140px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;wrap&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;left&quot;&gt;左侧&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;right&quot;&gt;右侧&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;middle&quot;&gt;中间&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .container &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  .left,</span><br><span class=\"line\">  .right,</span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    line-height: 200px;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .left &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .right &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    margin: 0 110px;</span><br><span class=\"line\">    background: black;</span><br><span class=\"line\">    color: white;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;left&quot;&gt;左边固定宽度&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;right&quot;&gt;右边固定宽度&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;main&quot;&gt;中间自适应&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .left,</span><br><span class=\"line\">  .right,</span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    line-height: 200px;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .main-wrapper &#123;</span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 100%;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .main &#123;</span><br><span class=\"line\">    margin: 0 110px;</span><br><span class=\"line\">    background: black;</span><br><span class=\"line\">    color: white;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .left,</span><br><span class=\"line\">  .right &#123;</span><br><span class=\"line\">    float: left;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    margin-left: -100%;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .right &#123;</span><br><span class=\"line\">    margin-left: -100px; &#x2F;* 同自身宽度 *&#x2F;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class&#x3D;&quot;main-wrapper&quot;&gt;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;main&quot;&gt;中间自适应&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;left&quot;&gt;左边固定宽度&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;right&quot;&gt;右边固定宽度&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"水平垂直居中方式","date":"2021-04-07T13:46:56.000Z","_content":"### 1. 定位+margin:auto\n```\n<style>\n    .father{\n        width:500px;\n        height:300px;\n        border:1px solid #0a3b98;\n        position: relative;\n    }\n    .son{\n        width:100px;\n        height:40px;\n        background: #f0a238;\n        position: absolute;\n        top:0;\n        left:0;\n        right:0;\n        bottom:0;\n        margin:auto;\n    }\n</style>\n<div class=\"father\">\n    <div class=\"son\"></div>\n</div>\n```\n### 2. 定位+margin:负值\n```\n.father {\n        position: relative;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-left:-50px;\n        margin-top:-50px;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 3. 定位+transform\n```\n    .father {\n        position: relative;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n  transform: translate(-50%,-50%);\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 4. table布局\n```\n.father {\n        display: table-cell;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n        vertical-align: middle;\n        text-align: center;\n    }\n    .son {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 5. flex布局\n```\n.father {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 6. grid网格布局\n```\n .father {\n            display: grid;\n            align-items:center;\n            justify-content: center;\n            width: 200px;\n            height: 200px;\n            background: skyblue;\n\n        }\n        .son {\n            width: 10px;\n            height: 10px;\n            border: 1px solid red\n        }\n```\n### 7. 小结\n## 7.1 内联元素居中布局\n水平居中：\n行内元素设置text-align:center\ndisplay:flex;justify-content:center\n垂直居中：\n单行文本父元素确认高度：height === line-height\n多行文本父元素确认高度：display：table-cell；vertical-align：middle\n## 7.2 块级元素居中布局\n水平居中：\n定宽：margin：0 auto\n绝对定位+left：50%+margin：负自身一半\n垂直居中：\nposition：absolute设置left，top，margin-left，margin-top\ndisplay：table-cell\ntransform：translate(x,y)\nflex\ngrid\n","source":"_posts/水平垂直居中方式.md","raw":"---\ntitle: 水平垂直居中方式\ndate: 2021-04-07 21:46:56\ntags:\n - CSS\n - 响应式布局\ncategories: UI设计开发\n---\n### 1. 定位+margin:auto\n```\n<style>\n    .father{\n        width:500px;\n        height:300px;\n        border:1px solid #0a3b98;\n        position: relative;\n    }\n    .son{\n        width:100px;\n        height:40px;\n        background: #f0a238;\n        position: absolute;\n        top:0;\n        left:0;\n        right:0;\n        bottom:0;\n        margin:auto;\n    }\n</style>\n<div class=\"father\">\n    <div class=\"son\"></div>\n</div>\n```\n### 2. 定位+margin:负值\n```\n.father {\n        position: relative;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-left:-50px;\n        margin-top:-50px;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 3. 定位+transform\n```\n    .father {\n        position: relative;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n  transform: translate(-50%,-50%);\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 4. table布局\n```\n.father {\n        display: table-cell;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n        vertical-align: middle;\n        text-align: center;\n    }\n    .son {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 5. flex布局\n```\n.father {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 200px;\n        height: 200px;\n        background: skyblue;\n    }\n    .son {\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n```\n### 6. grid网格布局\n```\n .father {\n            display: grid;\n            align-items:center;\n            justify-content: center;\n            width: 200px;\n            height: 200px;\n            background: skyblue;\n\n        }\n        .son {\n            width: 10px;\n            height: 10px;\n            border: 1px solid red\n        }\n```\n### 7. 小结\n## 7.1 内联元素居中布局\n水平居中：\n行内元素设置text-align:center\ndisplay:flex;justify-content:center\n垂直居中：\n单行文本父元素确认高度：height === line-height\n多行文本父元素确认高度：display：table-cell；vertical-align：middle\n## 7.2 块级元素居中布局\n水平居中：\n定宽：margin：0 auto\n绝对定位+left：50%+margin：负自身一半\n垂直居中：\nposition：absolute设置left，top，margin-left，margin-top\ndisplay：table-cell\ntransform：translate(x,y)\nflex\ngrid\n","slug":"水平垂直居中方式","published":1,"updated":"2021-04-07T15:01:24.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckna1opsk0001w8va22hnhydd","content":"<h3 id=\"1-定位-margin-auto\"><a href=\"#1-定位-margin-auto\" class=\"headerlink\" title=\"1. 定位+margin:auto\"></a>1. 定位+margin:auto</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .father&#123;</span><br><span class=\"line\">        width:500px;</span><br><span class=\"line\">        height:300px;</span><br><span class=\"line\">        border:1px solid #0a3b98;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son&#123;</span><br><span class=\"line\">        width:100px;</span><br><span class=\"line\">        height:40px;</span><br><span class=\"line\">        background: #f0a238;</span><br><span class=\"line\">        position: absolute;</span><br><span class=\"line\">        top:0;</span><br><span class=\"line\">        left:0;</span><br><span class=\"line\">        right:0;</span><br><span class=\"line\">        bottom:0;</span><br><span class=\"line\">        margin:auto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-定位-margin-负值\"><a href=\"#2-定位-margin-负值\" class=\"headerlink\" title=\"2. 定位+margin:负值\"></a>2. 定位+margin:负值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son &#123;</span><br><span class=\"line\">        position: absolute;</span><br><span class=\"line\">        top: 50%;</span><br><span class=\"line\">        left: 50%;</span><br><span class=\"line\">        margin-left:-50px;</span><br><span class=\"line\">        margin-top:-50px;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-定位-transform\"><a href=\"#3-定位-transform\" class=\"headerlink\" title=\"3. 定位+transform\"></a>3. 定位+transform</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  .father &#123;</span><br><span class=\"line\">      position: relative;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      height: 200px;</span><br><span class=\"line\">      background: skyblue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .son &#123;</span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">      top: 50%;</span><br><span class=\"line\">      left: 50%;</span><br><span class=\"line\">transform: translate(-50%,-50%);</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      background: red;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-table布局\"><a href=\"#4-table布局\" class=\"headerlink\" title=\"4. table布局\"></a>4. table布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">        display: table-cell;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: skyblue;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        text-align: center;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son &#123;</span><br><span class=\"line\">        display: inline-block;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-flex布局\"><a href=\"#5-flex布局\" class=\"headerlink\" title=\"5. flex布局\"></a>5. flex布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">        display: flex;</span><br><span class=\"line\">        justify-content: center;</span><br><span class=\"line\">        align-items: center;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-grid网格布局\"><a href=\"#6-grid网格布局\" class=\"headerlink\" title=\"6. grid网格布局\"></a>6. grid网格布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">           display: grid;</span><br><span class=\"line\">           align-items:center;</span><br><span class=\"line\">           justify-content: center;</span><br><span class=\"line\">           width: 200px;</span><br><span class=\"line\">           height: 200px;</span><br><span class=\"line\">           background: skyblue;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       .son &#123;</span><br><span class=\"line\">           width: 10px;</span><br><span class=\"line\">           height: 10px;</span><br><span class=\"line\">           border: 1px solid red</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-小结\"><a href=\"#7-小结\" class=\"headerlink\" title=\"7. 小结\"></a>7. 小结</h3><h2 id=\"7-1-内联元素居中布局\"><a href=\"#7-1-内联元素居中布局\" class=\"headerlink\" title=\"7.1 内联元素居中布局\"></a>7.1 内联元素居中布局</h2><p>水平居中：<br>行内元素设置text-align:center<br>display:flex;justify-content:center<br>垂直居中：<br>单行文本父元素确认高度：height === line-height<br>多行文本父元素确认高度：display：table-cell；vertical-align：middle</p>\n<h2 id=\"7-2-块级元素居中布局\"><a href=\"#7-2-块级元素居中布局\" class=\"headerlink\" title=\"7.2 块级元素居中布局\"></a>7.2 块级元素居中布局</h2><p>水平居中：<br>定宽：margin：0 auto<br>绝对定位+left：50%+margin：负自身一半<br>垂直居中：<br>position：absolute设置left，top，margin-left，margin-top<br>display：table-cell<br>transform：translate(x,y)<br>flex<br>grid</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-定位-margin-auto\"><a href=\"#1-定位-margin-auto\" class=\"headerlink\" title=\"1. 定位+margin:auto\"></a>1. 定位+margin:auto</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .father&#123;</span><br><span class=\"line\">        width:500px;</span><br><span class=\"line\">        height:300px;</span><br><span class=\"line\">        border:1px solid #0a3b98;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son&#123;</span><br><span class=\"line\">        width:100px;</span><br><span class=\"line\">        height:40px;</span><br><span class=\"line\">        background: #f0a238;</span><br><span class=\"line\">        position: absolute;</span><br><span class=\"line\">        top:0;</span><br><span class=\"line\">        left:0;</span><br><span class=\"line\">        right:0;</span><br><span class=\"line\">        bottom:0;</span><br><span class=\"line\">        margin:auto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-定位-margin-负值\"><a href=\"#2-定位-margin-负值\" class=\"headerlink\" title=\"2. 定位+margin:负值\"></a>2. 定位+margin:负值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son &#123;</span><br><span class=\"line\">        position: absolute;</span><br><span class=\"line\">        top: 50%;</span><br><span class=\"line\">        left: 50%;</span><br><span class=\"line\">        margin-left:-50px;</span><br><span class=\"line\">        margin-top:-50px;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-定位-transform\"><a href=\"#3-定位-transform\" class=\"headerlink\" title=\"3. 定位+transform\"></a>3. 定位+transform</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  .father &#123;</span><br><span class=\"line\">      position: relative;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      height: 200px;</span><br><span class=\"line\">      background: skyblue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .son &#123;</span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">      top: 50%;</span><br><span class=\"line\">      left: 50%;</span><br><span class=\"line\">transform: translate(-50%,-50%);</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      background: red;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-table布局\"><a href=\"#4-table布局\" class=\"headerlink\" title=\"4. table布局\"></a>4. table布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">        display: table-cell;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: skyblue;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        text-align: center;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son &#123;</span><br><span class=\"line\">        display: inline-block;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-flex布局\"><a href=\"#5-flex布局\" class=\"headerlink\" title=\"5. flex布局\"></a>5. flex布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">        display: flex;</span><br><span class=\"line\">        justify-content: center;</span><br><span class=\"line\">        align-items: center;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        background: skyblue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .son &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        background: red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-grid网格布局\"><a href=\"#6-grid网格布局\" class=\"headerlink\" title=\"6. grid网格布局\"></a>6. grid网格布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">           display: grid;</span><br><span class=\"line\">           align-items:center;</span><br><span class=\"line\">           justify-content: center;</span><br><span class=\"line\">           width: 200px;</span><br><span class=\"line\">           height: 200px;</span><br><span class=\"line\">           background: skyblue;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       .son &#123;</span><br><span class=\"line\">           width: 10px;</span><br><span class=\"line\">           height: 10px;</span><br><span class=\"line\">           border: 1px solid red</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-小结\"><a href=\"#7-小结\" class=\"headerlink\" title=\"7. 小结\"></a>7. 小结</h3><h2 id=\"7-1-内联元素居中布局\"><a href=\"#7-1-内联元素居中布局\" class=\"headerlink\" title=\"7.1 内联元素居中布局\"></a>7.1 内联元素居中布局</h2><p>水平居中：<br>行内元素设置text-align:center<br>display:flex;justify-content:center<br>垂直居中：<br>单行文本父元素确认高度：height === line-height<br>多行文本父元素确认高度：display：table-cell；vertical-align：middle</p>\n<h2 id=\"7-2-块级元素居中布局\"><a href=\"#7-2-块级元素居中布局\" class=\"headerlink\" title=\"7.2 块级元素居中布局\"></a>7.2 块级元素居中布局</h2><p>水平居中：<br>定宽：margin：0 auto<br>绝对定位+left：50%+margin：负自身一半<br>垂直居中：<br>position：absolute设置left，top，margin-left，margin-top<br>display：table-cell<br>transform：translate(x,y)<br>flex<br>grid</p>\n"},{"title":"CSS3特性","date":"2021-04-13T11:16:40.000Z","_content":"### 1. 选择器\n### 2. 边框\n新增3个边框属性：\n1.border-radius:创建圆角边框\n2.box-shadow:为元素添加阴影\n3.border-image:使用图片来绘制边框\n### 3. 背景\n1.background-clip:确定背景画区\n2.background-origin:设置对齐方式\n3.background-break:设置盒子绘制\n### 4. 文字\n1.word-wrap:normal(换行) break-all(单词内换行)\n2.text-overflow:clip(修剪文本) ellipsis(显示省略符代替遮盖文本)\n3.text-shadow:设置文本阴影\n4.text-decoration:设置深层渲染\n### 5. 颜色\nrgba：rgb为颜色值，a为透明度\nhala：h为色相，s为饱和度，1为亮度，a为透明度\n### 6. transition 过渡\n```\ntransition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)\ntransition-property: width; \ntransition-duration: 1s;\ntransition-timing-function: linear;\ntransition-delay: 2s;\n```\n### 7. transform 转换\n```\ntransform: translate(120px, 50%)：位移\ntransform: scale(2, 0.5)：缩放\ntransform: rotate(0.5turn)：旋转\ntransform: skew(30deg, 20deg)：倾斜\n```\n### 8. animation 动画\n```\nanimation-name：动画名称\nanimation-duration：动画持续时间\nanimation-timing-function：动画时间函数\nanimation-delay：动画延迟时间\nanimation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环\nanimation-direction：动画执行方向\nanimation-paly-state：动画播放状态\nanimation-fill-mode：动画填充模式\n```\n### 9. 渐变\n```\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...); // 线性渐变\nlinear-gradient(0deg, red, green); // 径向渐变\n```\n### 10. 其他\nflex布局，grid布局，多列布局，媒体查询，混合模式等。。。","source":"_posts/CSS3特性.md","raw":"---\ntitle: CSS3特性\ndate: 2021-04-13 19:16:40\ntags:\n - CSS\ncategories: 页面样式\n---\n### 1. 选择器\n### 2. 边框\n新增3个边框属性：\n1.border-radius:创建圆角边框\n2.box-shadow:为元素添加阴影\n3.border-image:使用图片来绘制边框\n### 3. 背景\n1.background-clip:确定背景画区\n2.background-origin:设置对齐方式\n3.background-break:设置盒子绘制\n### 4. 文字\n1.word-wrap:normal(换行) break-all(单词内换行)\n2.text-overflow:clip(修剪文本) ellipsis(显示省略符代替遮盖文本)\n3.text-shadow:设置文本阴影\n4.text-decoration:设置深层渲染\n### 5. 颜色\nrgba：rgb为颜色值，a为透明度\nhala：h为色相，s为饱和度，1为亮度，a为透明度\n### 6. transition 过渡\n```\ntransition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)\ntransition-property: width; \ntransition-duration: 1s;\ntransition-timing-function: linear;\ntransition-delay: 2s;\n```\n### 7. transform 转换\n```\ntransform: translate(120px, 50%)：位移\ntransform: scale(2, 0.5)：缩放\ntransform: rotate(0.5turn)：旋转\ntransform: skew(30deg, 20deg)：倾斜\n```\n### 8. animation 动画\n```\nanimation-name：动画名称\nanimation-duration：动画持续时间\nanimation-timing-function：动画时间函数\nanimation-delay：动画延迟时间\nanimation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环\nanimation-direction：动画执行方向\nanimation-paly-state：动画播放状态\nanimation-fill-mode：动画填充模式\n```\n### 9. 渐变\n```\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...); // 线性渐变\nlinear-gradient(0deg, red, green); // 径向渐变\n```\n### 10. 其他\nflex布局，grid布局，多列布局，媒体查询，混合模式等。。。","slug":"CSS3特性","published":1,"updated":"2021-04-13T12:41:36.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckng0l4yu0000o8vae2caaq04","content":"<h3 id=\"1-选择器\"><a href=\"#1-选择器\" class=\"headerlink\" title=\"1. 选择器\"></a>1. 选择器</h3><h3 id=\"2-边框\"><a href=\"#2-边框\" class=\"headerlink\" title=\"2. 边框\"></a>2. 边框</h3><p>新增3个边框属性：<br>1.border-radius:创建圆角边框<br>2.box-shadow:为元素添加阴影<br>3.border-image:使用图片来绘制边框</p>\n<h3 id=\"3-背景\"><a href=\"#3-背景\" class=\"headerlink\" title=\"3. 背景\"></a>3. 背景</h3><p>1.background-clip:确定背景画区<br>2.background-origin:设置对齐方式<br>3.background-break:设置盒子绘制</p>\n<h3 id=\"4-文字\"><a href=\"#4-文字\" class=\"headerlink\" title=\"4. 文字\"></a>4. 文字</h3><p>1.word-wrap:normal(换行) break-all(单词内换行)<br>2.text-overflow:clip(修剪文本) ellipsis(显示省略符代替遮盖文本)<br>3.text-shadow:设置文本阴影<br>4.text-decoration:设置深层渲染</p>\n<h3 id=\"5-颜色\"><a href=\"#5-颜色\" class=\"headerlink\" title=\"5. 颜色\"></a>5. 颜色</h3><p>rgba：rgb为颜色值，a为透明度<br>hala：h为色相，s为饱和度，1为亮度，a为透明度</p>\n<h3 id=\"6-transition-过渡\"><a href=\"#6-transition-过渡\" class=\"headerlink\" title=\"6. transition 过渡\"></a>6. transition 过渡</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</span><br><span class=\"line\">transition-property: width; </span><br><span class=\"line\">transition-duration: 1s;</span><br><span class=\"line\">transition-timing-function: linear;</span><br><span class=\"line\">transition-delay: 2s;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-transform-转换\"><a href=\"#7-transform-转换\" class=\"headerlink\" title=\"7. transform 转换\"></a>7. transform 转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform: translate(120px, 50%)：位移</span><br><span class=\"line\">transform: scale(2, 0.5)：缩放</span><br><span class=\"line\">transform: rotate(0.5turn)：旋转</span><br><span class=\"line\">transform: skew(30deg, 20deg)：倾斜</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-animation-动画\"><a href=\"#8-animation-动画\" class=\"headerlink\" title=\"8. animation 动画\"></a>8. animation 动画</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation-name：动画名称</span><br><span class=\"line\">animation-duration：动画持续时间</span><br><span class=\"line\">animation-timing-function：动画时间函数</span><br><span class=\"line\">animation-delay：动画延迟时间</span><br><span class=\"line\">animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</span><br><span class=\"line\">animation-direction：动画执行方向</span><br><span class=\"line\">animation-paly-state：动画播放状态</span><br><span class=\"line\">animation-fill-mode：动画填充模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-渐变\"><a href=\"#9-渐变\" class=\"headerlink\" title=\"9. 渐变\"></a>9. 渐变</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-image: linear-gradient(direction, color-stop1, color-stop2, ...); &#x2F;&#x2F; 线性渐变</span><br><span class=\"line\">linear-gradient(0deg, red, green); &#x2F;&#x2F; 径向渐变</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-其他\"><a href=\"#10-其他\" class=\"headerlink\" title=\"10. 其他\"></a>10. 其他</h3><p>flex布局，grid布局，多列布局，媒体查询，混合模式等。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-选择器\"><a href=\"#1-选择器\" class=\"headerlink\" title=\"1. 选择器\"></a>1. 选择器</h3><h3 id=\"2-边框\"><a href=\"#2-边框\" class=\"headerlink\" title=\"2. 边框\"></a>2. 边框</h3><p>新增3个边框属性：<br>1.border-radius:创建圆角边框<br>2.box-shadow:为元素添加阴影<br>3.border-image:使用图片来绘制边框</p>\n<h3 id=\"3-背景\"><a href=\"#3-背景\" class=\"headerlink\" title=\"3. 背景\"></a>3. 背景</h3><p>1.background-clip:确定背景画区<br>2.background-origin:设置对齐方式<br>3.background-break:设置盒子绘制</p>\n<h3 id=\"4-文字\"><a href=\"#4-文字\" class=\"headerlink\" title=\"4. 文字\"></a>4. 文字</h3><p>1.word-wrap:normal(换行) break-all(单词内换行)<br>2.text-overflow:clip(修剪文本) ellipsis(显示省略符代替遮盖文本)<br>3.text-shadow:设置文本阴影<br>4.text-decoration:设置深层渲染</p>\n<h3 id=\"5-颜色\"><a href=\"#5-颜色\" class=\"headerlink\" title=\"5. 颜色\"></a>5. 颜色</h3><p>rgba：rgb为颜色值，a为透明度<br>hala：h为色相，s为饱和度，1为亮度，a为透明度</p>\n<h3 id=\"6-transition-过渡\"><a href=\"#6-transition-过渡\" class=\"headerlink\" title=\"6. transition 过渡\"></a>6. transition 过渡</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</span><br><span class=\"line\">transition-property: width; </span><br><span class=\"line\">transition-duration: 1s;</span><br><span class=\"line\">transition-timing-function: linear;</span><br><span class=\"line\">transition-delay: 2s;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-transform-转换\"><a href=\"#7-transform-转换\" class=\"headerlink\" title=\"7. transform 转换\"></a>7. transform 转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform: translate(120px, 50%)：位移</span><br><span class=\"line\">transform: scale(2, 0.5)：缩放</span><br><span class=\"line\">transform: rotate(0.5turn)：旋转</span><br><span class=\"line\">transform: skew(30deg, 20deg)：倾斜</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-animation-动画\"><a href=\"#8-animation-动画\" class=\"headerlink\" title=\"8. animation 动画\"></a>8. animation 动画</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation-name：动画名称</span><br><span class=\"line\">animation-duration：动画持续时间</span><br><span class=\"line\">animation-timing-function：动画时间函数</span><br><span class=\"line\">animation-delay：动画延迟时间</span><br><span class=\"line\">animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</span><br><span class=\"line\">animation-direction：动画执行方向</span><br><span class=\"line\">animation-paly-state：动画播放状态</span><br><span class=\"line\">animation-fill-mode：动画填充模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-渐变\"><a href=\"#9-渐变\" class=\"headerlink\" title=\"9. 渐变\"></a>9. 渐变</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-image: linear-gradient(direction, color-stop1, color-stop2, ...); &#x2F;&#x2F; 线性渐变</span><br><span class=\"line\">linear-gradient(0deg, red, green); &#x2F;&#x2F; 径向渐变</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-其他\"><a href=\"#10-其他\" class=\"headerlink\" title=\"10. 其他\"></a>10. 其他</h3><p>flex布局，grid布局，多列布局，媒体查询，混合模式等。。。</p>\n"},{"title":"CSS动画","date":"2021-04-14T06:32:51.000Z","_content":"### 1. CSS动画\n实现方式：\n1.transition实现渐变动画\n2.transform转变动画\n3.animation实现自定义动画\n---\n### 2. transition\ntransition的属性：\n1.property\n填写需要变化的CSS属性\n2.duration\n完成过渡效果需要的时间单位\n3.timing-function\n完成效果的速度曲线\nlinear(匀速)，ease(从慢到快再到慢)，ease-in(慢慢变快)，ease-out(慢慢变慢)，ease-in-out(先变快在到慢)，cubic-bezier(定义自己的值)\n4.delay\n动画效果的延迟触发时间\n---\n### 3. transform\ntranform有的属性\n1.translate 位移\n2.scale 缩放\n3.rotate 旋转\n4.skew 倾斜\n一般配合transition使用，不支持inline元素\n---\n### 4. animation\nanimation自带属性：\n1.animation-duration\n指动画周期时间\n2.animation-timing-function\n指动画计时函数\n3.animation-delay\n延迟时间，默认为0\n4.animation-iteration-count\n播放次数\n5.animation-fill-mode\n填充模式，默认none\n6.animation-play-state\n播放状态\n7.animation-name\n@keyframes动画名称\n8.animation-dirction\n播放方向normal\n### 5. 总结\ntransition(过渡)：用于设置元素的样式过渡，和animation有着类似的效果，但细节上有很大的不同\ntransform(变形):用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，相当于color一样用来设置元素的“外表”\ntranslate(移动)：只是transform的一个属性值，即移动\nanimation(动画):用于设置动画属性\n\n","source":"_posts/CSS动画.md","raw":"---\ntitle: CSS动画\ndate: 2021-04-14 14:32:51\ntags:\n - CSS\ncategories: 页面样式\n---\n### 1. CSS动画\n实现方式：\n1.transition实现渐变动画\n2.transform转变动画\n3.animation实现自定义动画\n---\n### 2. transition\ntransition的属性：\n1.property\n填写需要变化的CSS属性\n2.duration\n完成过渡效果需要的时间单位\n3.timing-function\n完成效果的速度曲线\nlinear(匀速)，ease(从慢到快再到慢)，ease-in(慢慢变快)，ease-out(慢慢变慢)，ease-in-out(先变快在到慢)，cubic-bezier(定义自己的值)\n4.delay\n动画效果的延迟触发时间\n---\n### 3. transform\ntranform有的属性\n1.translate 位移\n2.scale 缩放\n3.rotate 旋转\n4.skew 倾斜\n一般配合transition使用，不支持inline元素\n---\n### 4. animation\nanimation自带属性：\n1.animation-duration\n指动画周期时间\n2.animation-timing-function\n指动画计时函数\n3.animation-delay\n延迟时间，默认为0\n4.animation-iteration-count\n播放次数\n5.animation-fill-mode\n填充模式，默认none\n6.animation-play-state\n播放状态\n7.animation-name\n@keyframes动画名称\n8.animation-dirction\n播放方向normal\n### 5. 总结\ntransition(过渡)：用于设置元素的样式过渡，和animation有着类似的效果，但细节上有很大的不同\ntransform(变形):用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，相当于color一样用来设置元素的“外表”\ntranslate(移动)：只是transform的一个属性值，即移动\nanimation(动画):用于设置动画属性\n\n","slug":"CSS动画","published":1,"updated":"2021-04-14T07:25:33.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknh4rjzr0000wcva25m2hho7","content":"<h3 id=\"1-CSS动画\"><a href=\"#1-CSS动画\" class=\"headerlink\" title=\"1. CSS动画\"></a>1. CSS动画</h3><p>实现方式：<br>1.transition实现渐变动画<br>2.transform转变动画<br>3.animation实现自定义动画</p>\n<hr>\n<h3 id=\"2-transition\"><a href=\"#2-transition\" class=\"headerlink\" title=\"2. transition\"></a>2. transition</h3><p>transition的属性：<br>1.property<br>填写需要变化的CSS属性<br>2.duration<br>完成过渡效果需要的时间单位<br>3.timing-function<br>完成效果的速度曲线<br>linear(匀速)，ease(从慢到快再到慢)，ease-in(慢慢变快)，ease-out(慢慢变慢)，ease-in-out(先变快在到慢)，cubic-bezier(定义自己的值)<br>4.delay<br>动画效果的延迟触发时间</p>\n<hr>\n<h3 id=\"3-transform\"><a href=\"#3-transform\" class=\"headerlink\" title=\"3. transform\"></a>3. transform</h3><p>tranform有的属性<br>1.translate 位移<br>2.scale 缩放<br>3.rotate 旋转<br>4.skew 倾斜<br>一般配合transition使用，不支持inline元素</p>\n<hr>\n<h3 id=\"4-animation\"><a href=\"#4-animation\" class=\"headerlink\" title=\"4. animation\"></a>4. animation</h3><p>animation自带属性：<br>1.animation-duration<br>指动画周期时间<br>2.animation-timing-function<br>指动画计时函数<br>3.animation-delay<br>延迟时间，默认为0<br>4.animation-iteration-count<br>播放次数<br>5.animation-fill-mode<br>填充模式，默认none<br>6.animation-play-state<br>播放状态<br>7.animation-name<br>@keyframes动画名称<br>8.animation-dirction<br>播放方向normal</p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>transition(过渡)：用于设置元素的样式过渡，和animation有着类似的效果，但细节上有很大的不同<br>transform(变形):用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，相当于color一样用来设置元素的“外表”<br>translate(移动)：只是transform的一个属性值，即移动<br>animation(动画):用于设置动画属性</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-CSS动画\"><a href=\"#1-CSS动画\" class=\"headerlink\" title=\"1. CSS动画\"></a>1. CSS动画</h3><p>实现方式：<br>1.transition实现渐变动画<br>2.transform转变动画<br>3.animation实现自定义动画</p>\n<hr>\n<h3 id=\"2-transition\"><a href=\"#2-transition\" class=\"headerlink\" title=\"2. transition\"></a>2. transition</h3><p>transition的属性：<br>1.property<br>填写需要变化的CSS属性<br>2.duration<br>完成过渡效果需要的时间单位<br>3.timing-function<br>完成效果的速度曲线<br>linear(匀速)，ease(从慢到快再到慢)，ease-in(慢慢变快)，ease-out(慢慢变慢)，ease-in-out(先变快在到慢)，cubic-bezier(定义自己的值)<br>4.delay<br>动画效果的延迟触发时间</p>\n<hr>\n<h3 id=\"3-transform\"><a href=\"#3-transform\" class=\"headerlink\" title=\"3. transform\"></a>3. transform</h3><p>tranform有的属性<br>1.translate 位移<br>2.scale 缩放<br>3.rotate 旋转<br>4.skew 倾斜<br>一般配合transition使用，不支持inline元素</p>\n<hr>\n<h3 id=\"4-animation\"><a href=\"#4-animation\" class=\"headerlink\" title=\"4. animation\"></a>4. animation</h3><p>animation自带属性：<br>1.animation-duration<br>指动画周期时间<br>2.animation-timing-function<br>指动画计时函数<br>3.animation-delay<br>延迟时间，默认为0<br>4.animation-iteration-count<br>播放次数<br>5.animation-fill-mode<br>填充模式，默认none<br>6.animation-play-state<br>播放状态<br>7.animation-name<br>@keyframes动画名称<br>8.animation-dirction<br>播放方向normal</p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>transition(过渡)：用于设置元素的样式过渡，和animation有着类似的效果，但细节上有很大的不同<br>transform(变形):用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，相当于color一样用来设置元素的“外表”<br>translate(移动)：只是transform的一个属性值，即移动<br>animation(动画):用于设置动画属性</p>\n"}],"PostAsset":[{"_id":"source/_posts/SVN工具在编辑器上的使用/SVN-1.png","slug":"SVN-1.png","post":"ckkrow376001bpcvahsf4f30n","modified":0,"renderable":0},{"_id":"source/_posts/JavaScript高级程序设计/文档树.png","slug":"文档树.png","post":"ckkrow33g000bpcva1bifgyqa","modified":0,"renderable":0},{"_id":"source/_posts/Git和SVN的使用/git命令.jpg","slug":"git命令.jpg","post":"ckkrow33d0007pcvadu38e1ea","modified":0,"renderable":0},{"_id":"source/_posts/Git和SVN的使用/svn-git.png","slug":"svn-git.png","post":"ckkrow33d0007pcvadu38e1ea","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/Aren.jpg","slug":"Aren.jpg","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/Flex基本概念.png","slug":"Flex基本概念.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/Flex容器.png","slug":"Flex容器.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/align-items.png","slug":"align-items.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/align-self.png","slug":"align-self.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/flex.png","slug":"flex.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/justify-content.png","slug":"justify-content.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Flex布局/轴.png","slug":"轴.png","post":"ckkrow33c0006pcva70baddbt","modified":0,"renderable":0},{"_id":"source/_posts/Vue开发/vue.png","slug":"vue.png","post":"ckkrow377001cpcvaaqxacdou","modified":0,"renderable":0},{"_id":"source/_posts/清除浮动的方法/浮动溢出.jpg","slug":"浮动溢出.jpg","post":"ckkrow37o002ppcvaf9kr6g7x","modified":0,"renderable":0},{"_id":"source/_posts/闭包/过程.png","slug":"过程.png","post":"ckkrow37q002wpcva6pw50ej5","modified":0,"renderable":0},{"_id":"source/_posts/SVN工具在编辑器上的使用/SVN-2.png","slug":"SVN-2.png","post":"ckkrow376001bpcvahsf4f30n","modified":0,"renderable":0},{"_id":"source/_posts/SVN工具在编辑器上的使用/SVN-3.png","slug":"SVN-3.png","post":"ckkrow376001bpcvahsf4f30n","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckkrow3370002pcva4a6nddk8","category_id":"ckkrow33a0004pcva22v335gf","_id":"ckkrow33i000cpcvacpjchqvu"},{"post_id":"ckkrow3390003pcva2wa12eyr","category_id":"ckkrow33f0009pcva3ge54cbc","_id":"ckkrow33k000ipcva916capqt"},{"post_id":"ckkrow33c0006pcva70baddbt","category_id":"ckkrow33f0009pcva3ge54cbc","_id":"ckkrow33l000kpcva67mk6kes"},{"post_id":"ckkrow33d0007pcvadu38e1ea","category_id":"ckkrow33k000hpcvahrm26m1c","_id":"ckkrow33m000opcvahjdagmsl"},{"post_id":"ckkrow33e0008pcva5c3wglf7","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow33m000spcva79iq03vt"},{"post_id":"ckkrow33g000bpcva1bifgyqa","category_id":"ckkrow33m000qpcva1nie5iar","_id":"ckkrow33n000wpcvae71xa8sv"},{"post_id":"ckkrow374001apcva15kh67px","category_id":"ckkrow33a0004pcva22v335gf","_id":"ckkrow379001gpcva2fky6o8i"},{"post_id":"ckkrow3700014pcva8bn3e7fa","category_id":"ckkrow3740018pcva722ibuva","_id":"ckkrow379001ipcva4f6ngm45"},{"post_id":"ckkrow377001cpcvaaqxacdou","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37c001mpcva1yex83zh"},{"post_id":"ckkrow378001fpcva1sls5pbx","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37d001ppcva85d408ic"},{"post_id":"ckkrow3720016pcva4u69bu4x","category_id":"ckkrow377001dpcvagihb286u","_id":"ckkrow37e001upcvaez7c6cws"},{"post_id":"ckkrow379001hpcva4qe08lr5","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37f001xpcvabpe131h1"},{"post_id":"ckkrow376001bpcvahsf4f30n","category_id":"ckkrow379001jpcva2dqw8z2u","_id":"ckkrow37g0022pcvadnydcowo"},{"post_id":"ckkrow37a001lpcva34lmfs6d","category_id":"ckkrow37e001spcvadexlay8e","_id":"ckkrow37i0026pcvabhshguci"},{"post_id":"ckkrow37g0024pcva8ozv01zz","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37k002cpcva75hc3h87"},{"post_id":"ckkrow37d001opcva8juc0eqs","category_id":"ckkrow37g0021pcva956a84wg","_id":"ckkrow37l002gpcva7hhx5l2m"},{"post_id":"ckkrow37h0025pcva2hmbeoo7","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37m002jpcva925ieqcc"},{"post_id":"ckkrow37e001tpcva00srfvvd","category_id":"ckkrow37i0028pcva8zlg58s2","_id":"ckkrow37o002npcva72ofbfva"},{"post_id":"ckkrow37f001wpcvahdv36onk","category_id":"ckkrow37k002epcvaaua9g7ot","_id":"ckkrow37p002rpcva2ijtb43n"},{"post_id":"ckkrow37m002ipcvahg0gb0u1","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37q002vpcvah4f17509"},{"post_id":"ckkrow37o002ppcvaf9kr6g7x","category_id":"ckkrow33f0009pcva3ge54cbc","_id":"ckkrow37r0030pcva4x33hgus"},{"post_id":"ckkrow37g0020pcva69xl66dv","category_id":"ckkrow37n002lpcva29346qjz","_id":"ckkrow37r0033pcva3i0z4e5r"},{"post_id":"ckkrow37p002spcva2wx1ggco","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37s0036pcva0u1l8ksg"},{"post_id":"ckkrow37q002wpcva6pw50ej5","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37s0039pcvackqg5h0b"},{"post_id":"ckkrow37i002apcvag7ncejmd","category_id":"ckkrow37p002tpcva5hr0d5al","_id":"ckkrow37s003bpcva7x5fg0v8"},{"post_id":"ckkrow37r002zpcva7ui3hz97","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckkrow37t003fpcva3j3rdalo"},{"post_id":"ckkrow37j002bpcvabs0o7ckv","category_id":"ckkrow37r0032pcva2y4881tk","_id":"ckkrow37u003gpcva1pse3wg8"},{"post_id":"ckkrow37k002fpcva3king599","category_id":"ckkrow37s0038pcva6szah1rd","_id":"ckkrow37u003ipcva8hxmdiob"},{"post_id":"ckkrow37n002mpcva6x6j7oph","category_id":"ckkrow37t003dpcva6u9har7b","_id":"ckkrow37v003lpcvah03nends"},{"post_id":"cklkl9v3w0000ksvaa86paphi","category_id":"cklkl9v430002ksvaf36j60yv","_id":"cklkl9v4c0008ksva31kb5d5a"},{"post_id":"cklkl9v410001ksvaef75a51m","category_id":"cklkl9v430002ksvaf36j60yv","_id":"cklkl9v4c000bksva6msubh9j"},{"post_id":"cklm4c58i0000lgva0pz3e43i","category_id":"cklkl9v430002ksvaf36j60yv","_id":"cklm4c58u0004lgva0jf5apu5"},{"post_id":"cklm4c58p0001lgvae6jle1yw","category_id":"cklkl9v430002ksvaf36j60yv","_id":"cklm4c58u0006lgva638rezi9"},{"post_id":"ckmafka730001qgva1gow2ny1","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckmafka7c0008qgva6vea48u2"},{"post_id":"ckmafka7b0004qgva56he4z8i","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckmafka7d0009qgvaadsx6sxv"},{"post_id":"ckmafka6w0000qgva4b765vx8","category_id":"ckmafka750002qgva6g3zcjoh","_id":"ckmafka7d000aqgvadple8ksb"},{"post_id":"ckmewjlt40000fkva3ndc62ed","category_id":"cklkl9v430002ksvaf36j60yv","_id":"ckmewjltc0004fkvabth81lgm"},{"post_id":"ckmewjlta0001fkva0uoo85iv","category_id":"ckkrow33l000lpcvaaviaej4h","_id":"ckmewjltc0006fkvaaz7h3j1k"},{"post_id":"ckmol1ivn0000bovahyys81z8","category_id":"cklkl9v430002ksvaf36j60yv","_id":"ckmol1iw10002bovacm1mbs9u"},{"post_id":"ckmwz6dhc0001d4vabk6d4gjm","category_id":"cklkl9v430002ksvaf36j60yv","_id":"ckmwz6dhl0004d4vaezmx9gg6"},{"post_id":"ckmwz6dh60000d4vadasf0w0s","category_id":"ckmwz6dhd0002d4vab74ee57i","_id":"ckmwz6dhm0008d4vaekt2ctti"},{"post_id":"ckmy6y2050000j8vaf918h3ej","category_id":"ckmafka750002qgva6g3zcjoh","_id":"ckmy6y20d0002j8vabru01l3m"},{"post_id":"ckn5qjyo2000090vah75q6ry3","category_id":"ckkrow33f0009pcva3ge54cbc","_id":"ckn5qjyo9000490vaep2eaem8"},{"post_id":"ckn5qjyo6000190vahhz06x2r","category_id":"ckmafka750002qgva6g3zcjoh","_id":"ckn5qjyo9000590vabzw24bku"},{"post_id":"ckna1opse0000w8va1uw42wke","category_id":"ckmafka750002qgva6g3zcjoh","_id":"ckna1opso0004w8va6umfbwef"},{"post_id":"ckna1opsk0001w8va22hnhydd","category_id":"ckkrow33f0009pcva3ge54cbc","_id":"ckna1opso0006w8vaayl9h7kk"},{"post_id":"ckng0l4yu0000o8vae2caaq04","category_id":"ckmafka750002qgva6g3zcjoh","_id":"ckng0l4z10002o8va8l5e4sbd"},{"post_id":"cknh4rjzr0000wcva25m2hho7","category_id":"ckmafka750002qgva6g3zcjoh","_id":"cknh4rjzx0002wcvadv7y6q21"}],"PostTag":[{"post_id":"ckkrow3370002pcva4a6nddk8","tag_id":"ckkrow33b0005pcvaa51vg9tm","_id":"ckkrow33k000fpcvacb1jhbq3"},{"post_id":"ckkrow3370002pcva4a6nddk8","tag_id":"ckkrow33f000apcva7o3w5j37","_id":"ckkrow33k000gpcva1ddm4ape"},{"post_id":"ckkrow3390003pcva2wa12eyr","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckkrow33l000npcva8s8df31p"},{"post_id":"ckkrow3390003pcva2wa12eyr","tag_id":"ckkrow33k000jpcva0y0q749a","_id":"ckkrow33m000ppcva51bw6l8p"},{"post_id":"ckkrow33c0006pcva70baddbt","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckkrow33m000upcva89pm4aqf"},{"post_id":"ckkrow33c0006pcva70baddbt","tag_id":"ckkrow33m000rpcvacwpqbdmp","_id":"ckkrow33m000vpcvacetb2kii"},{"post_id":"ckkrow33d0007pcvadu38e1ea","tag_id":"ckkrow33m000tpcva3uob0kjz","_id":"ckkrow33n000ypcvagm8m6qcm"},{"post_id":"ckkrow33e0008pcva5c3wglf7","tag_id":"ckkrow33n000xpcvafu3be8et","_id":"ckkrow33n0011pcvahy1gco4l"},{"post_id":"ckkrow33e0008pcva5c3wglf7","tag_id":"ckkrow33n000zpcva23icgdpe","_id":"ckkrow33n0012pcva01ordqpf"},{"post_id":"ckkrow33g000bpcva1bifgyqa","tag_id":"ckkrow33n0010pcva2qy6cdan","_id":"ckkrow33n0013pcvadztb6bh9"},{"post_id":"ckkrow3700014pcva8bn3e7fa","tag_id":"ckkrow3740019pcva12dq9nh5","_id":"ckkrow37c001npcva5xv36gjc"},{"post_id":"ckkrow3700014pcva8bn3e7fa","tag_id":"ckkrow377001epcvahhzz6ozr","_id":"ckkrow37d001qpcva63k5bist"},{"post_id":"ckkrow37a001lpcva34lmfs6d","tag_id":"ckkrow33n0010pcva2qy6cdan","_id":"ckkrow37e001vpcva6e8d8q8e"},{"post_id":"ckkrow3720016pcva4u69bu4x","tag_id":"ckkrow37a001kpcva90bg47m8","_id":"ckkrow37f001ypcvah2p2db94"},{"post_id":"ckkrow374001apcva15kh67px","tag_id":"ckkrow37d001rpcva15d3bc59","_id":"ckkrow37g0023pcvab4va6vtz"},{"post_id":"ckkrow376001bpcvahsf4f30n","tag_id":"ckkrow37f001zpcvabppqdwfq","_id":"ckkrow37i0029pcvacctccgnb"},{"post_id":"ckkrow377001cpcvaaqxacdou","tag_id":"ckkrow37i0027pcva4d49149c","_id":"ckkrow37l002hpcva6aoygqpj"},{"post_id":"ckkrow378001fpcva1sls5pbx","tag_id":"ckkrow37i0027pcva4d49149c","_id":"ckkrow37o002opcvagq049rbr"},{"post_id":"ckkrow379001hpcva4qe08lr5","tag_id":"ckkrow37i0027pcva4d49149c","_id":"ckkrow37p002upcva9pds1ht7"},{"post_id":"ckkrow37o002ppcvaf9kr6g7x","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckkrow37q002xpcvah6s37vqu"},{"post_id":"ckkrow37p002spcva2wx1ggco","tag_id":"ckkrow33n000zpcva23icgdpe","_id":"ckkrow37r0031pcvag043h1a8"},{"post_id":"ckkrow37d001opcva8juc0eqs","tag_id":"ckkrow37o002qpcvaf80jbd64","_id":"ckkrow37r0034pcva53mv84nc"},{"post_id":"ckkrow37q002wpcva6pw50ej5","tag_id":"ckkrow33n000zpcva23icgdpe","_id":"ckkrow37s0037pcvadg6n7csn"},{"post_id":"ckkrow37e001tpcva00srfvvd","tag_id":"ckkrow37q002ypcvac0iu10lc","_id":"ckkrow37s003apcva7nzkgb2u"},{"post_id":"ckkrow37f001wpcvahdv36onk","tag_id":"ckkrow37s0035pcva9c6u7106","_id":"ckkrow37t003epcvag0dmcaxw"},{"post_id":"ckkrow37g0020pcva69xl66dv","tag_id":"ckkrow37s003cpcva8f4o2c18","_id":"ckkrow37u003jpcva0pozeycv"},{"post_id":"ckkrow37g0024pcva8ozv01zz","tag_id":"ckkrow37u003hpcva4ddfamlk","_id":"ckkrow37v003mpcva1e1jems7"},{"post_id":"ckkrow37h0025pcva2hmbeoo7","tag_id":"ckkrow33n000zpcva23icgdpe","_id":"ckkrow37w003opcva0agud83c"},{"post_id":"ckkrow37h0025pcva2hmbeoo7","tag_id":"ckkrow37v003kpcva76lrdn5s","_id":"ckkrow37w003ppcvae1abbetf"},{"post_id":"ckkrow37i002apcvag7ncejmd","tag_id":"ckkrow37v003npcvaeobb0bz9","_id":"ckkrow37w003rpcva33hoh9j5"},{"post_id":"ckkrow37j002bpcvabs0o7ckv","tag_id":"ckkrow37w003qpcva0wvecc71","_id":"ckkrow37x003upcvahna94894"},{"post_id":"ckkrow37j002bpcvabs0o7ckv","tag_id":"ckkrow37w003spcva1p7g2w9d","_id":"ckkrow37x003vpcva4bdkftp3"},{"post_id":"ckkrow37k002fpcva3king599","tag_id":"ckkrow37x003tpcvadnub8uha","_id":"ckkrow37y003xpcva1aep12kc"},{"post_id":"ckkrow37m002ipcvahg0gb0u1","tag_id":"ckkrow33n000zpcva23icgdpe","_id":"ckkrow37y003zpcvacidqdkey"},{"post_id":"ckkrow37m002ipcvahg0gb0u1","tag_id":"ckkrow37x003wpcva7viv2nte","_id":"ckkrow37y0040pcva2dvpay1y"},{"post_id":"ckkrow37n002mpcva6x6j7oph","tag_id":"ckkrow37y003ypcva6nxqb0yt","_id":"ckkrow37z0042pcva343whu3f"},{"post_id":"ckkrow37r002zpcva7ui3hz97","tag_id":"ckkrow37y0041pcvae2q4asno","_id":"ckkrow37z0043pcva1ke22mp3"},{"post_id":"cklkl9v3w0000ksvaa86paphi","tag_id":"ckkrow37i0027pcva4d49149c","_id":"cklkl9v4c0006ksva8jo1csg9"},{"post_id":"cklkl9v3w0000ksvaa86paphi","tag_id":"cklkl9v490003ksva68x94mdf","_id":"cklkl9v4c0007ksva2fin694i"},{"post_id":"cklkl9v410001ksvaef75a51m","tag_id":"ckkrow37i0027pcva4d49149c","_id":"cklkl9v4c0009ksvab92y9k6a"},{"post_id":"cklkl9v410001ksvaef75a51m","tag_id":"cklkl9v490003ksva68x94mdf","_id":"cklkl9v4c000aksvafxr176um"},{"post_id":"cklm4c58i0000lgva0pz3e43i","tag_id":"ckkrow33n000zpcva23icgdpe","_id":"cklm4c58u0002lgva5qf146a1"},{"post_id":"cklm4c58p0001lgvae6jle1yw","tag_id":"ckkrow37i0027pcva4d49149c","_id":"cklm4c58u0003lgvab2pz825i"},{"post_id":"cklm4c58p0001lgvae6jle1yw","tag_id":"cklkl9v490003ksva68x94mdf","_id":"cklm4c58u0005lgva19lodk9k"},{"post_id":"ckmafka6w0000qgva4b765vx8","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckmafka7a0003qgva62x6grri"},{"post_id":"ckmafka6w0000qgva4b765vx8","tag_id":"ckkrow33k000jpcva0y0q749a","_id":"ckmafka7b0005qgva4hws9wmu"},{"post_id":"ckmafka730001qgva1gow2ny1","tag_id":"ckkrow37i0027pcva4d49149c","_id":"ckmafka7c0007qgvah6ok2tsb"},{"post_id":"ckmafka7b0004qgva56he4z8i","tag_id":"ckmafka7c0006qgva2vaefbn2","_id":"ckmafka7d000bqgvadb4e215r"},{"post_id":"ckmewjlt40000fkva3ndc62ed","tag_id":"ckkrow37i0027pcva4d49149c","_id":"ckmewjltb0002fkva3u7aeztk"},{"post_id":"ckmewjlt40000fkva3ndc62ed","tag_id":"cklkl9v490003ksva68x94mdf","_id":"ckmewjltc0003fkva3l7z5mpn"},{"post_id":"ckmewjlta0001fkva0uoo85iv","tag_id":"ckkrow37i0027pcva4d49149c","_id":"ckmewjltc0005fkvaf8kg44m2"},{"post_id":"ckmewjlta0001fkva0uoo85iv","tag_id":"cklkl9v490003ksva68x94mdf","_id":"ckmewjltc0007fkvac9vp06we"},{"post_id":"ckmafka730001qgva1gow2ny1","tag_id":"cklkl9v490003ksva68x94mdf","_id":"ckmewjlu40008fkvafuci14rp"},{"post_id":"ckmol1ivn0000bovahyys81z8","tag_id":"ckmol1ivu0001bova673g57up","_id":"ckmol1iw20003bovahkzf36ef"},{"post_id":"ckmwz6dh60000d4vadasf0w0s","tag_id":"ckmwz6dhk0003d4vah2v03o4f","_id":"ckmwz6dhm0006d4vaexm518fy"},{"post_id":"ckmwz6dh60000d4vadasf0w0s","tag_id":"cklkl9v490003ksva68x94mdf","_id":"ckmwz6dhm0007d4va9dsxdx90"},{"post_id":"ckmwz6dhc0001d4vabk6d4gjm","tag_id":"ckmwz6dhl0005d4vahtrugrdl","_id":"ckmwz6dhn0009d4vagml00b5k"},{"post_id":"ckmy6y2050000j8vaf918h3ej","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckmy6y20c0001j8vaa8eneoxg"},{"post_id":"ckn5qjyo2000090vah75q6ry3","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckn5qjyo8000290va6t9bf993"},{"post_id":"ckn5qjyo6000190vahhz06x2r","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckn5qjyo8000390vagqcscq3c"},{"post_id":"ckna1opse0000w8va1uw42wke","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckna1opsm0002w8va37pb87f9"},{"post_id":"ckna1opsk0001w8va22hnhydd","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckna1opso0003w8va9y81h0wz"},{"post_id":"ckna1opsk0001w8va22hnhydd","tag_id":"ckkrow33k000jpcva0y0q749a","_id":"ckna1opso0005w8va28ft82tu"},{"post_id":"ckng0l4yu0000o8vae2caaq04","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"ckng0l4z00001o8vab3315uh4"},{"post_id":"cknh4rjzr0000wcva25m2hho7","tag_id":"ckkrow33i000epcvacr3qfc5q","_id":"cknh4rjzx0001wcvad9ic57xm"}],"Tag":[{"name":"原型设计","_id":"ckkrow33b0005pcvaa51vg9tm"},{"name":"Axure","_id":"ckkrow33f000apcva7o3w5j37"},{"name":"CSS","_id":"ckkrow33i000epcvacr3qfc5q"},{"name":"响应式布局","_id":"ckkrow33k000jpcva0y0q749a"},{"name":"伸缩布局","_id":"ckkrow33m000rpcvacwpqbdmp"},{"name":"版本管理","_id":"ckkrow33m000tpcva3uob0kjz"},{"name":"语法知识","_id":"ckkrow33n000xpcvafu3be8et"},{"name":"JavaScript","_id":"ckkrow33n000zpcva23icgdpe"},{"name":"javaScript","_id":"ckkrow33n0010pcva2qy6cdan"},{"name":"diary","_id":"ckkrow3740019pcva12dq9nh5"},{"name":"日记","_id":"ckkrow377001epcvahhzz6ozr"},{"name":"前端开发","_id":"ckkrow37a001kpcva90bg47m8"},{"name":"图片编辑","_id":"ckkrow37d001rpcva15d3bc59"},{"name":"代码管理","_id":"ckkrow37f001zpcvabppqdwfq"},{"name":"前端框架","_id":"ckkrow37i0027pcva4d49149c"},{"name":"Web性能","_id":"ckkrow37o002qpcvaf80jbd64"},{"name":"HEXO","_id":"ckkrow37q002ypcvac0iu10lc"},{"name":"学习","_id":"ckkrow37s0035pcva9c6u7106"},{"name":"学习需求","_id":"ckkrow37s003cpcva8f4o2c18"},{"name":"前端学习","_id":"ckkrow37u003hpcva4ddfamlk"},{"name":"函数","_id":"ckkrow37v003kpcva76lrdn5s"},{"name":"单页面与多页面应用","_id":"ckkrow37v003npcvaeobb0bz9"},{"name":"Mpvue","_id":"ckkrow37w003qpcva0wvecc71"},{"name":"开发者工具","_id":"ckkrow37w003spcva1p7g2w9d"},{"name":"工作职责","_id":"ckkrow37x003tpcvadnub8uha"},{"name":"正则表达式","_id":"ckkrow37x003wpcva7viv2nte"},{"name":"测试","_id":"ckkrow37y003ypcva6nxqb0yt"},{"name":"设计模式","_id":"ckkrow37y0041pcvae2q4asno"},{"name":"Vue","_id":"cklkl9v490003ksva68x94mdf"},{"name":"工程化","_id":"ckmafka7c0006qgva2vaefbn2"},{"name":"前端","_id":"ckmol1ivu0001bova673g57up"},{"name":"移动端开发","_id":"ckmwz6dhk0003d4vah2v03o4f"},{"name":"网络安全","_id":"ckmwz6dhl0005d4vahtrugrdl"}]}}